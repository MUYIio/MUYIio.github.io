{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"about","text":"教育经历 本科 计算机科学与技术重庆工商大学派斯学院2019/09 - 现在努力小白 联系方式 电子邮箱1571504536@qq.com 地址重庆市合川区交通路593号 微信feezxe QQ1571504536","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"friends","text":"赞赏名单感谢所有赞赏过我的小伙伴啦，你们的支持是我最大的动力！panakot 友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：Tyzhao 地址：https://www.muyiio.com 简介：Yshawlon 头像：https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.2/Images/avatars/favicon.jpg","link":"/friends/index.html"},{"title":"contact","text":"留言板故障已修复，有问题可以留言啦！！欢迎留言大家有任何问题，都可以在评论区给我留言，或者加我联系方式： QQ：1571504536 微信：feezxe 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。当然不介意小改改加我哦~~ 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：godxiaolong 地址：https://www.yashwlon.cn 简介：Yshawlon 头像：https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.2/Images/avatars/favicon.jpg","link":"/contact/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Github + Hexo 搭建个人博客超详细教程","text":"在搭建过程中遇到问题欢迎来骚扰我哈！ V：godxiaolong，QQ:1571504536，如果觉得有帮助的话不介意打赏一杯奶茶哟~ 前言 作为一名计算机爱好者，摸索了一周搭建出自己的博客。目前只学 习了c语言，没有任何前端知识和网站开发经验，总的来说，算不上很难， 但也要费些心思。网上各类教程应有尽有，只要肯摸索，还是水到渠成的事。另外，写下这篇文章，记录下自己的经验，给需要的朋友，祝你早日拥有自己的博客！ 搭建博客的初衷是希望用博客记录下自己的学习过程，帮助自己复习，分享一部分不成熟的思考，敦促自己把既定的目标完成。 为什么要搭建自己的博客？可以看看这三篇文章： 《为什么你应该（从现在开始就）写博客》 (By 刘未鹏 | Mind Hacks) 《为什么要自建博客？》 (By 知乎) 《我为什么写博客》 （By 知明所以） 我们需要知道搭建博客要用到的框架。Hexo是高效的静态站点生成框架，它基于Node.js。我们使用MarkDown在本地编辑我们的博客文章，通过Hexo生成静态页面，再用两条命令即可部署到我们的网站。无需关心网页源代码的具体细节，我们只需要用心写好自己的博客内容就行。 本文目录 快速搭建 安装Node.js 添加国内镜像 安装Git 注册Github账号 创建Git仓库 安装Hexo 配置本地Hexo 连接Github与本地 写文章、发布文章 MarkDown文章编辑器说明 配置个性化域名 更换自己喜欢的Hexo主题 我的博客源代码 结语 快速搭建（直接使用我的博客源代码）建议自己成功搭建博客之后再使用我的源代码，新手容易出错 有的朋友可能不想去折腾，自定义主题也比较麻烦，亦或有尝试几次搭建却失败，那就可以看这部分。快速搭建可以帮助我们更快搭建出自己的博客，优点是别人博客有的东西你都有，就跟复制差不多；缺点是博客里的配置信息都是别人的，不过不要紧，稍稍改改配置就可以。 在这里以我的博客为例。 一、下载博客源代码大家可以直接素质二连，Star&amp;Fork我的博客源代码：https://github.com/MUYIio/hexo-themes-matery，这里我给出两种下载方法： 第一种：直接DownLoad，下载到本地就可以。（不推荐） 第二种：如果你已经安装了Git，就可以右键单击Come Bash Here运行 git clone git@github.com:MUYIio/hexo-themes-matery.git 将所有文件下载到本地，这个复杂一点。 二、修改博客文档配置首先将我们下载的博客源代码解压，然后修改主要配置： 点击查看隐藏的文件夹删除 .git 文件夹，将自己博客仓库的 .git 文件夹拷贝进去 根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。 根目录配置文件中修改deploy一栏的repository，修改为自己的仓库地址。 根目录配置文件中修改baidu_url_submit一栏的token。 主题配置文件中修改gitalk一栏，修改方法见正文。 我给出的是博客比较明显的几个地方，先修改这几个地方，其它的可以自己慢慢摸索修改。 最后一步，本地的运行环境还是需要搭建好的，跟着下文操作到连接Github与本地，环境就算是搭建完成。 本地环境搭建好之后会生成的文件： 然后直接把Hexo文件夹里面的文件删掉，把我的源代码的文件全部移动过来，就是这样了： 然后在Hexo文件夹下右键单击鼠标，点击 Git Bash Here点击输入以下命令上传就可以了： hexo clean hexo g hexo d安装Node.js了解一下什么是Node.js： Node.js就是一个用于创建服务器端应用程序的运行系统，它可以轻松构建网络或其他事件驱动的应用程序服务器。 需要用到的命令： $ git --version $ node -v $ npm -v点击此处进入Node.js官网下载相应版本即可，安装时选项全部默认，一路点击Next。 检验是否安装成功：按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。 添加国内镜像这里我们使用阿里的国内镜像进行加速，按Win+R打开命令提示符输入： npm config set registry https://registry.npm.taobao.org安装Git Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，帮助我们把本地网页上传到Github。 点击此处进入Git官网下载相应版本，默认安装即可。 参考资料：《如何在windows下安装GIT》 (By 俊雨廷休) 检验是否安装成功： 安装完成后在命令提示符中输入git –version验证是否安装成功 git --version 注册Github账号Github作为全球最大的开源社区，相信朋友们都已经有了吧，如果没有，点击此处进入Github官网点击 Sign Up 注册账户。 创建git仓库登录Github创建一个仓库 如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的Github名字完全一样，比如你github名字叫A，那么仓库名字一定要是A.github.io。 选择一个自己喜欢的主题：在上面创建的仓库里面点击Settings（不是头像下面那个Settings），向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，就可以预览效果啦。 安装Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。 选择一个磁盘，新建一个文件夹用来存放博客文件。比如我的（C/panakot Blog），在该文件夹下右键单击鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装 $ npm install hexo-cli -g 输入hexo -v即可检验是否安装成功，我这里就不演示了。 配置本地hexo还是在刚才新建的文件夹下再新建一个Hexo文件夹，比如我的（C/panakot Blog/Hexo），在Hexo文件夹下右键单击鼠标，点击 Git Bash Here，依次输入以下 npm 命令即可初始化。 hexo init npm install 初始化成功生成的文件： 接着我们输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以预览我们的博客啦，如图： 显示以下信息说明操作正确： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 按ctrl+c关闭本地服务器。 我们以后常用到的Hexo命令： hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 hexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下) hexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github) hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 连接Github与本地一、生成密钥右键单击鼠标，点击 Git Bash Here输入以下命令： git config --global user.name &quot;Name&quot; git config --global user.email &quot;Email&quot;Name和Email是我们注册Github时的用户名和邮箱。 然后生成密钥： ssh-keygen -t rsa -C &quot;Email&quot;Email是我们注册Github时的邮箱 然后会出现： Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //到这里可以直接回车将密钥按默认文件进行存储回车之后： Enter passphrase (empty for no passphrase): //这里是要你输入密码，其实不需要输什么密码，直接回车就行 Enter same passphrase again:接下来会有： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 这里是各种字母数字组成的字符串，结尾是你的邮箱 The key's randomart image is: 这里也是各种字母数字符号组成的字符串现在密钥已经生成，一般存放在（/c/Users/you/.ssh/id_rsa.pub.），我们运行下面的命令将密钥复制为粘贴板： clip &lt; ~/.ssh/id_rsa.pub 二、连接Github在Github头像下面点击Settings，再点击SSH and GPG keys，新建一个SSH，名字任意。 然后将刚才复制的密钥添加就可以了，像这样： 本地连接Github 右键单击鼠标，点击 Git Bash Here输入以下命令，如果如下图所示，出现你的用户名，那就成功了 ssh -T git@github.com //注意不要做任何修改 用编辑器打开博客根目录下的_config.yml文件，我用的是记事本，当然vscode也可以这是博客的配置文件，我们需要修改一下才能连接Github。 修改最后一行的配置： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type:改为： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:panakot/panakot.github.io.git //自己的仓库地址 branch: master这个是我的更为完整： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: git repository: github: git@github.com:MUYIio/MUYIio.github.io.git //GitHub仓库 coding: git@e.coding.net:godxiaolon/yshawlon/feezxe.git //coding仓库 gitee: git@gitee.com:feezxe/feezxe.git //gitee仓库 #repo: root@xxxxx :/home/git/blog.git //前面加#表示注释掉，这个是服务器地址 branch: master - type: baidu_url_submitter 切记： repository修改为你自己的github项目地址。 每一个冒号后面都有一个空格。 写文章、发布文章首先在博客根目录下右键打开Git Bash Here输入以下命令，安装一个扩展. npm i hexo-deployer-git然后输入下面的命令，新建一篇文章。 hexo new post &quot;article title&quot; 然后打开C:\\panakot Blog\\Hexo\\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后，根目录下右键打开Git Bash Here输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。 你的博客地址：https://你的用户名.github.io，比如我的是：https://muyiio.github.io，现在每个人都可以通过此链接访问你的博客 MarkDown文章编辑器说明 前面我们提到了使用MarkDown编辑我们的博客文章。 Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会， .md 文件可以使用支持 Markdown 语法的编辑器编辑，然后将写好的文章（.md文件）保存到 \\Hexo\\source_posts 文件夹下即可。 Windows 上推荐使用 MarkdownPad2 或者小书匠编辑器，macOS 上使用 Mou 编辑器，Linux 上使用 Remarkable 编辑器，Web 端上使用 简书。 点击此处下载MarkDown，刚使用的朋友或许不知道如何使用这个编辑器，只需要几分钟就可以掌握啦，给出以下几个我觉得不错的参考： 《献给写作者的 Markdown 新手指南》 （By 简书） 《Markdown语法图文全面详解(10分钟学会)》（By 黑暗星球） 《Markdown 语法手册 （完整整理版）》 （By witnessai1） 《认识与入门 Markdown》（By Te_Lee） 写完文章记得在博客根目录Bash Here输入hexo g和hexo d上传到网站。 配置个性化域名一顿操作下来，打开我们的博客还是：www.xxx.github.io，是不是很没有牌面？我们可以考虑购买一个专属域名，以后打开博客就是这样：www.xxx.com 。 阿里云和腾讯云都可以，我的是腾讯云，购买域名后首先需要添加解析： 方法一：点击添加记录，需要添加两个记录，两个记录类型都是 CNAME ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都是填你自己的博客地址（比如我的是：muyiio.github.io），保存之后域名解析就完成了！ 方法二：两个记录类型为 A ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都为博客的 IP 地址，IP 地址可以 cmd 中输入 ping 你的博客地址 获得（比如我的：ping muyiio.github.io），保存之后域名解析就完成了！ 参考资料： 《域名解析中A记录、CNAME、MX记录、NS记录的区别和联系》 不管在哪个平台购买域名，操作都大同小异，这里说明两点： 如果你填写的是没有www的，比如 muyio.com，那么无论是访问 https://www.muyiio.com 还是 https://muyiio.com ，都会自动跳转到 https://muyiio.com。 如果你填写的是带www的，比如 www.muyiio.com ，那么无论是访问 https://www.muyiio.com 还是 https://muyiio.com ，都会自动跳转到 http://www.imuyiio.com。 然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存就可以了。 现在我们的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是C:\\Blog\\Hexo\\source，新建CNAME文件，（注意不要加.txt，没有任何后缀名！）。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。 现在就可以通过我们的个性化域名：www.xxx.com、xxx.com访问自己的博客了。 更换自己喜欢的Hexo主题点击进入Hexo主题专栏可以看到很多Hexo主题： 推荐： 几个好用的hexo主题 (By fail_perfectly) 这里我们以Bean Tech主题为例，下滑到底部我们可以看到他的GitHub（有的主题是：Theme by xxx，点击那里也是进入GitHub地址）： 点击进入主题的GitHub地址： 复制该项目地址： 然后打开 Hexo 文件夹下的 themes 目录（如：C:\\MUYIio Blog\\Hexo\\themes），右键 Git Bash Here，输入以下命令： $ git clone 此处填写你刚才复制的主题地址以我们刚才复制的为例： $ git clone https://github.com/Huxpro/huxpro.github.io下载完成后即可在 themes 目录下生成 hexo-theme-Bean-Tech 文件夹，然后打开 Hexo 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：theme：hexo-theme-Bean-Tech （其他主题修改成相应名称即可），再次注意冒号后面有一个空格！ 现在我们的主题已经替换完成，将它部署到我们的博客，博客根目录下右键 Git Bash Here，输入以下命令： hexo clean hexo g hexo d现在访问我们的网站就可以看到主题已经更换了，但是比如网站标题，图标等都没有更换，我们博客文件中有两份主要的配置文件，名称都是 _config.yml ，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如我的：C:\\MUYIio Blog\\Hexo_config.yml），主要包含 Hexo 本身整站的配置；另一份位于主题目录下（比如我的：C:\\MUYIio Blog\\Hexo\\themes\\hexo-theme-matery_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项，一般 _config.yml 文件里都有相关注释，按需修改即可。 我的博客源代码我的博客源代码地址：https://github.com/MUYIio/hexo-themes-matery，有心的话可以给个Star&amp;Fork。 下载源代码：git clone git@github.com:MUYIio/hexo-themes-matery.git 在文章开头给出了快速搭建教程，相对于自己从头开始搭建还是比较方便的，修复了很多Bug，也添加了一些插件，下载就可以使用，可以帮你们省去个性化配置带来的很多麻烦。 主题的原地址在这里：hexo-theme-matery，作者把文档写得也非常的详细，还有中英文两个版本，建议可以多看几遍，在本地修改的时候轻松一些。 使用我的源代码之前本地的环境还是要搭建好，就是前面一部分。 ----------------------------------------------------------------------------------------------------------- 结语初学者可能会觉得困难，毕竟很多东西都是第一次接触，当初我也尝试了好几次才成功，不要放弃，弄错了就删掉重新来过，当你把博客搭建出来会觉得受益良多的。 文章中难免有错误的地方，有大佬发现了欢迎给我指正！有的地方解释不够详细，可以百度一下看看细节，文章中的引用以及参考资料涉及侵权请联系我删除！","link":"/1.html"},{"title":"2019总结及2020规划","text":"博客搭建了快半个月了吧，没有前端知识搞起来还是挺麻烦，有些东西要很久才能完全掌握，可能是我愚钝吧，不过在这里还是要感谢给我解答困惑的前辈，让我少走了许多弯路。 既然是个人博客，总该写点什么首先，感谢屏幕前的你来到我的博客，想要写点什么可是脑子里没东西，就写点自我介绍还有对过去的总结以及未来规划吧 关于我 大一学生，重庆工商大学派斯学院 计算机科学与技术专业，没什么特长，资质平平，平凡得不能再平凡。 有谁甘做一个平凡的人呢？ 我也想活的恣意潇洒，做自己喜欢的事，最近看了阎真写的《沧浪之水》、《活着之上》，方才明白我的这些想法不外乎幼稚而已。认清现实，选择自己的一条路走下去才是目前该做的事。刚好今年第一天搭建成功自己的博客，对于我来说是一件很有成就感的事，用它来记录以后学习中一些不成熟的思考吧，也当做归纳笔记，帮助自己复习，能够与广大的互联网朋友们交流心得体会。 2019上半年经历一千多万人的高考上岸，有一部分原因是没发挥好，更多的原因是自己没努力吧，其实心中是很明白自己如果想过上更好的生活就要努力，但是往往做不到严于律己；要做的事情明日复明日，也就只剩下悲叹了。 高中在学习上只学自己喜欢的科目，英语烂的一塌糊涂，现在真正需要用到英语，连上个GitHub都要用Google翻译，书到用时方恨少。提高英语能力已经迫在眉睫，不能再这样下去了。 下半年我的大学跟好的学校比起来确实差的太多，半年下来，我也更明白一个人的能力并不与他上哪个学校直接相关，感觉像是在安慰自己，，，所以给自己制定目标，自学是一个大学生最基本的能力，以此来弥补学校的差距吧 半学期下来，也没有什么记忆深刻的事情，就连这些也就是无病呻吟而已 学习上： 虽然学校不够好，硬件设施也比较老旧，但是上课的老师大多数是本部过来，算是个意外之喜吧。没有参加任何部门和社团，我不觉得这样没有意义，相反，我找不到参加的理由。 课程还是比较轻松，期末考试比想象中简单，目前还没学习专业课程，虽然是大学，但是每天还是稀里糊涂的忙着，不知道干了什么一天就过去了。希望下学期不会有这样的感受了，加油吧 生活上： 健身停止 高中健身接近两年，上了大学没有好像没有动力了，腹肌没有了胸肌还在，以前崇拜肌肉巨兽，现在手机里都看不到他们的照片了，心里没有健身的想法了，或许是大学生活把自己腐朽了吧。 学会滑板 因为滑板，认识了很多朋友，不论是校友还是校外的都能因为滑板聚在一起滑板，当做出一个新动作的时候换来的开心是其它事情无法代替的，有时候为了一个动作死磕几天或者一个月都会坚持下去……总之滑板带给我的是无拘无束的快乐还有不放弃的滑板精神！ 想起《我的少女时代》里的一句话，送给因为滑板遇见的一切： 每人都有一颗林真心，遇见是最美好的小幸运，谢谢你出现在我的青春里。 2020目标和规划生活上：两个心愿： 云南旅行 明年暑假骑自行车回家 学习上：目前还没找到自己的方向，但我挺喜欢操作系统这块的，准备深入学习。另外，准备明年参加ACM，或许有点晚，先开始再说。 阿城《棋王》里有这样一句话: 天地广阔，有所作为 1024+996=2020，2020注定是不平凡的一年，定下目标，努力实现。 目标 寒假学完c++ 寒假出一篇博客搭建教程 提高英语水平 坚持写博客 计划要看的专业书籍 《数据结构与算法》 《操作系统真象还原》 《从实模式到保护模式》 《现代操作系统》 《汇编语言》 《linux内核完全剖析》 《c++ primer plus》 最后: 业精于勤，荒于嬉；行成于思，毁于随。 自勉。","link":"/2019-zong-jie-ji-2020-gui-hua.html"},{"title":"C++ 中关于Lambda 表达式的总结","text":"Lambda表达式是C++ 11新特性之一，总的来说就是一个函数，第一眼看到这个函数也是一脸懵逼，怎么没有见到过这个写法？于是查找了一些资料，按照我的理解记录一下 Lambda基本语法Lambda标准语法定义： [capture] (parameters) mutable ->ret-type{body}; 说明： 1.[capture]：捕捉列表。捕捉列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数。捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，捕获列表可以是下面的类型： 1.[var]表示值传递方式捕捉变量var； 2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）； auto f1 = [=]{return a + 1;}; //按值捕获a 3.[&amp;var]表示引用传递捕捉变量var； 4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）； auto f2 = [&amp;]{return a + 1;}; //按引用捕获a 5.[this]表示值传递方式捕捉当前的this指针。 6.[ ]表示不捕获任何变量。 捕获列表也可以组合： 1.[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量; 2.[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。 如果重复是不允许的： 1.[=,x]这里已经以值传递方式捕捉了所有变量，但重复捕捉x; 2.[&amp;,&amp;this]&amp;已经相当于以引用传递方式捕捉了所有变量，再捕捉this则会重复。 2.(parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略; 3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）; 4.-&gt;ret-type：返回类型。可以指定，也可以不指定，不指定编译器则会自动推导返回类型，例如： [](double x ) {int y = x ;}; 如果函数有多个返回值，编译器不能推导，需要自行添加，例如： [](double x )->double{int y = x ;return x - y;}; 5.{body}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。 Lambda函数具体使用1.其中上面讲到了父作用域，简单来说就是包含Lambda函数的{ }代码段。 2. 另外，Lambda是匿名函数，但通常会给它取名，例如： auto f = [](int x ) {return x % 3 ==0;}; 这样就可以在程序中更方便的调用Lambda函数了： #include &lt;iostream> using namespace std; int main() { int a = 10, b = 5; auto f = [=]{return a + b;}; //[=]按值捕获了a和b cout &lt;&lt; f() &lt;&lt; endl; //值为15 return 0; } 3.保持Lambda函数引用的变量的值是最新的： #include &lt;iostream> using namespace std; int main() { int a = 8; auto f1 = [=]{return a + 1;}; //按值捕获a auto f2 = [&amp;]{return a + 1;}; //按引用捕获a cout &lt;&lt; f1() &lt;&lt; endl; cout &lt;&lt; f2()&lt;&lt; endl; a++; cout &lt;&lt; f1() &lt;&lt; endl; cout &lt;&lt; f2() &lt;&lt; endl; return 0; } 程序结果： 8 8 8 9 按值捕获可以看作Lambda函数生成了一个const类型的变量，它的值是不会因为外部更新而更新的；同样引用捕获相当于调用a的内存地址，保证实时更新，如果想要Lambda函数在调用时访问的外部变量是最新的，我们就需要使用按引用捕获。 如果非要做到修改值捕获变量的值，就可以使用mutale关键字；默认情况下，lambda函数是一个const函数，而mutable也可以取消常量性，例如： #include &lt;iostream> using namespace std; int main() { int a = 10; auto f = [=]()mutable{return a *= 10;};//取消常量性 cout &lt;&lt; f() &lt;&lt; endl; return 0; } 程序结果： 100 mutable 修饰的 Lambda 表达式就算没有参数也要写明参数列表，这里的()表示没有省略，只是没有参数而已。","link":"/c-zhong-guan-yu-lambda-biao-da-shi-de-zong-jie.html"},{"title":"C++学习笔记整理-数据的共享与保护","text":"第五章数据的共享与保护1.标识符的作用域与可见性①作用域作用域是一个标识符在程序正文中有效的区域。 函数原型作用域 局部作用域(块作用域) 类作用域 文件作用域 命名空间作用域 函数原形的作用域 函数原型中的参数，其作用域始于”(“，结束于”)”。 //例如，设有下列原型声明： double area(double radius); //radius 的作用域仅在于此area，不能用于程序正文其他地方，因而可有可无。 局部作用域 函数的形参，在块中声明的标识符，其作用域自声明处起，限于块中，例如： void fun(int a) { int b = a; cin >> b; if (b > 0) { int c; ...... } } //a的作用域是整个fun函数，b作用域在fun函数内，而c作用域在if语句内 类作用域 类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）。 文件作用域 不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束于文件尾。 //example.1 #include using namespace std; int i; //全局变量，文件作用域 int main() { i = 5; //为全局变量i赋值 { //子块1 int i; //局部变量，局部作用域 i = 7; cout","link":"/c-xue-xi-bi-ji-zheng-li-di-wu-zhang-shu-ju-de-gong-xiang-yu-bao-hu.html"},{"title":"C++学习笔记整理-函数","text":"前面几章大体上和C差不多，就从函数开始吧。 第三章 函数1 .函数的定义与使用函数定义的语法形式：类型标识符 函数名（形式参数表） { 语句序列 } 若无返回值，类型标识符写void 形式参数表：是被初始化的内部变量，寿命和可见性仅限于函数内部 函数的调用调用前先声明函数： 若函数定义在调用点之前，则无需另外声明； 若函数定义在调用点之后，则需要在调用函数前按如下形式声明函数原型： 类型标识符 被调用函数名（含类型说明的形参表）; 调用形式： 函数名（实参列表） 嵌套调用： 在一个函数的函数体中，可以调用另一函数，称为嵌套调用。 递归调用： 函数直接或间接调用自身。 //1.编写一个求x的n次方的函数 #include using namespace std; //计算x的n次方 double power(double x,int n) { double val=1.0; while(n--) val*=x; return val; } int main() { cout","link":"/c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html"},{"title":"C++编程题目整合","text":"就从第四章类与对象开始吧，前面的章节和c差不多。 1.点类定义和使用【问题描述】 定义一个点类，该类包含整形坐标x,y以及用于设置坐标值的函数，名为setxy（）参数自行确定，以及用于显示坐标的函数displayxy()参数自行设置。合理编写主函数，能够实现（3，4）以及（5，6）固定两个点对象的参数设置，以及信息输出 【输入形式】 无数据输入，请一定使用类的定义以及对象的创建的相关知识 【输出形式】 输出两个固定点的相关信息 【样例输入】 【样例输出】 The first point is:(3,4) The second point is:(5,6) #include using namespace std; class Point { public: Point(int a,int b) { x=a; y=b; } void setxy(int a,int b) { x=a; y=b; } void display() { cout","link":"/c-bian-cheng-ti-mu-zheng-he.html"},{"title":"C++学习笔记整理-类与对象","text":"第四章 类和对象1.面向对象程序设计的基本特点①抽象抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。 先注意问题的本质及描述，其次是实现过程或细节。 数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。 代码抽象：描述某类对象的共有的行为特征或具有的功能。 抽象的实现：通过类的声明。 //数据抽象： int hour,int minute,int second //代码抽象： setTime(),showTime() class Clock { public: void setTime(int newH, int newM, int newS); void showTime(); private: int hour, minute, second; }; ②封装将抽象出的数据成员、代码成员相结合，将它们视为一个整体。 目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。 实现封装：类声明中的{} //实例： class Clock { public://公有的访问权限 void setTime(int newH, int newM, int newS);//外部接口 void showTime();//外部接口 private: //私有的访问权限 int hour, minute, second; };//边界 ③继承是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。 实现：声明派生类 ④多态多态：同一名称，不同的功能实现方式。 目的：达到行为标识统一，减少程序中标识符的个数。 实现：重载函数和虚函数 2.类和对象①类和对象类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。 利用类可以实现数据的封装、隐藏、继承与派生。 利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。 定义一个新的class也就定义了一个新的类型 ②类的定义类是一种用户自定义类型，声明形式： class 类名称 { public: 公有成员（外部接口） private: 私有成员 protected: 保护型成员 }; 在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。 在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。 protected保护型成员与private类似，其差别表现在继承与派生时对派生类的影响不同 ③对象类的对象是该类的某一特定实体，即类类型的变量。声明形式： 类名 对象名； 例：Clock myClock; 类中成员互访：直接使用成员名 类外访问：使用“对象名.成员名”方式访问 public 属性的成员 ④类的成员函数 在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。 允许声明重载函数和带默认形参值的函数 ⑤内联成员函数 为了提高运行时的效率，对于较简单的函数可以声明为内联形式。 内联函数体中不要有复杂结构（如循环语句和switch语句）。 在类中声明内联成员函数的方式： 将函数体放在类的声明中。 使用inline关键字。 //example.1类的实现 #include using namespace std; class Clock{ public: void setTime(int newH = 0, int newM = 0, int newS = 0); void showTime(); private: int hour, minute, second; }; int main() { Clock myClock; myClock.setTime(8, 30, 30); myClock.showTime(); return 0; } void Clock::setTime(int newH, int newM,int newS) { hour=newH; minute=newM; second=newS; } void Clock::showTime() { cout","link":"/c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html"},{"title":"Hash算法","text":"哈希算法(Hash Function) 将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。 构成哈希算法的条件： 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法） 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同； 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。 哈希算法的应用一、MD5算法最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA（Secure Hash Algorithm，安全散列算法）。 其他加密算法 DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。 加密哈希算法，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。 MD5目前最有效的攻击方式就是彩虹表，具体可以通过谷歌了解。 MD5相当于超损压缩。，但网络上也有针对MD5中出现的彩虹表，最常见的思路是在密码后面添加一组 盐码(salt), 比如可以使用md5(1234567.’2019@STARK-%$#&amp;-idje-789’),2019@STARK-%$#&amp;-idje-789作为盐码起到了一定的保护和安全的作用。 MD5不可逆的原因是其是一种散列函数，使用的是hash算法，在计算过程中原文的部分信息是丢失了的。像MD5,有2^128个不同的哈希值，所以散列冲突的概率是很小的；如果我们拿到一个 MD5 哈希值，希望通过毫无规律的穷举的方法，找到跟这个 MD5 值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是被很难破解的。 MD5算法：①确定性，②不可逆性 主要用途： 防止被篡改： 比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。 比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。 SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. 防止直接看到明文： 现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。） 防止抵赖（数字签名）： 这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。 实现：在包java.security有个类MessageDigest。官方文档如下 ： MessageDigest 类为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。信息摘要是安全的单向哈希函数，它接收任意大小的数据，输出固定长度的哈希值。MessageDigest 对象开始被初始化。该对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算。对于给定数量的更新数据，digest 方法只能被调用一次。digest 被调用后，MessageDigest 对象被重新设置成其初始状态。 //Java import java.security.MessageDigest; public class MyMD5 { static char[] hex = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}; public static void main(String[] args) { try{ MessageDigest md5 = MessageDigest.getInstance(\"MD5\");//申明使用MD5算法 md5.update(\"a\".getBytes());// System.out.println(\"md5(a)=\"+byte2str(md5.digest())); md5.update(\"a\".getBytes()); md5.update(\"bc\".getBytes()); System.out.println(\"md5(abc)=\"+byte2str(md5.digest())); }catch(Exception e){ e.printStackTrace(); } } /** * 将字节数组转换成十六进制字符串 * @param bytes * @return */ private static String byte2str(byte []bytes){ int len = bytes.length; StringBuffer result = new StringBuffer(); for (int i = 0; i &lt; len; i++) { byte byte0 = bytes[i]; result.append(hex[byte0 >>> 4 &amp; 0xf]); result.append(hex[byte0 &amp; 0xf]); } return result.toString(); } } 二、唯一标识(uuid)我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。 三、数据校验BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。Nginx上有个分片技术，大概就是这个意思。我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。还有网盘的闪存，当你提交上传文件时，会先在本地计算出文件的哈希值，然后与网盘服务器中的哈希值比较，如果有一样的，说明服务器已经有这个文件了，直接指向服务器中的文件地址就行了。当然整个过程并不是这么简单，还有其他算法。 四、散列函数散列函数也是哈希算法的一种应用。 核心思想：定义一个散列函数h（k），使得对于给定的关键字k，散列函数h（k）将其转换为k所对应的逻辑地址 散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。 不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。 使用散列函数应当避免原始数据相同的概率 散列函数实现方法： 平方取中法 折叠法 随机数法 除留余数法 五、负载均衡我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端： 如果客户端很多，映射表可能会很大，比较浪费内存空间；客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大； 如果借助哈希算法，这些问题都可以非常完美地解决。我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。 六、数据分片 如何统计“搜索关键词”出现的次数？假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？我们来分析一下。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。 如何快速判断图片是否在图库中？ 如何快速判断图片是否在图库中？上一节我们讲过这个例子，不知道你还记得吗？当时我介绍了一种方法，即给每个图片取唯一标识（或者信息摘要），然后构建散列表。 假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。 我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。 散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。 假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。 实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。 七、分布式存储一致性哈希算法假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。","link":"/hash-suan-fa.html"},{"title":"C语言编程题目整合","text":"做过的题目渐渐变得生疏，索性记录在博客上，看着更直观些，好记性不如烂笔头！ 1.数值变换【问题描述】 编写一程序，从键盘输入输入一个三位正整数，然后反向输出对应的数，如果输入的数不是三位正整数，则输出－1。 【输入形式】 从键盘输入三位的正整数。 【输出形式】 输出交换后的正整数值。 【输入样例】 356 【输出样例】 653 【样例说明】 从键盘输入的正整数值为356，将该数的个位与百位互换，所得结果为653.如果输入的正整数为300，则输出为3。 【评分标准】 结果完全正确得20分，每个测试点4分。 #include &lt;stdio.h> int main() { int a, b, c, d; scanf(\"%d\",&amp;a); if(a>=100&amp;&amp;a&lt;1000) { b=a/100; c=a%100/10; d=a%10; if(d==0&amp;&amp;c==0) printf(\"%d\",b); else if(d==0) printf(\"%d%d\",c,b); else printf(\"%d%d%d\",d,c,b); } else printf(\"-1\"); } 2.sinx计算公式【问题描述】 已知sinx的近似计算公式如下： sin x = x - x3/3! + x5/5! - x7/7! + … + (-1)n-1x2n-1/(2n-1)! 其中x为弧度，n为正整数。编写程序根据用户输入的x和n的值，利用上述近似计算公式计算sinx的近似值，要求输出结果小数点后保留8位。 【输入形式】 从控制台输入小数x（0&lt;=x&lt;=20）和整数n（1&lt;=n&lt;=5000），两数中间用空格分隔。 【输出形式】 控制台输出公式结果：小数点后保留8位。 【样例输入1】 0.5236 4 【样例输出1】 0.50000105 【样例输入2】 0.5236 50 【样例输出2】 0.50000106 【样例说明】 输入x为0.5236，n为4，求得sinx近似计算公式的值为0.50000105，小数点后保留8位；同样，输入x为0.5236，n为50，求得sinx近似计算公式的值为0.50000106，小数点后保留8位。注意：为保证数据的准确性和一致性，请使用double数据类型保存计算结果。 【评分标准】 该题要求输出上述公式的计算结果，共有5个测试点 # include&lt;stdio.h> # include&lt;math.h> int main() { double p=1.0,f,x;//p是阶乘中的变量，总量即分母是f double s=0,t=-1; double i,j,n; scanf(\"%lf %lf\",&amp;x,&amp;n); s=x; f=x; for(i=3;i&lt;=2*n-1;i=i+2) { p=p*i*(i-1); s=s+t*pow(x,i)/p; t=-t; } printf(\"%.8lf\",s); } 3.个人所得税【问题描述】2019年1月1月新修订的个税法正式实施，个人所得税由之前的3500元提高到了5000元，还可以减去6项专项附加扣除，主要有子女教育、继续教育、赡养老人、大病医疗、住房贷款利息和住房租金，扣除三险一金和专项附加，工资大于5000元需要缴纳个人所得税，若小于5000元则不需要缴纳。2019年5000起征点个税表如下： 假设6项专项附加扣除为零。 请根据税率表编写代码，输入月收入和扣除的三险一金（单位：元），输出待交的个人所得税。 注：个税的计算方法 比如张先生在武汉工作每个月工资为10000元，公司每个月缴纳社保公积金扣除1300元，没有专项附加扣除费。那么张先生到手的工资为10000-1300-0=8700元，达到了个税起征点5000元，超出的部分按照10%的个人所得税率来计算，(8700-5000)*10%-210=160元，那么张先生一个月需要缴纳的个人所得税为160元。 【输入形式】用户在第一行输入月收入和三险一金(单位：元），中间用空格分开，第一个数是月收入，第二个数是三险一金【输出形式】用户待交的个人所得税（单位：元），保留两位小数【样例输入】10000 1300【样例输出】160.00【样例说明】输入的两个数中，第一个表示月收入，第二个数表示扣除的三险一金;输出待交的个人所得税【评分标准】完全正确20分。提交源文件名为tax.c #include &lt;stdio.h> int main() { int t; double m,l,p,tax; double rate,late; scanf(\"%lf%lf\",&amp;l,&amp;p); m=l-p-5000; if(m&lt;=0) { tax=0; } else { if(m&lt;=3000) t=1; else if(m&lt;=12000) t=2; else if(m&lt;=25000) t=3; else if(m&lt;=35000) t=4; else if(m&lt;=55000) t=5; else if(m&lt;=80000) t=6; else t=7; switch(t) { case 1: rate=0.03,late=0; break; case 2: rate=0.10,late=210; break; case 3: rate=0.20,late=1410; break; case 4: rate=0.25,late=2660; break; case 5: rate=0.30,late=4410; break; case 6: rate=0.35,late=7160; break; case 7: rate=0.45,late=15160; } tax=m*rate-late; } printf(\"需要缴纳的个人所得税为:%.2f 元\",tax); return 0; } 4.字符串复制【问题描述】 编写一个字符串复制函数strCopy()，将字符串1中奇数位置的字符复制到另一个字符串2中，在主函数中调用函数strCopy()并输出复制后的结果。例如，当字符串1为”This is a C program”，则字符串2为”Ti saCporm”。 【输入形式】 输入字符串 【输出形式】 输出复制后的字符串 【样例输入】 This is a C Program 【样例输出】 Ti saCporm #include &lt;stdio.h> #include &lt;string.h> char *strCopy(char a[20]) { static char b[20]; int j = 0; for (int i = 0; i &lt; 20; i += 2, j++) { b[j]=a[i]; } return b; } int main() { char a[20]; char *p = \"\"; gets(a); printf(\"%s\", strCopy(a)); } 5.还是三角形【问题描述】 给定三条边，请判断三角形的类型。 【输入形式】 输入数据包含3个整数，表示三条边的长度，数据保证三条边一定能够组成三角形。 【输出形式】 请判断三条边组成的三角形类型（锐角三角形、钝角三角形、直角三角形、等腰三角形、等边三角形）。如果数据符合多种类型，则只输出优先度最高的类型（上面的五种三角形，优先级从低到高），具体输出格式参见样例。 【样例输入】 3 3 3 【样例输出】 等边三角形 #include &lt;stdio.h> #include &lt;math.h> int Max(int a,int b,int c) { int t,max; t=a>b?a:b; max=t>c?t:c; return max; } int Min(int a,int b,int c) { int t,min; t=a&lt;b?a:b; min=t&lt;c?t:c; return min; } int Mid(int a,int b,int c) { int mid; mid=a>b?(a&lt;c?a:(b>c?b:c)):(b&lt;c?b:(a>c?a:c)); return mid; } int main() { int i,n; int a,b,c,k,x,y,z; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if((a+b>c)&amp;&amp;(abs(a-b)&lt;c)) {// 满足上面条件的三边可以构成三角形 if(a==b&amp;&amp;b==c) printf(\"等边三角形\\n\"); else if((a==b&amp;&amp;c!=a)||(b==c&amp;a!=b)||(a==c&amp;&amp;b!=a)) printf(\"等腰三角形\\n\"); else { x=Min(a,b,c); y=Mid(a,b,c); z=Max(a,b,c); if(x*x+y*y>z*z) printf(\"锐角三角形\\n\"); else if (a*a+b*b==c*c) printf(\"直角三角形\\n\"); else if(x*x+y*y&lt;z*z) printf(\"钝角三角形\\n\"); } } else//不满足构成三角形的条件 { printf(\"这三边不能构成三角形\\n\"); } } 6.寻找完全数【问题描述】 完全数是特殊的自然数。它所有的真约数（即除了自身以外的约数）的和，恰好等于它本身。 第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3=6 第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。 输入一个整数m，输出区间[1,m]内最大的完全数。 【输入形式】 输入一个整数。 【输出形式】 输出不超过m的最大完全数。 【样例输入】 32 【样例输出】 28 #include &lt;stdio.h> int main() { long long int m; long long int n=0,s=1; long long int i=1,j=2; long long int c; scanf(\"%ld\",&amp;m); for(i=m;i>=1;i--) { for(j=2;j&lt;=i;j++) { s = i/j; if(i%j==0) n = n+s; } if(n==i) { c = i; break; } n = 0; } printf(\"%ld\\n\",c); return 0; } 7.回文字符串【问题描述】 回文字符串是具有回文特性的字符串：即该字符串从左向右读和从右向左读都一样，单独的字母不作为回文字符串，例如abcddcba即为一个长度为8的回文字符串。 编写一个程序，输入一个全是字母的字符串，找出字符串中最长的回文字符串，输出最长回文字符串的长度和最长的回文字符串（长度相同的输出第一个），若无回文字符串，只输出0。 【输入形式】 输入第一行为只含字母的字符串，长度不超过10000字符。 【输出形式】 输出结果第一行为最长回文字符串的长度输出结果第二行为最长的回文字符串 【样例输入1】 abcdef 【样例输出1】 0 【样例输入2】 abcba 【样例输出2】 5 abcba 【样例输入3】 `aAabccbaABcdcBA 【样例输出3】 8 AabccbaA #include&lt;stdio.h> #include&lt;string.h> #define LEN 100 /* \"最大回文子串是指个字行串中长度最大的回文字符串,其基本算法思想如下： 1、每个回文都有一个\"中心\"，当回文字符数为奇数时，中间的那个字符就是 回文中心，但是当回文的字数为偶数时,回文的中心是最中间的那两个字符, 且这两个字符相同。 2.对任一个字符或者相同的两个连续字符,我们都可以假设它为回文的\"中心\"， 向它的左右两边扩展出尽可能长的回文,对于每种假设,我们都能得到一个回文, 而最长回文必定由其中的某个假设中得到!*/ int Maxhw(char s[]) { int i,j,k,maxlen; int start=0; int slen=strlen(s); if(slen&lt;1) return 0; maxlen=0; for(i=0;i&lt;slen;i++) { for(j=0;(i-j>=0)&amp;&amp;(i+j&lt;slen);j++)// 如果以i为中心是奇数的回文子串 { if(s[i-j]!=s[i+j]) break; if(j*2+1>maxlen) { start=i-j; maxlen=j*2+1; } } for(j=0;(i-j>=0)&amp;&amp;(i+j+1&lt;slen);j++) // 如果以i为中心是偶数的回文子串 { if(s[i-j]!=s[i+j+1]) break; if(j*2+2>maxlen) { start=i-j; maxlen=j*2+2; } } } for (k=start;k&lt;start+maxlen;k++) //输出最长回文串 printf(\"%c\",s[k]); printf(\"\\n\"); return maxlen; //返回最长回文串的长度 } int main() { char ch[]=\"aAabccbaABcdcBA\"; //char ch[LEN]; //gets(ch); printf(\"%d\\n\",Maxhw(ch)); } 8.三种方法求Fabonacci数列本题要求实现求Fabonacci数列项的函数。 Fabonacci数列的定义如下：f(n)=f(n−2)+f(n−1) (n≥2)，其中f(0)=0，f(1)=1。 函数接口定义：int f( int n ); 函数f应返回第n个Fabonacci数。题目保证输入输出在长整型范围内。建议用递归实现。 //递归 #include &lt;stdio.h> int fib(int n) { if(n==1||n==2) return 1; else return fib(n-1)+fib(n-2); } int main() { int n; scanf(\"%d\",&amp;n); printf(\"%d\",fib(n)); } //递推 #include &lt;stdio.h> int main() { int i,n,a=1,b=1; scanf(\"%d\",&amp;n); for (i=3;i&lt;=(n+1)/2+1;i++) //递推求相应项的值 { a=a+b; b=b+a; } if(n%2==1) printf(\"%d \",a); else printf(\"%d\",b); } //数组方法 #include &lt;stdio.h> int main() { int i,n,m; scanf(\"%d\",&amp;n); int fib[n]; fib[0]=1;fib[1]=1; for(i=2;i&lt;n;i++) { fib[i]=fib[i-1]+fib[i-2]; } printf(\"%d\",fib[n-1]); } 9.相亲数【问题描述】 2500年前数学大师毕达哥拉斯就发现，220和284两数之间存在着奇妙的联系： 220的因数之和（除了自身之外的因数）为：110+55+44+22+20+11+10+5+4+2+1=284，284的因数之和为：142+71+4+2+1=220。 毕达哥拉斯把这样的数对称为相亲数。输入两个正整数（大于1并且在int的表示范围之内），分别计算它们所有因数之和（除了自身之外的因数），并判断它们是否是一对相亲数。 【输入形式】 从标准输入输入两个正整数，以一个空格分隔这两个正整数。 【输出形式】 以输入的先后顺序分行输出：输入的正整数，后跟英文逗号&ldquo;,&rdquo;，再从除自身之外的最大的因数开始输出其因数相加的公式（最小的因数1之后没有加号），最后输出英文等号&ldquo;=&rdquo;和因数之和。注意：所有输出元素间无空格。 若它们是一对相亲数，则在新的一行上输出1；若不是则在新的一行上输出0。 【样例输入1】 220 284 【样例输出1】 220,110+55+44+22+20+11+10+5+4+2+1=284 284,142+71+4+2+1=220 1 【样例输入2】 2560 3282 【样例输出2】 2560,1280+640+512+320+256+160+128+80+64+40+32+20+16+10+8+5+4+2+1=3578 3282,1641+1094+547+6+3+2+1=3294 0 【样例说明】 样例1中输入的两个正整数为220和284，220的因数之和为284，284的因数之和为220，所以它们是一对相亲数，最后输出1； 例2中输入的两个正整数是2560和3282，2560的因数之和为3578，3282的因数之和为3294，所以它们不是一对相亲数，最后输出0。 #include&lt;stdio.h> int p(int x) { int i,n=0; printf(\"%d,\",x); for(i=x-1;i>=1;i--) { if(x%i==0) { printf(\"%d\",i); n=n+i; if(i==1) printf(\"=\"); else printf(\"+\"); } } printf(\"%d\\n\",n); return n; } int main() { int a,b,v; scanf(\"%d %d\",&amp;a,&amp;b); v=p(a); p(b); if(v==b) printf(\"1\"); else printf(\"0\"); } 10.计算天数【问题描述】 定义一个结构体变量用以记录一个日期（包括年，月，日）。输入一个日期，计算该日是本年的第几天。 【输入形式】 输入日期（包括年 月 日），是三个整数，以空格分隔。 【输出形式】 输出该日是本年的第多少天。 【样例输入】 2003 3 25 【样例输出】 84 【样例说明】 输入一个日期，输出该日是本年的第几天。 #include&lt;stdio.h> int Y(int year) { int g; if(year%400==0) g=1; else { if(year%4==0&amp;&amp;year%100!=0) g=1; else g=0; } if(g==1) { return 1; } else { return 2; } } int main() { int a,b,c,sum; int i,k=0,n=0; scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;c); if(Y(a)==1&amp;&amp;b>2) { for(i=b-1;i>=1;i--) { if(i%2==0) n++; else k++; } sum=31*k+30*n+c-1; printf(\"%d\",sum); } if(Y(a)==2&amp;&amp;b>2) { for(i=b-1;i>=1;i--) { if(i%2==0) n++; else k++; } sum=31*k+30*n+c-2; printf(\"%d\",sum); } if(b&lt;=2) { for(i=b-1;i>=1;i--) { if(i%2==0) n++; else k++; } sum=31*k+30*n+c; printf(\"%d\",sum); } } 11.求最大公因子【问题描述】 用递归方法编写求最大公因子程序。两个正整数x和y的最大公因子定义为：如果y&lt;=x且x mod y＝0时，gcd(x,y)=y;如果y&gt;x时，gcd(x,y)=gcd(y,x);其他情况，gcd(x,y)=gcd(y,x mod y) 【输入形式】 用户在第一行输入两个数字，数字之间用空格分割。 【输出形式】 程序在下一行输出前面输入的两个数字的最大公因子。 【样例输入】 36 24 【样例输出】 12 【样例说明】 用户输入36，24，程序输出它们的最大公因子12 #include&lt;stdio.h> int f(int x,int y) { if(x%y==0) return y; else f(y,x%y); } int main() { int a,b; scanf(\"%d %d\",&amp;a,&amp;b); printf(\"%d\",f(a,b)); } 12.整数合并【问题描述】 编写一函数int comb(int a,int b)，将两个两位数的正整数a、b合并形成一个整数并返回。合并的方式是：将a的十位和个位数依次放在结果的十位和千位上， b的十位和个位数依次放在结果的个位和百位上。例如，当a＝45，b=12。调用该函数后，返回5241。要求在main函数中调用该函数进行验证：从键盘输入两个整数，然后调用该函数进行合并，并输出合并后的结果。 【输入形式】 输入两个两位数的正整数，以空格隔开。 【输出形式】 输出合并后的正整数。 【输入样例】 45 12 【输出样例】 5241 #include&lt;stdio.h> int main() { int a,b; int sum,c,d,e,f; scanf(\"%d %d\",&amp;a,&amp;b); c=(a%10)*1000; a=a/10; d=(a%10)*10; e=(b%10)*100; b=b/10; f=(b%10); sum=c+d+e+f; printf(\"%d\",sum); } 暂时就更新到这里吧","link":"/c-yu-yan-bian-cheng-ti-mu-zheng-he.html"},{"title":"Hexo-个人博客之博客实用功能添加","text":"本文以作者blinkfox的matery主题为例，对主题的部分地方进行优化，添加了一部分功能。 没有博客？ Github + Hexo 搭建个人博客超详细教程 获取我配置好的主题？ git clone git@github.com:MUYIio/hexo-themes-matery.git 须知： 不同的Hexo主题的美化方式可能存在一些差异，但也相差无几，把源代码放在合适的位置就可以。 前提条件： 进行博客主题美化前需要了解Hexo博客的目录结构，主题的目录结构！请阅读官方文档。了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus,有一定的前端知识最好。 1】添加gittalk评论插件matery主题自带gittalk评论插件，我们只需要开启就可以了。 1.打开GitHub申请，填写信息： Application name //应用名称，随便填 Homepage URL //填自己的博客地址 Application description //应用描述，随便填 Authorization callback URL //填自己的博客地址 2.打开themes/_config.yml下修改gitalk那里： gitalk: enable: true owner: 你的github用户名 repo: 你的github用户名.github.io oauth: clientId: 粘贴刚刚注册完显示的字符串 clientSecret: 粘贴刚刚注册完显示的字符串 admin: 你的github用户名 添加完成。 2】添加Valine评论系统1.进入LeanCloud官网注册账户，需要实名认证以及邮箱验证 2.创建应用 3.进入我们创建的应用，将AppID、AppKey粘贴到我们的主题配置文件_config中 valine: enable: true appId: appKey: notify: true #评论回复提醒 verify: false #验证码 visitor: false #他人可见 avatar: 'wavatar' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide pageSize: 10 placeholder: '如果你没有GitHub账号，还可以在这里评论啦！' # Comment Box placeholder 如果没有上面的配置代码，自己添加就可以。 4.最后更新就可以了，添加邮件通知、云引擎等等可以自己添加 3】添加RSS订阅 简易信息聚合是“Really Simple Syndication”或“Richsite summary”(网站内容摘要)的中文名字。是站点用来和其他站点之间共享内容的一种简易方式。英文缩写为RSS技术。 RSS是一种信息聚合的技术，是某一站点和其他站点之间共享内容的一种简易信息发布与传递的方式，使得一个网站可以方便的调用其他提供RSS订阅服务的网站内容，从而形成非常高效的信息聚合，让网站发布的内容在更大的范围内传播。他是一种用于共享新闻和其他WEB内容的数据交换规范，也是使用最广泛的一种扩展性标识语言。 安装： 1.在本地hexo目录下右键git bash here，输入以下命令： npm install hexo-generator-feed 2.安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下代码： # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 3.最后打开主题配置文件themes/_config.yml，添加以下代码： rss: /atom.xml 现在RSS订阅就添加完成。 4】增加建站时间1.在/themes/matery/layout/_partial/footer.ejs最后加上以下代码： &lt;script language=javascript> function siteTime() { window.setTimeout(\"siteTime()\", 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth() + 1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); // 北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); document.getElementById(\"sitetime\").innerHTML = \"本站已运行 \" +diffYears+\" 年 \"+diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } siteTime(); &lt;/script> 2.然后在自己想添加的地方（比如网站底部）添加以下代码： &lt;span id=\"sitetime\">&lt;/span> 5】添加404页面1.在/source/目录下新建一个404.md，加上以下代码： --- title: 404 date: 2019-07-19 16:41:10 type: \"404\" layout: \"404\" description: \"页面丢失了 :(\" --- 2.然后在/themes/matery/layout/目录下新建一个404.ejs文件，代码如下： &lt;style type=\"text/css\"> /* don't remove. */ .about-cover { height: 75vh; } &lt;/style> &lt;div class=\"bg-cover pd-header about-cover\"> &lt;div class=\"container\"> &lt;div class=\"row\"> &lt;div class=\"col s10 offset-s1 m8 offset-m2 l8 offset-l2\"> &lt;div class=\"brand\"> &lt;div class=\"title center-align\"> 404 &lt;/div> &lt;div class=\"description center-align\"> &lt;%= page.description %> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;script> $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &lt;/script> 添加完成。 6】文章图片水印1.在博客根目录下新建一个watermark.py，代码如下： ​ # -*- coding: utf-8 -*- import sys import glob from PIL import Image from PIL import ImageDraw from PIL import ImageFont def watermark(post_name): if post_name == 'all': post_name = '*' dir_name = 'source/_posts/' + post_name + '/*' for files in glob.glob(dir_name): im = Image.open(files) if len(im.getbands()) &lt; 3: im = im.convert('RGB') print(files) font = ImageFont.truetype('STSONG.TTF', max(30, int(im.size[1] / 20))) draw = ImageDraw.Draw(im) draw.text((im.size[0] / 2, im.size[1] / 2), u'@yourname', fill=(0, 0, 0), font=font) im.save(files) if __name__ == '__main__': if len(sys.argv) == 2: watermark(sys.argv[1]) else: print('[usage] &lt;input>') 写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all。 7】添加背景音乐1.首先打开网易云网页版，找到想听的歌曲，然后点击生成外链： 2.选择尺寸，复制代码： 3.然后把代码直接放到文章中就可以了： 写完文章上传就可以看到了。 8】配置音乐播放器1.首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json文件，文件内容如下所示： [{ \"name\": \"涩\", \"artist\": \"纣王老胡\", \"url\": \"http://xxx.com/music1.mp3\", \"cover\": \"http://xxx.com/music-cover1.png\" }, { \"name\": \"Take me hand\", \"artist\": \"DAISHI DANCE,Cecile Corbel\", \"url\": \"/medias/music/music2.mp3\", \"cover\": \"/medias/music/cover2.png\" }, { \"name\": \"Shape of You\", \"artist\": \"J.Fla\", \"url\": \"http://xxx.com/music3.mp3\", \"cover\": \"http://xxx.com/music-cover3.png\" }] 以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。 2.然后，在主题的 _config.yml 配置文件中激活配置即可： # 是否在首页显示音乐. music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 9】修改社交链接1.在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 2.其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fa-facebook 微信: fa-wechat QQ: fa-qq Twitter: fa-twitter github：fa-github Google：fa-goodle 官网速度比较慢也可以访问这个网站： FontAwesome 4.7.0 中完整的675个图标样式CSS参考 本主题中使用的 Font Awesome 版本为 4.7.0，使用font awesome图标版本也需要对应，不然无法显示。 如果需要更改font awesome版本，在themes/matery/source/libs/awesome/css文件夹下更换相应版本就可以，5.x版本的图标挺好看的。 另外，图标使用非常广泛，比如你可以添加在博客页脚等等，具体自己摸索 10】添加博客首页搜索功能1.安装插件 npm install hexo-generator-search --save 2.在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 11】新建友情连接 friends 页具体的主题配置已经完成。 只需要自己新增friends链接就可以， source / _data /friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"ttps://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 根据自己需要修改 12】添加百度统计 全球最大的中文网站流量分析平台，帮助企业收集网站访问数据，提供流量趋势、来源分析、转化跟踪、页面热力图、访问流等多种统计分析服务，同时与百度搜索、百度推广、云服务无缝结合，为网站的精细化运营决策提供数据支持，进而有效提高企业的投资回报率。 进入百度统计首页选择站长版注册登录；点击左上角【管理】，右边【新增网站】填写自己的网站域名，然后获取代码复制下来： 然后把代码复制到themes/matery/layout/_partial/head.ejs 上传之后等一会点击【代码安装检查】就可以看到成功了。 13】添加CNZZ网站统计1.进入友盟官网注册账户 2.添加站点 3.将代码复制粘贴到footer.ejs（任选一种样式就可以） 4.效果预览 持续更新中…","link":"/hexo-ge-ren-bo-ke-zhi-bo-ke-shi-yong-gong-neng-tian-jia.html"},{"title":"Hexo 博客代码块样式美化","text":"下面的代码放置位置基于matery主题，不同的主题可能存在一些差异，但也相差无几，自己琢磨琢磨;另外，如果原有关于代码块配置代码，请删掉，不然可能会发生冲突导致无法展示效果。 1】预览 直接看效果： 2】配置 1.首先在themes/matery/source/libs下创建一个codeBlock文件夹，后面在该文件夹下创建五个.js文件 创建codeBlockFuction.js文件夹，写入下面代码： // 代码块功能依赖 $(function () { $('pre').wrap('&lt;div class=\"code-area\" style=\"position: relative\">&lt;/div>'); }); 创建codeBLang.js文件夹，写入下面代码： // 代码块语言识别 $(function () { var $highlight_lang = $('&lt;div class=\"code_lang\" title=\"代码语言\">&lt;/div>'); $('pre').after($highlight_lang); $('pre').each(function () { var code_language = $(this).attr('class'); if (!code_language) { return true; }; var lang_name = code_language.replace(\"line-numbers\", \"\").trim().replace(\"language-\", \"\").trim(); // 首字母大写 lang_name = lang_name.slice(0, 1).toUpperCase() + lang_name.slice(1); $(this).siblings(\".code_lang\").text(lang_name); }); }); 创建codeCopy.js文件夹，写入下面代码： $(function () { var $copyIcon = $('&lt;i class=\"fa fa-copy code_copy\" title=\"复制代码\" aria-hidden=\"true\">&lt;/i>'); $('.code-area').prepend($copyIcon); new ClipboardJS('.fa-copy', { target: function (trigger) { return trigger.nextElementSibling; } }); }); 创建clipboard.min.js文件夹，写入下面代码： /*! * clipboard.js v2.0.4 * https://zenorocha.github.io/clipboard.js * * Licensed MIT © Zeno Rocha */ ! function (t, e) { \"object\" == typeof exports &amp;&amp; \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define &amp;&amp; define.amd ? define([], e) : \"object\" == typeof exports ? exports.ClipboardJS = e() : t.ClipboardJS = e() }(this, function () { return function (n) { var o = {}; function r(t) { if (o[t]) return o[t].exports; var e = o[t] = { i: t, l: !1, exports: {} }; return n[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports } return r.m = n, r.c = o, r.d = function (t, e, n) { r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }) }, r.r = function (t) { \"undefined\" != typeof Symbol &amp;&amp; Symbol.toStringTag &amp;&amp; Object.defineProperty(t, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t, \"__esModule\", { value: !0 }) }, r.t = function (e, t) { if (1 &amp; t &amp;&amp; (e = r(e)), 8 &amp; t) return e; if (4 &amp; t &amp;&amp; \"object\" == typeof e &amp;&amp; e &amp;&amp; e.__esModule) return e; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, \"default\", { enumerable: !0, value: e }), 2 &amp; t &amp;&amp; \"string\" != typeof e) for (var o in e) r.d(n, o, function (t) { return e[t] }.bind(null, o)); return n }, r.n = function (t) { var e = t &amp;&amp; t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, \"a\", e), e }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r.p = \"\", r(r.s = 0) }([function (t, e, n) { \"use strict\"; var r = \"function\" == typeof Symbol &amp;&amp; \"symbol\" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t &amp;&amp; \"function\" == typeof Symbol &amp;&amp; t.constructor === Symbol &amp;&amp; t !== Symbol.prototype ? \"symbol\" : typeof t }, i = function () { function o(t, e) { for (var n = 0; n &lt; e.length; n++) { var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o &amp;&amp; (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function (t, e, n) { return e &amp;&amp; o(t.prototype, e), n &amp;&amp; o(t, n), t } }(), a = o(n(1)), c = o(n(3)), u = o(n(4)); function o(t) { return t &amp;&amp; t.__esModule ? t : { default: t } } var l = function (t) { function o(t, e) { ! function (t, e) { if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\") }(this, o); var n = function (t, e) { if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return !e || \"object\" != typeof e &amp;&amp; \"function\" != typeof e ? t : e }(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this)); return n.resolveOptions(e), n.listenClick(t), n } return function (t, e) { if (\"function\" != typeof e &amp;&amp; null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e); t.prototype = Object.create(e &amp;&amp; e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e &amp;&amp; (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(o, c.default), i(o, [{ key: \"resolveOptions\", value: function () { var t = 0 &lt; arguments.length &amp;&amp; void 0 !== arguments[0] ? arguments[0] : {}; this.action = \"function\" == typeof t.action ? t.action : this.defaultAction, this.target = \"function\" == typeof t.target ? t.target : this.defaultTarget, this.text = \"function\" == typeof t.text ? t.text : this.defaultText, this.container = \"object\" === r(t.container) ? t.container : document.body } }, { key: \"listenClick\", value: function (t) { var e = this; this.listener = (0, u.default)(t, \"click\", function (t) { return e.onClick(t) }) } }, { key: \"onClick\", value: function (t) { var e = t.delegateTarget || t.currentTarget; this.clipboardAction &amp;&amp; (this.clipboardAction = null), this.clipboardAction = new a.default({ action: this.action(e), target: this.target(e), text: this.text(e), container: this.container, trigger: e, emitter: this }) } }, { key: \"defaultAction\", value: function (t) { return s(\"action\", t) } }, { key: \"defaultTarget\", value: function (t) { var e = s(\"target\", t); if (e) return document.querySelector(e) } }, { key: \"defaultText\", value: function (t) { return s(\"text\", t) } }, { key: \"destroy\", value: function () { this.listener.destroy(), this.clipboardAction &amp;&amp; (this.clipboardAction.destroy(), this.clipboardAction = null) } }], [{ key: \"isSupported\", value: function () { var t = 0 &lt; arguments.length &amp;&amp; void 0 !== arguments[0] ? arguments[0] : [\"copy\", \"cut\"], e = \"string\" == typeof t ? [t] : t, n = !!document.queryCommandSupported; return e.forEach(function (t) { n = n &amp;&amp; !!document.queryCommandSupported(t) }), n } }]), o }(); function s(t, e) { var n = \"data-clipboard-\" + t; if (e.hasAttribute(n)) return e.getAttribute(n) } t.exports = l }, function (t, e, n) { \"use strict\"; var o, r = \"function\" == typeof Symbol &amp;&amp; \"symbol\" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t &amp;&amp; \"function\" == typeof Symbol &amp;&amp; t.constructor === Symbol &amp;&amp; t !== Symbol.prototype ? \"symbol\" : typeof t }, i = function () { function o(t, e) { for (var n = 0; n &lt; e.length; n++) { var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o &amp;&amp; (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function (t, e, n) { return e &amp;&amp; o(t.prototype, e), n &amp;&amp; o(t, n), t } }(), a = n(2), c = (o = a) &amp;&amp; o.__esModule ? o : { default: o }; var u = function () { function e(t) { ! function (t, e) { if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\") }(this, e), this.resolveOptions(t), this.initSelection() } return i(e, [{ key: \"resolveOptions\", value: function () { var t = 0 &lt; arguments.length &amp;&amp; void 0 !== arguments[0] ? arguments[0] : {}; this.action = t.action, this.container = t.container, this.emitter = t.emitter, this.target = t.target, this.text = t.text, this.trigger = t.trigger, this.selectedText = \"\" } }, { key: \"initSelection\", value: function () { this.text ? this.selectFake() : this.target &amp;&amp; this.selectTarget() } }, { key: \"selectFake\", value: function () { var t = this, e = \"rtl\" == document.documentElement.getAttribute(\"dir\"); this.removeFake(), this.fakeHandlerCallback = function () { return t.removeFake() }, this.fakeHandler = this.container.addEventListener(\"click\", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement(\"textarea\"), this.fakeElem.style.fontSize = \"12pt\", this.fakeElem.style.border = \"0\", this.fakeElem.style.padding = \"0\", this.fakeElem.style.margin = \"0\", this.fakeElem.style.position = \"absolute\", this.fakeElem.style[e ? \"right\" : \"left\"] = \"-9999px\"; var n = window.pageYOffset || document.documentElement.scrollTop; this.fakeElem.style.top = n + \"px\", this.fakeElem.setAttribute(\"readonly\", \"\"), this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = (0, c.default)(this.fakeElem), this.copyText() } }, { key: \"removeFake\", value: function () { this.fakeHandler &amp;&amp; (this.container.removeEventListener(\"click\", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem &amp;&amp; (this.container.removeChild(this.fakeElem), this.fakeElem = null) } }, { key: \"selectTarget\", value: function () { this.selectedText = (0, c.default)(this.target), this.copyText() } }, { key: \"copyText\", value: function () { var e = void 0; try { e = document.execCommand(this.action) } catch (t) { e = !1 } this.handleResult(e) } }, { key: \"handleResult\", value: function (t) { this.emitter.emit(t ? \"success\" : \"error\", { action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) }) } }, { key: \"clearSelection\", value: function () { this.trigger &amp;&amp; this.trigger.focus(), window.getSelection().removeAllRanges() } }, { key: \"destroy\", value: function () { this.removeFake() } }, { key: \"action\", set: function () { var t = 0 &lt; arguments.length &amp;&amp; void 0 !== arguments[0] ? arguments[0] : \"copy\"; if (this._action = t, \"copy\" !== this._action &amp;&amp; \"cut\" !== this._action) throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"') }, get: function () { return this._action } }, { key: \"target\", set: function (t) { if (void 0 !== t) { if (!t || \"object\" !== (void 0 === t ? \"undefined\" : r(t)) || 1 !== t.nodeType) throw new Error('Invalid \"target\" value, use a valid Element'); if (\"copy\" === this.action &amp;&amp; t.hasAttribute(\"disabled\")) throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute'); if (\"cut\" === this.action &amp;&amp; (t.hasAttribute(\"readonly\") || t.hasAttribute(\"disabled\"))) throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes'); this._target = t } }, get: function () { return this._target } }]), e }(); t.exports = u }, function (t, e) { t.exports = function (t) { var e; if (\"SELECT\" === t.nodeName) t.focus(), e = t.value; else if (\"INPUT\" === t.nodeName || \"TEXTAREA\" === t.nodeName) { var n = t.hasAttribute(\"readonly\"); n || t.setAttribute(\"readonly\", \"\"), t.select(), t.setSelectionRange(0, t.value.length), n || t.removeAttribute(\"readonly\"), e = t.value } else { t.hasAttribute(\"contenteditable\") &amp;&amp; t.focus(); var o = window.getSelection(), r = document.createRange(); r.selectNodeContents(t), o.removeAllRanges(), o.addRange(r), e = o.toString() } return e } }, function (t, e) { function n() {} n.prototype = { on: function (t, e, n) { var o = this.e || (this.e = {}); return (o[t] || (o[t] = [])).push({ fn: e, ctx: n }), this }, once: function (t, e, n) { var o = this; ​ function r() { ​ o.off(t, r), e.apply(n, arguments) ​ } ​ return r._ = e, this.on(t, r, n) }, emit: function (t) { ​ for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), o = 0, r = n.length; o &lt; r; o++) n[o].fn.apply(n[o].ctx, e); ​ return this }, off: function (t, e) { ​ var n = this.e || (this.e = {}), ​ o = n[t], ​ r = []; ​ if (o &amp;&amp; e) ​ for (var i = 0, a = o.length; i &lt; a; i++) o[i].fn !== e &amp;&amp; o[i].fn._ !== e &amp;&amp; r.push(o[i]); ​ return r.length ? n[t] = r : delete n[t], this } }, t.exports = n }, function (t, e, n) { var d = n(5), h = n(6); t.exports = function (t, e, n) { if (!t &amp;&amp; !e &amp;&amp; !n) throw new Error(\"Missing required arguments\"); if (!d.string(e)) throw new TypeError(\"Second argument must be a String\"); if (!d.fn(n)) throw new TypeError(\"Third argument must be a Function\"); if (d.node(t)) return s = e, f = n, (l = t).addEventListener(s, f), { destroy: function () { l.removeEventListener(s, f) } }; if (d.nodeList(t)) return a = t, c = e, u = n, Array.prototype.forEach.call(a, function (t) { t.addEventListener(c, u) }), { destroy: function () { Array.prototype.forEach.call(a, function (t) { t.removeEventListener(c, u) }) } }; if (d.string(t)) return o = t, r = e, i = n, h(document.body, o, r, i); throw new TypeError(\"First argument must be a String, HTMLElement, HTMLCollection, or NodeList\"); var o, r, i, a, c, u, l, s, f } }, function (t, n) { n.node = function (t) { return void 0 !== t &amp;&amp; t instanceof HTMLElement &amp;&amp; 1 === t.nodeType }, n.nodeList = function (t) { var e = Object.prototype.toString.call(t); return void 0 !== t &amp;&amp; (\"[object NodeList]\" === e || \"[object HTMLCollection]\" === e) &amp;&amp; \"length\" in t &amp;&amp; (0 === t.length || n.node(t[0])) }, n.string = function (t) { return \"string\" == typeof t || t instanceof String }, n.fn = function (t) { return \"[object Function]\" === Object.prototype.toString.call(t) } }, function (t, e, n) { var a = n(7); function i(t, e, n, o, r) { var i = function (e, n, t, o) { return function (t) { t.delegateTarget = a(t.target, n), t.delegateTarget &amp;&amp; o.call(e, t) } }.apply(this, arguments); return t.addEventListener(n, i, r), { destroy: function () { t.removeEventListener(n, i, r) } } } t.exports = function (t, e, n, o, r) { return \"function\" == typeof t.addEventListener ? i.apply(null, arguments) : \"function\" == typeof n ? i.bind(null, document).apply(null, arguments) : (\"string\" == typeof t &amp;&amp; (t = document.querySelectorAll(t)), Array.prototype.map.call(t, function (t) { return i(t, e, n, o, r) })) } }, function (t, e) { if (\"undefined\" != typeof Element &amp;&amp; !Element.prototype.matches) { var n = Element.prototype; n.matches = n.matchesSelector || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector } t.exports = function (t, e) { for (; t &amp;&amp; 9 !== t.nodeType;) { if (\"function\" == typeof t.matches &amp;&amp; t.matches(e)) return t; t = t.parentNode } } }]) }); 创建codeShrink.js文件夹，写入下面代码： // 代码块收缩 $(function () { var $code_expand = $('&lt;i class=\"fa fa-chevron-down code-expand\" title=\"折叠代码\" aria-hidden=\"true\">&lt;/i>'); $('.code-area').prepend($code_expand); $('.code-expand').on('click', function () { if ($(this).parent().hasClass('code-closed')) { $(this).siblings('pre').find('code').show(); $(this).parent().removeClass('code-closed'); } else { $(this).siblings('pre').find('code').hide(); $(this).parent().addClass('code-closed'); } }); }); 2.然后在matery.css中添加CSS代码 code { padding: 1px 5px; font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace; /* font-size: 0.91rem; */ color: #e96900; background-color: #f8f8f8; border-radius: 2px; } pre code { padding: 0; color: #e8eaf6; background-color: #272822; } pre[class*=\"language-\"] { padding: 1.2em; margin: .5em 0; } code[class*=\"language-\"], pre[class*=\"language-\"] { color: #e8eaf6; white-space: pre-wrap !important; } */ .line-numbers-rows { border-right-width: 0px !important; } .line-numbers { padding: 1.5rem 1.5rem 1.5rem 3.2rem !important; margin: 1rem 0 !important; background: #272822; overflow: auto; border-radius: 0.35rem; tab-size: 4; } pre { padding: 1.5rem !important; margin: 1rem 0 !important; background: #272822; overflow: auto; border-radius: 0.35rem; tab-size: 4; } pre::before { content: \"\"; height: 16px; margin-bottom: 0; display: block; } pre::after { content: \" \"; position: absolute; border-radius: 50%; background: #ff5f56; width: 12px; height: 12px; top: 0; left: 12px; margin-top: 12px; -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; } code { padding: 1px 5px; font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace; font-size: 0.91rem; color: #e96900; background-color: #f8f8f8; border-radius: 2px; } .code_copy { position: absolute; top: 0.7rem; right: 35px; z-index: 1; filter: invert(50%); cursor: pointer; } .code_lang { position: absolute; top: 1.2rem; right: 60px; line-height: 0; font-weight: bold; font-family: normal; z-index: 1; filter: invert(50%); cursor: pointer; } .code-expand { position: absolute; top: 4px; right: 0px; filter: invert(50%); padding: 7px 10px; z-index: 1; cursor: pointer; transition: all .3s; transform: rotate(0deg); } .code-closed .code-expand { transform: rotate(-180deg) !important; transition: all .3s; } .code-closed pre::before { height: 0px; } pre code { padding: 0; color: #e8eaf6; background-color: #272822; } pre[class*=\"language-\"] { padding: 1.2em; margin: .5em 0; } code[class*=\"language-\"], pre[class*=\"language-\"] { color: #e8eaf6; white-space: pre-wrap !important; } 3.最后在post.ejs中添加如下代码： &lt;script type=\"text/javascript\" src=\"/libs/codeBlock/codeBlockFuction.js\">&lt;/script> &lt;!-- 代码语言 --> &lt;script type=\"text/javascript\" src=\"/libs/codeBlock/codeLang.js\">&lt;/script> &lt;!-- 代码块复制 --> &lt;script type=\"text/javascript\" src=\"/libs/codeBlock/codeCopy.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"/libs/codeBlock/clipboard.min.js\">&lt;/script> &lt;!-- 代码块收缩 --> &lt;script type=\"text/javascript\" src=\"/libs/codeBlock/codeShrink.js\">&lt;/script> &lt;!-- 代码块折行 --> &lt;style type=\"text/css\">code[class*=\"language-\"], pre[class*=\"language-\"] { white-space: pre !important; }&lt;/style> 最后三连看看效果吧~","link":"/hexo-bo-ke-dai-ma-kuai-yang-shi-mei-hua.html"},{"title":"Hexo 双线部署到 Coding Pages 和 GitHub Pages 提升访问速度","text":"相信不少朋友用Hexo+Github搭建博客后，会发现网站的访问速度简直是龟速。为了摆脱GitHub的龟速暴击，我们选择把博客托管到Coding来提升访问速度。 至于什么是Coding： Coding WebIDE 是 Coding 自主研发的在线集成开发环境 (IDE)。用户可以通过 WebIDE 创建项目的工作空间, 进行在线开发, 调试等操作。同时 WebIDE 集成了 Git 代码版本控制, 用户可以选择 Coding、GitHub、BitBucket、Git@OSC 等任意的代码仓库。 WebIDE 还提供了分享开发环境的功能, 用户可以保存当前的开发环境, 分享给团队的其他成员。大家可以理解为中国版的github，如果把代码既托管到coding上，又托管到github上，让大陆的用户访问的是由coding托管的网站，歪果仁访问的是由github托管的网站，以此来提升我们网站的访问速度。 部署到 Coding Pages 的好处：国内访问速度更快，可以提交百度收录（GitHub 禁止了百度的爬取） 部署过程中我所遇到的两个问题： 使用密钥连接Coding时出现权限不足的情况；（已解决） 无法无法实现全站 HTTPS。（已解决） 这两个问题我会在文中给出解决办法。 进行下面操作的前提是你已经将自己的博客推送到GitHub（拥有自己的博客），如果没有，可以参考我之前的文章《Github + Hexo 博客搭建超详细教程》 文章目录 1.创建项目 2.配置 _config.yml 3.将代码推送到Coding 4.开启 Coding Pages 5.绑定域名并开启 Https 1.创建项目点击此处进入Coding个人版官网注册账号，由于 Coding 已经被腾讯收购了，所以登录就会来到腾讯云开发者平台： 找到创建项目： 项目名称建议和你的用户名一致，到时候可以直接通过 user_name.coding.me 访问你的博客，如果项目名与用户名不一致，则需要通过 user_name.coding.me/project_name 才能访问，项目描述随便写： 2.配置 _config.yml进入我们的项目，在右上角选择连接方式，这里我以HTTPS连接为例（SSH就复制ssh链接），将链接复制下来： 然后打开你本地博客根目录的 _config.yml 文件，找到 deploy 关键字，添加 我们刚才复制的 coding 地址： 注意： 1.如果要同时推送到GitHub和Coding，type前面加 -。 2.每一行冒号后面的空格不要忘记。 SSH连接 1.相信小伙伴们已经把博客部署在GitHub。这里操作是一样的，鼠标移动到【头像】→【个人设置】→【SSH公钥】，把我们的密钥复制粘贴到coding。 2.配置本地文件 贴上我的 3.连接coding ssh -T git@e.coding.net 我之前不选择SSH连接Coding的原因： 1.我的SSH连接GitHub没有问题，但是连接Coding就显示没有权限。 原因是：以前的连接代码是ssh -T git@git.coding.net 3.将代码推送到Coding现在我们在博客根目录下右键单击Git Bash Here，输入下面三个命令： hexo clean hexo g hexo d 使用HTTPS的缺点就是在推送时会要求我们输入Coding的用户名和密码，如果第一次输入错误了，可以参考这篇资料： git本地第一次推送密码填写错误处理方式 (By 颜墨白) 4.开启 Coding Pages进入你的项目，在构建与部署一栏选择静态网站，这里需要实名认证： 选择我们的代码库： 这个时候就可以看到我们的网站地址啦： 5.绑定域名并开启 Https在静态网站一栏右上角点击设置，下滑到底绑定我们的域名（注意：www.xxx.com 开头）： 然后打开我们的域名解析，我在之前的文章中详细介绍了关于域名解析《Github + Hexo 博客搭建超详细教程》，两种方法： 1.在域名 DNS 设置中添加一条 CNAME 记录指向 xxxx.coding.me，解析路线选择默认。 2.在域名 DNS 设置中添加一条A记录，记录指向 xxxx.coding.me的ip，解析路线选择默认。（ip地址获取：WIN+R输入cmd进入终端，输入：ping xxxx.coding.me 即可。） 将 GitHub 的解析路线改为 境外，这样境外访问就会走 GitHub，境内就会走 Coding，也有人说阿里云是智能解析，自动分配路线，如果解析路线都是默认，境外访问同样会智能选择走 GitHub，境内走 Coding。 我的解析： SSL证书申请失败解决方法： 先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问 开启HTTPS,如图，勾选即可： 文章中难免有错误的地方，有大佬发现了欢迎给我指正！有的地方解释不够详细，可以百度一下看看细节，文章中的引用以及参考资料涉及侵权请联系我删除！","link":"/hexo-shuang-xian-bu-shu-dao-coding-pages-he-github-pages-ti-sheng-fang-wen-su-du.html"},{"title":"Hexo博客提交百度收录SEO","text":"1】前言博客也搭建了几个月了，在百度/Google都没有提交收录，于是记录一下提交收录的过程。 对于Hexo博客而言，我们需要手动给搜索引擎提交收录，这样别人在搜索到文章关键词时才能够看到我们的文章，才能增加曝光率。 Github禁止了百度爬取，如果只是部署到了GitHub，是无法进行收录的。可以考虑同时部署在Coding，然后进行百度收录。参考教程： Hexo 双线部署到 Coding Pages 和 GitHub Pages 提升访问速度 2】查看网站是否收录 输入site:域名查看我们的网站是否收录 由于我之前提交过，所以有记录，正常情况下是查询不到信息的。 3】百度搜索资源平台添加网站 首先进入百度资源搜索平台注册登录（使用百度联盟账号也可以） 点击【用户中心】→【站点管理】添加网站 协议开头建议Https:// 验证站点（推荐两个方法） 1.HTML标签验证 放到head.ejs，&lt;head&gt;与 &lt;/head&gt;标签之间 2.CNAME验证 在DNS添加这条解析就可以了，生效可能得等一会。 4】提交链接 主动推送 1.安装插件： npm install hexo-baidu-url-submit --save 2.在根目录 _config.yml 文件里加入以下代码： baidu_url_submit: count: 100 # 提交最新的多少个链接 host: www.muyiio.com # 在百度站长平台中添加的域名 token: # 秘钥 path: baidu_urls.txt token可以在推送接口下面看到： 3.在根目录的 _config.yml 下找到以下配置： # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: https://www.muyiio.com root: / permalink: :year/:month/:day/:title/ url:后面填写在百度添加的域名 4.在_config.yml 加入新的deployer deploy: - type: git repository: github: git@github.com:MUYIio/MUYIio.github.io.git coding: git@e.coding.net:godxiaolon/godxiaolon.git repo: root@118.25.27.52:/home/git/blog.git branch: master - type: baidu_url_submitter #新加的主动推送 5.最后三连上传就可以了,这样显示就是成功 {\"remain\":2985,\"success\":15} #表示成功15条 INFO Deploy done: baidu_url_submitter 自动推送 1.复制代码 &lt;script> (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script> 2.放到\\themes\\material-x\\layout\\_partial\\head.ejs的&lt;head&gt;与 &lt;/head&gt;标签之间。 3.如果主题集成了这个功能，比如 next 主题，在 themes\\next\\layout_scripts\\ 下有个 baidu_push.swig 写入下面代码： {% if theme.baidu_push %} &lt;script> (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script> 然后在文件主题配置文件_config.yml 中设置 即可。 baidu_push: true 5】总结 我只使用了上面两种方法推送，更多的可以自己尝试。 收录大概需要半个多月，耐心等待。","link":"/hexo-bo-ke-ti-jiao-bai-du-shou-lu-seo.html"},{"title":"Hexo博客添加在线留言DaoVoice实时联系","text":"DaoVoice简介：DaoVoice 是一款革命性的应用运营平台，致力于帮助企业实现以用户为中心的「精益运营」体系。融合「在线聊天」、「客服支持」、「用户画像」、「消息推送」、「行为引导」等功能为一体， 按需获取用户信息和行为，实现场景化消息推送，让通知更富有人情味。只需数分钟的安装，你将与你网站用户及访客开启便捷沟通的窗口。更多请查看：DaoVoice 用户手册 “DaoVoice 帮我们更好地运营用户。实时在线沟通，可更快解决用户问题。后台管理可帮我们建立用户画像，针对不同的用户需求进行精准运营。此外，DaoVoice 团队会快速响应我们的反馈，给予高质量服务支持。”——————-Travis 创始人 &amp; CEO 1.注册DaoVoice并获取安装代码DaoVoice入口 2.本地配置部署我使用的是Hexo matery主题，配置如下，不同主题可能需要改动： ①复制下面代码放到theme/layout/_partial/head.ejs中的 /head&gt; 之前 &lt;% if(theme.daovoice.enable &amp;&amp; theme.daovoice.appid){ %> &lt;script>(function (i, s, o, g, r, a, m) { i['DaoVoiceObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments); }; i[r].l = 1 * new Date(); a = s.createElement(o); m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; a.charset = 'utf-8'; m.parentNode.insertBefore(a, m); })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/&lt;%= theme.daovoice.appid %>.js\", 'daovoice'); daovoice('init', { app_id: \"&lt;%= theme.daovoice.appid %>\", }); daovoice('update'); &lt;/script> &lt;% } %> ②复制下面代码到theme/_config并填入ID # Online contact 在线客服 Daovoice 参考：http://dashboard.daovoice.io daovoice: # 在线客服 Daovoice 参考：http://dashboard.daovoice.io enable: true # 是否开启在线客服聊天 appid: 'xxxxxx' # 应用ID设置 ID在图示位置： ③最后: hexo clean #清除缓存 hexo g #生成hexo文件 hexo s #预览 hexo d #部署 3.DaoVoice个性化配置选择【聊天设置】个性化设置：","link":"/hexo-bo-ke-tian-jia-zai-xian-liu-yan-daovoice-shi-shi-lian-xi.html"},{"title":"Hexo网站部署node版本过高配置问题","text":"前几天更新了node，部署博客的时候发现部署不了了。主要的提示如下，查了一下发现是node版本过高，更新前是13.x，更新后是14.15.5。 The “mode” argument must be integer. Received an instance of Object 网上的解决办法林林总总，使用NVM我感觉挺麻烦，于是来个直接点的。 方法一点击此处进入node官网下载，尽量选择与更新前版本相近的版本，我下载的13.14.0，选择.msi后缀下载到本地，卸载更新的nodejs，重新安装就可以了。 方法二1】找到node安装位置不知道安装位置的，可以Win+R输入cmd按下回车，输入where node查询： 2】下载旧版本node点击此处进入node官网下载，尽量选择与更新前版本相近的版本，我下载的13.14.0，下载到本地文件夹解压打开如图，删除圈中的三个文件： 3】替换node本地文件打开本地node安装位置，删除里面的所有文件，将我们下载的node替换进去： 这样就🆗啦，如果不行重启一下试试，输入hexo -v可以看到node版本已经变更：","link":"/hexo-wang-zhan-bu-shu-node-ban-ben-guo-gao-pei-zhi-wen-ti.html"},{"title":"Hexo 博客部署到腾讯云服务器","text":"相信大家把博客部署到服务器都是为了加快访问速度，这里就不啰嗦了。 这篇教程没有使用宝塔Linux面板部署，浏览器访问会显示不安全，如果Hexo博客只部署到服务器，不部署到GitHub或者coding，那么请参照我的另一篇文章，使用宝塔面板更为方便，主要是为了部署SSL。 Hexo博客部署到腾讯云服务器(使用宝塔面板) 我的服务器 系统 CentOS 7.5 64bit 配置 标准型S2/1核/2GB/1Mbps 服务器需要的环境 环境：git，Nginx 使用git 自动化部署发布 打开腾讯云，进入【云服务器】→【登录】 初始密码在右上角消息里面有 1】Git安装及配置一、安装依赖库和编译工具 安装依赖库： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 然后会出现： Is this ok [y/d/N]:输入y继续安装，后面也一样。 安装编译工具： yum install gcc perl-ExtUtils-MakeMaker package 二、下载 git并解压编译安装 查看服务器已有的git版本 git --version然后会看到： git version 1.8.3.1 但是官网版本已经更新了，因为yum仓库的Git版本更新的时间会存在延时，我们这里采用源码包安装方式安装。 将陈旧版本的git删除 yum remove git 选择一个目录来存放下载下来的 git 安装包。这里选择了/usr/local/src 目录 cd /usr/local/src 下载最新版git到/usr/local/src，可以在官网找到版本，目前最新版本是2.26.0。 wget http://ftp.ntu.edu.tw/software/scm/git/git-2.26.0.tar.gz 解压到当前目录 tar -zvxf git-2.26.0.tar.gz 进入 git-2.26.0.tar.gz 目录下 cd git-2.26.0 执行编译 make prefix=/usr/local/git all 安装 git 到 /usr/local/git 目录下 make prefix=/usr/local/git install三、配置 git 环境变量 打开环境变量配置文件 vim /etc/profile按i进入编辑模式，按向下键到底部，添加下面两行命令： PATH=$PATH:/usr/local/git/bin # git 的目录 export PATH按esc退出，按:wq保存编辑。(注意是先:再是wq) 使 git 环境变量生效 source /etc/profile 验证安装完成，查看 git 的版本号 git --version这时候我们的git版本已经变成了： git version 2.26.0 四、创建 git 用户 创建git用户 adduser git 获取权限 chmod 740 /etc/sudoers vim /etc/sudoers按 i 键进入文件的编辑模式，按向下键找到如下字段 root ALL=(ALL) ALL在其后面增加一句： git ALL=(ALL) ALL按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入:，然后输入wq回车） 退回权限 chmod 400 /etc/sudoers五、配置密钥 创建密钥 来到这里的小伙伴应该都已经有了自己的hexo博客，那么肯定已经创建过自己的密钥，一般存放在c/用户/.ssh下。 如果没有自己的密钥，可以移步我之前的教程，里面有密钥创建步骤 Github + Hexo 搭建个人博客超详细教程 将密钥保存在服务器(之前有密钥的直接复制就可以) 将id_rsa.pub里面的密钥复制,在服务器运行下面命令，创建.ssh文件夹 su git mkdir ~/.ssh创建.ssh/authorized_keys文件，打开authorized_keys文件并将刚才在本地机器复制的内容拷贝其中并保存 vim ~/.ssh/authorized_keys按i进入编辑模式粘贴完按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入:，然后输入wq回车） 修改权限 chmod 755 ~ chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 测试本地连接服务器 在本地电脑git bash here //yourIp为远程服务器的ip地址 ssh -v git@yourIp //yourIp为你的服务器ip如图则证明本地机器与远程机器已经接通 六、创建git仓库 切换到root用户，创建一个目录用于存储网站的根目录 su root 创建网站的根目录 mkdir /home/hexo 给予权限 chown gitgit -R //hexo2】安装Nginx Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务 一、安装配置Nginx 安装Nginx yum install -y nginx 配置Nginx nginx -t使用vim打开nginx.conf文件 vim /etc/nginx/nginx.conf按i进入编辑模式粘贴完按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入:，然后输入wq回车） server { listen 80 default_server; listen [::]:80 default_server; server_name www.muyiio.com; //你的博客域名 root /home/hexo; //git仓库目录 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } j error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 启动Nginx systemctl start nginx.service 重启Nginx systemctl restart nginx.service二、自动化部署 获取root权限 su root 建立git仓库 cd /home/git git init --bare blog.git 修改blog.git权限 chown git:git -R blog.git 在 /home/hexo/blog.git 下，有一个自动生成的 hooks 文件夹，我们创建一个新的 git 钩子 post-receive，用于自动部署。 vim blog.git/hooks/post-receive 按 i 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录 #!/bin/bash git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f 按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入：，然后输入wq回车） 修改文件权限，使得其可执行。 chmod +x /home/git/blog.git/hooks/post-receive3】配置本地Hexo 博客根目录_config下增加 deploy: type: git repo: root@***(服务器ip,内网外网都行):/home/git/blog.git #仓库地址 branch: master #分支 部署 hexo clean hexo g hexo d 输入hexo d的时候，会要求你输入自己的服务器密码 Branch 'master' set up to track remote branch 'master' from 'https://e.coding.net/godxiaolon/godxiaolon.git'. On branch master nothing to commit, working tree clean root@119.25.56.82's password: Enumerating objects: 182, done. Counting objects: 100% (182/182), done. Delta compression using up to 12 threads Compressing objects: 100% (61/61), done. Writing objects: 100% (95/95), 73.08 KiB | 3.18 MiB/s, done. Total 95 (delta 45), reused 0 (delta 0) remote: hooks/post-receive: line 1: t: command not found To 118.25.27.52:/home/git/hexoBlog.git 8df3691..7d63b39 HEAD -&gt; master Branch 'master' set up to track remote branch 'master' from 'root@118.25.27.52:/home/git/hexoBlog.git'. INFO Deploy done: git 输入密码不会有显示，输完回车就可以 如果出现bash: git-receive-pack: command not found,则运行： sudo ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack 访问服务器ip，看看有没有成功 最后，发现其实挺简单的，快去访问你的服务器ip看看有没有部署成功吧","link":"/hexo-bo-ke-bu-shu-dao-teng-xun-yun-fu-wu-qi.html"},{"title":"Linux学习笔记-Vim编辑器","text":"我的Linux版本：CentOS 发行版本：CentOS 8.1 Vi编辑器是所有Unix及Linux系统下标准的编辑器，类似于windows系统下的notepad（记事本），在Unix及Linux系统的任何版本，Vi编辑器是完全相同的，因此可以在其他任何介绍vi的地方都能进一步了解它，Vi也是Linux中最基本的文本编辑器，学会它后，我们将在Linux的世界里畅行无阻，尤其是在终端中。 vi和vim都是Linux中的编辑器，不同的是，vim比较高级，可以视为vi的升级版本。vi使用于文本编辑，但是vim更适用于coding（代码编辑）。 1】.安装Vim Centos再带Vi，所以要安装Vim取代Vi yum search vim 查找有哪些Vim包 which vim 已安装Vim的地址 rpm -qf /usr/bin/vim 查看已安装的版本 yum install vim-enhanced 安装最新的Vim 打开Vim以及使用在后文 2】.vim的三种模式1.Vim中存在三种模式：命令模式、编辑模式（输入模式）、末行模式（尾行模式）。 命令模式：在该模式下是不能对文件直接编辑，可以输入快捷键进行一些操作（删除行，复制行，移动光标，粘贴等等）【打开文件之后默认进入的模式】； 编辑模式：在该模式下可以对文件的内容进行编辑； 末行模式：可以在末行输入命令来对文件进行操作（搜索、替换、保存、退出、撤销、高亮等等）； 2.Vim的打开文件的方式： #vim 文件路径; #作用：打开指定的文件 #vim +数字 文件的路径; #作用：打开指定的文件，并且将光标移动到指定行 #vim +/关键词 文件的路径; #作用：打开指定的文件，并且高亮显示关键词 #vim 文件路径1 文件路径2 文件路径3; #作用：同时打开多个文件 重点：先复制出一个/etc/passwd文件，复制当前home目录下（千万不要在etc下直接修改！） 后续一切vim命令都是基于/root/passwd文件进行操作。 退出方式：输入:q按下回车即可 3】.命令模式 该模式是打开文件的第一个看到的模式 1.光标移动 ①光标移动到行首按键：shift + 6 或 ^（T字母上面的6，不要按小键盘的6） ②光标移动到行尾按键：shift + 4 或 $（R字母的左上角的4，不是小键盘的4） ③光标移动到首行按键：gg ④光标移动到末行按键：G ⑤翻屏向上翻屏：按键ctrl + b （before） 或 PgUp 向下翻屏：按键ctrl + f （after） 或 PgDn 2.复制操作 ①复制光标所在行按键：yy粘贴：在想要粘贴的地方按下p键 ②以光标所在行为准（包含当前行），向下复制指定的行数按键：数字yy ③可视化复制按键：ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑↓←→方向键来选中需要复制的区块，按下y键进行复制，最后按下p键粘贴 3.撤销/恢复 ①撤销：输入:u（不属于命令模式） 或者 u （undo） ②恢复：ctrl + r 恢复（取消）之前的撤销操作 4.剪切/删除 ①剪切/删除光标所在行按键：dd （删除之后下一行上移）注意：dd严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。 ②剪切/删除光标所在行为准（包含当前行），向下删除/剪切指定的行按键：数字dd （删除之后下一行上移） ③剪切/删除光标所在的当前行之后的内容，但是删除之后下一行不上移按键：D （删除之后当前行会变成空白行） ④可视化删除按键：ctrl + v（可视块）或V（可视行）或v（可视），↑↓←→移动，按下D表示删除选中行，d表示删选中块 5.光标的快速移动 ①快速将光标移动到指定的行按键：数字G ②以当前光标为准向上/向下移动n行按键：数字↑，数字↓ ③以当前光标为准向左/向右移动n字符按键：数字←，数字→ ④末行模式下的快速移动方式：移动到指定的行按键：输入英文“:”，其后输入行数数字，按下回车 4】.编辑模式1.进入方式 i:在光标所在字符前插入 a:在光标所在字符后插入 o:在光标所在行的下面另起一新行插入 I:在光标所在行的首行开始插入（如果首行有空格则在空格之后插入） A:在光标所在行的尾行开始插入 O:在光标所在行的上面另起一新行开始插入 S:删除光标所在行并开始插入 2.退出方式 按下esc键 5】.末行模式1.进入方式： 由命令模式进入，按下“:”或者“/（表示查找）”即可进入 2.退出方式： a. 按下esc b. 连按2次esc键 c. 删除末行全部输入字符 3.使用命令 ①保存操作（write） 输入：“:w” 保存文件 输入：“:w 路径” 另存为 ②退出（quit） 输入：“:q” 退出文件 ③保存并退出 输入：“:wq” 保存并且退出 ④强制 （!） 输入：“:q!” 表示强制退出，刚才做的修改操作不做保存 vim还支持另外一个保存退出方法“:x”。(推荐) ①“:x”在文件没有修改的情况下，表示直接退出，在文件修改的情况下表示保存并退出； ②如果文件没有被修改，但是使用wq进行退出的话，则文件的修改时间会被更新；但是如果文件没有被修改，使用x进行退出的话，则文件修改时间不会被更新的；主要是会混淆用户对文件的修改时间的认定。 不要使用X，X表示对文件进行加密操作。 ⑤调用外部命令 输入：“:!外部命令” ⑥搜索/查找 输入：“/关键词” 在搜索结果中切换上/下一个结果：N/n （next） 如果需要取消高亮，则需要输入：“:nohl”【no highlight】 ⑦替换 :s/搜索的关键词/新的内容 替换光标所在行的第一处符合条件的内容 :s/搜索的关键词/新的内容/g 替换光标所在行的全部符合条件的内容 :%s/搜索的关键词/新的内容 替换整个文档中每行第一个符合条件的内容 :%s/搜索的关键词/新的内容/g 替换整个文档的符合条件的内容 %表示整个文件,g表示全局（global） ⑧显示行号（临时） 输入：“:set nu”[number] 如果想取消显示，则输入：“:set nonu” 6】.模式间的切换 7】.vim的配置 Vim是一款编辑器，编辑器也是有配置文件的。 Vim配置有三种情况： a. 在文件打开的时候在末行模式下输入的配置（临时的） b. 个人配置文件（~/.vimrc，如果没有可以自行新建） c. 全局配置文件（vim自带，/etc/vimrc） ①新建好个人配置文件之后进入编辑 ②在配置文件中进行配置比如显示行号：set nu 配置好之后vim打开文件就会永远显示行号 如果某个配置项，在个人配置文件与全局配置文件产生冲突的时候应该以谁为准？ ①先在全局的配置中设置不显示行号，在个人的配置文件中设置显示行号，观察结果最后显示行号：说明以个人为准 ②先在全局中配置显示行号，在个人中设置不显示行号，观察结果最后的显示是不显示行号，说明以个人为准","link":"/linux-xue-xi-bi-ji-vim-bian-ji-qi.html"},{"title":"VMware 安装 CentOS 8.1 完整教程 ","text":"我使用的VMware版本：VMware 15 Pro 镜像：CentOS 8.1 电脑配置需求： 2 GB 及以上的RAM（官方推荐至少4G） 2 GHz 或以上的 CPU 64 位 x86 架构 20 GB 及以上硬盘空间 关于CentOS 8.1 基于Linux 4.18 提供 PHP 7.2、Python 3.6、Ansible 2.8、VIM 8.0 和 Squid 4 使用网络管理器（nmcli 和 nmtui）进行网络配置，移除了网络脚本通过 BaseOS 和应用流(AppStream)仓库发布. AppStream 是对传统rpm格式的全新扩展，为一个组件同时提供多个主要版本 YUM 包管理器基于 DNF 技术，提供模块化内容支持，增强了性能，并且提供了设计良好的API用于与其他工具集成 RHEL 8提供了版本控制工具: Git 2.18, Mercurial 4.8,和 Subversion 1.10. 内核实时修补；称为 FRR 的新路由协议堆栈（支持多种 IPv4 和 IPv6 路由协议）；伯克利数据包筛选器（eBPF）的扩展版本，可帮助系统管理员解决复杂的网络问题；支持在使用设备时对 LUKS2 中的块设备进行重新加密；此外，还提供了一种用于为容器生成 SELinux 策略的新工具 udica. CentOS 8系列增加了许多新特性，CentOS 8.1相当于它的第二个发行版本，我这里就不列出了，具体可以看官方文档： CentOS 官网文档手册 Centos8与Centos7区别参照redhat） 一、准备过程目前比较流行的两款虚拟机软件 VMware 、VirtualBox，VirtualBox安装CentOS 8系列目前还有很多Bug，推荐使用VMware。 1.安装VMware 如果你还没有安装虚拟机，进入VMware官网下载相应版本安装即可： 官网下载过程可能有点慢，这里安装过程我就不赘述了。 2.下载CentOS 8.1镜像资源 进入CentOS官网下载CentOS 8.1镜像，我这里给的是在华为云的，下载速度还是可以。 二、创建虚拟机1.打开VMware，点击创建新的虚拟机： 2.点击自定义（高级）： 3.这一步直接默认就可以： 4.选择稍后安装操作系统： 5.选择Linux，版本选择Linux 4 ×64位，因为CentOS 8系列基于 Linux 内核 4.18： 6.虚拟机名称随便，安装位置看自己电脑配置吧，建议安装在D盘： 7.处理器数量根据自己电脑来配置，反正不够后面可以更改，要安装图形界面的话可以填大一点，新手就这个配置也可以了： 8.内存大小根据自己电脑适当配置，我的电脑内存16G，所以我给它分配4G，要安装图形界面的话可以填大一点： 9.设置虚拟机网络连接模式（NAT）： 关于网络连接模式说明： 桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。 NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。 仅主机：虚拟机与宿主机直接连起来 10.选择I/O控制器类型，然后下一步： 11.选择磁盘类型： 12.选择创建新虚拟磁盘，然后下一步： 13.根据自己的需要分配磁盘容量，勾选将虚拟磁盘拆分成多个文件（方便以后将虚拟机拷贝到设备），然后下一步： 14.根据自己需要指定磁盘文件存储位置，我放在D盘： 15.到这里虚拟机就创建完成了，可以点击自定义硬件更改配置，点击完成创建成功： 三、安装CentOS 8.11.点击编辑虚拟机设置： 2.选择CD/DVD，勾选启动时连接，再选择使用ISO映像文件，找到下载好的系统镜像文件添加进去，最后确定： 3.开启此虚拟机： 4.开启虚拟机后会出现以下界面，鼠标点进黑窗口，使用键盘方向键选择第一项，安装CentOS 8，回车，系统开始自动安装 5.安装完成后选择语言，根据自己情况选择，然后点击继续： 6.首先打开网络和主机名，给虚拟机连上网络： 如果网络连接不上，多半是DHCP问题，解决办法： 解决安装centos 过程中以太网连接不上网络，不能自动分配ip的问题 (By 索渝东) 7.点击时间和日期，设置系统时间并更改时区(打开网络时间)： 8.选择安装目的地： 9.选择自定义配置，点击完成： 10.添加磁盘分区 Linux的分区，并不像Windows一样，分成C、D、E等盘，介绍几个重要的分区： 交换分区（swap）：交换分区和Windows的虚拟内存很像。现在内存也便宜，物理服务器的配置也高，以前的说法是一般为物理内存的2倍，现在一般情况下划分为4~8GB备用即可。我们虚拟机的内存是4GB，我们就划8GB吧。 启动分区（boot）：200MB足够了。 根分区（/）：剩余空间都给根分区吧。当然我们也可以单独划出/data分区，专门用来存储存数据，不过这里我们先不这样做，直接全部都给根分区。 按照下图顺序依次进行设置： 11.点击完成后会弹出更改摘要页面，点击接受更改： 12.点击开始安装： 13.设置ROOT密码： 14.点击创建用户，可以把用户设为管理员方便操作，如果密码简单就点击两次完成： 15.安装完成后点击重启电脑： 16.重启完成后点击LICENS INFORMATION,勾选同意许可，然后点击完成： 17.点击结束配置： 18.来到登录界面，点击未列出，以root登录，方便后面配置操作： 19.选择语言： 选择键盘布局： 是否打开位置服务： 然后按照需要添加账号，然后就可以进入啦： 20.关闭系统使用帮助后，来到我们的centos8.1桌面，点击活动可以看到系统软件，第一个是内置浏览器，点击最下面可以看到系统所有软件： 21.点击右上角折叠按钮可以连接网络，打开浏览器就可以访问啦，如果不能联网，在上面已经给出解决办法： 22.右上角有关机按钮，点击就可以关机： 到这里，我们的CentOS 8 Linux 就算安装完成了，其他CentOS 8 系列发行版本安装过程类似，可作参考。","link":"/vmware-an-zhuang-centos-8-1-wan-zheng-jiao-cheng.html"},{"title":"Linux网络设置-CentOS由NAT模式改为桥接模式","text":"Linux版本：CentOS CentOS发行版本：CentOS 8.1 虚拟机：VMware 在前面CentOS 8.1安装教程中关于网络配置我们默认使用的是NAT模式，这篇文章主要记录将我们的Linux网络设置由NAT模式改为桥接模式（Bridged）。 需要安装CentOS的朋友可以可以看这篇文章： VMware 安装 CentOS 8.1 完整教程 1】NAT与Bridged区别 NAT(网络地址转换模式) 虚拟机要联网得先通过宿主机才能和外面进行通信。 NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来 看，只能看到宿主机，完全看不到新建的虚拟局域网。就是虚拟系统会通过宿主机的网络来访问外网，而这里的宿主机相当于有两个网卡，一个是真实网卡，一个是虚拟网卡，真实网卡相当于链接了现实世界的真实路由器，而宿主机的虚拟网卡，相当于连接了一个可以认为是虚拟交换机。 虚拟机可以上网可以ping通主机，但是主机ping不通虚拟机。 Bridged(桥接模式) 虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。 需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。相当于在一个局域网内创立了一个单独的主机，他可以访问这个局域网内的所有的主机，但是需要手动来配置IP地址，子网掩码，并且他是和真实主机在同一个网段（nat是两个网段）. 这个模式里，虚拟机和宿主机可以互相ping通。 3】虚拟机网络设置右键点击以管理员身份打开VMware，找到要更改网络的虚拟机。 点击左上角【编辑虚拟机设置】→【网络适配器】→选择【桥接模式】，并勾选【复制物理网络连接状】态 点击左上角【编辑E】→【虚拟网络编辑器】 VMnet0、VMnet1、VMnet8，分别对应了桥接模式、仅主机模式、NAT模式。 选择【VMnet0】→【已桥接至】选择当前电脑连接的网络→【确定】 3】CentOS网络设置 查看自己电脑的IP网段（Win+R输入cmd再输入ipconfig） 将 IPv4 地址、子网掩码 、默认网关保存后面用到。 打开虚拟机，以root账户登录CentOS 1.由于我安装了图形界面，登录是这样： 说明：倘若没有设置root账户，但登录的账户yyo拥有root权限，那就直接登陆。 2.没有安装图形界面登录简单一些，我就不演示了。 获取权限 sudo -i 编辑配置ip地址信息文件（使用vi打开，CentOS自带vi） vi /etc/sysconfig/network-scripts/ifcfg-ens33可以看到我们的网络配置文件： 按i进入编辑，按方向键移动 修改这两个值： BOOTPROTO=static #设置为手动分配IP地址 ONBOOT=yes在ONBOOT=yes后面增加四个值（上面我们保存的ip）： IPADDR=192.168.0.107 # 配置为局域网固定IP(IPv4 地址) NETMASK=255.255.255.0 # 配置子网掩码 GATEWAY=192.168.0.1 # 配置局域网网关 DNS1=8.8.8.8 # 配置首选DNS，8.8.8.8为免费DNS服务器的IP地址编辑完成后按esc退出，再按:wq保存（如果无法保存，就按:wq！强制保存） 接下来修改第二个配置，输入下面这个命令 vi /etc/sysconfig/network增加这四个配置： 按i进入编辑，按方向键移动 NETWORKING=yes NETWORKING_IPV6=no #关掉IPv6 HOSTNAME=localhost.localdomain GATEWAY=192.168.0.1 #默认网关地址编辑完成后按esc退出，再按:wq保存 启动network服务,输入下面这个命令 service network restart使用CentOS 8.x 版本的就会有问题了，8以下的版本到这里就可以结束了。 事实上并没有启动network服务，而是： Redirecting to /bin/systemctl reatart network.service Failed to restart network.service: Unit network.service not found查了很多资料才发现centos 8.x 已经替换了原来的network, 新版的叫：NetworkManager，下面给出解决办法 首先安装NetworkManager yum install NetworkManager* 启动NetworkManager service NetworkManager restart 开启NetworkManager网络服务 systemctl status NetworkManager 4】验证网络 在Windows终端ping我们CentOS的IP：192.168.0.107，可以正常通信。 在CentOS验证一下，也是完全🆗 一番折腾下来，花费了不少时间，尤其是NetworkManager那里，都不想写这篇文章了，但是又想解决这个困难，希望对有需要朋友的有点帮助！ 参考： centos7输入systemctl status network.service出现Unit network.service could not be found的解决办法 Failed to restart network.service: Unit network.service not found","link":"/linux-wang-luo-she-zhi-centos-you-nat-mo-shi-gai-wei-qiao-jie-mo-shi.html"},{"title":"Windows+Ubuntu20.04双系统安装教程","text":"由于需要在Linux下写代码，之前虚拟机安装过centos，但运行速度不理想，使用颇为受限，故安装双系统，这篇教程没有繁琐赘述，重要之处以及我所遇到的一些BUG都会详细说明。 1. 为什么选择Ubuntu20.04之前使用centos，但是centos8.x已经不再维护，综合其他一些原因选择Ubuntu，而且这个发行版本会维护5年（具体到哪一年忘记了），很多需要用到的软件也会一直支持。 2. 我的电脑配置 惠普战99 工作站 Windows10 家庭版 64 16GRAM 固态硬盘256，2T机械 3. 安装方式上面说到了，我的固态硬盘其实所剩无几，于是选择安装在机械硬盘（需要几百兆SSD容量），我压缩了500G的机械硬盘空间来给·Ubuntu，有条件的全部在分在固态硬盘就行。 另外重要两点 Ubuntu的/SWAP（虚拟内存）分区最好在固态硬盘这样读写速度会快一点（建议），具体大小根据RAM决定，后面会说明。 Ubuntu的/boot分区要分在Windows系统盘，这样才能在Windows状态下读取到Ubuntu，否则会出现无法启动Ubuntu的情况。 一、制作启动硬盘1. 下载Ubuntu20.04 ISO官网入口下载LTS版本，我是直接下载的，搭配迅雷下载器还是很快的几分钟吧，如果速度很慢可以从华为或者清华大学镜像网站下载。 2.下载 UltraISO并制作启动U盘UltraISO官网入口点免费下载试用，安装好后打开点击免费试用。 准备一个4G以上大小的U盘，制作过程中会格式化U盘，记得备份文件 选择好下载的UbuntuISO文件打开，点击【启动】→【写入硬盘映像】如图： 写入方式选择【USB-HDD+】 点击【写入】会弹出格式化U盘提示点击确定等待写入完成即可。 二、为Ubuntu分配磁盘空间我们需要在固态硬盘（也就是系统盘）分出300M-500M的空间用于Ubuntu的/boot分区来作为启动引导文件（否则无法启动Ubuntu，具体原因百度），另外如果固态硬盘充足可以预留处/SWAP分区的空间。 swap,电脑内存8G大小就分配内存两倍的空间,8G以上跟内存一样大或者稍大1、2个G,交换空间,虚拟内存，这个建议分固态硬盘的区，不然会影响运行速度，机械硬盘也是可以用的. 右键点击【此电脑】，选择【管理】→【磁盘管理】，选择想压缩的盘右键单击可以看到压缩卷，点进去就能看到可压缩大小，单位是MB，我在机械硬盘分了500G大小，固态硬盘分了20G大小。 这是我压缩好后的样子： 由于电脑存储文件并非连续的，比如前面20G使用了，之间空了10G，后面的又占用了，那么这10G也就无法压缩。所以会出现可压缩空间远远小于剩余空间 解决方法参考： 进行磁盘分区时，“可用压缩空间”远小于真实的空间大小时的设置方法 Windows系统压缩卷时可压缩空间远小于实际剩余空间解决方法 三、安装Ubuntu1. 查看电脑BIOS模式WIN+R输入msinfo32，回车确认 BIOS模式，传统代表MBR，另外就是UEFI，Ubuntu是UFFI模式 2. BiOS安装准备插入我们制作好的启动硬盘，开机按F10进入BiOS模式（不同的电脑进入方式可能不同，另外建议把英文改为中文，方法自行百度） 不会操作先看说明，我的是按F1，选择【系统设置】→【启动选项】 将【U盘/USB硬盘】更改为首选项，我的电脑是按F5/F6移动，F10保存。 保存退出后，电脑会自动重启进入Ubuntu的安装。 3. 开始安装①. 将语言改为中文或者英文，点击安装Ubuntu ②. 键盘布局选择【Chinese】，后面的连接网络我就跳过了，如果要选择【正常安装】要联网。 ③. 由于我准备的硬盘大小充足，所以我选择【正常安装】，也可以选择【最小安装】不影响使用。其他的在图中。 ④. 安装类型选择其他选择其他选项。 ⑤. 创建分区，这是最重要的一步，我的分区如下： - 注意：先分逻辑区，再分主分区 1./swap交换分区（虚拟内存），逻辑分区，我分了16GB（8G及以下RAM选择两倍大小，以上跟RAM大小一样就行） 2./boot分区 ，逻辑分区，默认ext4。 我分了将近300M，放置Ubuntu的启动引导文件， 3./ 根分区（root分区），逻辑分区，我选择100G就可以，默认ext4， 4./home分区，主分区，默认ext4，我选择400G，用户的所有文件都在这里。 说明：交换分区和/boot分区容量我都是在c盘压缩的，/和/home分区总共500G是在机械硬盘分的，另外根据自己的实际情况合理分配就行了，按照我的比例。 不清楚Linux分区的自行百度或者查看这篇文章：Linux下硬盘分区：根分区（/）交换分区（/swap）和/boot分区 分区按照我上面的说明来就行，我就不一一展示了，位置选择压缩好的空闲分区（或者用分区助手创建的分区，看大小和使用量就知道，创建的分区不是空闲分区，不能点加号，更改为可用就行），点左下角加号创建。 安装启动引导器的设备选择/boot分区那个路径，然后点击【现在安装】 ⑥. 开始安装，我只用了20分钟不到就安装好了，没有几个小时，一次成功。 4. 更改BIOS启动选项安装好Ubuntu之后，拔下U盘（不拔等会开机还会进入Ubuntu安装），右上角关机，彻底关机后开机F10进入BIOS，跟之前的步骤一样，选择【系统设置】→【启动选项】，将【操作系统的启动管理员】上移 按ENTER将Ubuntu启动移到第一位，保存退出，开机进入启动界面就可以看到选项了，第一位是Ubuntu，第三个是Windows. 四. 安装完成至此Ubuntu安装全部完成，接下来就可以愉快的使用Linux了，遇到不会的建议先查看官方文档。如果教程有什么不足之处欢迎指正评论。学无止境，希望这篇文章对你有所帮助！","link":"/windows-ubuntu20-04-shuang-xi-tong-an-zhuang-jiao-cheng.html"},{"title":"《X86汇编语言从实模式到保护模式》阅读笔记","text":"基本概念处理器基本工作：取指令，执行指令，数据访问，万变不离其宗。而处理器访问内存地址通过内存的分段机制来实现。分段机制为： 逻辑地址（20位）=段寄存器地址左移4位（16位）+偏移地址（16位）。 使用上述方式是有历史原因，由于早期只有16位的寄存器，16位的只能达到64KB内存，为了能够表示更大的内存，8086提供20位的地址线可以达到1MB。将16位的段地址+16位的偏移地址不足以得到20位的物理地址，于是将16位的端寄存器左移4位+偏移地址，形成20位的物理地址。 分段机制最重要两个寄存器。CS：代码段寄存器，用于表示cpu从代码段哪个位置执行；DS：数据段寄存器，指向数据段。","link":"/x86-hui-bian-yu-yan-cong-shi-mo-shi-dao-bao-hu-mo-shi-yue-du-bi-ji.html"},{"title":"《汇编语言》王爽著学习笔记记录(后半部分)","text":"第七章：更灵活的定位内存地址的方法 and 和 or 指令： 指令 功能 例 and 将操作对象的相应位设为0，其它位不变 将al的第0位设为0：and al,11111110B or 逻辑或指令，按位进行或运算 将al的第6位设为1：or al,01000000B 使用这两个命令可以帮助我们对内存中的数据按位置 0 或 1. 指明内存单元的另一个方法：[bx + idata]来访问一个内存单元(一个变量一个常量)，其代表的是一个偏移地址；这种内存访问方式为高级语言实现数组提供了便利机制。 命令 mov ax,[200 + bx] 的含义为： (ax) = ((ds) * 16 + (bx) + 200) 通用写法： mov ax,[bx + 200] mov ax,200[bx] mov ax,[bx].200 si 和 di 是8086CPU中两个和 bx 功能相近的寄存器， 但不能分为两个 8 为寄存器来使用。 mov bx，0 mov ax，[bx] mov si，0 mov ax，[si] mov di，0 mov ax，[di] mov bx,0 mov ax,[bx + 123] mov si,0 mov ax,[si + 123] mov di,0 mov ax,[di + 123] 上面的代码说明了si 与 di 同 bx 使用上的相同之处。 我们可以使用 [bx (si 或 di)]（一个变量） 、[bx (si 或 di) + idata] （一个变量和一个常量）来指明一个内存单元，还有 [bx + si] 、[bx + di] （两个变量） mov ax,[bx + si] ;(ax) = ((ds) * 16 + (bx) + (si)) 常用形式: mov ax,[bx] [si] 更多的内存访问方式：[bx + si + idata] 、[bx + di + idata]（两个变量，一个常量） mov ax,[bx + si + idata] ;(ax) = ((ds) * 16 + (bx) + (si) + idata) 常用形式： mov ax,[bx + 200 + si] mov ax,[200 + bx + si] mov ax,200[bx][si] mov ax,[bx].200[si] mov ax,[bx] [si].200 将datasg中的每个单词改为大写字母： ;版本1 ;使用 dx 寄存器临时保存 cx 中的值 assume cs:codesg,ds:datasg datasg segment db 'ibm ' db 'dec ' db 'dos ' db 'vax ' datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 ;此时指向第一行第一个字节的字母 mov cx,4 s0: mov dx,cx ;将 cx 的值暂存到 dx 中 mov si,0 mov cx,3 s: mov al,[bx + si] ;(al) = ((ds) * 16 + (bx) + (si)) and al,11011111b ;将小写字母改为大写字母 mov [bx + si],al ;((ds) * 16 +(bx) + (si)) = (al) inc si ;si + 1 loop s add bx,16 ;00 → 10 → 20 → 30 ... mov cx,dx ;将暂存的 cx 返回 loop s0 ;cx - 1 codesg ends end start ;版本2 ;使用栈空间来暂存数据，前面我们使用的是寄存器，但有些时候寄存器是不足的，不是可取的办法 assume cs:codesg,ds:datasg,ss:stacksg datasg segment db 'ibm ' db 'dec ' db 'dos ' db 'vax ' datasg ends stacksg segnebt dw 0,0,0,0,0,0,0,0,0 ;定义一个段用作栈段，容量为16字节 stacksg ends codesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov bx,0 ;此时指向第一行第一个字节的字母 mov cx,4 s0: push cx ;将外循环 cx 的值压栈 mov si,0 mov cx,3 ;内循环 cx 的值 s: mov al,[bx + si] ;(al) = ((ds) * 16 + (bx) + (si)) and al,11011111b ;将小写字母改为大写字母 mov [bx + si],al ;((ds) * 16 +(bx) + (si)) = (al) inc si ;si + 1 loop s add bx,16 ;00 → 10 → 20 → 30 ... pop cx ;将暂存的 cx 返回 loop s0 ;cx - 1 mov ax,4c00H int 21H codesg ends end start 在需要暂存数据的时候，一般使用栈来操作 将 datasg 段中每个单词前4个字母改为大写： assume cs:codesg,ds:datasg,ss:stacksg datasg segment db '1. display ' db '2. brows ' db '3. replace ' db '4. modify ' datasg ends stacksg segnebt dw 0,0,0,0,0,0,0,0,0 ;定义一个段用作栈段，容量为16字节 stacksg ends codesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov bx,0 ;此时指向第一行第一个字节的字母 mov cx,4 s0: push cx ;将外循环 cx 的值压栈 mov si,0 mov cx,4 ;内循环 cx 的值 s: mov al,[bx + 3 + si] ;(al) = ((ds) * 16 + (bx) + (si) + 3) and al,11011111b ;将小写字母改为大写字母 mov [bx + 3 + si],al ;((ds) * 16 +(bx) + (si) + 3) = (al) inc si ;si + 1 loop s add bx,16 ;00 → 10 → 20 → 30 ... pop cx ;将暂存的 cx 返回 loop s0 ;cx - 1 mov ax,4c00H int 21H codesg ends end start 第八章：数据处理的两个基本问题 描述性符号： 符号 功能 集合 reg 代表一个寄存器 ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di sreg 代表一个段寄存器 ds、ss、cs、es 在8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 […] 中来进行内存单元的寻址。 在 […] 中，这四个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di mov ax,[bx] mov ax,[si] mov ax,[di] mov ax,[bp] mov ax,[bx + si] mov ax,[bx + di] mov ax,[bp + si] mov ax,[bp + di] mov ax,[bx + si + idata] mov ax,[bx + di + idata] mov ax,[bp + si + idata] mov ax,[bp + di + idata] 使用寄存器 bp 进行寻址，如果没有显性的给出段地址，那么段地址默认在 ss 段寄存器中 mov ax,[bp] ;(ax) = ((ss) * 16 + (bp)) mov ax,[bp + si + idata] ;(ax) = ((ss) * 16 + (bp) + (si) + idata) 处理指令大致分为3类：读取、写入、运算；指令执行前，数据一般在3个地方：CPU内部、内存、端口 数据的位置： 立即数（idata）：在汇编指令中字节给出 mov ax,1 add bx,2000H 寄存器：要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名就可以。 段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，使用段地址+偏移地址定位内存单元。 寻址方式总结： 寻址方式 含义 名称 常用格式 [idata] EA = idata;SA = (ds) 直接寻址 [idata] [bx] EA = (bx);SA = (ds) 寄存器间接寻址 [bx] [si] EA = (si) ;SA = (ds) [di] EA = (di);SA = (ds) [bp] EA = (bp);SA = (ds) [bx + idata] EA = (bx) + idata;SA = (ds) 寄存器相对寻址 用于结构体:[bx].idata [si + idata] EA = (si) + idata;SA = (ds) 用于数组:idata[si],idata[di] [di + idata] EA = (di) + idata;SA = (ds) 用于二维数组:[bx] [idata] [bp + idata] EA = (bp) + idata;SA = (ss) [bx + si] EA = (bx) + (si);SA = (ds) 基址变址寻址 用于二维数组:[bx] [si] [bx + di] EA = (bx) + (di);SA = (ds) [bp + si] EA = (bp) + (si);SA = (ss) [bp + di] EA = (bp) + (di);SA = (ss) [bx + si + idata] EA = (bx) + (si) + idata;SA = (ds) 相对基址变址寻址 用于表格中的数组:[bx].idata[si] [bx + di + idata] EA = (bx) + (di) + idata;SA = (ds) [bp + si + idata] EA = (bp) + (si) + idata;SA = (ss) 用于二维数组:idata[bx] [si] [bp + di + idata] EA = (bp) + (di) + idata;SA = (ss) 8086CPU 可以处理 byte 和 word 两种尺寸的数据。 通过寄存器名指明要处理的数据的尺寸： ;字操作 mov ax,1 add ax,1000 inc ax ;字节操作 mov al add al000 inc al 没有寄存器名存在得情况下，用操作符 X ptr 指明内存单元的长度，X 可以为 byte 或 word： ;word ptr 表示访问一个字单元 mov word ptr ds:[0],1 inc word ptr [bx] inc word ptr ds:[0] add word ptr [bx],2 ;byte ptr 表示访问一个字节单元 mov byte ptr ds:[0],1 inc byte ptr [bx] inc byte ptr ds:[0] add byte ptr [bx],2 在机器指令中指明要访问的是字单元还是字节单元是非常重要的，8086CPU中，一个byte为8bit，而一个字为2byte，如果不指明，那么在访问的时候是有区别的。 使用 push 和 pop 指令就代表了是进行字操作，无需指明 div 除法指令： (1)除数：8位和16位两种，在一个reg或内存单元中 (2)被除数：默认在AX或AX和DX中，除数位8位，被除数位16位，默认在AX中存放；除数位16位，则被除数位32位，DX存放高16位，AX存放低16位。 (3)结果：如果除数位8位，则AL存储除法操作的商，AH存放余数；如果除数位16位，AX存储除法操作的商，DX存放余数 ;格式 div reg div 内存单元 ;示例 div byte ptr ds:[0] ;(al) = (ax) / ((ds) * 16 + 0 )的商 ;(ah) = (ax) / ((ds) * 16 + 0)的余数 div word ptr es:[0] ;(ax) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的商 ;(dx) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的余数 div byte ptr [bx + si + 8] ;(al) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的商 ;(ah) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的余数 div word ptr [bx + si + 8] ;(ax) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的商 ;(dx) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的余数js 计算：100001 / 100 ;100001 > 65535,所以除数得是32位，转为16进制为 186A1H，所以高16位在DX中，低16位在AX中 mov dx,1 mov ax,86A1H mov bx,100 div bx 伪指令 dd 、dup 指令 功能 示例 db 定义字节型数据 db 1 dw 定义字型数据 dw 100 dd 定义dword双字型数据 dd 100001 dup 与上面3个指令配合使用，用来进行数据的重复 db(dw、dd) 重复次数 dup (重复的数据) 汇编语言实验七： ;题目太长，只贴代码，先思考写代码，而后体会别人的代码 assume cs:code data segment db '1975','1976','1977','1978','1979','1980','1981','1982','1983','1984','1985' db '1986','1987','1988','1989','1990','1991','1992','1993','1994','1995' dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514,345980 dd 590827,803530,1183000,1843000,2758000,3753000,4649000,5937000 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 data ends stack segment dw 0,0,0,0,0,0,0 stack ends table segment db 21 dup ('year summ ne ?? ') table ends code segment start: mov ax,data mov es,ax mov si,0 mov ax,table mov ds,ax mov di,0 mov ax,stack mov ss,ax mov sp,16 mov bx,0 mov cx,21 s0: mov ax,es:[si] mov ds:[di+bx],ax add si,2 add di,2 mov ax,es:[si] mov ds:[di+bx],ax mov ax,es:[si+82] mov ds:[bx+di+3],ax mov ax,es:[si+84] mov ds:[bx+di+5],ax add si,2 mov di,0 add bx,16 loop s0 mov bx,0 mov si,168 mov di,5 mov cx,21 s1: mov ax,es:[si] mov ds:[bx+di+5],ax mov ax,ds:[bx+di] mov dx,ds:[bx+di+2] div word ptr ds:[bx+di+5] mov ds:[bx+di+8],ax add si,2 add bx,16 loop s1 mov ax,4c00h int 21h code ends end start 第九章：转移指令的原理 可以修改 IP ，或者同时修改 CS 和 IP 得指令统称为转移指令。 段内转移：jmp ax 短转移IP修改范围：-128~127 近转移IP修改范围：-32768~32767 段间转移：jmp 1000:0 转移指令分为无条件转移指令（jmp）和条件转移指令、循环指令、过程、中断等等 操作符 offset ，能够取得标号的偏移地址： start: mov ax,offset start ;取得start的偏移地址，相当于 mov ax，0 第十章：CALL和RET指令 第十一章：标志寄存器 第十二章：内中断 第十三章：int 指令 第十四章：端口 第十五章：外中断 第十六章：直接定址表 第十七章：使用BIOS进行键盘输入","link":"/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu-hou-ban-bu-fen.html"},{"title":"十大经典排序算法(附动画及代码)","text":"各个算法的时空复杂度及稳定性： 稳定：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。 一、冒泡排序（Bubble Sort）1、原理​ 基本思想：通过无序区中相邻元素关键字间的比较和位置的交换，使关键字最小的元素像气泡一样浮到最顶部；接着对剩下的元素排序，使得第二小的元素到达顶部，同样的方法直到所有元素排序完成。 2、步骤 ① 比较相邻的元素。如果第一个比第二个大，就交换它们两个； ② 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； ③ 针对所有的元素重复步骤 ① ~ ②，除了最后一个元素，直到排序完成。 3、动画演示 4、代码实现void bubble_sort() { for (int i = n-1; i >= 1; i -- ) { bool flag = true; for (int j = 1; j &lt;= i; j ++ ) if (a[j-1] > a[j]) { swap(a[j-1], a[j]); flag = false; } if (flag) return; } } 二、选择排序（Selection Sort）1、原理​ 选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2、步骤n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 3、动画演示 4、代码实现void select_sort() { for (int i = 0; i &lt; n; i ++ ) { int k = i; for (int j = i+1; j &lt; n; j ++ ) { if (a[j] &lt; a[k]) k = j; } swap(a[i], a[k]); } } 三、插入排序（Insertion Sort）1、原理 这里主要针对直接插入排序。将元素与已经排序的有序序列比较，找到对应的位置插入。 2、步骤 ① 从第一个元素开始，该元素可以认为已经被排序； ② 取出下一个元素，在已经排序的元素序列中从后向前扫描； ③ 如果该元素（已排序）大于新元素，将该元素移到下一位置； ④ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； ⑤ 将新元素插入到该位置后； ⑥ 重复步骤2~5。 3、动画演示 4、代码实现void insert_sort() { for (int i = 1; i &lt; n; i ++ ) { int x = a[i]; int j = i-1; while (j >= 0 &amp;&amp; x &lt; a[j]) { a[j+1] = a[j]; j -- ; } a[j+1] = x; } } 四、快速排序（Quick Sort）1、原理​ 一般选择将待排序序列分为两个序列，正中间的那个数作为关键字，然后两个指针一个从头到关键字遍历，遇到大于（小于）关键字的元素就停下来，另一个指针从尾到关键字遍历，遇到小于（大于）关键字的元素停下来，交换两个指针的元素完成排序；将序列递归分治按照前面的原理排序，直到序列有序。 2、步骤快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 选取基准元素（pivot） 划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分 递归求解小于pivot和大于pivot的部分 基准元素可以选择第一个元素或者最后一个元素即 Lomuto Partition Scheme，但是这样划分成两部分的时候有一部分是空的，这样可能造成死循环；从中间划分可以保证两部分都不为空，即 Hoare Partition Scheme。 3、动画演示 4、代码实现void quick_sort(int q[], int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] > x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 快速排序的边界问题 快排属于分治算法，最怕的就是 n分成0和n，或 n分成n和0,导致死循环。 以j为划分时，x不能选q[r] (若以i为划分,则x不能选q[l]) ​ 假设 x = q[r] ​ 关键句子quick_sort(q, l, j), quick_sort(q, j + 1, r); ​ 由于j的最小值是l,所以q[j+1..r]不会造成无限划分 ​ 但q[l..j]（即quick_sort(q, l, j)）却可能造成无限划分，因为j可能为r ​ 举例来说，若x选为q[r]，数组中q[l..r-1] &lt; x, ​ 那么这一轮循环结束时i = r, j = r，显然会造成无限划分 do i++; while(q[i] &lt; x)和do j–; while(q[j] &gt; x)不能用q[i] &lt;= x 和 q[j] &gt;= x ​ 假设q[l..r]全相等 ​ 则执行完do i++; while(q[i] &lt;= x);之后，i会自增到r+1 ​ 然后继续执行q[i] &lt;= x 判断条件，造成数组下标越界(但这貌似不会报错) ​ 并且如果之后的q[i] &lt;= x (此时i &gt; r) 条件也不幸成立， ​ 就会造成一直循环下去(亲身实验)，造成内存超限(Memory Limit Exceeded) if(i &lt; j) swap(q[i], q[j])能否使用 i &lt;= j ​ 可以使用if(i &lt;= j) swap(q[i], q[j]); ​ 因为 i = j 时，交换一下q[i],q[j] 无影响，因为马上就会跳出循环了 最后一句能否改用quick_sort(q, l, j-1), quick_sort(q, j, r)作为划分(用i做划分时也是同样的道理,) ​ 不能 ​ 根据之前的证明，最后一轮循环可以得到这些结论 ​ j &lt;= i 和 q[l..i-1] &lt;= x, q[i] &gt;= x 和 q[j+1..r] &gt;= x, q[j] &lt;= x ​ 所以，q[l..j-1] &lt;= x 是显然成立的， ​ 但quick_sort(q, j, r)中的q[j] 却是 q[j] &lt;= x，这不符合快排的要求 ​ 另外一点，注意quick_sort(q, l, j-1), quick_sort(q, j, r)可能会造成无线划分 ​ 当x选为q[l]时会造成无限划分，报错为(MLE), ​ 如果手动改为 x = q[r],可以避免无限划分 ​ 但是上面所说的q[j] &lt;= x 的问题依然不能解决，这会造成 WA (Wrong Answer) j的取值范围为[l..r-1] ​ 证明: ​ 假设 j 最终的值为 r ,说明只有一轮循环(两轮的话 j 至少会自减两次) ​ 说明q[r] &lt;= x (因为要跳出do-while循环) ​ 说明 i &gt;= r(while循环的结束条件), i 为 r 或 r + 1(必不可能成立) ​ 说明 i 自增到了 r , 说明 q[r] &gt;= x 和 q[l..r-1] &lt; x, ​ 得出 q[r] = x 和 q[l..r-1] &lt; x 的结论,但这与 x = q[l + r &gt;&gt; 1]矛盾 ​ 反证法得出 j &lt; r ​ 假设 j 可能小于 l 说明 q[l..r] &gt; x ,矛盾 ​ 反证法得出 j &gt;= l 所以 j的取值范围为[l..r-1],不会造成无限划分和数组越界。 五、希尔排序（Shell Sort）1、原理​ 希尔排序又叫缩小增量排序，也是一种插入排序方法（通常快于直接插入法），具体做法是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序； 2、步骤 1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作… 2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。 对于增量的选定无一定论，但最后一个增量必须等于1，也就是说，每趟后一个增量是前一个增量的1/2。 3、动画演示 4、代码实现void shell_sort() { for (int gap = n >> 1; gap; gap >>= 1) { for (int i = gap; i &lt; n; i ++ ) { int x = a[i]; int j; for (j = i; j >= gap &amp;&amp; a[j-gap] > x; j -= gap) a[j] = a[j-gap]; a[j] = x; } } } 六、归并排序（Merge Sort）1、原理 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 2、步骤 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列 3、动画演示 4、代码实现void merge_sort(int q[], int l, int r) { //递归的终止情况 if(l >= r) return; //第一步：分成子问题 int mid = l + r >> 1; //第二步：递归处理子问题 merge_sort(q, l, mid ), merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1, tmp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k]; } tmp 保存的是 q[l..mid] , q[mid+1..r] 中从小到大排序的所有数 证明(第一个 while 循环) 循环不变式: tmp[0..k-1] 保存上述俩数组中从小到大排序的最小 k 个数 1.初始 ​ k = 0, tmp[0..k-1] 为空，显然成立 2.保持 ​ 假设某轮循环开始之前，循环不变式成立 ​ 若 q[i] &lt;= q[j], 则 tmp[k] = q[i] ​ 其中 q[i] &lt;= q[i+1..mid], q[i] &lt;= q[j] &lt;= q[j+1..r] ​ ∴ q[i] 是剩下的所有数中最小的一个 ​ 当 q[i] &gt; q[j] 时，同理可以得到 tmp[k] = q[j] 是剩下数中最小的一个 ​ ∴ tmp[k] 是剩下数中最小的一个 ​ ∴ k自增之后，下轮循环开始之前，tmp[0..k-1]保存从小到大排序的最小k个数 3.终止 ​ i &gt; mid 或 j &gt; r ​ 则 q[l..mid] 和 q[mid+1..r] 其中一个数组的数都已遍历 ​ tmp[0..k-1]保存从小到大排序的最小k个数 七、计数排序（Counting Sort）1、原理​ 计数排序，又叫非比较排序，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数 2、步骤 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 3、动画演示 4、代码实现void counting_sort() { int sorted[N]; int maxv = a[0]; for (int i = 1; i &lt; n; i ++ ) if (maxv &lt; a[i]) maxv = a[i]; int count[maxv+1]; for (int i = 0; i &lt; n; i ++ ) count[a[i]] ++ ; for (int i = 1; i &lt;= maxv; i ++ ) count[i] += count[i-1]; for (int i = n-1; i >= 0; i -- ) { sorted[count[a[i]]-1] = a[i]; count[a[i]] -- ; } for (int i = 0; i &lt; n; i ++ ) a[i] = sorted[i]; } 八、基数排序（Radix Sort）1、原理基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 2、步骤 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点)。 3、动画演示 4、代码实现int maxbit() { int maxv = a[0]; for (int i = 1; i &lt; n; i ++ ) if (maxv &lt; a[i]) maxv = a[i]; int cnt = 1; while (maxv >= 10) maxv /= 10, cnt ++ ; return cnt; } void radixsort() { int t = maxbit(); int radix = 1; for (int i = 1; i &lt;= t; i ++ ) { for (int j = 0; j &lt; 10; j ++ ) count[j] = 0; for (int j = 0; j &lt; n; j ++ ) { int k = (a[j] / radix) % 10; count[k] ++ ; } for (int j = 1; j &lt; 10; j ++ ) count[j] += count[j-1]; for (int j = n-1; j >= 0; j -- ) { int k = (a[j] / radix) % 10; temp[count[k]-1] = a[j]; count[k] -- ; } for (int j = 0; j &lt; n; j ++ ) a[j] = temp[j]; radix *= 10; } } 九、桶排序（Bucket Sort）1、原理 遍历原始序列确定最大值 maxval 和最小值 minval，并确定桶的个数 n; 然后，将待排序集合中处于同一个值域的元素存入同一个桶中,在桶内使用各种现有的算法进行排序; 最后按照从小到大的顺序依次收集桶中的每一个元素, 即为最终结果。 2、步骤 1.设置一个定量的数组当作空桶； 2.遍历输入数据，并且把数据一个一个放到对应的桶里去； 3.对每个不是空的桶进行排序； 4.从不是空的桶里把排好序的数据拼接起来。 桶排序是一种用空间换取时间的排序。桶的个数和大小都是我们人为设置的，而每个桶又要避免空桶的情况，所以我们在使用桶排序的时候即需要对待排序数列要求偏均匀，又要要求桶的设计兼顾效率和空间；数要相对均匀分布，桶的个数也要合理设计。在设计桶排序时，需要知道输入数据的上界和下界。 3、动画演示 （动图来源于@五分钟学算法，侵删） 4、代码实现//桶排序 void BucketSort(int a[], int n){ int minval = a[0], maxval = a[0]; for(int i = 0; i &lt; n; i ++){//寻找原序列数组元素的最大值和最小值 minval = min(minval, a[i]); maxval = max(maxval, a[i]); } int bnum = 10;//桶中元素个数 int m = (maxval - minval) / bnum + 1;//桶的个数 vector&lt; vector&lt;int> > bucket(m); //收集,将元素入相应的桶中. 减偏移量是为了将元素映射到更小的区间内,省内存 for(int i = 0; i &lt; n; i ++) bucket[(a[i] - minval) / bnum].push_back(a[i]); //将桶内元素排序 for(int i = 0; i &lt; m; i ++) sort(bucket.begin(), bucket.end()); //收集, 将各个桶中的元素收集到一起 for(int i = 0, k = 0; i &lt; m; i ++){ for(int j = 0; j &lt; bucket[i].size(); j ++){ data[k ++] = bucket[i][j]; } } } 十、堆排序（Heap Sort）1、原理先看看堆的特性： 堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 2、步骤 1.构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆； 2.此时的堆顶元素，为最大或者最小元素； 3.把堆顶元素和堆尾元素互换，调整堆，重新使堆有序； 4.此时堆顶元素为第二大元素； 5.重复以上步骤，直到堆变空。 3、动画演示 4、代码实现void down(int u) { int t = u; if (u&lt;&lt;1 &lt;= n &amp;&amp; h[u&lt;&lt;1] &lt; h[t]) t = u&lt;&lt;1; if ((u&lt;&lt;1|1) &lt;= n &amp;&amp; h[u&lt;&lt;1|1] &lt; h[t]) t = u&lt;&lt;1|1; if (u != t) { swap(h[u], h[t]); down(t); } } int main() { for (int i = 1; i &lt;= n; i ++ ) cin >> h[i]; for (int i = n/2; i; i -- ) down(i); while (true) { if (!n) break; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n]; n -- ; down(1); } return 0; }","link":"/qsort.html"},{"title":"《汇编语言》王爽著学习笔记记录(前半部分)","text":"看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。 第一章：基础知识 汇编指令是机器指令的助记符，同机器指令一一对应。 每一种CPU都有自己的汇编指令集 在存储器中指令和数据没有任何区别，都是二进制信息。 CPU可以直接使用的信息在存储器中存放。 存储器单元从零开始顺序编号。 一个存储单元可以存储8 bit，即8个二进制位。 1Byte = 8bit…. 每一个CPU芯片都有许多管脚，它们与总线相连。其分为三类： 地址总线的宽度决定了CPU的寻址能力 数据总线的宽度决定了CPU与其它器件进行数据传送时一次数据传送量 控制总线的宽度决定了CPU对系统中其它器件的控制能力 内存地址空间：最终运行程序的是CPU，对CPU来讲，系统中所有的存储器的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力（读取内存地址的范围）的限制。这个逻辑存储器即内存地址空间。 第二章：寄存器 8086CPU所有的寄存器都是16位的，可以存放两个字节。 AX、BX、CX、DX这四个寄存器用来存放一般性数据，称为通用寄存器。为了兼容，通常把它们掰为两半来使用,它们可以独立使用： AX → AH + AL BX → BH + BL CX → CH + CL DX → DH + DL 在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的。 8086cpu一次性能处理16位地址，但有20位地址总线，于是采用两个16位地址合成来形成一个20位的物理地址。 物理地址 = 段地址 * 16 + 偏移地址，其含义是用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加得到物理地址。 将若干地址连续的内存单元看作是一个段，段地址就是该段的起始地址，用偏移地址定位段中的具体位置。其中段地址必然是16的倍数，偏移地址为16位，所以寻址能力为64K，故一个段的长度最大为64K 段寄存器：CS、DS、SS、ES、 8086pc机中，设CS中的内容为M(段地址)，IP中的内容为N(偏移地址)，任意时刻，CPU将从M * 16 + N内存单元读取指令执行。 “ jmp 某一合法寄存器” ：用寄存器中的值修改 IP。 Debug基本命令： 命令 功能 格式 R(Register) 查看、改变CPU寄存器中的内容 ①查看：直接输入r，②修改寄存器值：r ax，按enter然后输入数据 D(Dump) 查看内存中的内容 d 段地址：偏移地址 或者 d 段地址：偏移地址段 或d 起始位置 L长度 E(Enter) 改写内存中的内容 e 起始地址 数据 数据 … 空格键表示处理完成 U(Unassemble) 将内存中的机器指令翻译为汇编指令 u 段地址：偏移地址 T(Trace) 执行一条机器指令 输入t ，CPU执行CS:IP指向的指令 A(Assemble) 以汇编指令的格式在内存中写入一条机器指令 a 段地址：偏移地址，接着输入汇编指令 第三章：寄存器(内存访问) 8086CPU用16位来存储一个字，高8位存放在高位字节，低8位存放在低位字节。一个字用两个地址连续的内存单元存放，低位字节在低位地址，高位字节在高位地址。 DS寄存器通常用来存放要要访问的数据的段地址。不支持直接将数据送入段寄存器。 mov、add、sub指令 指令 格式 示例 mov 寄存器，数据 mov ax，6 mov 寄存器，寄存器 mov ax，bx mov 寄存器，内存单元 mov ax，[8] mov 内存单元，寄存器 mov [9]，ax mov 段寄存器，寄存器 mov ds，ax add 寄存器，数据 add ax，0 add 寄存器，寄存器 add ax，bx add 寄存器，内存单元 add ax，[0] add 内存单元，寄存器 add [0]，ax sub 寄存器，数据 sub ax，0 sub 寄存器，寄存器 aub ax，bx sub 寄存器，内存单元 sub ax，[9] sub 内存单元，寄存器 sub [9]，ax 入栈：将新元素放到栈顶，出栈：从栈顶取出一个元素。遵循先入后出原则（LIFO） PUSH（入栈），POP（出栈），以字为单位进行， 任意时刻，SS:SP指向栈顶元素，push和pop执行时，cpu从ss：sp中得到栈顶地址。 执行PUSH指令时，SP=SP-2，表示栈顶向上移动；执行pop指令时，SP=SP+2，表示栈顶向下移动；当栈为空时，SS:SP指向栈顶内存地址+2的内存单元。 在使用栈的时候，应当注意不要出现越界。 出栈的顺序应该和入栈的顺序相反，这与栈后入先出的特性相关。 PUSH过程：①CPU先改变SP=SP+2，②向SS：SP处传送； POP过程：①CPU先向SS：SP读取数据，②改变SP的值SP=SP-2。 push和pop指令操作栈的时候，修改的只是SP。 栈的栈顶变化范围：0~FFFFH，所以一个栈段最大容量为64K. 第四章：第一个程序 伪指令：由编译器执行的指令，CPU是不知道它们的，由编译器执行它们 指令 功能 段名 segment … 段名 ends 定义一个段，segment说明一个段开始，ends说明一个段结束 ebd 汇编程序结束的标志 assume assume cs：code，将段code与寄存器cs关联起来 mov ax，4c00H int 21H 两行汇编指令，实现程序返回 连接（LINK）作用： 当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件； 程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件； 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。 EXE文件加载过程：找到一段起始地址为0的空闲区，创建一个程序段前缀（PSP），在PSP后256字节开始，即SA+10H:0为段地址载入ds寄存器中，并初始化CS:IP指向这个地址。 第五章：[BX]和loop指令 [BX]: 指令 功能 mov ax，[bx] bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即(ax) = ((ds)*16 + (bx)) mov [bx]，ax bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA:EA处，即((ds)*16 + (bx)) = (ax) loop指令： 指令 格式 功能 loop loop 标号 实现循环功能，cx中存放着循环次数，就相当于for，cx为0向下执行，不为0循环 使用方法： ①在cx中存放循环次数②loop指令中的标号所标识地址在前面③循环执行的程序段在标号和lpp指令之间 loop指令框架： mov cx，循环次数 s： 循环执行的程序段 loop s 在汇编源程序中，数据不能以字母开头。所以大于9FFFH的数要在前面加0。 loop指令的每一次都先判断cx的值，不为0则CS：IP指向下一步循环指令的地址，CPU执行。 在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须使用 “[…]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显示的给出段地址所在的段寄存器。 mov al,ds:[0] //正确的表示 mov al,[0] //masm就将[idata] 解释为 idata ，而不是一个内存单元地址 用于显示的指明内存单元的段地址的 “ds:” 、”cs:”、”ss:”、”es:”，在汇编语言中成为段前缀。 在pc机中，一般 0:200~0:2ff 的256个字节的空间是安全的，即没有其它应用使用这段内存单元。 第六章：包含多个段的程序 在操作系统环境中，合法的通过操作系统取得的空间都是安全的，需要在汇编源程序中做出说明 dw(define word) 关键字的意思是定义字型数据，数据之间使用逗号分隔。 将 start 放在第一条指令前面，然后在伪指令 end 后面加上 start，表示程序第一条指令从前面的 start 开始。 内存空间的开辟：使用 dw 关键字定义一些字型数据，通常为 0，然后将这一段空间当作栈段来使用。 使用内存 0:0~0:15 单元中的内容改写为程序中的数据: assume cs:codesg codesg segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h start: mov ax,0 mov ds,ax mov bx,0 ;ds = 0,bx = 0 mov cx,8 ;循环8次 s: mov ax,[bx] ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax mov cs:[bx],ax ;将ax中的数据放入内存地址 ((cs)*16 + (bx)) 处，[bx]为偏移地址，段地址在cs中 add bx,2 ;bx + 2 loop s mov ax,4c00h int 21h codesg ends end start 使用内存 0:0~0:15 单元中的内容改写为程序中的数据（数据的传送用栈来进行。栈空间设置在程序内）： assume cs:codesg codesg segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h dw 0,0,0,0,0,0,0,0,0,0 start: mov ax,cs mov ss,ax mov sp,24h ;或mov sp, 36 ，ss:sp = cs:24h mov ax,0 mov ds,ax ;ds = 0 mov bx,0 ;bx = 0 mov cx,8 ;循环8次 s: push [bx] ;将[bx]中的数据压入栈中 pop cs:[bx] ;或 pop ss:[bx], add bx,2 ;bx + 2 loop s mov ax,4c00h int 21h codesg ends end start 在汇编程序中，一个段的段名就代表了这个段的段地址，而偏移地址需要根据段中的数据来确定。 8086CPU不允许直接将一个数值送入段寄存器，应该由一个寄存器比如 ax 来中转。 汇编语言实验五： （1）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题 assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h data ends stack segment dw 0,0,0,0,0,0,0,0 stack ends code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends end start ①CPU执行程序，程序返回前，data段中的数据 不变 。 ②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。 ③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。 （2）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。 assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h data ends stack segment dw 0,0 stack ends code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends end start ①CPU执行程序，程序返回前，data段中的数据 不变 。 ②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。 ③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。 ④对于如下定义的段： name segment …… name ends 如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 ((N+15)/16)*16 。 ④解析： N分为被16整除和不被16整除。 当N被16整除时： 占有的空间为(N/16)*16 当N不被16整除时： 占有的空间为(N/16+1)*16，N/16得出的是可以整除的部分，还有一个余数，余数肯定小于16，加上一个16。 程序加载后分配空间是以16个字节为单位的，也就是说如果不足16个字节的也分配16个字节。 两种情况总结成一个通用的公式：((N+15)/16)*16 （3）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。 assume cs:code,ds:data,ss:stack code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends data segment dw 0123h,0456h data ends stack segment dw 0,0 stack ends end start ①CPU执行程序，程序返回前，data段中的数据 不变 。 ②CPU执行程序，程序返回前，CS= 0C86H ，SS= 0C8AH ，DS= 0C89H 。 ③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X+3 ，STACK段的段地址为 X+4 。 （4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。 答：start 作为汇编程序的一个标号，定义了程序的入口，如果不指名入口，程序会从加载进内存的第一个单元起开始执行，前二个题中，前面定义的是数据段、栈段，CPU 能够执行，但在整个程序上来讲，逻辑顺序错误，这样会导致空间二次分配等等情况。 ​ 如果指明了程序的入口，CPU会直接从入口处开始执行真正的机器码，直到遇到中断指令返回，比如指令进行到需要栈段空间的时候，CPU 会跳到前面定义的栈段得到分配空间的地址。此种方式能够确保程序逻辑上的正确。因此有必要为程序来指明入口。 ​ 综上，只有（3）可以在没有指明程序入口的情况下正确执行。 （5）程序如下，编写code段中代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。 assume cd:code a segment db 1,2,3,4,5,6,7,8 a ends b segment db 1,2,3,4,5,6,7,8 b ends c segment db 0,0,0,0,0,0,0,0 c ends code segment start: mov ax,a mov ds,ax ;ds段寄存器地址指向a mov ax,b mov es,ax ;es段寄存器地址指向b mov ax,c mov ss,ax ;ss段寄存器地址指向c mov bx,0 ;偏移地址为0 mov cx,8 ;循环8次 s: mov ax,[bx] ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax mov ss:[bx],ax ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中 mov ax,es:[bx] ;(ax) = ((es)*16 + (bx)),将对应的数据送入ax mov ss:[bx],ax ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中 inc bx ;bx + 1 loop s mov ax,4c00h int 21h code ends end start （6）程序如下，编写 code 段中代码，用 push 指令将 a 段中的前8个字型数据，逆序存储到 b 段中。 assume cs:code a segment dw 1,2,3,4,5,6,7,8 a ends b segment dw 0,0,0,0,0,0,0,0 b ends code segment start: mov ax,a mov ds,ax ;ds指向a段 mov ax,b mov bx,0 ;ds:bx 指向a段的第1个单元 mov ss,ax mov sp,16 ;设置栈顶指向 b:16 mov cx,8 ;循环8次 s: push [bx] add bx,2 ;bx + 2 loop s ;将a段中0～16个单元逆次入栈 code ends end start","link":"/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu.html"},{"title":"个人博客、网站被恶意DDOS攻击怎么办","text":"起因：几天前我的博客遭受DDOS攻击，攻击次数高达85万次，腾讯云COS加CDN欠费400，作为一个小白碰到有点不知所措，所以记录一下我处理的过程。 首先，我的网站Page在Github和TencentYun，同时托管在服务器上，之前觉得腾讯云COS够快就没使用GitHub免费图床（付钱还有风险）。 拒绝服务攻击（DDoS）DDoS(Distributed Denial of Service),即分布式拒绝服务攻击,是目前最为强大、最难以防御的攻击方式之一。要理解DDos,得先从DoS说起。 最基本的DoS攻击就是利用合理的客户端请求来占用过多的服务器资源,从而使合法用户无法得到服务器的响应。DDoS攻击手段是在传统的DoS攻击基础之上产生的一类攻击方式,传统的DoS攻击一般是采用一对一方式的,当攻击目标CPU速度、内存或者网络带宽等等各项性能指标不高的情况下,它的效果是明显的,但随着计算机与网络技术的发展,计算机的处理能力显著增加,内存不断增大,同时也出现了千兆级别的网络,这使得DoS攻击逐渐失去效果。这时候分布式拒绝服务攻击手段(DDoS)便应运而生了。你理解了DoS攻击以后, DDoS的原理就非常简单了,它指的是攻击者借助公共网络,将数量庞大的计算机设备联合起来作为 攻击平台,对一个或多个目标发动攻击,从而达到瘫痪目标主机的目的。通常,在攻击开始前,攻击者会提前控制大量的用户计算机,称之为“肉鸡”,并通过指令使大量的肉鸡在同一时刻对某个主机进行访问,从而达到瘫痪目标主机的目的。 DDoS的攻击有很多种类型,如依赖蛮力的ICMP Flood、UDP Flood等等,随着硬件性能的 提升,需要的机器规模越来越大,组织大规模的攻击越来越困难,现在已经不常见,还有就是依赖协议特征以及具体的软件漏洞进行的攻击,如Slowloris攻击,Hash碰撞攻击等等,这类攻击主要利用协议以及软件漏洞发起攻击,需要在特定环境下才会出现,更多的攻击者采用的是前面两种的混合方式,即利用了协议、系统的缺陷,又具备了海量的流量, 如SYN Flood、DNS Query Flood等等。 这里再说一下另外一种CC攻击CC(Challenge Collapsar)攻击属于DDos的一种,是基于应用层HTTP协议 发起的DDos攻击,也被称为HTTP Flood。 CC攻击的原理是这样的,攻击者通过控制的大量“肉鸡”或者利用从互联网上搜寻的大量匿名的HTTP代理,模拟正常用户给网站发起请求直到该网站拒绝服务为止。大部分网站会通过CDN以及分布式缓存来加快服务端响应,提升网站的吞吐量,而这些精心构造的HTTP请求往往有意避开这些缓存,需要进行多次DB查询操作或者是一次请求返回大量的数据,加速系统 资源消耗,从而拖垮后端的业务处理系统,甚至连相关存储以及日志收集系统也无法幸免。 1】-当我知道已经是第二天早上，收到腾讯云的通知，欠费400。让我一个学生措不及防，打开电脑看到COS请求85.8万次，我猜测应该是被攻击了，第一时间找了腾讯云投诉，经过腾讯云技术人员追查是DDOS攻击，查到的IP是美国的 2】-网上查找解决办法： 1.找12315投诉，但是现在已经不受理这类纠纷。 2.找网警举报，可能是金额太低，我提交之后一直没有回复。 3.最后只能找客服了，几天的交流才给我补款。 腾讯云坚持不承担损失，只知道让我去找网警去找解决办法，我倒是不明白到底谁是用户了。口口声声说是我没有设置好安全防护，腾讯云作为产品的提供方，并没有将产品Bug完善，那么谁应该承担？ 腾讯云客服以我没有设置防盗链为由，并不承担损失。总的来说，不管设置阈值预警还是防盗链，都不能完全阻止网站被盗刷，那么我设置也就没有多大意义。次数少的攻击可以阻挡，但是上万的攻击就没用了，因为就算网站返回404页面也会产生流量，攻击次数多产生的流量就多了。 ##3】- 最后给我补款： 不管是阿里云还是其他平台CDN盗刷，都是可以退款，前提是不是自己蓄意而为。 总结：吃一堑长一智，建议做好网站的安全防护不给坏人可乘之机！","link":"/ge-ren-bo-ke-wang-zhan-bei-e-yi-ddos-gong-ji-zen-me-ban.html"},{"title":"使用 PicGo+腾讯云对象存储COS 作为图床","text":"随着博客文章的增加，网站的访问速度也变慢了，尤其是图片使用比较多的文章，在本地还得一张一张添加，更新到CSDN还得重新上传一次，有时候还会出现图片丢失问题。 于是我考虑弄个图床来储存文章图片，优化访问速度也为了更加方便。由于我的域名、服务器在腾讯云，所以就选择PicGo+对象存储COS；看了一下网上关于腾讯云COS作为图床的教程还是挺少的，所以写这篇文章记录一下。 一、腾讯云COS配置据了解腾讯云COS以前有50G永久免费额度，2019-01-25之后腾讯云对象存储COS免费额度作了调整，现在是50G免费六个月。 其次，我觉得续费也不是很贵，节约一点还是有的，而且六个月到期不使用了也可以。 现在腾讯云使用需要实名认证，没有实名认证的朋友先去认证吧，也不麻烦。 1.创建存储桶进入【对象存储】→【存储桶列表】→【创建存储桶】 访问权限选择公有读私有写，否则图片无法读取，其他的根据自己往下填写就可以。 地域建议和你网站地区一样。 2.密钥配置 点击【密钥管理】→【云API密钥】→【新建密钥】 生成的密钥我们后面会用到。 二、配置PicGo PicGo 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、sm.ms、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。 1.下载PicGo首先进入PicGo-Github项目地址下载相应版本： Windows下载我标记的版本，Linux、mac都有标明。 下载速度真的是龟速，需要的小伙伴可以在CSDN下载PicGo-Setup-2.2.2.exe压缩,找我拿2.1.2版本也可以。 2.配置PicGo打开软件，点击【腾讯云COS】，首先将我们上面创建的API密钥粘贴 然后来到我们的【储存桶列表】，将存储桶名称、地域填入PicGo，域名为空即可 记得设为默认图床，否则上传不会默认走腾讯云COS。 3.上传图片拖拽图片到PicGo，再打开COS就可以看到图片已经上传，使用的时候直接粘贴链接就可以了。 PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，以后还可以使用PicGo+GitHub作为图床。 使用COS客户端如果不喜欢使用PicGo的话，还可以下载COS客户端，下载相应版本就可以。 然后登录跟之前PicGo差不多，进去页面跟PicGo相差无几。 使用方法简单说一下，进入对象存储桶，找到你的照片，点击右边【详情】，然后把对象地址复制粘贴到markdown就可以了。 完","link":"/shi-yong-picgo-teng-xun-yun-dui-xiang-cun-chu-cos-zuo-wei-tu-chuang.html"},{"title":"使用GitHub备份Hexo博客源文件","text":"可能有的小伙伴认为备份不就创建一个仓库多简单；或者说我将Hexo博客源文件拷贝到U盘不就可以了吗，可是你写一篇文章或者更新一次配置就要拷贝一次不是很麻烦吗？ 备份博客源文件的好处： 如果电脑突然罢工，我们的源文件也不会丢失。 有时候不方便需要更换电脑写作，我们直接clone仓库就可以了。 开始我也认为创建一个仓库就可以，可是clone下来的文件却是这样？ 原因： Hexo 博客是静态托管的，仓库只有生成的静态网页文件，并没有Hexo的源文件。 备份步骤 创建一个仓库用来存放备份文件，名字随便，勾选README。 复制仓库地址，运行Git将仓库clone到本地。 git clone git@github.com:MUYIio/hexo-themes-matery.git //git@github.com:MUYIio/hexo-themes-matery.git 改为你自己的 将要备份的文件放到我们刚才clone的文件夹里面。 在clone的文件夹下运行Git（免得切换cd XXX），依次输入以下命令就可以了。 git add . git commit -m \"backup\" （注：“backup”里面换成你需要，如“first commit”） git push -u origin master （注：此操作目的是把本地仓库push到github上面，如果没有使用密钥此步骤需要你输入帐号和密码） 最后打开我们的仓库就可以看到已经上传了。","link":"/shi-yong-github-bei-fen-hexo-bo-ke-yuan-wen-jian.html"},{"title":"使用JSDelivr加速Github、博客文件","text":"前言：当我们博客添加了本地视频或者大量图片等等，会导致加载时间过长，这里我们用JSDelivr对其进行加速，相当于免费的的CDN。 一、新建一个GitHub仓库 仓库名称随便 仓库属性Public，不然JSDelivr无法访问 初始化Readme 二、克隆创建仓库到本地 本地打开Git Bash Here克隆仓库到指定文件夹 git clone //复制的链接 三、上传需要加速的文件把要加速的文件复制到克隆的文件夹里，注意：JSDelivr不能加速超过50M的文件，如果文件超过50M，可以分次上传，到时候在仓库设置版本号，加速不同的版本就行了。 复制下面四个命令，在本地克隆的文件夹下Git Bash Here输入： git status //查看状态 git add . //添加所有文件到暂存区 git commit -m '第一次提交' //把文件提交到仓库 git push //推送至远程仓库 注：每次提交记得标明，比如第二次第三次，才能分辨，克隆的文件夹下含有.git文件夹，上传时会自动上传到创建的文件夹 四、创建版本还是我们创建的仓库 版本便于我们区别就行，更新一次就更新一下版本。 五、JSDelivr加速并引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径格式：https://cdn.jsdelivr.net/gh/user/repo@version/file例如： https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.0/Images/avatars/csdn.icohttps://cdn.jsdelivr.net/gh/MUYIio/CDN@2.0.1/music/stayalive.mp3 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： // 加载任何Github发布、提交或分支 https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载 jQuery v3.2.1 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本 https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表 https://cdn.jsdelivr.net/gh/jquery/jquery/ 具体可以参考官方文档说明： 把博客中的文件替换成链接就行了 示例： 参考：免费CDN：jsDelivr+Github 使用方法","link":"/shi-yong-jsdelivr-jia-su-github-bo-ke-wen-jian.html"},{"title":"使用Java Arrays类进行排序","text":"使用Java Arrays类进行排序在使用排序算法时，C语言有qsort()函数，C++有sort()函数，java语言有Arrays类（与Array区分），记录一下使用Arrays排序算法的知识点。 1.对基本数据类型的数组的排序：tips： 1.Arrays类中的sort()使用的是“经过调优的快速排序法; 2.比如int[]，double[]，char[]等基数据类型的数组，Arrays类之只是提供了默认的升序排列，没有提供相应的降序排列方法。 3.要对基础类型的数组进行降序排序，需要将这些数组转化为对应的封装类数组，如Integer[]，Double[]，Character[]等，对这些类数组进行排序。(其实还不如先进行升序排序，自己在转为降序)。 函数原型（默认升序）： static void sort(int[] a) // 对指定的 int 型数组按数字升序进行排序 static void sort(int[] a, int fromIndex, int toIndex) // 对指定 int 型数组的指定范围按数字升序进行排序 代码实例： import java.util.Arrays; public class ArraysSort_11 { public static void main(String args[]) { int[] a={1,4,-1,5,0}; Arrays.sort(a); //数组a[]的内容变为{-1,0,1,4,5} for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+\" \"); } } 2.对复合数据类型的数据的排序： 函数原型： (1)public static&lt;T> void sort(T[] a，Comparator c) // 根据指定比较器产生的顺序对指定对象数组进行排序。 (2)public static&lt;T> void sort(T[] a，int fromIndex，int toIndex，Comparator c) // 根据指定比较器产生的顺序对指定对象数组的指定范围进行排序。 代码实例： package aa; import java.util.Arrays; import java.util.Comparator; public class Arraysort { Point[] arr; Arraysort(){ arr=new Point[4]; //定义对象数组arr，并分配存储的空间 for(int i=0;i&lt;4;i++) arr[i]=new Point(); } public static void main(String[] args) { Arraysort sort=new Arraysort(); sort.arr[0].x=2;sort.arr[0].y=1; //初始化，对象数组中的数据 sort.arr[1].x=2;sort.arr[1].y=2; sort.arr[2].x=1;sort.arr[2].y=2; sort.arr[3].x=0;sort.arr[3].y=1; Arrays.sort(sort.arr, new MyComprator()); //使用指定的排序器，进行排序 for(int i=0;i&lt;4;i++) //输出排序结果 System.out.println(\"(\"+sort.arr[i].x+\",\"+sort.arr[i].y+\")\"); } } class Point{ int x; int y; } //比较器，x坐标从小到大排序；x相同时，按照y从小到大排序 class MyComprator implements Comparator { public int compare(Object arg0, Object arg1) { Point t1=(Point)arg0; Point t2=(Point)arg1; if(t1.x != t2.x) return t1.x>t2.x? 1:-1; else return t1.y>t2.y? 1:-1; } } tips:上面的两个算法是经过调优的合并排序算法","link":"/shi-yong-java-arrays-lei-jin-xing-pai-xu.html"},{"title":"使用Java开发一个记事本","text":"概述：大二下的Java课程设计，仿的Windows记事本，使用Java Swing组件开发。 重要的： 新建、打开、保存、另存为、退出询问 剪切、复制、粘贴、删除 字体设置、背景色、字体颜色、编码格式 … 常用快捷键 CTRL + 滚轮 改变字体大小 工具栏显示 当前时间 + 字体大小 + 字数统计 全局字体设置 Windows文件窗口风格 代码：Demo 类： import javax.swing.UIManager; import javax.swing.UnsupportedLookAndFeelException; class Demo { public static void main(String [] args) { // 生成Windows风格的UI界面 try { UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) { e.printStackTrace(); } new NotePad(); } } NotePad 类： import java.io.*; import java.awt.*; import java.awt.Font; import java.awt.event.*; import java.util.Calendar; import java.util.Enumeration; import java.awt.event.ActionEvent; import java.util.GregorianCalendar; import java.awt.event.ActionListener; import javax.swing.*; import javax.swing.undo.UndoManager; import javax.swing.plaf.FontUIResource; import javax.swing.event.DocumentEvent; import javax.swing.event.DocumentListener; import javax.swing.event.UndoableEditEvent; import javax.swing.event.UndoableEditListener; public class NotePad extends JFrame implements ActionListener // extends继承JFrame类 { int start = 0, end = 0; JMenuBar bar; JMenu mu1, mu2, mu3, mu4, mu5; JMenuItem mt11, mt12, mt13, mt14, mt15; JMenuItem mt21, mt22, mt23, mt24, mt25; JMenuItem mt31, mt32, mt33, mt34, mt35; JMenuItem mt41, mt42, mt43; JMenuItem mt51; JRadioButton en_utf_8_Item = null; JRadioButton en_gbk_Item = null; JRadioButton de_utf_8_Item = null; JRadioButton de_gbk_Item = null; UndoManager manager; // 添加布局管理器 JFileChooser jfc; // 定义一个文件选择框 JTextArea area; // 定义一个文本框 JScrollPane jsp; // 定义一个视窗 File file; // 底部状态栏 JLabel labelLeft, labelCenter, labelRight; JToolBar jDown; // 定义一个工具栏 // 编码格式 String encode = \"UTF-8\"; String decode = \"UTF-8\"; String jsb = \"新建记事本\"; // ctrl键是否按下 boolean key_ctrl = false; // 是否在打开文件 boolean isOpen = false; // 是否修改文件 boolean isChanged = false; // 系统滚动条 MouseWheelListener sysWheel; // 初始化文本域字体大小 Font f = new Font(\"Serif\", 0, 23); GregorianCalendar time = new GregorianCalendar(); // 定义一个标准时间 int hour = time.get(Calendar.HOUR_OF_DAY); int min = time.get(Calendar.MINUTE); int second = time.get(Calendar.SECOND); public NotePad() { initFrame(); initGUI(); } public void initFrame() { InitGlobalFont(new Font(\"宋体\", Font.PLAIN, 20)); // 统一设置字体 setTitle(\"新建记事本\"); setBounds(200, 100, 750, 900); // 加载Label的板块 this.launchLabel(); Clock clock = new Clock(); clock.start(); setLocationRelativeTo(null); // 窗口居中显示 setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE); // 3设置JFram不要默认关闭，为了用对话框触发退出 setVisible(true); } public void initGUI() { bar = new JMenuBar(); mu1 = new JMenu(\"文件(F)\"); mu2 = new JMenu(\"编辑(E)\"); mu3 = new JMenu(\"格式(O)\"); mu4 = new JMenu(\"查看(V)\"); mu5 = new JMenu(\"帮助(H)\"); mt11 = new JMenuItem(\"新建(N) Ctrl+N\"); mt12 = new JMenuItem(\"打开(O) Ctrl+O\"); mt13 = new JMenuItem(\"保存(S) Ctrl+S\"); mt14 = new JMenuItem(\"另存为(A)...\"); mt15 = new JMenuItem(\"退出(X)\"); mt11.addActionListener(this); mt12.addActionListener(this); mt13.addActionListener(this); mt14.addActionListener(this); mt15.addActionListener(this); mt21 = new JMenuItem(\"撤销(U) Ctrl+Z\"); mt22 = new JMenuItem(\"剪切(T) Ctrl+X\"); mt23 = new JMenuItem(\"复制(C) Ctrl+C\"); mt24 = new JMenuItem(\"粘贴(P) Ctrl+V\"); mt25 = new JMenuItem(\"删除(L) Del\"); mt21.addActionListener(this); mt22.addActionListener(this); mt23.addActionListener(this); mt24.addActionListener(this); mt25.addActionListener(this); mt31 = new JCheckBoxMenuItem(\"自动换行\", true); mt32 = new JMenuItem(\"字体选择(F)\"); mt33 = new JMenuItem(\"替换(R)||查找(F)\"); mt34 = new JMenu(\"编码\"); mt35 = new JMenu(\"解码\"); en_utf_8_Item = new JRadioButton(\"UTF-8\",true); en_gbk_Item = new JRadioButton(\"GBK\",false); de_utf_8_Item = new JRadioButton(\"UTF-8\",true); de_gbk_Item = new JRadioButton(\"GBK\",false); ButtonGroup group1 = new ButtonGroup(); ButtonGroup group2 = new ButtonGroup(); mt31.addActionListener(this); mt32.addActionListener(this); mt33.addActionListener(this); mt41 = new JMenuItem(\"字体颜色\"); mt42 = new JMenuItem(\"背景颜色\"); mt43 = new JMenuItem(\"关于记事本(About)\"); mt41.addActionListener(this); mt42.addActionListener(this); mt43.addActionListener(this); mt51 = new JMenuItem(\"帮助选项(H)\"); mt51.addActionListener(this); mu1.add(mt11); mu1.add(mt12); mu1.add(mt13); mu1.add(mt14); // 将默认大小的分隔符添加到工具栏的末尾 mu1.addSeparator(); mu1.add(mt15); mu2.add(mt21); mu2.add(mt22); mu2.add(mt23); mu2.add(mt24); mu2.add(mt25); mu3.add(mt31); mu3.add(mt32); mu3.add(mt33); mu3.add(mt34); mu3.add(mt35); mu4.add(mt41); mu4.add(mt42); mu4.add(mt43); mu5.add(mt51); group1.add(en_utf_8_Item); group1.add(en_gbk_Item); group2.add(de_utf_8_Item); group2.add(de_gbk_Item); mt34.add(en_utf_8_Item); mt34.add(en_gbk_Item); mt35.add(de_utf_8_Item); mt35.add(de_gbk_Item); bar.add(mu1); bar.add(mu2); bar.add(mu3); bar.add(mu4); bar.add(mu5); setJMenuBar(bar); manager = new UndoManager(); // 撤销的监听器 area = new JTextArea(); jsp = new JScrollPane(area); jfc = new JFileChooser(); area.setFont(f); area.setCaretColor(Color.blue); // 光标颜色 area.setSelectedTextColor(Color.blue); // 选中字体颜色 area.setSelectionColor(Color.green); // 选中背景颜色 area.setLineWrap(true); // 是否换行 area.setWrapStyleWord(true); // 当输入单词为行末时，换行以显示完整单词 area.setMargin(new Insets(3, 5, 3, 5)); // 文本区与边框的间距 add(jsp, BorderLayout.CENTER); this.launchTextArea(); // 全局按键事件监听 this.addKeyListener(); // 窗口的监听器 this.myaddWindowListener(); } /* 统一设置字体，父界面设置之后，所有由父界面进入的子界面都不需要再次设置字体 */ private static void InitGlobalFont(Font font) { FontUIResource fontRes = new FontUIResource(font); //遍历字体集合元素 for (Enumeration&lt;Object> keys = UIManager.getDefaults().keys(); keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if (value instanceof FontUIResource) { UIManager.put(key, fontRes); } } } /* 文件格式过滤器 */ public class filter extends javax.swing.filechooser.FileFilter // 继承 FileFilter 类 { public boolean accept(File file) { String name = file.getName(); name.toString(); // 该字符串中的数字被转换为字符 /* 文件后缀是.txt且是个目录 */ if (name.endsWith(\".txt\") || file.isDirectory()) // 判断文件后缀 { return true; } else return false; } /* 将引用具体子类的子类对象的方法,不可以省略类中的getDescription(),原因是编译器只允许调用在类中声明的方法. */ public String getDescription() { return \".txt\"; // 返回文件名 } } /* 文本区域是否更改 */ private class change implements DocumentListener { @Override public void insertUpdate(DocumentEvent e) { changedUpdate(e); } @Override public void removeUpdate(DocumentEvent e) { changedUpdate(e); } @Override public void changedUpdate(DocumentEvent e) { changed(); } public void changed() { if(!isOpen) { isChanged = true; // 统计字数 labelRight.setText(\"字数统计：\" + tools.replaceBlank(area.getText())); // 调用外部方法 } } } /* 打开文件保存对话框的方法，保存和另存为时调用此方法 */ public void openSaveDialog() { int status = jfc.showSaveDialog(null); BufferedWriter bw = null; if (status == JFileChooser.APPROVE_OPTION) { file = jfc.getSelectedFile(); try { OutputStreamWriter fWriter = new OutputStreamWriter(new FileOutputStream(file),encode); bw = new BufferedWriter(fWriter); String[] strs = area.getText().split(\"\\n\"); for (String str : strs) { bw.write(str); bw.newLine(); bw.flush(); } } catch (FileNotFoundException e1) { area.setText(area.getText() + '\\n' + \"文件未找到\"); e1.printStackTrace(); } catch (IOException e1) { e1.printStackTrace(); } finally { if (bw != null) { try { bw.close(); } catch (IOException e1) { e1.printStackTrace(); } } isChanged = false; labelLeft.setText(\"状态：已保存\"); this.setTitle(file.getName()); } } } /* 不打开文件保存对话框直接按照当前文件保存的方法 */ public void onlySave() { BufferedWriter bw = null; try { OutputStreamWriter fWriter = new OutputStreamWriter(new FileOutputStream(file),encode); bw = new BufferedWriter(fWriter); String[] strs = area.getText().split(\"\\n\"); for (String str : strs) { bw.write(str); bw.newLine(); bw.flush(); } } catch (IOException e1) { e1.printStackTrace(); } finally { if (bw != null) { try { bw.close(); } catch (IOException e1) { e1.printStackTrace(); } } isChanged = false; labelLeft.setText(\"状态：已保存\"); this.setTitle(file.getName()); } } /* 窗口的监听器，在退出时弹窗 */ public void myaddWindowListener() { this.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { // 如果修改未保存弹出对话框，保存了则直接退出 if (isChanged == false) { System.exit(0); } else if (file == null) { new JOptionPane(); int result = JOptionPane.showConfirmDialog(null, \"文件还未保存，是否保存\", \"提示\", JOptionPane.YES_NO_CANCEL_OPTION); // 选择是的时候调用保存文件的文件选择对话框,否的时候直接退出 if (result == JOptionPane.YES_OPTION) { openSaveDialog(); } else if (result == JOptionPane.NO_OPTION) { System.exit(0); } } else if (file != null) { new JOptionPane(); int result = JOptionPane.showConfirmDialog(null, \"文件还未保存，是否保存到\" + file.getPath(), \"提示\", JOptionPane.YES_NO_CANCEL_OPTION); // 选择是的时候直接保存,否的时候直接退出 if (result == JOptionPane.YES_OPTION) { onlySave(); } else if (result == JOptionPane.NO_OPTION) { System.exit(0); } } } }); } /* 全局按键事件监听 */ public void addKeyListener() { Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() { public void eventDispatched(AWTEvent event) { if (((KeyEvent) event).getID() == KeyEvent.KEY_RELEASED) { int key = ((KeyEvent) event).getKeyCode(); // System.out.println(key); if (key == 17) { key_ctrl = false; // 初始化 CTRL 状态为 false } } if (((KeyEvent) event).getID() == KeyEvent.KEY_PRESSED) { int key = ((KeyEvent) event).getKeyCode(); // System.out.println(key); if (key == 17) { key_ctrl = true; // 表示已经按下 CTRL } if (key == 78 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + n\"); // 控制台输出所按的键 if (manager.canRedo()) { // 新建文件 area.setText(\"\"); } } if (key == 79 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + o\"); if (manager.canRedo()) { // 打开文件 } } if (key == 83 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + s\"); if (file == null) { // 如果文本为空则打开文件，否则保存文件 openSaveDialog(); } else { onlySave(); } } if (key == 83 &amp;&amp; key_ctrl == true) { if (key == 16) { System.out.println(\"ctrl + shift + s\"); onlySave(); // 另存为... } } if (key == 90 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + z\"); if (manager.canUndo()) { // 撤销 manager.undo(); } } if (key == 88 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + x\"); if (manager.canRedo()) { // 剪切 manager.redo(); } } if (key == 67 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + c\"); if (manager.canRedo()) { // 复制 manager.redo(); } } if (key == 86 &amp;&amp; key_ctrl == true) { System.out.println(\"ctrl + v\"); if (manager.canRedo()) { // 粘贴 manager.redo(); } } if (key == 127) { System.out.println(\"Delete\"); if (manager.canRedo()) { // 删除 // 删除选定范围内的文本 area.replaceRange(\"\", area.getSelectionStart(), area.getSelectionEnd()); } } } } }, AWTEvent.KEY_EVENT_MASK); } /* 加载文本域 */ public void launchTextArea() { // 监听状态改变 area.getDocument().addDocumentListener(new change()); // 监听撤销 area.getDocument().addUndoableEditListener(new UndoableEditListener() {// 注册撤销可编辑监听器 public void undoableEditHappened(UndoableEditEvent e) { manager.addEdit(e.getEdit()); } });// 编辑撤销的监听 // 文本域滚动条 jsp = new JScrollPane(area); //jsp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); //把滚动条全局作用在视窗 -_-难看 sysWheel = jsp.getMouseWheelListeners()[0]; // 得到系统滚动事件 jsp.removeMouseWheelListener(sysWheel); // 移除系统滚动，需要时添加 jsp.addMouseWheelListener(new event()); add(jsp, BorderLayout.CENTER); } /* Ctrl + 鼠标改变字体 */ public class event extends MouseAdapter { @Override public void mouseWheelMoved(MouseWheelEvent e) { if (e.isControlDown()) {// 当ctrl键被按下，滚动为放大缩小 // System.out.println(e.getWheelRotation()); if (e.getWheelRotation() &lt; 0 &amp;&amp; f.getSize() &lt; 60) {// 如果滚动条向前就放大文本 f = new Font(f.getFamily(), f.getStyle(), f.getSize() + 1); area.setFont(f); } else if (e.getWheelRotation() > 0 &amp;&amp; f.getSize() > 0) {// 滚动条向后就缩小文本 f = new Font(f.getFamily(), f.getStyle(), f.getSize() - 1); area.setFont(f); } labelCenter.setText(\"字体大小：\" + f.getSize()); } else {// 当ctrl没有被按下，则为系统滚动 jsp.addMouseWheelListener(sysWheel); sysWheel.mouseWheelMoved(e);// 触发系统滚动事件。 jsp.removeMouseWheelListener(sysWheel); } } } /* 模拟时钟 */ class Clock extends Thread { public void run() { while (true) { GregorianCalendar time = new GregorianCalendar(); int year = time.get(Calendar.YEAR); int month = time.get(Calendar.MONTH); // 月份是从 0 开始，所以输出时要 + 1 int day = time.get(Calendar.DAY_OF_MONTH); int hour = time.get(Calendar.HOUR_OF_DAY); int min = time.get(Calendar.MINUTE); int second = time.get(Calendar.SECOND); // 设置时间格式完整格式：year + \"/\" + (month + 1) + \"/\" + day + \" \" + hour + \":\" + min + \":\" + second // 由于太长就不设置了，难看 -_- labelLeft.setText(\" 当前时间：\" + hour + \":\" + min + \":\" + second); try { Thread.sleep(950); } catch (InterruptedException exception){} } } } /* 底部工具栏 */ public void launchLabel() { jDown = new JToolBar(); // 底部Label的板块 labelLeft = new JLabel(\" 当前时间：\" + hour + \":\" + min + \":\" + second); labelCenter = new JLabel(\"字体大小：\" + f.getSize()); labelRight = new JLabel(\"字数统计：\" ); jDown.setLayout(new GridLayout(1, 3)); // 三行一列的意思 jDown.add(labelLeft); jDown.add(labelCenter); jDown.add(labelRight); add(jDown, BorderLayout.SOUTH); jDown.setVisible(true); } public void actionPerformed(ActionEvent e) { if (e.getSource() == mt11) // 新建选项 { area.setText(\"\"); } else if (e.getSource() == mt12) // 打开选项 { JFileChooser fc = new JFileChooser(\"D:\\\\\"); int d = fc.showOpenDialog(this); if (d == 0) { try{ File f = fc.getSelectedFile(); FileReader fr = new FileReader(f); BufferedReader br = new BufferedReader(fr); String line = \"\"; while ((line = br.readLine()) != null) { area.append(line + \"\\n\"); } br.close(); fr.close(); } catch(FileNotFoundException e2) { System.out.println(\"文件未找到\"); } catch(IOException e3) { System.out.println(\"文件无法读取\"); } } } else if (e.getSource() == mt13) // 保存选项 { if (file == null) { try { jfc = new JFileChooser(); jfc.setCurrentDirectory(null); jsb = JOptionPane.showInputDialog(\"请输入文件名：\") + \".txt\"; jfc.setSelectedFile(new File(jsb)); jfc.setFileFilter(new filter()); int temp = jfc.showSaveDialog(null); // 获取当前对象 if (temp == jfc.APPROVE_OPTION) // 获得选中的文件对象 { if (file != null) file.delete(); file = new File(jfc.getCurrentDirectory(), jsb); file.createNewFile(); FileWriter fw = new FileWriter(file); fw.write(area.getText()); fw.close(); } } catch (Exception e2) { JOptionPane.showMessageDialog(null, e); } } else { try { FileWriter fw = new FileWriter(file); fw.write(area.getText()); fw.close(); } catch (Exception e3) { JOptionPane.showMessageDialog(null, e); } } } else if(e.getSource() == mt14) // 另存为选项 { jfc = new JFileChooser(); jfc.setCurrentDirectory(new File(\".\")); try { if (file == null) { jsb = JOptionPane.showInputDialog(\"请输入文件名：\") + \".txt\"; } else jsb = file.getName(); jfc.setSelectedFile(new File(jsb)); jfc.setFileFilter(new filter()); int temp = jfc.showSaveDialog(null); if (temp == jfc.APPROVE_OPTION) // 获得选中的文件对象 { if (file != null) file.delete(); file = new File(jfc.getCurrentDirectory(), jsb); file.createNewFile(); FileWriter fw = new FileWriter(file); fw.write(area.getText()); fw.close(); } } catch (Exception e4) { JOptionPane.showMessageDialog(null, e4); } } else if (e.getSource() == mt15) // 退出选项 { int state = JOptionPane.showConfirmDialog(null, \"您确定要退出？退出前请确定您的文件已保存\"); if (state == JOptionPane.OK_OPTION) System.exit(0); } else if (e.getSource() == mt21) // 撤销选项 { if (manager.canUndo()) manager.undo(); } else if (e.getSource() == mt22) // 剪切选项 { area.cut(); } else if (e.getSource() == mt23) // 复制选项 { area.copy(); } else if (e.getSource() == mt24) // 粘贴选项 { area.paste(); } else if (e.getSource() == mt25) // 删除选项 使用空格替换文本 { area.replaceRange(\"\", area.getSelectionStart(), area.getSelectionEnd()); } else if (e.getSource() == mt31) // 自动换行 { //if (mt31.getState()) //area.setLineWrap(true); //else //area.setLineWrap(false); } else if (e.getSource() == mt32) // 字体选择 { /* 获取本地图形环境 */ GraphicsEnvironment gr = GraphicsEnvironment.getLocalGraphicsEnvironment(); /* 字体名称列表框 */ JList fontnames = new JList(gr.getAvailableFontFamilyNames()); /* JScrollPane 管理视口、可选的垂直和水平滚动条以及可选的行和列标题视口 */ int selection = JOptionPane.showConfirmDialog(null, new JScrollPane(fontnames), \"请选择字体\",JOptionPane.OK_CANCEL_OPTION); Object selectedFont = fontnames.getSelectedValue(); if (selection == JOptionPane.OK_OPTION &amp;&amp; selectedFont != null) { area.setFont(new Font(fontnames.getSelectedValue().toString(), Font.PLAIN, 20)); } } else if (e.getSource() == mt33) // 查找 || 替换 选项 { JDialog search = new JDialog(); search.setSize(300, 100); search.setLocation(450, 350); JLabel label_1 = new JLabel(\"查找的内容\"); JLabel label_2 = new JLabel(\"替换的内容\"); JTextField textField_1 = new JTextField(5); JTextField textField_2 = new JTextField(5); JButton buttonFind = new JButton(\"查找下一个\"); JButton buttonChange = new JButton(\"替换\"); JPanel panel = new JPanel(new GridLayout(2, 3)); panel.add(label_1); panel.add(textField_1); panel.add(buttonFind); panel.add(label_2); panel.add(textField_2); panel.add(buttonChange); search.add(panel); search.setVisible(true); // 为查找下一个 按钮绑定监听事件 buttonFind.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String findText = textField_1.getText();// 查找的字符 String textArea = area.getText();// 当前文本框的内容 start = textArea.indexOf(findText, end); end = start + findText.length(); if (start == -1) // 没有找到 { JOptionPane.showMessageDialog(null, \"没找到\" + findText, \"记事本\", JOptionPane.WARNING_MESSAGE); area.select(start, end); } else { area.select(start, end); } } }); // 为替换按钮绑定监听时间 buttonChange.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String changeText = textField_2.getText();// 替换的字符串 /* 如果选定文件为真 */ if (area.getSelectionStart() != area.getSelectionEnd()) area.replaceRange(changeText, area.getSelectionStart(), area.getSelectionEnd()); } }); } else if (e.getSource() == mt41) // 字体颜色 { JColorChooser cc = new JColorChooser(); Color c = cc.showDialog(this, \"选择颜色\", Color.blue); area.setForeground(c); } else if (e.getSource() == mt42) // 背景颜色 { JColorChooser cc= new JColorChooser(); Color c = cc.showDialog(this, \"选择颜色\", Color.green); area.setBackground(c); } else if (e.getSource() == mt43) // 关于记事本 { JOptionPane.showMessageDialog(null, \"记事本\\n开发语言：JAVA\\n开发者：赵晓龙\\n联系方式：muyiio@outlook.com\", \"关于\", JOptionPane.PLAIN_MESSAGE); } else if (e.getSource() == mt51) // 帮助选项 { JOptionPane.showMessageDialog(null, \"详细代码请移步\\n博客：https://yshawlon.cn/\", \"帮助\", JOptionPane.PLAIN_MESSAGE); } } } tools 类： public class tools { // 字符串去无效字符(空格，制表符，换行，标点等)后的长度. public static int replaceBlank(String str) { String dest = \"\"; if (str != null) { // 如果文本不为空则计数 str = str.replaceAll(\"[\\\\pP‘’“”]\", \"\"); dest = str.replaceAll(\"\\\\s*|\\t|\\r|\\n\", \"\"); } return dest.length(); // 返回文本的有效长度 } }","link":"/shi-yong-java-kai-fa-yi-ge-ji-shi-ben.html"},{"title":"Hexo博客部署到腾讯云服务器(使用宝塔面板)","text":"前两天突然发现网站挂了，因为Coding和GitHub同时故障。于是我的博客也进不去！虽然博客也部署在服务器，但是没有开启HTTPS,也没有部署证书。所以就想用宝塔面板来部署博客。 使用宝塔面板的好处： 操作更方便，习惯了Windows或者对Linux不熟悉的朋友可以更方便 添加证书更加方便，而且可以开启HTTPS 我的服务器： 系统 CentOS 7.5 64bit 配置 标准型S2/1核/2GB/1Mbps 服务器需要的环境 环境：git，Nginx，宝塔Linux 使用git 自动化部署发布 打开腾讯云，进入【云服务器】→【登录】 初始密码在右上角消息里面有 1】Git安装及配置一、安装依赖库和编译工具 安装依赖库： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 然后会出现： Is this ok [y/d/N]: 输入y继续安装，后面也一样。 安装编译工具： yum install gcc perl-ExtUtils-MakeMaker package 二、下载 git并解压编译安装 查看服务器已有的git版本 git --version 然后会看到： git version 1.8.3.1 但是官网版本已经更新了，因为yum仓库的Git版本更新的时间会存在延时，我们这里采用源码包安装方式安装。 将陈旧版本的git删除 yum remove git 选择一个目录来存放下载下来的 git 安装包。这里选择了/usr/local/src 目录 cd /usr/local/src 下载最新版git到/usr/local/src，可以在官网找到版本，目前最新版本是2.26.0。 wget http://ftp.ntu.edu.tw/software/scm/git/git-2.26.0.tar.gz 解压到当前目录 tar -zvxf git-2.26.0.tar.gz 进入 git-2.26.0.tar.gz 目录下 cd git-2.26.0 执行编译 make prefix=/usr/local/git all 安装 git 到 /usr/local/git 目录下 make prefix=/usr/local/git install 三、配置 git 环境变量 打开环境变量配置文件 vim /etc/profile 按i进入编辑模式，按向下键到底部，添加下面两行命令： PATH=$PATH:/usr/local/git/bin # git 的目录 export PATH 按esc退出，按:wq保存编辑。(注意是先:再是wq) 使 git 环境变量生效 source /etc/profile 验证安装完成，查看 git 的版本号 git --version 这时候我们的git版本已经变成了： git version 2.26.0 四、创建 git 用户 创建git用户 adduser git 获取权限 chmod 740 /etc/sudoers vim /etc/sudoers 按 i 键进入文件的编辑模式，按向下键找到如下字段 root ALL=(ALL) ALL 在其后面增加一句： git ALL=(ALL) ALL 按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入:，然后输入wq回车） 退回权限 chmod 400 /etc/sudoers 五、配置密钥 创建密钥 来到这里的小伙伴应该都已经有了自己的hexo博客，那么肯定已经创建过自己的密钥，一般存放在c/用户/.ssh下。 如果没有自己的密钥，可以移步我之前的教程，里面有密钥创建步骤 Github + Hexo 搭建个人博客超详细教程 将密钥保存在服务器(之前有密钥的直接复制就可以) 将id_rsa.pub里面的密钥复制,在服务器运行下面命令，创建.ssh文件夹 su git mkdir ~/.ssh 创建.ssh/authorized_keys文件，打开authorized_keys文件并将刚才在本地机器复制的内容拷贝其中并保存 vim ~/.ssh/authorized_keys 按i进入编辑模式粘贴完按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入:，然后输入wq回车） 修改权限 chmod 755 ~ chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 测试本地连接服务器 在本地电脑git bash here //yourIp为远程服务器的ip地址 ssh -v git@yourIp //yourIp为你的服务器ip 如图则证明本地机器与远程机器已经接通 六、创建git仓库 切换到root用户，创建一个目录用于存储网站的根目录 su root 创建网站的根目录 mkdir /home/hexo 给予权限 chown git:git -R /home/hexo 七、自动化部署 获取root权限 su root 建立git仓库 cd /home/git git init --bare blog.git 修改blog.git权限 chown git:git -R blog.git 在 /home/hexo/blog.git 下，有一个自动生成的 hooks 文件夹，我们创建一个新的 git 钩子 post-receive，用于自动部署。 vim blog.git/hooks/post-receive 按 i 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录 #!/bin/bash git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f 按 Esc 键退出编辑模式，输入:wq 保存退出。（先输入：，然后输入wq回车） 修改文件权限，使得其可执行。 chmod +x /home/git/blog.git/hooks/post-receive 2】安装宝塔 宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等100多项服务器管理功能。支持的操作系统有CentOS，Ubuntu、Debian、Fedora. 首先切换到根目录 cd ~ 安装6.9稳定版（宝塔linux6.x版本基于centos7开发，适用于centos7.x版本） yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 中间会让你输入y/n继续安装，输入y 7.x版本以下安装宝塔5.9 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh 3】登录宝塔面板 宝塔安装完成后会出现以下字样 ================================================================ BT-Panel default info! ================================================================== Bt-Panel-URL: http://119.34.25.52:8888/af293c8c username: aaaaaaaaa password: 123456789 Warning: If you cannot access the panel, release the following port (8888|888|80|443|20|21) in the security group ================================================================== 注明： Bt-Panel-URL: http://119.34.25.52:8888/af293c8c #登录宝塔面板的地址 username: aaaaaaaaa #账号 password: 123456789 #密码 然后我们来到浏览器输入URL进入宝塔面板，再输入账号密码登录。 不知道账号密码以及登录地址在服务器输入下面命令即可 /etc/init.d/bt default 安装LNMP（推荐） 等待安装完成。 4】添加网站 点击【网站】→【添加站点】 添加密钥和证书并强制Https 如果没有申请证书就去域名注册商处免费申请一个，这里我以腾讯云为例 1.首先下载证书： 2.在本地解压打开，我们可以看到证书目录文件： 3.宝塔面板只需要用到Nginx或Apache的，其他无需理会。 ①使用Nginx: 其中.key后缀的是服务器私钥，填入面板证书的左边框中（用文本编辑器完整复制粘贴进去） .crt后缀的是证书（也可能是pem后缀），填入面板证书的右边框中（用文本编辑器完整复制粘贴进去） ②使用Apache: 其中.key后缀的是服务器私钥，填入面板证书的左边框中（用文本编辑器完整复制粘贴进去） 1、2两张证书则需要合并填入面板证书的右边蓝框中（用文本编辑器完整复制粘贴进去） 若不合并只填蓝框域名证书手机访问就会报缺失证书链/不安全等同时 若顺序不正确会导致apache无法正常启动 4.证书添加成功后在右上角强制Https 5】配置本地Hexo 博客根目录_config下增加 deploy: type: git repo: root@***(服务器ip,内网外网都行):/home/git/blog.git #仓库地址 branch: master #分支 部署 hexo clean hexo g hexo d 输入hexo d的时候，会要求你输入自己的服务器密码 Branch 'master' set up to track remote branch 'master' from 'https://e.coding.net/godxiaolon/godxiaolon.git'. On branch master nothing to commit, working tree clean root@119.25.56.82's password: Enumerating objects: 182, done. Counting objects: 100% (182/182), done. Delta compression using up to 12 threads Compressing objects: 100% (61/61), done. Writing objects: 100% (95/95), 73.08 KiB | 3.18 MiB/s, done. Total 95 (delta 45), reused 0 (delta 0) remote: hooks/post-receive: line 1: t: command not found To 118.25.27.52:/home/git/hexoBlog.git 8df3691..7d63b39 HEAD -&gt; master Branch 'master' set up to track remote branch 'master' from 'root@118.25.27.52:/home/git/hexoBlog.git'. INFO Deploy done: git 输入密码不会有显示，输完回车就可以 如果出现bash: git-receive-pack: command not found,则运行： sudo ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack 访问服务器ip，看看有没有成功 可以看到，使用宝塔面板部署了证书，浏览器标识为安全。 6】总结宝塔的实用性挺广的，喜欢的小伙伴们可以去探索~ 教程有不对的地方欢迎指正~","link":"/shi-yong-bao-ta-mian-ban-yi-jian-bu-shu-hexo-bo-ke.html"},{"title":"利用 Github 和 Coding 为 Hexo 博客开启 Https","text":"本文记录使用Github和Coding官方支持为我们的Hexo博客开启Https HTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。 HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 [1] 。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。 使用GitHub开启Https目前利用GitHub Pages的网站都可以开启Https，不论是自定义域名还是官方的二级域名。 首先来到我们的域名解析： 如果你域名的记录类型是 CNAME 方式，那么就不需要做任何更改； 域名的记录类型是 A 方式，那么就需要把记录值指向以下IP地址： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 我的解析是在腾讯云，A记录只能添加四个，GitHub和Coding就只能分配2个，所以上面的IP我只解析了一个，不过阿里云好像可以解析多个，自己看着办。 可以参考一下我的： 域名解析好了之后打开GitHub仓库，点击【Settings】： 勾选【Enforce HTTPS】，注意：如果此时你不能勾选，请删除【Custom domain】里面你的域名并点击【Save】保存，刷新网页后就可以勾选了 使用Coding开启Https如果你的博客还没有托管到Coding，可以参照我另外一篇文章：Hexo 双线部署到 Coding Pages 和 GitHub Pages 提升访问速度 进入我们的Coding项目，点击【构建与部署】-【静态网站】，再点击右上角的设置，下拉到底部勾选【强制 HTTPS】。 这里说明一下： Coding绑定域名后SSL证书申请失败，去域名解析把GitHub解析暂停就可以申请成功了。 参照：hexo双线部署coding+github pages，实现https并开启又拍云CDN全站加速","link":"/li-yong-github-he-coding-wei-hexo-bo-ke-kai-qi-https.html"},{"title":"如何实现一个公平的洗牌算法","text":"问题描述：设计一个公平的洗牌算法 就像打牌的时候一样，我们洗牌之后并不知道牌的顺序变成什么样，当然，前提是这个牌洗转了。正如这个问题，核心的点是公平，怎样才叫公平呢？ 暴力解法：n个数的全排列有n！个，那么随机拿出这里面任意一个结果也算公平。但是它的时间复杂度是O(n!)！原地爆炸boomboom Knuth 洗牌算法:至于Knuth何许人也，感兴趣的可以去查一下。微软是 IT 界老大的年代，比尔盖茨直接说，如果你看完了Knuth写的《The Art of Computer Programming》第一卷本，请给我发简历。 生成的排列中，也就是我们的结果，每一个元素都能独立等概率的出现在每一个位置。或者反过来，每一个位置都能独立等概率的放置每个元素。 for(int i = n - 1; i >= 0 ; i -- ) swap(arr[i], arr[rand(0, i)]) // rand(0, i) 生成 [0, i] 之间的随机整数 很好理解，i从后向前，每次生成0~i之间的一个随机数，然后将i和这个随机数交换， swap(arr[i], arr[rand(0, i)]) 看出，i可以跟自己交换。（假想rand()无偏） 为什么公平呢？对于生成的排列，每一个元素都能等概率的出现在每一个位置 示例：现有6个数从小到大排列：1 2 3 4 5 6 首先随机选择一个数和6进行交换，假设是3 因为可以和自己交换，我们可以知道3出现在最后的概率是1/6 选择到5，假设和2交换 同样的第一轮2没有被选中，那么它逃掉的概率是5/6，第二轮被选中的概率是1/5，那么它被选中的概论等于5/6x1/5=1/6 到4，假设和1交换 1被选中的概率等于5/6x4/5x1/4=1/6 看到这里，应该知道后面的概率也是1/6了，所以这个算法是公平的，可以自己去实验一下。最后这个算法的时间复杂度是O(n)","link":"/ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html"},{"title":"对 Hexo 博客文章进行加密","text":"写在前面 有时候我们可能需要写一些私密的博客，通过密码验证的方式让人不能随意浏览。 这在wordpress，emlog或其他博客系统中都很容易实现，然而hexo除外。:( 为了解决这个问题，我们需要安装“ hexo-blog-encrypt”扩展。 特性 一旦你输入了正确的密码，它就会被存储在本地浏览器的localStorage中。按个按钮，密码将会被清空。若博客中又脚本，它将被正确地执行。 支持按标签加密。 所有的核心功能都是由原生的API所提供的。在Node.js中，我们使用Crypto。在浏览器中，我们使用Web Crypto API。 PBKDF2，SHA256被用作复制密钥，AES256-CBC被用作加解密，我们还使用HMAC来验证密文的来源，并确保其纠正。 广泛地使用Promise来进行异步操作，从而确保线程不被杜塞。 过时的浏览器将无法正常显示，因此，请升级您的浏览器。 安装npm install --save hexo-blog-encrypt 快速使用 将“ password”添加到您的文章信息头就像这样： ```javascriptj title: Hello World date: 2020-03-13 21:12:21 password: muyiio --- ```按标签加密 修改文章信息头如下： title: Hello World tags: - 加密文章tag date: 2020-03-13 21:12:21 password: muyiio abstract: 这里有东西被加密了，需要输入密码查看哦。 message: 您好，这里需要密码。 wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。 wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。 --- 对博客根目录_config添加如下字段： # 安全 encrypt: # hexo-blog-encrypt abstract: 这里有东西被加密了，需要输入密码查看哦。 message: 您好, 这里需要密码. tags: - {name: tagName, password: 密码A} - {name: tagName, password: 密码B} template: {{hbeMessage}}{{hbeEncryptedData}} wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 对 TOC 文章进行加密如果您有一篇文章使用了TOC，您需要修改模板的部分代码。这里以matery主题作为示例： 在hexo/themes/matery/layout/_partial/article.ejs找到article.ejs。 然后找到&lt;％post.content％&gt;这段代码，通常在30行左右。 使用如下的代码来替代它： Index 声明本文转载自作者MikeCoder的hexo-blog-encrypt项目，对有些地方略有修改。 项目地址：https://github.com/MikeCoder/hexo-blog-encrypt 发现这个还是挺好玩的~","link":"/dui-hexo-bo-ke-wen-zhang-jin-xing-jia-mi.html"},{"title":"怎样告别我的2020呢？","text":"赶在2021前写下这篇文章，想要总结一下2020，实在没什么好总结的，就是一团糟。 一】1.大二上快结束了，这一年也还凑合，懈怠了没有达到自己的目标。 怎么说呢，一方面，定下的目标一拖再拖，拖延症重度。另一方面感觉时间太碎片化了，就很难专心的去做一件事。所以一年下来也没干什么，自己学了c++，看了几本操作系统的书，看完了《啊哈算法》，目前在学习数据结构。 2.跟我的丫头三年了，特此记录一下！年年岁岁有今朝！ 二】总之，一步一步来吧，一口也吃不下大象。其他的就不一一列举了，不想为此贴上什么标准。思想上总是很矛盾的，行为上兴奋精神上疲惫。一步一步下来自己的目标变得清晰，感受到时间的紧迫，对未来越来越迷茫 打出几个字好像就绞尽脑汁了，那就省去无病呻吟吧。希望2021能够有所改变。","link":"/zen-yang-gao-bie-wo-de-2020-ni.html"},{"title":"寻找多数元素（主元素）问题","text":"问题描述：给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数.（默认都是存在众数的） 示例输入： 已知序列：[2,3,2,5,2,6,2,2]，找出主元素 示例输出： 2 题解：方法一：最简单的就是记录每个数字出现的次数，暴力解题。但是时间复杂度为O(n²)。 c语言代码： #include #include #include int main(void) { int n; int a[101]; int count, max=0; printf(\"数据个数:\\n\"); scanf(\"%d\", &n); int i, j, k = 0; for (i = 1; i h[2 * j + 1] &amp;&amp; 2 * j + 1 &lt;= n) { i = 2 * j + 1; } if (i != j) { int t; t = a[i]; a[i] = a[j]; a[j] = t; j = i; } else { flag = 1; } } return h; } int main(void) { int count = 1, max = 0; printf(\"数据个数:\\n\"); scanf_s(\"%d\", &amp;n); int i, k = 0; for (i = 1; i &lt;= n; ++i) //循环存入数据 { scanf_s(\"%d\", &amp;a[i]); } siftup(n, a); //堆排序 int c = a[1]; int num = n; for (i = 1; i &lt;= n; ++i) //遍历每一个数据 { a[1] = a[num]; --num; siftdown2(1, num, a); //对于堆，作向下调整，对内部变量h[101]作调整 if (a[1] ==c) //找出下一个较小的数，与前一个比较是否相等 { count++; } else { if (count > max) //寻找有相同数据最多的数 { max = count; k = a[i]; } count = 1; } c = a[1]; } printf(\"%d\\n\",k); return 0; } 方法三：堆排序一个数组，排好后在主函数中给出第一个数，与第二个数比较，如相等count加1，如不相等，与max比较，更新max，最终找出多数元素 /*对于堆，作向上调整，对内部变量h[101]作调整*/ int* siftup(int n, int h[101]) { int i = n, flag = 0, j; while (i >= 1 &amp;&amp; flag == 0) { if (h[i] &lt; h[i / 2] &amp;&amp; i >= 1) { j = i / 2; int t; t = a[i]; a[i] = a[j]; a[j] = t; i = j; } else { flag = 1; } } return h; } 这个算法的时间复杂度是O(N+M)，空间复杂度也是O(N+M)。但是，如果序列中数的大小跨度比较大这个方法就不行了，空间开销非常大。那么看看下面的方法。 方法四：也许你不知道，像这种序列的有一个特性，就是在原序列中去除两个不一样的数，原序列中出现超过50%的那个数，在取出的新序列中出现的次数也一定会超过50%。现在知道了，有没有想到解题的方法呢？ #include&lt;stdio.h> #include&lt;stdlib.h> int main() { int a[] = {3,1,1,2,3,1,3,3,3}; int i; //初始化 int count = 1; int temp = a[0]; for(i = 1; i &lt; sizeof(a)/sizeof(int);i++) { if(count == 0) { temp = a[i]; count++; } else if(a[i] == temp) count++; else count--; } printf(\"最多的数是:%d\\n\",temp); system(\"pause\"); return 0; } Boyer-Moore 投票算法 如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。 Boyer-Moore 算法的本质和分治十分类似。 Boyer-Moore 算法的详细步骤： 我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0； 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x： 如果 x 与 candidate 相等，那么计数器 count 的值增加 1； 如果 x 与 candidate 不等，那么计数器 count 的值减少 1。 在遍历完成后，candidate 即为整个数组的众数。 举一个具体的例子，例如下面的这个数组： [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。 Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考： 首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。 那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组 [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]作为例子，首先写下它在每一步遍历时 candidate 和 count 的值： nums: [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7] candidate: 7 7 7 7 7 7 5 5 5 5 5 5 7 7 7 7 count: 1 2 1 2 1 0 1 0 1 2 1 0 1 2 3 4我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方： nums: [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7] value: 1 2 1 2 1 0 -1 0 -1 -2 -1 0 1 2 3 4有没有发现什么？我们将 count 和 value 放在一起： nums: [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7] count: 1 2 1 2 1 0 1 0 1 2 1 0 1 2 3 4 value: 1 2 1 2 1 0 -1 0 -1 -2 -1 0 1 2 3 4发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！ 为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。 这样以来，由于： 我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此； 由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数； 在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。 class Solution { public: int majorityElement(vector& nums) { int candidate = -1; int count = 0; for (int num : nums) { if (num == candidate) ++count; else if (--count < 0) { candidate = num; count = 1; } } return candidate; } }; 复杂度分析: 时间复杂度：O(n)O(n)。Boyer-Moore 算法只对数组进行了一次遍历。 空间复杂度：O(1)O(1)。Boyer-Moore 算法只需要常数级别的额外空间。 这个算法最初是在《啊哈！算法》看到的，通过最后一个方法可以将时间复杂度优化到O(n)，","link":"/xun-zhao-duo-shu-yuan-su-zhu-yuan-su-wen-ti.html"},{"title":"操作系统实现第一篇","text":"—很早之前就想自己实现一个操作系统，现在才正式开始，我也不知道什么时候能啃下这个庞然大物；这篇博客将尽可能详细，记录学习过程，有感兴趣的小伙伴也可以加入我~ 什么是操作系统？","link":"/cao-zuo-xi-tong-shi-xian-di-yi-pian.html"},{"title":"汇编语言学习 DOSBox+MASM 安装及使用教程","text":"学校没有开设《汇编语言》这门课，但我觉得学习汇编挺重要的，对学习计组以及理解计算机原理很有帮助！ 1】安装DOSBox和MASM1)安装DOSBox首先官网下载DOSBox传送门，网盘链接：https://pan.baidu.com/s/13H0IU9xdYUJIQnwv1eE4Ag 提取码：2g8s ，包含MASM 安装过程就不说了，建议安装在D盘，C盘也可以。我这里是安装在C盘，安装好后打开，注意有两个窗口，不要关闭 找到文件：C:\\Users\\用户\\AppData\\Local\\DOSBox\\dosbox-0.74-3.conf，找不到AppData查看隐藏的文件，使用记事本打开dosbox-0.74-3.conf，在末尾添加下面两行代码： mount d d:\\masm d: 上面代码的意思就是把D盘映射为虚拟C盘，现在打开DOSBox可以看到自动映射了。 2）安装MASM自己去下载也可以，网盘里面下载下来直接提取到D盘根目录就行了 没有提取 MASM是无法进行debug的，现在打开就可以愉快的开始使用了。 2】使用DOSBox编写汇编程序1）编写 helloword 汇编源程序打开 DOSBox，输入 edit 编写一个汇编源程序 代码：// data segment ;这里定义一个数据段 tab db 'hello world$' ;这里用内存存放字节数据 'hellow world!',$用来判断字符串是否输出完毕 data ends ;数据段的结束标志 code segment ;这里定义了一个代码段 assume cs:code, ds:data ;这里把程序中定义的段与对应的段寄存器关联起来 start: ;这里是一个标号，根据end后面的标号判断这里是程序的开始位置 mov ax,data mov ds,ax ;这里把数据段的地址放到数据段寄存器ds中 lea dx,tab ;dx中放将要显示数据的偏移地址 mov ah,9h int 21h ;调用21号中断的9号功能来显示字符串 mov ah,4c00h int 21h ;程序返回在这里插入图片描述 code ends ;代码段的结束语 end start ;定义程序从哪个标号处开始执行 编写好后点击 file ，选择 save as …，输入文件名称 hello ，后缀是 .asm ,然后点击 ok 也可使用其他编辑器编写源代码，保存到 MASM 文件夹下，修改后缀为 .ASM就行了。 打开 D:\\MASM 就可以看见我们编写的源程序了。 2）编译打开DOSBox，输入 masm ，确认后弹出的第一行输入要编译的源程序的名称：hello.asm ,也可以直接输入 MASM hello.asm ，都一样。 “[.ASM]”提示我们，默认的文件扩展名是asm，比如，要编译的源程序文件名是“p1.asm”，只要在这里输入“p1”即可。可如果源程序文件不是以asm为扩展名的话，就要输入它的全名。比如源程序文件名为“p1.txt”，就要输入全名。 在输入源程序文件名的时候一定要指明它所在的路径。如果文件就在当前路径下，只输入文件名就可以，可如果文件在其他的目录中，则要输入路径，比如，要编译的文件p1.txt在“c:\\windows\\desktop”下，则要输入“c:\\windows\\desktop\\p1.txt”。这里，我们要编译的文件是C盘根目录下的1.asm，所以此处输入“c:\\1.asm”。 在输入源程序文件名后，程序会继续提示我们要编译出的目标文件的名称，目标文件是我们对一个源程序编译要得到的最终结果。注意屏幕上的显示 “[ hello.OBJ ] “,因为我们已经输入了源程序文件名为 hello.asm ,则编译程序默认输出文件名为 hello.obj ，所以不必再指定文件名。直接按 ENTER ，在当前目录下生成 hello.obj 文件。 我们到MASM文件夹下可以看到多了一个 hello.obj 文件，源程序的编译最后两行如果出现警告和错误必须要改正，否则无法生成obj文件。 3）连接接着上面的顺序，现在已经生成了一个hello.obj 文件，我们需要对目标文件进行连接，从而得到可执行文件。 输入 LINK ，弹出的第一行输入 obj 文件名称，比如 hello，也可以直接输入 LINK hello.obj 这里出现一个警告：没有栈段，我们不予理会。 连接成功后会在 MASM 目录下生成一个 hello.exe 文件，如果出现错误，则无法生成。 连接的作用： 当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件； 程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件； 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。 4）执行我们编译好的 .exe 文件输入: hello.exe hello都可以执行exe文件，当然前提是在 MASM 状态下。如图 至此就是编写汇编源程序以及运行的全部内容，我们还可以在此基础上进行debug，查看heelo.exe的执行情况，更多的知识请自行前往学习。","link":"/hui-bian-yu-yan-xue-xi-dosbox-masm-an-zhuang-ji-shi-yong-jiao-cheng.html"},{"title":"用具体数学解决约瑟夫环问题","text":"问题描述：有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？ 使用链表暴力求解时间复杂度是 O(qn)，递归的话是 O(n) ,使用这个方法可以加速到 O(logn). 解法思路：假设初始编号为 1，2，3 … n ，现在考虑一种新的编号方式。 第一个人不会被踢掉，那么他的编号从 n 开始往后加 1 ，变成 n+1 ，然后第二个人编号变为 n+2 ，直到第 q 个人，他被踢掉了。 然后第 q+1 个人编号继续加 1 ，变成了 n+q ，依次下去。 考虑当前踢到的人编号为 kq，那么此时已经踢掉了 k 个人，所以接下去的人新的编号为 n+k(q-1)+1…。 所以编号为 kq+d 的人编号变成了 n+k(q-1)+d ，其中 1&lt;=d&lt;q; 直到最后，可以发现活下来的人编号为 qn ，问题是怎么根据这个编号推出他原来的编号？ 以 n=10 , q=3 为例，下图就是每个人新的编号： 1 2 3 4 5 6 7 8 9 10 11 12 T 13 14 T 15 16 T 17 18 T 19 20 T 21 22 T 23 24 T 25 26 T 27 28 T 29 30 令：$$\\quad N=n+k(q-1)+d$$则他上一次的编号为：$$\\quad kq+d=kq+N-n-k(q-1)=k+N-n$$ $$又 \\because k=\\frac{N-n-d}{q-1}=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor$$ 所以他上一次的编号可以写为：$$\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor+N-n$$ 因此最后存活的人可以这样计算： N = qn while N > n: N = k + N - n ans = N 其中 k 等于：$$k=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor$$如果用 D=qn+1-N 代替 N ,那么算法可以简化为：$$\\begin{array}{l}D=q n+1-N \\=q n+1-\\left(\\left\\lfloor\\frac{(q n+1-D)-n-1}{q-1}\\right\\rfloor+q n+1-D-n\\right) \\=n+D-\\left[\\frac{(q-1) n-D}{q-1}\\right] \\=D-\\left\\lfloor\\frac{D}{q 1}\\right\\rfloor \\=D+\\left\\lceil\\frac{D}{q-1}\\right\\rceil \\=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil\\end{array}$$算法伪代码： D = 1 while D","link":"/yong-ju-ti-shu-xue-jie-jue-yue-se-fu-huan-wen-ti.html"},{"title":"暑假LeetCode刷题集合（下）","text":"【Day31】461. 汉明距离461. 汉明距离两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y &lt; 231. 示例: 输入: x = 1, y = 4 输出: 2 解释: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。题解： 可以考虑为求异或结果值当中1的个数，进一步转换为求二进制中1的个数。 class Solution { public: int lowbit(int x) { return x &amp; (-x); } int hammingDistance(int x, int y) { int ret = x ^ y; int ans = 0; while (ret) { ret -= lowbit(ret); ans++; } return ans; } }; 【Day32】477.汉明距离总和477. 汉明距离总和两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。 计算一个数组中，任意两个数之间汉明距离的总和。 示例: 输入: 4, 14, 2 输出: 6 解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系） 所以答案为： HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.注意: 数组中元素的范围为从 0到 10^9。 数组的长度不超过 10^4。 题解： class Solution { public: int totalHammingDistance(vector&lt;int>&amp; nums) { int ans = 0; for (int i = 0; i &lt; 31; i++) { int cnt[] = {0, 0}; for (auto&amp; num : nums) { cnt[num &amp; 1]++; num >>= 1; } ans += cnt[0] * cnt[1]; } return ans; } }; 【Day33】1074.元素和为目标值的子矩阵数量1074. 元素和为目标值的子矩阵数量给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。 子矩阵 x1, y1, x2, y2 是满足 x1 &lt;= x &lt;= x2 且 y1 &lt;= y &lt;= y2 的所有单元 matrix[x][y] 的集合。 如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 != x1’），那么这两个子矩阵也不同。 示例 1： 输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 输出：4 解释：四个只含 0 的 1x1 子矩阵。示例 2： 输入：matrix = [[1,-1],[-1,1]], target = 0 输出：5 解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。示例 3： 输入：matrix = [[904]], target = 0 输出：0提示： 1 &lt;= matrix.length &lt;= 100 1 &lt;= matrix[0].length &lt;= 100 -1000 &lt;= matrix[i] &lt;= 1000 -10^8 &lt;= target &lt;= 10^8 题解： 二维前缀和的题目，使用哈希表来优化 #define HT_LENGTH 256 struct HashTable { int keys[HT_LENGTH]; int vals[HT_LENGTH]; HashTable() { this->clear(); } void clear() { keys[0] = 0; vals[0] = 1; for (int i = 1;i &lt; HT_LENGTH;i++) keys[i] = -1; } bool find(int key, int&amp; ret) { uint32_t ikey = (uint32_t)key % HT_LENGTH; for (int i = 0;i &lt; HT_LENGTH;i++) { if (keys[ikey] == -1) return false; if (keys[ikey] == key) { ret = vals[ikey]; return true; } ikey ++; ikey = ikey == HT_LENGTH ? 0 : ikey; } return false; } void inc(int key) { uint32_t ikey = (uint32_t)key % HT_LENGTH; for (int i = 0;i &lt; HT_LENGTH;i++) { if (keys[ikey] == -1) { keys[ikey] = key; vals[ikey] = 1; return; } if (keys[ikey] == key) { vals[ikey]++; return; } ikey ++; ikey = ikey == HT_LENGTH ? 0 : ikey; } } }; class Solution { private: HashTable ht; public: int numSubmatrixSumTarget(vector&lt;vector&lt;int>>&amp; matrix, int target) { int rprefix[100][101]; int m = matrix.size(), n = matrix[0].size(); int ret = 0; for (int i = 0;i &lt; m;i++) { rprefix[i][0] = 0; for (int j = 1;j &lt;= n;j ++) { rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1]; } } for (int i = 1;i &lt;= n;i++) { for (int j = i;j &lt;= n;j++) { ht.clear(); int cprefix = 0, val; for (int row = 0;row &lt; m;row++) { cprefix += rprefix[row][j] - rprefix[row][i - 1]; if (ht.find(cprefix - target, val)) ret += val; ht.inc(cprefix); } } } return ret; } }; 【Day34】231. 2 的幂231. 2 的幂给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 示例 1： 输入：n = 1 输出：true 解释：20 = 1示例 2： 输入：n = 16 输出：true 解释：24 = 16示例 3： 输入：n = 3 输出：false示例 4： 输入：n = 4 输出：true示例 5： 输入：n = 5 输出：false提示： -231 &lt;= n &lt;= 231 - 1 题解： 位运算 若 n = 2^x 且 x为自然数（即 n 为 2 的幂），则一定满足以下条件： 首先，恒有 n &amp; (n - 1) == 0，因为： n 二进制最高位为 11，其余所有位为 00； n−1 二进制最高位为 00，其余所有位为 11； 其次，我们只需要限定n &gt; 0 即可。 class Solution { public: bool isPowerOfTwo(int n) { return n > 0 &amp;&amp; (n &amp; (n - 1)) == 0; } }; 【Day35】342. 4的幂342. 4的幂给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x 示例 1： 输入：n = 16 输出：true示例 2： 输入：n = 5 输出：false示例 3： 输入：n = 1 输出：true提示： -231 &lt;= n &lt;= 231 - 1 题解： 一个数是2的幂，那么二进制从右边数奇数位是1的一定是4的幂。判断是2的幂，我们只需要判断二进制中1的个数，用昨天的解即可。 0x55555555的 二进制是 01010101 01010101 01010101 01010101class Solution { public: bool isPowerOfFour(int n) { return n > 0 &amp;&amp; (n &amp; (n - 1)) == 0 &amp;&amp; (n &amp; 0x55555555) == n; } }; 【Day36】LeetCode 17441744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 示例 1： 输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] 输出：[true,false,true] 提示： 1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。 2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。 3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。示例 2： 输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] 输出：[false,true,true,false,false] 提示： 1 &lt;= candiesCount.length &lt;= 105 1 &lt;= candiesCount[i] &lt;= 105 1 &lt;= queries.length &lt;= 105 queries[i].length == 3 0 &lt;= favoriteTypei &lt; candiesCount.length 0 &lt;= favoriteDayi &lt;= 109 1 &lt;= dailyCapi &lt;= 109 题解： 使用前缀和解题： class Solution { public: vector&lt;long long> sum; bool check(vector&lt;int>&amp; candiesCount, vector&lt;int>&amp; q) { int favoriteType = q[0], favoriteDay = q[1], dailyCap = q[2]; // 第favoriteType类型的前缀和 int l = sum[favoriteType + 1]; // 每天吃一颗糖 if (favoriteDay + 1 > sum[favoriteType + 1]) return false; // 吃最多糖 if (sum[favoriteType] >= 1ll*(favoriteDay + 1) * dailyCap) return false; return true; } vector&lt;bool> canEat(vector&lt;int>&amp; candiesCount, vector&lt;vector&lt;int>>&amp; queries) { int n = candiesCount.size(); sum = vector&lt;long long>(n + 1, 0); for (int i = 1; i &lt;= n; i++) { sum[i] = sum[i - 1] + candiesCount[i - 1]; } vector&lt;bool> ans; for (auto q : queries) ans.push_back(check(candiesCount, q)); return ans; } }; 【Day37】523.连续的子数组和523. 连续的子数组和给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。 示例 1： 输入：nums = [23,2,4,6,7], k = 6 输出：true 解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。示例 2： 输入：nums = [23,2,6,4,7], k = 6 输出：true 解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。示例 3： 输入：nums = [23,2,6,4,7], k = 13 输出：false提示： 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 109 0 &lt;= sum(nums[i]) &lt;= 231 - 1 1 &lt;= k &lt;= 231 - 1 题解： 经典的前缀和 class Solution { public: bool checkSubarraySum(vector&lt;int>&amp; nums, int k) { int sum = 0; unordered_set&lt;int> st; for(int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; if(st.count(sum % k)) return true; st.insert((sum - nums[i]) % k); } return false; } }; 【Day38】525.连续数组525. 连续数组给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 输入: nums = [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。示例 2: 输入: nums = [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。提示： 1 &lt;= nums.length &lt;= 105 nums[i] 不是 0 就是 1 题解： 前缀和＋哈希 class Solution { public: int findMaxLength(vector&lt;int>&amp; nums) { for (auto&amp; num : nums) { num = num == 0 ? -1 : num; } map&lt;int, int> m; int sum = 0, ans = 0; for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; if (sum == 0) { ans = i + 1; } if (m.count(sum)) { ans = max(i - m[sum], ans); } else { m[sum] = i; } } return ans; } }; 【Day39】160.相交链表160. 相交链表给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意：函数返回结果后，链表必须 保持其原始结构 。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 题解： pA走过的路径为A链+B链 pB走过的路径为B链+A链 pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。 pA:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null-&gt;9-&gt;5-&gt;6-&gt;null pB:9-&gt;5-&gt;6-&gt;null-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p = headA, *q = headB; while (p != q) { p = p ? p->next : headB; q = q ? q->next : headA; } return p; } }; 【Day40】203.移除链表元素203. 移除链表元素给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]示例 2： 输入：head = [], val = 1 输出：[]示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]提示： 列表中的节点在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= k &lt;= 50 题解： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode *removeElements(ListNode *head, int val) { if (!head) return head; head->next = removeElements(head->next, val); return head->val == val ? head->next : head; } }; 【Day41】474.一和零474. 一和零给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;} ，因此答案是 4 。 其他满足题意但较小的子集包括 {&quot;0001&quot;,&quot;1&quot;} 和 {&quot;10&quot;,&quot;1&quot;,&quot;0&quot;} 。{&quot;111001&quot;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。示例 2： 输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1 输出：2 解释：最大的子集是 {&quot;0&quot;, &quot;1&quot;} ，所以答案是 2 。提示： 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] 仅由 ‘0’ 和 ‘1’ 组成 1 &lt;= m, n &lt;= 100 题解： 动态规划 const int N = 101; class Solution { public: int dp[N][N]; int findMaxForm(vector&lt;string>&amp; strs, int m, int n) { for (auto &amp;str:strs) { int one = 0, zero = 0; for (auto &amp;c:str) { if(c=='1') ++one; else ++zero; } // zero = str.size() - one; for (int j=m; j>=zero; --j) { for (int k=n; k>=one; --k) { dp[j][k] = max(dp[j][k], dp[j-zero][k-one] + 1); } } } return dp[m][n]; } }; 【Day42】494. 目标和494. 目标和给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3示例 2： 输入：nums = [1], target = 1 输出：1提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 100 题解： 还是动态规划 class Solution { int n; int ans = 0; int t; public: int findTargetSumWays(vector&lt;int>&amp; nums, int target) { n = nums.size(); t = target; dfs(0,nums, 0); return ans; } void dfs(int u, vector &lt;int> &amp; nums, int s){ if(u == n){ if(s == t) ++ans; return; } dfs(u + 1, nums, s + nums[u]); dfs(u + 1, nums, s - nums[u]); } }; 【Day43】1049. 最后一块石头的重量 II1049. 最后一块石头的重量 II有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例 1： 输入：stones = [2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。示例 2： 输入：stones = [31,26,33,21,40] 输出：5示例 3： 输入：stones = [1,2] 输出：1提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100 题解： class Solution { public: int lastStoneWeightII(vector&lt;int>&amp; stones) { auto sum = accumulate(stones.begin(), stones.end(), 0); vector&lt;int> dp(sum / 2 + 1); for (const auto&amp; stone : stones) { for (auto j = sum / 2; j >= stone; j--) { dp[j] = max(dp[j], dp[j - stone] + stone); } } return sum - dp[sum / 2] * 2; } }; 【Day44】879. 盈利计划879. 盈利计划集团里有 n 名员工，他们可以完成各种各样的工作创造利润。 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。 工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。 示例 1： 输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3] 输出：2 解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。 总的来说，有两种计划。示例 2： 输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] 输出：7 解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。 有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。提示： 1 &lt;= n &lt;= 100 0 &lt;= minProfit &lt;= 100 1 &lt;= group.length &lt;= 100 1 &lt;= group[i] &lt;= 100 profit.length == group.length 0 &lt;= profit[i] &lt;= 100 题解： 这题不会，贴一个题解吧 class Solution { public: int profitableSchemes(int n, int minProfit, vector&lt;int>&amp; group, vector&lt;int>&amp; profit) { int mod = 1e9 + 7; int size = group.size(); int dp[n + 1][minProfit + 1]; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt;= n; ++i) { dp[i][0] = 1; } for (int i = 1; i &lt;= size; ++i) { int cur_group = group[i - 1], cur_profit = profit[i - 1]; for (int j = n; j >= cur_group; --j) { for (int k = minProfit; k >= 0; --k) { dp[j][k] += dp[j - cur_group][max(k - cur_profit, 0)]; dp[j][k] %= mod; } } } return dp[n][minProfit]; } }; 【Day45】518. 零钱兑换 II518. 零钱兑换 II给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。示例 3: 输入: amount = 10, coins = [10] 输出: 1注意: 0 &lt;= amount (总金额) &lt;= 5000 1 &lt;= coin (硬币面额) &lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 题解： class Solution { public: int change(int amount, vector&lt;int>&amp; coins) { int n = coins.size(); vector&lt;int> dp(amount+1); dp[0] = 1; for(int i = 1; i&lt;=n; i++) { int val = coins[i-1]; for(int j = val; j &lt;= amount;++j) { dp[j] += dp[j-val]; } } return dp[amount]; } }; 【Day46】279. 完全平方数279. 完全平方数给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9提示： 1 &lt;= n &lt;= 104 题解： //假设最小公式值m = ƒ(n) //那么n的值满足下列公式 ∑(A[i] * A[i]) = n //令 k 为满足最小值 m 的时候，最大的平方数 。 令 d + k * k; = n ; d >= 0; // 注意：一定要是满足m最小的时候的k值,一味的取最大平方数,就是贪心算法了 //得出 f(d) + f(k*k) = f(n); //显然 f(k*k) = 1; 则 f(d) + 1 = f(n); 因为 d = n - k*k; //则可以推出ƒ(n - k * k) + 1 = ƒ(n) ; 且 k * k &lt;= n; class Solution { public: int numSquares(int n) { if (n &lt;= 0) return 0; std::vector&lt;int> nums(n+1); for(int i = 1; i &lt;= n;i++) { int min = i; for(int j = 1;i - j*j >= 0;j++) { int tmp = nums[i-j*j] + 1; min = min > tmp ? tmp:min; } nums[i] = min; } return nums[n]; } }; 【Day47】1449. 数位成本和为目标值的最大数字1449. 数位成本和为目标值的最大数字给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数： 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。 总成本必须恰好等于 target 。 添加的数位中没有数字 0 。 由于答案可能会很大，请你以字符串形式返回。 如果按照上述要求无法得到任何整数，请你返回 “0” 。 示例 1： 输入：cost = [4,3,2,5,6,7,2,5,5], target = 9 输出：&quot;7772&quot; 解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。 数字 成本 1 -&gt; 4 2 -&gt; 3 3 -&gt; 2 4 -&gt; 5 5 -&gt; 6 6 -&gt; 7 7 -&gt; 2 8 -&gt; 5 9 -&gt; 5示例 2： 输入：cost = [7,6,5,5,5,6,8,7,8], target = 12 输出：&quot;85&quot; 解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。示例 3： 输入：cost = [2,4,6,2,4,6,4,4,4], target = 5 输出：&quot;0&quot; 解释：总成本是 target 的条件下，无法生成任何整数。示例 4： 输入：cost = [6,10,15,40,40,40,40,40,40], target = 47 输出：&quot;32211&quot;提示： cost.length == 9 1 &lt;= cost[i] &lt;= 5000 1 &lt;= target &lt;= 5000 题解： class Solution { public: string largestNumber(vector&lt;int>&amp; cost, int target) { int len=cost.size(); vector&lt;string> dp(target+1,\"#\"); dp[0]=\"\"; //因为i遍历的顺序是从小到大，就保证了整数的高位一定大于等于整数的低位，也就保证了整数最大 for(int i=1;i&lt;len+1;++i) for(int j=1;j&lt;target+1;++j){ if(j>=cost[i-1]&amp;&amp;dp[j-cost[i-1]]!=\"#\"){ dp[j]=CompareString(dp[j],to_string(i)+dp[j-cost[i-1]]); } } return dp[target]==\"#\"?\"0\":dp[target]; } private: string CompareString(const string&amp; s1,const string&amp; s2){ int m=s1.size(),n=s2.size(); if(m==n)return max(s1,s2); return m>n?s1:s2; } }; 【Day48】278. 第一个错误的版本278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 题解： 二分 bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int lo = 1; int hi = n; while(lo &lt; hi) { int mid = lo + (hi - lo) / 2; if (isBadVersion(mid)) { hi = mid; } else { lo = mid + 1; } } return hi; } }; 【Day49】374. 猜数字大小374. 猜数字大小猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 1： 输入：n = 10, pick = 6 输出：6示例 2： 输入：n = 1, pick = 1 输出：1示例 3： 输入：n = 2, pick = 1 输出：1示例 4： 输入：n = 2, pick = 2 输出：2提示： 1 &lt;= n &lt;= 231 - 1 1 &lt;= pick &lt;= n 题解： /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */ class Solution { public: int guessNumber(int n) { int l = 0; int r = n; while (l &lt;= r) { int m = (l-r)/2 + r; int res = guess(m); if (res == 0) { return m; } else if (res &lt; 0) { r = m-1; } else { l = m + 1; } } return -1; } }; 【Day50】852. 山脉数组的峰顶索引852. 山脉数组的峰顶索引符合下列属性的数组 arr 称为 山脉数组 ： arr.length &gt;= 3 存在 i（0 &lt; i &lt; arr.length - 1）使得： arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i] arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1] 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。 示例 1： 输入：arr = [0,1,0] 输出：1示例 2： 输入：arr = [0,2,1,0] 输出：1示例 3： 输入：arr = [0,10,5,2] 输出：1示例 4： 输入：arr = [3,4,5,1] 输出：2示例 5： 输入：arr = [24,69,100,99,79,78,67,36,26,19] 输出：2提示： 3 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 106 题目数据保证 arr 是一个山脉数组 题解： 二分法 class Solution { public: int peakIndexInMountainArray(vector&lt;int>&amp; arr) { //根据 arr[mid-1]和arr[mid]对比 //所以搜索范围是 [1,arr.length -1] int left = 1; int right = arr.size() - 1; while(left &lt; right){ //如果check 函数调整的是left，则+1. 否则有可能陷入死循环 int mid = left + right + 1 >> 1; if(arr[mid-1] &lt; arr[mid]) left = mid; else right = mid -1; } return right; } }; 【Day51】877. 石子游戏877. 石子游戏亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。提示： 2 &lt;= piles.length &lt;= 500 piles.length 是偶数。 1 &lt;= piles[i] &lt;= 500 sum(piles) 是奇数。 题解： 博弈论 三叶的题解 class Solution { public: bool stoneGame(vector&lt;int>&amp; piles) { return true; } }; 【Day52】65. 有效数字有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 部分有效数字列举如下： [“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”] 部分无效数字列举如下： [“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”] 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。 示例 1： 输入：s = &quot;0&quot; 输出：true示例 2： 输入：s = &quot;e&quot; 输出：false示例 3： 输入：s = &quot;.&quot; 输出：false示例 4： 输入：s = &quot;.1&quot; 输出：true提示： 1 &lt;= s.length &lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，或者点 ‘.’ 。 题解： class Solution { public: bool isNumber(string s) { int l = 0, r = s.size() - 1; //去掉前后空格 while (l &lt;= r &amp;&amp; s[l] == ' ') l ++ ; while (l &lt;= r &amp;&amp; s[r] == ' ') r -- ; if (l > r) return false; s = s.substr(l, r - l + 1); //去掉正负号 if (s[0] == '+' || s[0] == '-') s = s.substr(1); //如果只有正负号，false if (s.empty()) return false; //如果只有一个点，或者.e || .E 返回false if (s[0] == '.' &amp;&amp; (s.size() == 1 || s[1] == 'e' || s[1] == 'E')) return false; //记录点和e的次数 int dot = 0, e = 0; for (int i = 0; i &lt; s.size(); i ++ ) { if (s[i] == '.') { //如果出现多个点或者e ，fasle if (dot > 0 || e > 0) return false; dot ++ ; } else if (s[i] == 'e' || s[i] == 'E') { //如果e的前面没东西或者后面没东西，或者多个e ，false if (!i || i + 1 == s.size() || e > 0) return false; //如果e的后面是正负号 if (s[i + 1] == '+' || s[i + 1] == '-') { //但是后面没东西了，返回false if (i + 2 == s.size()) return false; i ++ ; } e ++ ; //不合法 } else if (s[i] &lt; '0' || s[i] > '9') return false; } return true; } }; 【Day53】483. 最小好进制483. 最小好进制对于给定的整数 n, 如果n的k（k&gt;=2）进制数的所有数位全为1，则称 k（k&gt;=2）是 n 的一个好进制。 以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。 示例 1： 输入：&quot;13&quot; 输出：&quot;3&quot; 解释：13 的 3 进制是 111。示例 2： 输入：&quot;4681&quot; 输出：&quot;8&quot; 解释：4681 的 8 进制是 11111。示例 3： 输入：&quot;1000000000000000000&quot; 输出：&quot;999999999999999999&quot; 解释：1000000000000000000 的 999999999999999999 进制是 11。提示： n的取值范围是 [3, 10^18]。 输入总是有效且没有前导 0。 题解： class Solution { public: using LL = long long; string smallestGoodBase(string n) { LL x = stoll(n); for(int m = 2; m &lt;= 60; m++){ LL k = (LL)pow(x, 1. / m); if(k > 1){ LL cur = 1; for(LL i = 1, base = 1; i &lt;= m; i++){ base *= k; cur += base; } if(cur == x) return to_string(k); } } return to_string(x - 1); } }; 【Day54】1239. 串联字符串的最大长度1239. 串联字符串的最大长度给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。 请返回所有可行解 s 中最长长度。 示例 1： 输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;] 输出：4 解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。示例 2： 输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;] 输出：6 解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。示例 3： 输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;] 输出：26提示： 1 &lt;= arr.length &lt;= 16 1 &lt;= arr[i].length &lt;= 26 arr[i] 中只含有小写英文字母 题解： class Solution { public: int maxLength(vector&lt;string> &amp;arr) { int ans = 0; vector&lt;int> masks = {0}; for (string &amp;s : arr) { int mask = 0; for (char ch : s) { ch -= 'a'; if ((mask >> ch) &amp; 1) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解 mask = 0; break; } mask |= 1 &lt;&lt; ch; // 将 ch 加入 mask 中 } if (mask == 0) { continue; } int n = masks.size(); for (int i = 0; i &lt; n; ++i) { int m = masks[i]; if ((m &amp; mask) == 0) { // m 和 mask 无公共元素 masks.push_back(m | mask); ans = max(ans, __builtin_popcount(m | mask)); } } } return ans; } }; 【Day55】1600.皇位继承顺序1600. 皇位继承顺序一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。 这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。 Successor(x, curOrder): 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中： 如果 x 是国王，那么返回 null 否则，返回 Successor(x 的父亲, curOrder) 否则，返回 x 不在 curOrder 中最年长的孩子 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。 一开始， curOrder 为 [“king”]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。 通过以上的函数，我们总是能得到一个唯一的继承顺序。 请你实现 ThroneInheritance 类： ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。 void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。 void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。 string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。 示例： 输入： [&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;] [[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]输出： [null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]解释： ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：king t.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andy t.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bob t.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherine t.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine t.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine t.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;] t.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]提示： 1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15 kingName，parentName， childName 和 name 仅包含小写英文字母。 所有的参数 childName 和 kingName 互不相同。 所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。 每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。 最多调用 105 次birth 和 death 。 最多调用 10 次 getInheritanceOrder 。 题解： class ThroneInheritance { public: string root; unordered_map&lt;string, bool> isdeath; unordered_map&lt;string, vector&lt;string>> family; ThroneInheritance(string kingName) { root = kingName; } void birth(string parentName, string childName) { family[parentName].push_back(childName); } void death(string name) { isdeath[name] = true; } void dfs(vector&lt;string>&amp; ans, string root) { if (!isdeath[root]) ans.push_back(root); for (string str: family[root]) dfs(ans, str); } vector&lt;string> getInheritanceOrder() { vector&lt;string> ans; dfs(ans, root); return ans; } }; /** * Your ThroneInheritance object will be instantiated and called as such: * ThroneInheritance* obj = new ThroneInheritance(kingName); * obj->birth(parentName,childName); * obj->death(name); * vector&lt;string> param_3 = obj->getInheritanceOrder(); */ 【Day56】401.二进制手表401. 二进制手表二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 例如，下面的二进制手表读取 “3:25” 。 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： 例如，”01:00” 是无效的时间，正确的写法应该是 “1:00” 。 分钟必须由两位数组成，可能会以零开头： 例如，”10:2” 是无效的时间，正确的写法应该是 “10:02” 。 示例 1： 输入：turnedOn = 1 输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]示例 2： 输入：turnedOn = 9 输出：[]提示： 0 &lt;= turnedOn &lt;= 10 题解： class Solution { public: vector&lt;string> readBinaryWatch(int num) { vector&lt;string> res; //直接遍历 0:00 -> 12:00 每个时间有多少1 for (int i = 0; i &lt; 12; i++) { for (int j = 0; j &lt; 60; j++) { if (count1(i) + count1(j) == num) { res.push_back(to_string(i)+\":\"+ (j &lt; 10 ? \"0\"+to_string(j) : to_string(j))); } } } return res; } //计算二进制中1的个数 int count1(int n) { int res = 0; while (n != 0) { n = n &amp; (n - 1); res++; } return res; } }; 【Day57】剑指 Offer 15.二进制中1的个数剑指 Offer 15. 二进制中1的个数请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。提示： 输入必须是长度为 32 的 二进制串 。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 题解： 右移再 &amp; 1 class Solution { public: int hammingWeight(uint32_t n) { int ans = 0; for (int i = 0; i &lt; 32; i++) { ans += ((n >> i) &amp; 1); } return ans; } }; 【Day58】149. 直线上最多的点数149. 直线上最多的点数给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。 示例 1： 输入：points = [[1,1],[2,2],[3,3]] 输出：3示例 2： 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] 输出：4提示： 1 &lt;= points.length &lt;= 300 points[i].length == 2 -104 &lt;= xi, yi &lt;= 104 points 中的所有点 互不相同 题解： 直接枚举，比较斜率 class Solution { public: int maxPoints(vector&lt;vector&lt;int>>&amp; points) { int len = points.size(); // 点的数量不够 if(len &lt; 3) { return len; } int maxNum = 2; // 遍历每两个点 for(int i = 0; i &lt; len - 1; i ++) { for(int j = i + 1; j &lt; len; j ++) { // 统计斜率相等个数 int count = 2; long long dx = points[i][0] - points[j][0]; long long dy = points[i][1] - points[j][1]; // 与其他点比较 for(int k = j + 1; k &lt; len; k ++) { // 如果斜率相等 if(dx * (points[i][1] - points[k][1]) == dy * (points[i][0] - points[k][0])) { count ++; } } maxNum = max(maxNum, count); if(maxNum > len / 2) return maxNum; } } return maxNum; } }; 【Day59】752.打开转盘锁752. 打开转盘锁你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。 示例 1: 输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot; 输出：6 解释： 可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。 注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的， 因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。示例 2: 输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot; 输出：1 解释： 把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。示例 3: 输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot; 输出：-1 解释： 无法旋转到目标数字且不被锁定。示例 4: 输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot; 输出：-1提示： 1 &lt;= deadends.length &lt;= 500 deadends[i].length == 4 target.length == 4 target 不在 deadends 之中 target 和 deadends[i] 仅由若干位数字组成 题解： class Solution { public: int seen[10010];//记录搜到过的轮盘锁数字 int ans = -1; bool dead[10010];//记录死亡数字 int q[10010];//模拟队列 int openLock(vector&lt;string>&amp; deadends, string target) { for(auto d : deadends){ //将死亡数字转int作为下标存储在dead数组中 int tmp = stoi(d); dead[tmp] = 1; } //如果\"0000\"是死亡数字直接返回0,如果target为0000直接返回-1 if(dead[0])return -1; if(target == \"0000\") return 0; int tar=stoi(target); bfs(tar); return ans; } int numsadd(int num) { if(num == 10) return -9; if(num == -1) return -9; else return 1; } void bfs(int target) { //hh队头，tt队尾 int hh=0,tt=0; //先将队头初始化为0,代表从\"0000\"开始旋转 q[0] = 0; while(hh &lt;= tt){ auto t = q[hh++]; int prev = t; for(int i = 1 ; i &lt;= 1000 ; i *= 10){ int num = t / i % 10; int temp=t; //正向旋转当前位的数字 int tmp = temp + numsadd(num+1)*i; if(!seen[tmp] &amp;&amp; !dead[tmp]){ //满足条件就将temp插入队尾 q[++tt] = tmp; //更新新转盘锁数字的操作次数 seen[tmp] = seen[prev]+1; } //反向旋转当前位的数字 tmp = temp - numsadd(num-1)*i; if(!seen[tmp] &amp;&amp; !dead[tmp]){ q[++tt] = tmp; seen[tmp] = seen[prev]+1; } } if(seen[target] != 0){ ans = seen[target]; break; } } } }; 整整两个月就刷完啦，发现这些题更适合于找工作，而我目前没有这方面的需要，所以以后偶尔刷一下，有时间就发在博客上hh","link":"/shu-jia-leetcode-shua-ti-ji-he-xia.html"},{"title":"高级数据结构-AC自动机总结","text":"例题来自于ACWing网站 一、关于AC自动机AC自动机=KMP查找算法+Tire字典树 —&gt;可优化为Trie图 KMP查找算法：思路：例题：给定一个模式串 SS，以及一个模板串 PP，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模板串 PP 在模式串 SS 中多次作为子串出现。 求出模板串 PP 在模式串 SS 中所有出现的位置的起始下标。 输入格式第一行输入整数 NN，表示字符串 PP 的长度。 第二行输入字符串 PP。 第三行输入整数 MM，表示字符串 SS 的长度。 第四行输入字符串 SS。 输出格式共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。 数据范围1≤N≤1051≤N≤1051≤M≤1061≤M≤106 输入样例：3 aba 5 ababa输出样例：0 2代码实现： #include using namespace std; const int N = 100010, M = 1000010; int n, m; int ne[N]; //next数组 char s[M], p[N]; int main() { cin >> n >> p + 1 >> m >> s + 1; // 字符串从1开始 // 求next数组 for (int i = 2, j = 0; i n >> s+1 >> m >> p+1; // 下标从1开始 // 求next[]数组 for(int i = 2, j = 0; i > n; for(int i = 0;i < n;++i){ scanf(\"%s\",str); insert(); } build(); scanf(\"%s\",str); int res = 0; //j记录当前树节点的指针，初始是根节点 for(int i = 0,j = 0;str[i];++i){ //枚举总串str的每一个字母 int u = str[i] - 'a'; j = trie[j][u]; //跳到下一个树节点 int p = j; //每次从当前树节点开始 //fail[p]所指向的树节点如果有结尾标记可以直接算上，因为当前模式串后缀和fail指针指向的模式串部分前缀相同，所以是包含在里面的 while(p){ //假如模式串\"she\"可以匹配上，那么匹配到\"e\"的时候，用fail指针跳到模式串\"he\"的\"e\"，那么也一定能够匹配\"he\" res += cnt[p]; cnt[p] = 0; //去除标记 p = fail[p]; } } cout","link":"/gao-ji-shu-ju-jie-gou-ac-zi-dong-ji-zong-jie.html"},{"title":"暑假LeetCode刷题集合（上）","text":"最近决定巩固一下算法，开始刷leetcode每日一题，具体刷多久还不知道，刚开始是有点吃力，慢慢来。 【Day01】938.二叉搜索树的范围和题目： 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。 示例1： 输入：root = [10,5,15,3,7,null,18], low = 7, high = 15 输出：32示例 2： 输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 输出：23提示： 树中节点数目在范围 [1, 2 * 104] 内 1 &lt;= Node.val &lt;= 105 1 &lt;= low &lt;= high &lt;= 105 所有 Node.val 互不相同 题解： 递归 class Solution { public: int rangeSumBST(TreeNode* root, int low, int high) { if (!root) return 0; int sum = 0; sum += rangeSumBST(root->left, low, high); if (root->val >= low && root->val val; sum += rangeSumBST(root->right, low, high); return sum; } }; 非递归 class Solution { public: int rangeSumBST(TreeNode* root, int low, int high) { if (!root) return 0; queue q; TreeNode* p = root; int sum = 0; while (p || q.size()) { while (p) { q.push(p); p = p->left; } if (q.size()) { p = q.front(); q.pop(); if (p->val >= low && p->val val; } p = p->right; } } return sum; } }; 【Day02】633.平方数之和题目： 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。 示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5示例 2： 输入：c = 3 输出：false示例 3： 输入：c = 4 输出：true示例 4： 输入：c = 2 输出：true示例 5： 输入：c = 1 输出：true枚举 对 a 从 0 开始到 n√n 枚举，然后判断是否存在 b。 class Solution { public: bool judgeSquareSum(int c) { for (int i = 0; (long long)(i) * i id] = p; return dfs(id); } int dfs(int id) { auto p = hash[id]; int res = p->importance; for (auto son: p->subordinates) res += dfs(son); return res; } }; 【Day06】554.砖墙554. 砖墙你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。 你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。 给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。 示例 1： 输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] 输出：2示例 2： 输入：wall = [[1],[1],[1]] 输出：3提示： n == wall.length 1 &lt;= n &lt;= 104 1 &lt;= wall[i].length &lt;= 104 1 &lt;= sum(wall[i].length) &lt;= 2 * 104 对于每一行 i ，sum(wall[i]) 应当是相同的 1 &lt;= wall[i][j] &lt;= 231 - 1 题解： 贪心，哈希表 显然最优的线一定是沿某个块砖的边缘穿过的。统计每一行的砖可以从左到右可以构成的长度值，用 unordered_map 哈希表统计长度值出现的次数。出现次数最多的值就应该是这条线所在的位置。 class Solution { public: int leastBricks(vector& wall) { unordered_map cnt; for (auto& line: wall) { for (int i = 0, s = 0; i + 1 < line.size(); i ++ ) { s += line[i]; cnt[s] ++ ; } } int res = 0; for (auto [k, v]: cnt) res = max(res, v); return wall.size() - res; } }; 【Day07】7.整数反转7. 整数反转给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321示例 2： 输入：x = -123 输出：-321示例 3： 输入：x = 120 输出：21示例 4： 输入：x = 0 输出：0提示： -231 &lt;= x &lt;= 231 - 1 题解： (循环) O(logn)依次从右往左计算出每位数字，然后逆序累加在一个整数中。另外，这题有两点需要注意： 因为int型整数逆序后可能会溢出，所以我们要用long long记录中间结果； 在C++中，负数的取模运算和数学意义上的取模运算不同，结果还是负数，比如 −12%10=−2−12%10=−2，所以我们不需要对负数进行额外处理。 时间复杂度分析：一共有 O(logn) 位，对于每一位的计算量是常数级的，所以总时间复杂度是 O(logn) class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x > 0 && res > (INT_MAX - x % 10) / 10) return 0; if (x < 0 && res < (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x /= 10; } return res; } }; 【Day08】1473.粉刷房子III1473. 粉刷房子 III在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。 我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。） 给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中： houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。 cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。 示例 1： 输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出：9 解释：房子涂色方案为 [1,2,2,1,1] 此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。 涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。示例 2： 输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出：11 解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2] 此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。 给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。示例 3： 输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5 输出：5示例 4： 输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3 输出：-1 解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。提示： m == houses.length == cost.length n == cost[i].length 1 &lt;= m &lt;= 100 1 &lt;= n &lt;= 20 1 &lt;= target &lt;= m 0 &lt;= houses[i] &lt;= n 1 &lt;= cost[i][j] &lt;= 10^4 题解·： 很明显的DP 设状态 f(i,j,k) 表示处理了前 i 个房屋，有 j 个社区，最后一个房屋的颜色为 k 的最小花费，其中房屋的有效下标从 1 开始。建立辅助数组 g(i,j,k) 表示同样含义下，最后一个房屋颜色 不是 k 的最小花费。 初始时，f(0,0,k)=g(0,0,k)=0，其余为正无穷或者待定。转移时，分两种情况 如果第 i 个房屋已经有了颜色 c，则有两种选择，上一个房屋颜色为 c 或者不为 c，转移$$f(i, j, c)=\\min (f(i-1, j, c), g(i-1, j-1, c))$$ 如果第 i 个房屋没有颜色，则枚举一个颜色 k，然后同样根据上一个房屋的颜色，转移$$f(i, j, k)=\\min (f(i-1, j, k), g(i-1, j-1, k))+\\operatorname{cost}(i, k-1)_{\\text {。 }}$$ 对于 g 数组的维护如下，假设当前需要维护前 i 个房屋且有 j 个社区下的 g 数组，则我们找 f(i,j,k) 中的最小值 m1 和次小值 m2。如果 m1=m2，则说明对于所有 k， g(i,j,k)=m1；否则，对于 f(i,j,k0)=m1 的那个 k0，其 g(i,j,k0)=m2g，其余 k≠k0都有 g(i,j,k)=m1。 最终答案为$$\\min (f(m, \\text { target }, k)$$ class Solution { public: int minCost(vector& houses, vector& cost, int m, int n, int target) { const int MAX = 0x3f3f3f3f; const int M = 110; const int N = 30; int f[M][M][N], g[M][M][N]; memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); for (int k = 1; k left && !root->right) { if (index >= res.size()) return false; if (root->val != res[index]) return false; index++; return true; } return dfs2(root->left, res) && dfs2(root->right, res); } }; 【Day15】1734.解码异或后的排列1734. 解码异或后的排列给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。 它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。 给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。 示例 1： 输入：encoded = [3,1] 输出：[1,2,3] 解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]示例 2： 输入：encoded = [6,5,4,6] 输出：[2,4,1,5,3]提示： 3 &lt;= n &lt; 105 n 是奇数。 encoded.length == n - 1 题解： perm = [A,B,C,D,E] encoded = [A^B, B^C, C^D, D^E] 而B^C^D^E = encoded[1] ^ encode[3] A^B^C^D^E = total total ^ (B^C^D^E) = first class Solution { public: vector decode(vector& encoded) { int n = encoded.size() + 1; int total = 0; for (int i = 1; i = 0 && pos = 1) // 向左 ans += dfs(st - 1, arrLen, pos - 1); if (pos = arrLen) return 0; if (memo[st][pos] != -1) return memo[st][pos]; if (st == 0 && pos == 0) { return memo[st][pos] = 1; } int ans = 0; if (pos >= 0 && pos = 1) // 向左 ans = ans % N + dfs(st - 1, arrLen, pos - 1) % N; if (pos = values[i]) { num -= values[i]; ans += reps[i]; } return ans; } }; 【Day19】13.罗马数字转整数13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3示例 2: 输入: &quot;IV&quot; 输出: 4示例 3: 输入: &quot;IX&quot; 输出: 9示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3.示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4.提示： 1 &lt;= s.length &lt;= 15 s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’) 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 题解： 当小值在大值的左边，则减小值，如 IV=5-1=4； 当小值在大值的右边，则加小值，如 VI=5+1=6； 小值放在大值的左边，就是做减法，否则为加法。 class Solution { public: int romanToInt(string s) { int r=0; for(int i=0;i= 0; --i) { int t = (num >> i & 1); if (!root->next[t]) { root->next[t] = new Node(); } root = root->next[t]; } } int findMaximumXOR(vector& nums) { Node* root = new Node(); for (auto val : nums) { insert(val, root); } int res = 0, tmp = 0; Node* p = root; for (auto val : nums) { p = root; tmp = 0; for (int i = 30; i >= 0; --i) { int t = (val >> i) & 1; if (p->next[!t]) { p = p->next[!t]; tmp += (1 next[t]; } res = max(res, tmp); } return res; } }; 暴力+剪枝 剪枝策略两数异或最大不超过两数之和，先排序再剪枝。 class Solution { public: int findMaximumXOR(vector& nums) { sort(nums.begin(), nums.end(), [](auto a, auto b) {return a > b;}); int ans = 0; for (int i = 0; i < nums.size() - 1; i++) { for (int j = i + 1; j < nums.size(); j++) { long long x = (long long)nums[i] + nums[j]; if (ans > x) break; ans = max(ans, nums[i] ^ nums[j]); } } return ans; } }; 【Day21】993.二叉树的堂兄弟节点993. 二叉树的堂兄弟节点在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。 示例 1： 输入：root = [1,2,3,4], x = 4, y = 3 输出：false示例 2： 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true示例 3： 输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 题解： 假设从根节点开始编号1，依次往后编号，其两个孩子是2*n与2*n+1。反过来便是根据两个孩子节点判断是否是同一个父亲，那便是直接除以2，向下取整，看两者是否一样即可。 例如：2、3是同一父亲，2、4不是。 在BFS过程中记录节点编号以及x、y节点，最后判断即可。 class Solution { public: bool isCousins(TreeNode* root, int x, int y) { queue q; q.push(root); int cnt = 1; while (q.size()) { int sz = q.size(); bool xt = false, yt = false; int xcnt, ycnt; while (sz--) { auto p = q.front(); q.pop(); if (p) { if (x == p->val) { xt = true; xcnt = cnt; } if (y == p->val) { yt = true; ycnt = cnt; } if (xt && yt && int(xcnt / 2) != int(ycnt / 2) ) { return true; } q.push(p->left); q.push(p->right); } cnt++; } } return false; } }; 【Day22】1442.形成两个异或相等数组的三元组数目1442. 形成两个异或相等数组的三元组数目 给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。 a 和 b 定义如下： a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ … ^ arr[k] 注意：^ 表示 按位异或 操作。 请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。 示例 1： 输入：arr = [2,3,1,6,7] 输出：4 解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)示例 2： 输入：arr = [1,1,1,1,1] 输出：10示例 3： 输入：arr = [2,3] 输出：0示例 4： 输入：arr = [1,3,5,7,9] 输出：3示例 5： 输入：arr = [7,11,12,9,5,2,7,17,22] 输出：8提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[i] &lt;= 10^8 题解： ∵ a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] ​ b = arr[j] ^ arr[j + 1] ^ … ^ arr[k] ∴ arr[i] ^ arr[i + 1] ^ … ^ arr[k] = a ^ b = 0; a^b=0得到区间[i,k]中有k-i个元组，全部累加即可。区间内三元组的个数为 k - i（因为区间内的任意一个j，都和i，k组成满足题目的一个三元组）。 class Solution { public: int countTriplets(vector& arr) { int ans = 0; for (int i = 0; i < arr.size(); i++) { int s = arr[i]; for (int k = i + 1; k < arr.size(); k++) { s ^= arr[k]; if (s == 0) ans += k - i; } } return ans; } }; 【Day23】1738.找出第 K 大的异或坐标值1738. 找出第 K 大的异或坐标值给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。 矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。 请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。 示例 1： 输入：matrix = [[5,2],[1,6]], k = 1 输出：7 解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。示例 2： 输入：matrix = [[5,2],[1,6]], k = 2 输出：5 解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。示例 3： 输入：matrix = [[5,2],[1,6]], k = 3 输出：4 解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。示例 4： 输入：matrix = [[5,2],[1,6]], k = 4 输出：0 解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 1000 0 &lt;= matrix[i][j] &lt;= 106 1 &lt;= k &lt;= m * n 题解： 二维差分+最小堆 前缀和模板+维护k个元素的最小堆 class Solution { public: int prefix[1000][1000]; int kthLargestValue(vector& matrix, int k) { int m = matrix.size(); int n = matrix[0].size(); prefix[0][0] = matrix[0][0]; // 处理第一行 for (int i = 1; i < n; i++) { prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i]; } // 处理第一列 for (int i = 1; i < m; i++) { prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0]; } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1]; } } priority_queue pq; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { pq.push(prefix[i][j]); if (pq.size() > k) pq.pop(); } } return pq.top(); } }; 二分搜值 每次猜测一个值x，然后遍历前缀和矩阵，统计有多少个元素大于等于x，如果count小于k，那么x肯定不可能是答案，我们将猜测的上界下调至x-1；否则，我们就将猜测的下界调整至x。可以看到问题可以转换为查找最后一个小于等于target的数。因为当查找到大于等于target时要往上不断压缩区间，直到小于等于k为止。 class Solution { public: int prefix[1000][1000]; int m, n; int kthLargestValue(vector& matrix, int k) { m = matrix.size(); n = matrix[0].size(); prefix[0][0] = matrix[0][0]; // 处理第一行 for (int i = 1; i < n; i++) { prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i]; } // 处理第一列 for (int i = 1; i < m; i++) { prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0]; } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1]; } } int left = 0, right = 1e6; while (left < right) { int mid = right - (right - left - 1) / 2; if (count(mid) < k) { // 缩小值 right = mid - 1; } else { left = mid; } } return left; } int count (int mid) { int cnt = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (prefix[i][j] >= mid) cnt++; } } return cnt; } }; 【Day24】692.前K个高频单词692. 前K个高频单词给一非空的单词列表，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 示例 1： 输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2 输出: [&quot;i&quot;, &quot;love&quot;] 解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。 注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。示例 2： 输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4 输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;] 解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词， 出现次数依次为 4, 3, 2 和 1 次。注意： 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。 输入的单词均由小写字母组成。 扩展练习： 尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。 题解： struct Cmp { bool operator()(const pair& p1, const pair& p2) { if(p1.second != p2.second) return p1.second > p2.second; else return p1.first < p2.first; } }; class Solution { public: vector topKFrequent(vector& words, int k) { unordered_map m; for(string& word : words) m[word]++; vector sorted_list(m.begin(), m.end()); sort(sorted_list.begin(), sorted_list.end(), Cmp()); vector res; for(int i = 0; i < k; i++) res.push_back(sorted_list[i].first); return res; } }; 【Day25】1035.不相交的线1035. 不相交的线在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例 1： 输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。示例 2： 输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] 输出：3示例 3： 输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] 输出：2提示： 1 &lt;= nums1.length &lt;= 500 1 &lt;= nums2.length &lt;= 500 1 &lt;= nums1[i], nums2[i] &lt;= 2000 题解： class Solution { public: vector dp; int maxUncrossedLines(vector& nums1, vector& nums2) { int n = nums1.size(), m = nums2.size(); dp = vector(n + 1, vector(m + 1, 0)); for (int i = 1; i > i) & 1; if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } } int query(int x){ int ans = 0, p = 0; for(int i = 31; i >= 0; i--){ int u = (x >> i) & 1; if(son[p][!u]) { ans += (1","link":"/shu-jia-leetcode-shua-ti-ji-he-shang.html"},{"title":"Hexo-个人之博客主题美化","text":"本文以作者blinkfox的matery主题为例，对主题的部分地方进行优化，进行了一些美化。 没有博客？ Github + Hexo 搭建个人博客超详细教程 获取我配置好的主题？ git clone git@github.com:MUYIio/hexo-themes-matery.git 须知： 不同的Hexo主题的美化方式可能存在一些差异，但也相差无几，把源代码放在合适的位置就可以。 前提条件： 进行博客主题美化前需要了解Hexo博客的目录结构，主题的目录结构！请阅读官方文档。了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus,有一定的前端知识最好。 1】添加雪花飘落效果效果预览： 方法：在themes/matery/source/libs/others下新建文件snow.js，并插入如下代码： /*样式一*/ (function($){ $.fn.snow = function(options){ var $flake = $('&lt;div id=\"snowbox\" />').css({'position': 'absolute','z-index':'9999', 'top': '-50px'}).html('&amp;#10052;'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = { minSize : 10, maxSize : 20, newOn : 1000, flakeColor : \"#AFDAEF\" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ }, options = $.extend({}, defaults, options); var interval= setInterval( function(){ var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css({ left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor }).animate({ top: endPositionTop, left: endPositionLeft, opacity: 0.2 },durationFall,'linear',function(){ $(this).remove() }); }, options.newOn); }; })(jQuery); $(function(){ $.fn.snow({ minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ }); }); /*样式二*/ /* 控制下雪 */ function snowFall(snow) { /* 可配置属性 */ snow = snow || {}; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */ } /* 兼容写法 */ requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) { setTimeout(callback, 1000 / 60); }; cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame; /* 开始下雪 */ snowFall.prototype.start = function(){ /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this) } /* 创建画布 */ function snowCanvas() { /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function() { snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ } } /* 雪运动对象 */ function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) { this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */ } flakeMove.prototype.update = function() { var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) { this.velY = this.speed } this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x >= canvas.width || this.x &lt;= 0 || this.y >= canvas.height || this.y &lt;= 0) { this.reset(canvas.width, canvas.height) } }; /* 飞出边界-放置最顶端继续坠落 */ flakeMove.prototype.reset = function(width, height) { this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0; }; // 渲染雪花-随机形状（此处可修改雪花颜色！！！） flakeMove.prototype.render = function(ctx) { var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, \"rgba(255, 255, 255, 0.9)\"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, \"rgba(255, 255, 255, 0.5)\"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, \"rgba(255, 255, 255, 0)\"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }; /* 创建雪花-定义形状 */ function createFlakes() { var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) { flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) } } /* 画雪 */ function drawSnow() { var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) { flakes[e].update(); flakes[e].render(ctx); } /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() { drawSnow.apply(that); }); } /* 调用及控制方法 */ var snow = new snowFall({maxFlake:60}); snow.start(); 然后在themes/_config里libs.js.下面添加一行： snow: /libs/others/snow.js 在themes/matery/layout/layout.ejs里添加如下代码： 最后在themes/_config添加： # 雪花特效 snow: enable: true 2】添加动漫人物挂件效果预览： 能根据你鼠标位置摇头，还有不同的动作，摸摸它还能说话~ 方法： 1.获取模型： npm install --save hexo-helper-live2d 2.安装喜欢的模型： npm install packagename 将packagename换成模型名字，如我示例的模型： npm install live2d-widget-model-shizuku 模型预览：live2d-widget-models GitHub项目地址：hexo-helper-live2d 3.然后打开博客跟目录下的 _config.yml文件，添加如下代码： live2d: enable: true scriptFrom: local model: use: live2d-widget-model-shizuku #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 然后上传就可以了。 3】添加鼠标点击爱心效果1.在 \\themes\\hexo-theme-spfk\\source\\js 下新建文件 love.js，在 love.js 文件中添加以下代码： !function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 2.在 \\themes\\hexo-theme-spfk\\layout\\layout.ejs 文件末尾添加以下代码： &lt;!-- 页面点击小红心 --> &lt;script type=\"text/javascript\" src=\"/js/love.js\">&lt;/script> 4】浏览器网页标题1.在 \\themes\\material-x\\source\\js 下新建一个 FunnyTitle.js 文件，填写如下代码： // 浏览器搞笑标题 var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ>ω&lt;*ฅ) 噫又好啦 ~' + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); 2.在 \\themes\\material-x\\layout\\layout.ejs 文件中添加如下代码： &lt;!--浏览器搞笑标题--> &lt;script type=\"text/javascript\" src=\"/js/FunnyTitle.js\">&lt;/script> 5】添加鼠标点击显示核心价值观1.在 /themes/matery/source/js 下新建文件 ClickShowText.js，然后在ClickShowText.js文件中添加以下代码： var a_idx = 0; jQuery(document).ready(function($) { $(\"body\").click(function(e) { var a = new Array (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\"); var $i = $(\"&lt;span/>\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 5, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": \"#FF0000\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 3000, function() { $i.remove(); }); }); setTimeout('delay()', 2000); }); function delay() { $(\".buryit\").removeAttr(\"onclick\"); } 核心价值观文字也可以更换为自己喜欢得文字 2.然后在 /themes/matery/layout/layout.ejs 文件中的&lt;/body&gt;前添加以下代码： &lt;!--单击显示文字--> &lt;script type=\"text/javascript\" src=\"/js/click_show_text.js\">&lt;/script> 效果： 6】添加动态线条 会根据鼠标点击自动汇聚为一个圆 使用方法在 ：/Hexo/themes/matery/layout/layout.ejs文件中body前添加如下代码： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 7】修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } 8】页脚添加Github徽章效果： 制作方法 通过这个网站在线制作https://shields.io/，填写label、message、color三个字段，点击Make Badge就可以生成图标，然后保存生成的图标，放到页脚就可以了，其他的样式自己去探索吧。 具体可以参考这篇文章，很详细：GitHub 项目徽章的添加和设置 9】页脚添加ICP备案号 在footer.ejs中添加如下代码即可： 渝ICP备20002309号-1丨 说明： 渝ICP备20002309号-1 //改为自己的备案号 //这个是图片链接，可以修改，可能以后这个链接就不能使用了 10】添加樱花飘落效果1.在themes/matery/source/js下新建sakura.js文件夹，写入以下代码： var stop, staticx; var img = new Image(); img.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUgAAAEwCAYAAADVZeifAAAACXBIWXMAAACYAAAAmAGiyIKYAAAHG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBSaWdodHM9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9yaWdodHMvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcFJpZ2h0czpNYXJrZWQ9IkZhbHNlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NDFDMjQxQjYyNjIwNjgxMTgwODNEMjE2MDAzOTU1NDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozNDVjOWViOC04NDc4LTFkNDctOGRjMi0yZDkyOGNhYTYxZWQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE4LTA1LTA5VDE0OjQ5OjM3KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjEyMjVlZWE3LTEyY2QtMTY0NC04ZDAzLWFjOTE2ZTAxZDQ1YyIgc3RSZWY6ZG9jdW1lbnRJRD0idXVpZDoxRDIwNUFGNjZCRDlFNTExOUM5REMwMzg2RjlEQjFGNyIvPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphYmMzNjIzMy1hOWNkLWNiNDQtODViYi0zZTgyMjEwYmIxMjYiIHN0RXZ0OndoZW49IjIwMTgtMDUtMDlUMTQ6NTE6MjUrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE4IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiBzdEV2dDp3aGVuPSIyMDE4LTA1LTA5VDE0OjUxOjI1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2Vx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\"; function Sakura(x, y, s, r, fn) { this.x = x; this.y = y; this.s = s; this.r = r; this.fn = fn; } Sakura.prototype.draw = function (cxt) { cxt.save(); var xc = 40 * this.s / 4; cxt.translate(this.x, this.y); cxt.rotate(this.r); cxt.drawImage(img, 0, 0, 40 * this.s, 40 * this.s) cxt.restore(); } Sakura.prototype.update = function () { this.x = this.fn.x(this.x, this.y); this.y = this.fn.y(this.y, this.y); this.r = this.fn.r(this.r); if (this.x > window.innerWidth || this.x &lt; 0 || this.y > window.innerHeight || this.y &lt; 0) { this.r = getRandom('fnr'); if (Math.random() > 0.4) { this.x = getRandom('x'); this.y = 0; this.s = getRandom('s'); this.r = getRandom('r'); } else { this.x = window.innerWidth; this.y = getRandom('y'); this.s = getRandom('s'); this.r = getRandom('r'); } } } SakuraList = function () { this.list = []; } SakuraList.prototype.push = function (sakura) { this.list.push(sakura); } SakuraList.prototype.update = function () { for (var i = 0, len = this.list.length; i &lt; len; i++) { this.list[i].update(); } } SakuraList.prototype.draw = function (cxt) { for (var i = 0, len = this.list.length; i &lt; len; i++) { this.list[i].draw(cxt); } } SakuraList.prototype.get = function (i) { return this.list[i]; } SakuraList.prototype.size = function () { return this.list.length; } function getRandom(option) { var ret, random; switch (option) { case 'x': ret = Math.random() * window.innerWidth; break; case 'y': ret = Math.random() * window.innerHeight; break; case 's': ret = Math.random(); break; case 'r': ret = Math.random() * 6; break; case 'fnx': random = -0.5 + Math.random() * 1; ret = function (x, y) { return x + 0.5 * random - 1.7; }; break; case 'fny': random = 1.5 + Math.random() * 0.7 ret = function (x, y) { return y + random; }; break; case 'fnr': random = Math.random() * 0.03; ret = function (r) { return r + random; }; break; } return ret; } function startSakura() { requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame; var canvas = document.createElement('canvas'), cxt; staticx = true; canvas.height = window.innerHeight; canvas.width = window.innerWidth; canvas.setAttribute('style', 'position: fixed;left: 0;top: 0;pointer-events: none;'); canvas.setAttribute('id', 'canvas_sakura'); document.getElementsByTagName('body')[0].appendChild(canvas); cxt = canvas.getContext('2d'); var sakuraList = new SakuraList(); for (var i = 0; i &lt; 50; i++) { var sakura, randomX, randomY, randomS, randomR, randomFnx, randomFny; randomX = getRandom('x'); randomY = getRandom('y'); randomR = getRandom('r'); randomS = getRandom('s'); randomFnx = getRandom('fnx'); randomFny = getRandom('fny'); randomFnR = getRandom('fnr'); sakura = new Sakura(randomX, randomY, randomS, randomR, { x: randomFnx, y: randomFny, r: randomFnR }); sakura.draw(cxt); sakuraList.push(sakura); } stop = requestAnimationFrame(function () { cxt.clearRect(0, 0, canvas.width, canvas.height); sakuraList.update(); sakuraList.draw(cxt); stop = requestAnimationFrame(arguments.callee); }) } window.onresize = function () { var canvasSnow = document.getElementById('canvas_snow'); } img.onload = function () { startSakura(); } function stopp() { if (staticx) { var child = document.getElementById(\"canvas_sakura\"); child.parentNode.removeChild(child); window.cancelAnimationFrame(stop); staticx = false; } else { startSakura(); } } 2.在themes/matery/layout/layout.ejs中添加以下代码： &lt;script type=\"text/javascript\"> var windowWidth = $(window).width(); if (windowWidth > 768) { document.write('&lt;script type=\"text/javascript\" src=\"/js/sakura.js\">&lt;\\/script>'); } &lt;/script> 3.效果预览（只启用了桌面版） 持续更新中…","link":"/hexo-ge-ren-bo-ke-zhi-bo-ke-zhu-ti-mei-hua.html"}],"tags":[{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/博客搭建/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/学习笔记/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"代码整合","slug":"代码整合","link":"/tags/代码整合/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"博客优化","slug":"博客优化","link":"/tags/博客优化/"},{"name":"Code","slug":"Code","link":"/tags/Code/"},{"name":"Coding","slug":"Coding","link":"/tags/Coding/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"DaoVoice","slug":"DaoVoice","link":"/tags/DaoVoice/"},{"name":"CentOS 8.1","slug":"CentOS-8-1","link":"/tags/CentOS-8-1/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"NAT","slug":"NAT","link":"/tags/NAT/"},{"name":"Bridged","slug":"Bridged","link":"/tags/Bridged/"},{"name":"Ubuntu20.04","slug":"Ubuntu20-04","link":"/tags/Ubuntu20-04/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"COS","slug":"COS","link":"/tags/COS/"},{"name":"JSDelivr","slug":"JSDelivr","link":"/tags/JSDelivr/"},{"name":"Demo","slug":"Demo","link":"/tags/Demo/"},{"name":"Notepad","slug":"Notepad","link":"/tags/Notepad/"},{"name":"Https","slug":"Https","link":"/tags/Https/"},{"name":"洗牌","slug":"洗牌","link":"/tags/洗牌/"},{"name":"随机","slug":"随机","link":"/tags/随机/"},{"name":"主元素","slug":"主元素","link":"/tags/主元素/"},{"name":"多数元素","slug":"多数元素","link":"/tags/多数元素/"},{"name":"DOSBox","slug":"DOSBox","link":"/tags/DOSBox/"},{"name":"MASM","slug":"MASM","link":"/tags/MASM/"},{"name":"约瑟夫环","slug":"约瑟夫环","link":"/tags/约瑟夫环/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC自动机/"},{"name":"博客美化","slug":"博客美化","link":"/tags/博客美化/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"C语言","slug":"C语言","link":"/categories/C语言/"},{"name":"服务器","slug":"服务器","link":"/categories/服务器/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"双系统","slug":"双系统","link":"/categories/双系统/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"汇编","slug":"汇编","link":"/categories/汇编/"},{"name":"C++","slug":"算法/C","link":"/categories/算法/C/"},{"name":"DDOS","slug":"DDOS","link":"/categories/DDOS/"},{"name":"图床","slug":"图床","link":"/categories/图床/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"汇编","slug":"操作系统/汇编","link":"/categories/操作系统/汇编/"},{"name":"每日一题","slug":"每日一题","link":"/categories/每日一题/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}