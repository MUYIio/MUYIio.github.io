{"title":"十大经典排序算法(附动画及代码)","date":"2021-12-14T02:44:44.000Z","toc":true,"summary":"关于各种排序算法的笔记总结，含代码展示和动画演示！","source":"_posts/qSort.md","raw":"---\ntitle: 十大经典排序算法(附动画及代码)\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-12-14 10:44:44\npassword:\nsummary: 关于各种排序算法的笔记总结，含代码展示和动画演示！\ntags:\n- 排序\ncategories:\n- 算法\n- C++\nkeywords:\ndescription:\n---\n\n## 各个算法的时空复杂度及稳定性：\n\n- **稳定**：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。\n- **不稳定**：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。\n\n![](qSort/14.png)\n\n## 一、冒泡排序（Bubble Sort）\n\n### 1、原理\n\n​\t基本思想：通过无序区中相邻元素关键字间的比较和位置的交换，使关键字最小的元素像气泡一样浮到最顶部；接着对剩下的元素排序，使得第二小的元素到达顶部，同样的方法直到所有元素排序完成。\n\n### 2、步骤\n\n- **①** 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- **②** 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- **③** 针对所有的元素重复步骤 **①** ~ **②**，除了最后一个元素，直到排序完成。\n\n### 3、动画演示\n\n![](qSort/1.gif)\n\n### 4、代码实现\n\n```cpp\nvoid bubble_sort()\n{\n    for (int i = n-1; i >= 1; i -- )\n    {\n        bool flag = true;\n        for (int j = 1; j <= i; j ++ )\n            if (a[j-1] > a[j])\n            {\n                swap(a[j-1], a[j]);\n                flag = false;\n            }\n        if (flag) return;\n    }\n}\n```\n\n  \n\n## 二、选择排序（Selection Sort）\n\n### 1、原理\n\n​\t选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n### 2、步骤\n\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为`R[1..n]`，有序区为空；\n- 第i趟排序`(i=1,2,3…n-1)`开始时，当前有序区和无序区分别为`R[1..i-1]`和`R(i..n）`。该趟排序从当前无序区中-选出关键字最小的记录 `R[k]`，将它与无序区的第1个记录R交换，使`R[1..i]`和`R[i+1..n)`分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- `n-1`趟结束，数组有序化了。\n\n### 3、动画演示\n\n![](2.gif)\n\n### 4、代码实现\n\n```cpp\nvoid select_sort()\n{\n    for (int i = 0; i < n; i ++ )\n    {\n        int k = i;\n        for (int j = i+1; j < n; j ++ )\n        {\n            if (a[j] < a[k])\n                k = j;\n        }\n        swap(a[i], a[k]);\n    }\n}\n```\n\n\n\n## 三、插入排序（Insertion Sort）\n\n### 1、原理\n\n  这里主要针对直接插入排序。将元素与已经排序的有序序列比较，找到对应的位置插入。\n\n### 2、步骤\n\n- ① 从第一个元素开始，该元素可以认为已经被排序；\n- ② 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n- ③ 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n- ④ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n- ⑤ 将新元素插入到该位置后；\n- ⑥ 重复步骤2~5。\n\n### 3、动画演示\n\n![](3.gif)\n\n### 4、代码实现\n\n```cpp\nvoid insert_sort()\n{\n    for (int i = 1; i < n; i ++ )\n    {\n        int x = a[i];\n        int j = i-1;\n\n        while (j >= 0 && x < a[j])\n        {\n            a[j+1] = a[j];\n            j -- ;\n        }\n        a[j+1] = x;\n    }\n}\n```\n\n\n\n## 四、快速排序（Quick Sort）\n\n### 1、原理\n\n​\t一般选择将待排序序列分为两个序列，正中间的那个数作为关键字，然后两个指针一个从头到关键字遍历，遇到大于（小于）关键字的元素就停下来，另一个指针从尾到关键字遍历，遇到小于（大于）关键字的元素停下来，交换两个指针的元素完成排序；将序列递归分治按照前面的原理排序，直到序列有序。\n\n### 2、步骤\n\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n- 选取基准元素（pivot）\n- 划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分\n- 递归求解小于pivot和大于pivot的部分\n\n基准元素可以选择第一个元素或者最后一个元素即 Lomuto Partition Scheme，但是这样划分成两部分的时候有一部分是空的，这样可能造成死循环；从中间划分可以保证两部分都不为空，即 Hoare Partition Scheme。\n\n### 3、动画演示\n\n![](4.gif)\n\n### 4、代码实现\n\n```cpp\nvoid quick_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\n\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n    while (i < j)\n    {\n        do i ++ ; while (q[i] < x);\n        do j -- ; while (q[j] > x);\n        if (i < j) swap(q[i], q[j]);\n    }\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n}\n```\n\n**快速排序的边界问题**\n\n快排属于分治算法，最怕的就是 `n`分成`0`和`n`，或 `n`分成`n`和`0`,导致死循环。\n\n1. **以`j`为划分时，`x`不能选`q[r]` (若以`i`为划分,则`x`不能选`q[l]`)**\n\n   ​\t假设 `x = q[r]`\n\n   ​\t关键句子`quick_sort(q, l, j), quick_sort(q, j + 1, r);`\n\n   ​\t由于j的最小值是l,所以`q[j+1..r]`不会造成无限划分\n\n   ​\t但`q[l..j]（即quick_sort(q, l, j)）`却可能造成无限划分，因为j可能为r\n\n   ​\t举例来说，若`x`选为`q[r]`，数组中`q[l..r-1] < x`,\n\n   ​\t那么这一轮循环结束时`i = r, j = r`，显然会造成无限划分\n\n2. **do i++; while(q[i] < x)和do j--; while(q[j] > x)不能用q[i] <= x 和 q[j] >= x**\n\n   ​\t假设`q[l..r]`全相等\n\n   ​\t则执行完`do i++; while(q[i] <= x);`之后，`i`会自增到`r+1`\n\n   ​\t然后继续执行`q[i] <= x` 判断条件，造成数组下标越界(但这貌似不会报错)\n\n   ​\t并且如果之后的`q[i] <= x` (此时i > r) 条件也不幸成立，\n\n   ​\t就会造成一直循环下去(亲身实验)，造成内存超限(Memory Limit Exceeded)\n\n3. **`if(i < j) swap(q[i], q[j])`能否使用 `i <= j`**\n\n   ​\t可以使用`if(i <= j) swap(q[i], q[j])`;\n\n   ​\t因为 `i = j` 时，交换一下`q[i],q[j]` 无影响，因为马上就会跳出循环了\n\n4. **最后一句能否改用quick_sort(q, l, j-1), quick_sort(q, j, r)作为划分(用i做划分时也是同样的道理,)**\n\n   ​\t不能\n\n   ​\t根据之前的证明，最后一轮循环可以得到这些结论\n\n   ​\t`j <= i` 和 `q[l..i-1] <= x`, `q[i] >= x` 和 `q[j+1..r] >= x`, `q[j] <= x`\n\n   ​\t所以，`q[l..j-1] <= x` 是显然成立的，\n\n   ​\t但`quick_sort(q, j, r)`中的`q[j]` 却是 `q[j] <= x`，这不符合快排的要求\n\n   ​\t另外一点，注意`quick_sort(q, l, j-1), quick_sort(q, j, r)`可能会造成无线划分\n\n   ​\t当x选为q[l]时会造成无限划分，报错为(MLE),\n\n   ​\t如果手动改为 `x = q[r]`,可以避免无限划分\n\n   ​\t但是上面所说的`q[j] <= x` 的问题依然不能解决，这会造成 WA (Wrong Answer)\n\n5. **`j`的取值范围为`[l..r-1]`**\n\n   ​\t**证明:**\n\n   ​\t假设 `j` 最终的值为 `r` ,说明只有一轮循环(两轮的话 `j` 至少会自减两次)\n\n   ​\t说明`q[r] <= x` (因为要跳出do-while循环)\n\n   ​\t说明 `i >= r(while循环的结束条件)`, i 为 r 或 r + 1(必不可能成立)\n\n   ​\t说明 `i` 自增到了 `r` , 说明 `q[r] >= x` 和 `q[l..r-1] < x`,\n\n   ​\t得出 `q[r] = x` 和 `q[l..r-1] < x` 的结论,但这与 `x = q[l + r >> 1]`矛盾\n\n   ​\t反证法得出 `j < r`\n\n   ​\t假设 `j` 可能小于 `l` 说明 `q[l..r] > x` ,矛盾\n\n   ​\t反证法得出 `j >= l`\n\n**所以 `j`的取值范围为`[l..r-1]`,不会造成无限划分和数组越界。**\n\n## 五、希尔排序（Shell Sort）\n\n### 1、原理\n\n​\t希尔排序又叫**缩小增量排序**，也是一种插入排序方法（通常快于直接插入法），具体做法是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序；\n\n### 2、步骤\n\n- 1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…\n- 2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。\n\n对于增量的选定无一定论，但最后一个增量必须等于1，也就是说，每趟后一个增量是前一个增量的1/2。\n\n### 3、动画演示\n\n![](5.gif)\n\n### 4、代码实现\n\n```cpp\nvoid shell_sort()\n{\n    for (int gap = n >> 1; gap; gap >>= 1)\n    {\n        for (int i = gap; i < n; i ++ )\n        {\n            int x = a[i];\n            int j;\n            for (j = i; j >= gap && a[j-gap] > x; j -= gap)\n                a[j] = a[j-gap];\n            a[j] = x;\n        }\n    }\n}\n\n```\n\n\n\n## 六、归并排序（Merge Sort）\n\n### 1、原理\n\n   归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n### 2、步骤\n\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列\n\n### 3、动画演示\n\n![](6.gif)\n\n### 4、代码实现\n\n```cpp\nvoid merge_sort(int q[], int l, int r)\n{\n    //递归的终止情况\n    if(l >= r) return;\n\n    //第一步：分成子问题\n    int mid = l + r >> 1;\n\n    //第二步：递归处理子问题\n    merge_sort(q, l, mid ), merge_sort(q, mid + 1, r);\n\n    //第三步：合并子问题\n    int k = 0, i = l, j = mid + 1, tmp[r - l + 1];\n    while(i <= mid && j <= r)\n        if(q[i] <= q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    while(i <= mid) tmp[k++] = q[i++];\n    while(j <= r) tmp[k++] = q[j++];\n\n    for(k = 0, i = l; i <= r; k++, i++) q[i] = tmp[k];\n}\n```\n\n**tmp 保存的是 q[l..mid] , q[mid+1..r] 中从小到大排序的所有数**\n\t证明(第一个 `while` 循环)\n\t循环不变式: `tmp[0..k-1]` 保存上述俩数组中从小到大排序的最小 `k` 个数\n\n**1.初始**\n\n​\t`k = 0, tmp[0..k-1]` 为空，显然成立\n\n**2.保持**\n\n​\t假设某轮循环开始之前，循环不变式成立\n\n​\t若 `q[i] <= q[j], 则 tmp[k] = q[i]`\n\n​\t其中 `q[i] <= q[i+1..mid], q[i] <= q[j] <= q[j+1..r]`\n\n​\t∴ q[i] 是剩下的所有数中最小的一个\n\n​\t当 q[i] > q[j] 时，同理可以得到 `tmp[k] = q[j]` 是剩下数中最小的一个\n\n​\t∴ `tmp[k]` 是剩下数中最小的一个\n\n​\t∴ `k`自增之后，下轮循环开始之前，`tmp[0..k-1]`保存从小到大排序的最小k个数\n\n**3.终止**\n\n​\t`i > mid` 或 `j > r`\n\n​\t则 `q[l..mid]` 和 `q[mid+1..r]` 其中一个数组的数都已遍历\n\n​\t`tmp[0..k-1]`保存从小到大排序的最小k个数\n\n\n\n## 七、计数排序（Counting Sort）\n\n### 1、原理\n\n​\t计数排序，又叫非比较排序，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数\n\n### 2、步骤\n\n- 找出待排序的数组中最大和最小的元素；\n- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\n- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n\n### 3、动画演示\n\n![](7.gif)\n\n### 4、代码实现\n\n```cpp\nvoid counting_sort()\n{\n    int sorted[N];\n    int maxv = a[0];\n    for (int i = 1; i < n; i ++ )\n        if (maxv < a[i])\n            maxv = a[i];\n    int count[maxv+1];\n    for (int i = 0; i < n; i ++ ) count[a[i]] ++ ;\n    for (int i = 1; i <= maxv; i ++ ) count[i] += count[i-1];\n    for (int i = n-1; i >= 0; i -- )\n    {\n        sorted[count[a[i]]-1] = a[i];\n        count[a[i]] -- ;\n    }\n    for (int i = 0; i < n; i ++ ) a[i] = sorted[i];\n}\n```\n\n\n\n## 八、基数排序（Radix Sort）\n\n### 1、原理\n\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\n\n### 2、步骤\n\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序（利用计数排序适用于小范围数的特点)。\n\n### 3、动画演示\n\n![](8.gif)\n\n### 4、代码实现\n\n```cpp\nint maxbit()\n{\n    int maxv = a[0];\n    for (int i = 1; i < n; i ++ )\n        if (maxv < a[i])\n            maxv = a[i];\n    int cnt = 1;\n    while (maxv >= 10) maxv /= 10, cnt ++ ;\n\n    return cnt;\n}\nvoid radixsort()\n{\n    int t = maxbit();\n    int radix = 1;\n\n    for (int i = 1; i <= t; i ++ )\n    {\n        for (int j = 0; j < 10; j ++ ) count[j] = 0;\n        for (int j = 0; j < n; j ++ )\n        {\n            int k = (a[j] / radix) % 10;\n            count[k] ++ ;\n        }\n        for (int j = 1; j < 10; j ++ ) count[j] += count[j-1];\n        for (int j = n-1; j >= 0; j -- )\n        {\n            int k = (a[j] / radix) % 10;\n            temp[count[k]-1] = a[j];\n            count[k] -- ;\n        }\n        for (int j = 0; j < n; j ++ ) a[j] = temp[j];\n        radix *= 10;\n    }\n\n}\n\n```\n\n\n\n## 九、桶排序（Bucket Sort）\n\n### 1、原理\n\n 遍历原始序列确定最大值 `maxval` 和最小值 `minval`，并确定桶的个数 `n`; 然后，将待排序集合中处于同一个值域的元素存入同一个桶中,在桶内使用各种现有的算法进行排序; 最后按照从小到大的顺序依次收集桶中的每一个元素, 即为最终结果。\n\n### 2、步骤\n\n- 1.设置一个定量的数组当作空桶；\n- 2.遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- 3.对每个不是空的桶进行排序；\n- 4.从不是空的桶里把排好序的数据拼接起来。 \n\n桶排序是一种用空间换取时间的排序。桶的个数和大小都是我们人为设置的，而每个桶又要避免空桶的情况，所以我们在使用桶排序的时候即需要对待排序数列要求偏均匀，又要要求桶的设计兼顾效率和空间；数要相对均匀分布，桶的个数也要合理设计。在设计桶排序时，需要知道输入数据的上界和下界。\n\n### 3、动画演示\n\n![](9.gif)\n\n<font color=red size=4>`（动图来源于@五分钟学算法，侵删）`</font>\n\n### 4、代码实现\n\n```cpp\n//桶排序 \nvoid BucketSort(int a[], int n){\n    int minval = a[0], maxval = a[0];\n    for(int i = 0; i < n; i ++){//寻找原序列数组元素的最大值和最小值 \n        minval = min(minval, a[i]);\n        maxval = max(maxval, a[i]);\n    }\n\n    int bnum = 10;//桶中元素个数 \n    int m = (maxval - minval) / bnum + 1;//桶的个数 \n    vector< vector<int> > bucket(m);\n\n    //收集,将元素入相应的桶中. 减偏移量是为了将元素映射到更小的区间内,省内存 \n    for(int i = 0; i < n; i ++) bucket[(a[i] - minval) / bnum].push_back(a[i]);\n\n    //将桶内元素排序 \n    for(int i = 0; i < m; i ++) sort(bucket.begin(), bucket.end());\n\n    //收集, 将各个桶中的元素收集到一起 \n    for(int i = 0, k = 0; i < m; i ++){\n        for(int j = 0; j < bucket[i].size(); j ++){\n            data[k ++] = bucket[i][j];\n        }\n    }\n}\n```\n\n\n\n## 十、堆排序（Heap Sort）\n\n### 1、原理\n\n先看看堆的特性：\n\n> 堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。\n>\n\n![](12.png)\n\n堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n\n\n### 2、步骤\n\n- 1.构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；\n- 2.此时的堆顶元素，为最大或者最小元素；\n- 3.把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；\n- 4.此时堆顶元素为第二大元素；\n- 5.重复以上步骤，直到堆变空。\n\n### 3、动画演示\n\n![](qSort/10.gif)\n\n### 4、代码实现\n\n \n\n```cpp\nvoid down(int u)\n{\n    int t = u;\n    if (u<<1 <= n && h[u<<1] < h[t]) t = u<<1;\n    if ((u<<1|1) <= n && h[u<<1|1] < h[t]) t = u<<1|1;\n    if (u != t)\n    {\n        swap(h[u], h[t]);\n        down(t);\n    }\n}\n\nint main()\n{\n    for (int i = 1; i <= n; i ++ ) cin >> h[i];\n    for (int i = n/2; i; i -- ) down(i);\n    while (true)\n    {\n        if (!n) break;\n        cout << h[1] << ' ';\n        h[1] = h[n];\n        n -- ;\n        down(1);\n    }\n    return 0;\n}\n```\n\n","slug":"qSort","published":true,"updated":"2022-06-06T14:37:33.122Z","_id":"clq6dy49w001zikw0ccfcywxz","comments":true,"layout":"post","photos":[],"link":"","html":"<h2 id=\"各个算法的时空复杂度及稳定性：\"><a href=\"#各个算法的时空复杂度及稳定性：\" class=\"headerlink\" title=\"各个算法的时空复杂度及稳定性：\"></a>各个算法的时空复杂度及稳定性：</h2><ul>\n<li><strong>稳定</strong>：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。</li>\n<li><strong>不稳定</strong>：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。</li>\n</ul>\n<p><img src=\"qSort/14.png\" alt></p>\n<h2 id=\"一、冒泡排序（Bubble-Sort）\"><a href=\"#一、冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"一、冒泡排序（Bubble Sort）\"></a>一、冒泡排序（Bubble Sort）</h2><h3 id=\"1、原理\"><a href=\"#1、原理\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    基本思想：通过无序区中相邻元素关键字间的比较和位置的交换，使关键字最小的元素像气泡一样浮到最顶部；接着对剩下的元素排序，使得第二小的元素到达顶部，同样的方法直到所有元素排序完成。</p>\n<h3 id=\"2、步骤\"><a href=\"#2、步骤\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li><strong>①</strong> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li><strong>②</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li><strong>③</strong> 针对所有的元素重复步骤 <strong>①</strong> ~ <strong>②</strong>，除了最后一个元素，直到排序完成。</li>\n</ul>\n<h3 id=\"3、动画演示\"><a href=\"#3、动画演示\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"qSort/1.gif\" alt></p>\n<h3 id=\"4、代码实现\"><a href=\"#4、代码实现\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">bubble_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">--</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">bool</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"二、选择排序（Selection-Sort）\"><a href=\"#二、选择排序（Selection-Sort）\" class=\"headerlink\" title=\"二、选择排序（Selection Sort）\"></a>二、选择排序（Selection Sort）</h2><h3 id=\"1、原理-1\"><a href=\"#1、原理-1\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3 id=\"2、步骤-1\"><a href=\"#2、步骤-1\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为<code>R[1..n]</code>，有序区为空；</li>\n<li>第i趟排序<code>(i=1,2,3…n-1)</code>开始时，当前有序区和无序区分别为<code>R[1..i-1]</code>和<code>R(i..n）</code>。该趟排序从当前无序区中-选出关键字最小的记录 <code>R[k]</code>，将它与无序区的第1个记录R交换，使<code>R[1..i]</code>和<code>R[i+1..n)</code>分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li><code>n-1</code>趟结束，数组有序化了。</li>\n</ul>\n<h3 id=\"3、动画演示-1\"><a href=\"#3、动画演示-1\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"2.gif\" alt></p>\n<h3 id=\"4、代码实现-1\"><a href=\"#4、代码实现-1\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">select_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                k <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"三、插入排序（Insertion-Sort）\"><a href=\"#三、插入排序（Insertion-Sort）\" class=\"headerlink\" title=\"三、插入排序（Insertion Sort）\"></a>三、插入排序（Insertion Sort）</h2><h3 id=\"1、原理-2\"><a href=\"#1、原理-2\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>  这里主要针对直接插入排序。将元素与已经排序的有序序列比较，找到对应的位置插入。</p>\n<h3 id=\"2、步骤-2\"><a href=\"#2、步骤-2\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>① 从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>② 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>③ 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>④ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>⑤ 将新元素插入到该位置后；</li>\n<li>⑥ 重复步骤2~5。</li>\n</ul>\n<h3 id=\"3、动画演示-2\"><a href=\"#3、动画演示-2\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"3.gif\" alt></p>\n<h3 id=\"4、代码实现-2\"><a href=\"#4、代码实现-2\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">insert_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> x <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            j <span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"四、快速排序（Quick-Sort）\"><a href=\"#四、快速排序（Quick-Sort）\" class=\"headerlink\" title=\"四、快速排序（Quick Sort）\"></a>四、快速排序（Quick Sort）</h2><h3 id=\"1、原理-3\"><a href=\"#1、原理-3\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    一般选择将待排序序列分为两个序列，正中间的那个数作为关键字，然后两个指针一个从头到关键字遍历，遇到大于（小于）关键字的元素就停下来，另一个指针从尾到关键字遍历，遇到小于（大于）关键字的元素停下来，交换两个指针的元素完成排序；将序列递归分治按照前面的原理排序，直到序列有序。</p>\n<h3 id=\"2、步骤-3\"><a href=\"#2、步骤-3\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<ul>\n<li>选取基准元素（pivot）</li>\n<li>划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分</li>\n<li>递归求解小于pivot和大于pivot的部分</li>\n</ul>\n<p>基准元素可以选择第一个元素或者最后一个元素即 Lomuto Partition Scheme，但是这样划分成两部分的时候有一部分是空的，这样可能造成死循环；从中间划分可以保证两部分都不为空，即 Hoare Partition Scheme。</p>\n<h3 id=\"3、动画演示-3\"><a href=\"#3、动画演示-3\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"4.gif\" alt></p>\n<h3 id=\"4、代码实现-3\"><a href=\"#4、代码实现-3\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> q<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> r<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> l <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> r <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> x <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>l <span class=\"token operator\">+</span> r <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">do</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">do</span> j <span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>快速排序的边界问题</strong></p>\n<p>快排属于分治算法，最怕的就是 <code>n</code>分成<code>0</code>和<code>n</code>，或 <code>n</code>分成<code>n</code>和<code>0</code>,导致死循环。</p>\n<ol>\n<li><p><strong>以<code>j</code>为划分时，<code>x</code>不能选<code>q[r]</code> (若以<code>i</code>为划分,则<code>x</code>不能选<code>q[l]</code>)</strong></p>\n<p>​    假设 <code>x = q[r]</code></p>\n<p>​    关键句子<code>quick_sort(q, l, j), quick_sort(q, j + 1, r);</code></p>\n<p>​    由于j的最小值是l,所以<code>q[j+1..r]</code>不会造成无限划分</p>\n<p>​    但<code>q[l..j]（即quick_sort(q, l, j)）</code>却可能造成无限划分，因为j可能为r</p>\n<p>​    举例来说，若<code>x</code>选为<code>q[r]</code>，数组中<code>q[l..r-1] &lt; x</code>,</p>\n<p>​    那么这一轮循环结束时<code>i = r, j = r</code>，显然会造成无限划分</p>\n</li>\n<li><p><strong>do i++; while(q[i] &lt; x)和do j–; while(q[j] &gt; x)不能用q[i] &lt;= x 和 q[j] &gt;= x</strong></p>\n<p>​    假设<code>q[l..r]</code>全相等</p>\n<p>​    则执行完<code>do i++; while(q[i] &lt;= x);</code>之后，<code>i</code>会自增到<code>r+1</code></p>\n<p>​    然后继续执行<code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)</p>\n<p>​    并且如果之后的<code>q[i] &lt;= x</code> (此时i &gt; r) 条件也不幸成立，</p>\n<p>​    就会造成一直循环下去(亲身实验)，造成内存超限(Memory Limit Exceeded)</p>\n</li>\n<li><p><strong><code>if(i &lt; j) swap(q[i], q[j])</code>能否使用 <code>i &lt;= j</code></strong></p>\n<p>​    可以使用<code>if(i &lt;= j) swap(q[i], q[j])</code>;</p>\n<p>​    因为 <code>i = j</code> 时，交换一下<code>q[i],q[j]</code> 无影响，因为马上就会跳出循环了</p>\n</li>\n<li><p><strong>最后一句能否改用quick_sort(q, l, j-1), quick_sort(q, j, r)作为划分(用i做划分时也是同样的道理,)</strong></p>\n<p>​    不能</p>\n<p>​    根据之前的证明，最后一轮循环可以得到这些结论</p>\n<p>​    <code>j &lt;= i</code> 和 <code>q[l..i-1] &lt;= x</code>, <code>q[i] &gt;= x</code> 和 <code>q[j+1..r] &gt;= x</code>, <code>q[j] &lt;= x</code></p>\n<p>​    所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p>\n<p>​    但<code>quick_sort(q, j, r)</code>中的<code>q[j]</code> 却是 <code>q[j] &lt;= x</code>，这不符合快排的要求</p>\n<p>​    另外一点，注意<code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code>可能会造成无线划分</p>\n<p>​    当x选为q[l]时会造成无限划分，报错为(MLE),</p>\n<p>​    如果手动改为 <code>x = q[r]</code>,可以避免无限划分</p>\n<p>​    但是上面所说的<code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 WA (Wrong Answer)</p>\n</li>\n<li><p><strong><code>j</code>的取值范围为<code>[l..r-1]</code></strong></p>\n<p>​    <strong>证明:</strong></p>\n<p>​    假设 <code>j</code> 最终的值为 <code>r</code> ,说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p>\n<p>​    说明<code>q[r] &lt;= x</code> (因为要跳出do-while循环)</p>\n<p>​    说明 <code>i &gt;= r(while循环的结束条件)</code>, i 为 r 或 r + 1(必不可能成立)</p>\n<p>​    说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>,</p>\n<p>​    得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论,但这与 <code>x = q[l + r &gt;&gt; 1]</code>矛盾</p>\n<p>​    反证法得出 <code>j &lt; r</code></p>\n<p>​    假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> ,矛盾</p>\n<p>​    反证法得出 <code>j &gt;= l</code></p>\n</li>\n</ol>\n<p><strong>所以 <code>j</code>的取值范围为<code>[l..r-1]</code>,不会造成无限划分和数组越界。</strong></p>\n<h2 id=\"五、希尔排序（Shell-Sort）\"><a href=\"#五、希尔排序（Shell-Sort）\" class=\"headerlink\" title=\"五、希尔排序（Shell Sort）\"></a>五、希尔排序（Shell Sort）</h2><h3 id=\"1、原理-4\"><a href=\"#1、原理-4\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    希尔排序又叫<strong>缩小增量排序</strong>，也是一种插入排序方法（通常快于直接插入法），具体做法是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序；</p>\n<h3 id=\"2、步骤-4\"><a href=\"#2、步骤-4\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…</li>\n<li>2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</li>\n</ul>\n<p>对于增量的选定无一定论，但最后一个增量必须等于1，也就是说，每趟后一个增量是前一个增量的1/2。</p>\n<h3 id=\"3、动画演示-4\"><a href=\"#3、动画演示-4\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"5.gif\" alt></p>\n<h3 id=\"4、代码实现-4\"><a href=\"#4、代码实现-4\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">shell_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> n <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> gap<span class=\"token punctuation\">;</span> gap <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> gap<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> gap <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>gap<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> x<span class=\"token punctuation\">;</span> j <span class=\"token operator\">-</span><span class=\"token operator\">=</span> gap<span class=\"token punctuation\">)</span>\n                a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"六、归并排序（Merge-Sort）\"><a href=\"#六、归并排序（Merge-Sort）\" class=\"headerlink\" title=\"六、归并排序（Merge Sort）\"></a>六、归并排序（Merge Sort）</h2><h3 id=\"1、原理-5\"><a href=\"#1、原理-5\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>   归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>\n<h3 id=\"2、步骤-5\"><a href=\"#2、步骤-5\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列</li>\n</ul>\n<h3 id=\"3、动画演示-5\"><a href=\"#3、动画演示-5\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"6.gif\" alt></p>\n<h3 id=\"4、代码实现-5\"><a href=\"#4、代码实现-5\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> q<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//递归的终止情况</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> r<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//第一步：分成子问题</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> l <span class=\"token operator\">+</span> r <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//第二步：递归处理子问题</span>\n    <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//第三步：合并子问题</span>\n    <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">[</span>r <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> mid <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> q<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">)</span> tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> q<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>tmp 保存的是 q[l..mid] , q[mid+1..r] 中从小到大排序的所有数</strong><br>    证明(第一个 <code>while</code> 循环)<br>    循环不变式: <code>tmp[0..k-1]</code> 保存上述俩数组中从小到大排序的最小 <code>k</code> 个数</p>\n<p><strong>1.初始</strong></p>\n<p>​    <code>k = 0, tmp[0..k-1]</code> 为空，显然成立</p>\n<p><strong>2.保持</strong></p>\n<p>​    假设某轮循环开始之前，循环不变式成立</p>\n<p>​    若 <code>q[i] &lt;= q[j], 则 tmp[k] = q[i]</code></p>\n<p>​    其中 <code>q[i] &lt;= q[i+1..mid], q[i] &lt;= q[j] &lt;= q[j+1..r]</code></p>\n<p>​    ∴ q[i] 是剩下的所有数中最小的一个</p>\n<p>​    当 q[i] &gt; q[j] 时，同理可以得到 <code>tmp[k] = q[j]</code> 是剩下数中最小的一个</p>\n<p>​    ∴ <code>tmp[k]</code> 是剩下数中最小的一个</p>\n<p>​    ∴ <code>k</code>自增之后，下轮循环开始之前，<code>tmp[0..k-1]</code>保存从小到大排序的最小k个数</p>\n<p><strong>3.终止</strong></p>\n<p>​    <code>i &gt; mid</code> 或 <code>j &gt; r</code></p>\n<p>​    则 <code>q[l..mid]</code> 和 <code>q[mid+1..r]</code> 其中一个数组的数都已遍历</p>\n<p>​    <code>tmp[0..k-1]</code>保存从小到大排序的最小k个数</p>\n<h2 id=\"七、计数排序（Counting-Sort）\"><a href=\"#七、计数排序（Counting-Sort）\" class=\"headerlink\" title=\"七、计数排序（Counting Sort）\"></a>七、计数排序（Counting Sort）</h2><h3 id=\"1、原理-6\"><a href=\"#1、原理-6\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    计数排序，又叫非比较排序，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数</p>\n<h3 id=\"2、步骤-6\"><a href=\"#2、步骤-6\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>\n</ul>\n<h3 id=\"3、动画演示-6\"><a href=\"#3、动画演示-6\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"7.gif\" alt></p>\n<h3 id=\"4、代码实现-6\"><a href=\"#4、代码实现-6\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">counting_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> sorted<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> maxv <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>maxv <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            maxv <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">[</span>maxv<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> count<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> maxv<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> count<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> count<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">--</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        sorted<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        count<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"八、基数排序（Radix-Sort）\"><a href=\"#八、基数排序（Radix-Sort）\" class=\"headerlink\" title=\"八、基数排序（Radix Sort）\"></a>八、基数排序（Radix Sort）</h2><h3 id=\"1、原理-7\"><a href=\"#1、原理-7\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n<h3 id=\"2、步骤-7\"><a href=\"#2、步骤-7\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点)。</li>\n</ul>\n<h3 id=\"3、动画演示-7\"><a href=\"#3、动画演示-7\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"8.gif\" alt></p>\n<h3 id=\"4、代码实现-7\"><a href=\"#4、代码实现-7\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">maxbit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> maxv <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>maxv <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            maxv <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cnt <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>maxv <span class=\"token operator\">>=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> maxv <span class=\"token operator\">/</span><span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> cnt <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> cnt<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">radixsort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> <span class=\"token function\">maxbit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> radix <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> t<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> count<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> radix<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n            count<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> count<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> count<span class=\"token punctuation\">[</span>j<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">--</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> radix<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n            temp<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            count<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        radix <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"九、桶排序（Bucket-Sort）\"><a href=\"#九、桶排序（Bucket-Sort）\" class=\"headerlink\" title=\"九、桶排序（Bucket Sort）\"></a>九、桶排序（Bucket Sort）</h2><h3 id=\"1、原理-8\"><a href=\"#1、原理-8\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p> 遍历原始序列确定最大值 <code>maxval</code> 和最小值 <code>minval</code>，并确定桶的个数 <code>n</code>; 然后，将待排序集合中处于同一个值域的元素存入同一个桶中,在桶内使用各种现有的算法进行排序; 最后按照从小到大的顺序依次收集桶中的每一个元素, 即为最终结果。</p>\n<h3 id=\"2、步骤-8\"><a href=\"#2、步骤-8\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>1.设置一个定量的数组当作空桶；</li>\n<li>2.遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>3.对每个不是空的桶进行排序；</li>\n<li>4.从不是空的桶里把排好序的数据拼接起来。 </li>\n</ul>\n<p>桶排序是一种用空间换取时间的排序。桶的个数和大小都是我们人为设置的，而每个桶又要避免空桶的情况，所以我们在使用桶排序的时候即需要对待排序数列要求偏均匀，又要要求桶的设计兼顾效率和空间；数要相对均匀分布，桶的个数也要合理设计。在设计桶排序时，需要知道输入数据的上界和下界。</p>\n<h3 id=\"3、动画演示-8\"><a href=\"#3、动画演示-8\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"9.gif\" alt></p>\n<p><font color=\"red\" size=\"4\"><code>（动图来源于@五分钟学算法，侵删）</code></font></p>\n<h3 id=\"4、代码实现-8\"><a href=\"#4、代码实现-8\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//桶排序 </span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">BucketSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> minval <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> maxval <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//寻找原序列数组元素的最大值和最小值 </span>\n        minval <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>minval<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        maxval <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxval<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> bnum <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//桶中元素个数 </span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>maxval <span class=\"token operator\">-</span> minval<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> bnum <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//桶的个数 </span>\n    vector<span class=\"token operator\">&lt;</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> <span class=\"token function\">bucket</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//收集,将元素入相应的桶中. 减偏移量是为了将元素映射到更小的区间内,省内存 </span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> bucket<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> minval<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> bnum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//将桶内元素排序 </span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> bucket<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//收集, 将各个桶中的元素收集到一起 </span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            data<span class=\"token punctuation\">[</span>k <span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"十、堆排序（Heap-Sort）\"><a href=\"#十、堆排序（Heap-Sort）\" class=\"headerlink\" title=\"十、堆排序（Heap Sort）\"></a>十、堆排序（Heap Sort）</h2><h3 id=\"1、原理-9\"><a href=\"#1、原理-9\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>先看看堆的特性：</p>\n<blockquote>\n<p>堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。</p>\n</blockquote>\n<p><img src=\"12.png\" alt></p>\n<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<h3 id=\"2、步骤-9\"><a href=\"#2、步骤-9\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>1.构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；</li>\n<li>2.此时的堆顶元素，为最大或者最小元素；</li>\n<li>3.把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；</li>\n<li>4.此时堆顶元素为第二大元素；</li>\n<li>5.重复以上步骤，直到堆变空。</li>\n</ul>\n<h3 id=\"3、动画演示-9\"><a href=\"#3、动画演示-9\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"qSort/10.gif\" alt></p>\n<h3 id=\"4、代码实现-9\"><a href=\"#4、代码实现-9\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> u<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>u<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">[</span>u<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> h<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> t <span class=\"token operator\">=</span> u<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>u<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">|</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">[</span>u<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">|</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> h<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> t <span class=\"token operator\">=</span> u<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">|</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>u <span class=\"token operator\">!=</span> t<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">down</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> cin <span class=\"token operator\">>></span> h<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">--</span> <span class=\"token punctuation\">)</span> <span class=\"token function\">down</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> h<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span>\n        h<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        n <span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","excerpt":"","more":"<h2 id=\"各个算法的时空复杂度及稳定性：\"><a href=\"#各个算法的时空复杂度及稳定性：\" class=\"headerlink\" title=\"各个算法的时空复杂度及稳定性：\"></a>各个算法的时空复杂度及稳定性：</h2><ul>\n<li><strong>稳定</strong>：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。</li>\n<li><strong>不稳定</strong>：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。</li>\n</ul>\n<p><img src=\"qSort/14.png\" alt></p>\n<h2 id=\"一、冒泡排序（Bubble-Sort）\"><a href=\"#一、冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"一、冒泡排序（Bubble Sort）\"></a>一、冒泡排序（Bubble Sort）</h2><h3 id=\"1、原理\"><a href=\"#1、原理\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    基本思想：通过无序区中相邻元素关键字间的比较和位置的交换，使关键字最小的元素像气泡一样浮到最顶部；接着对剩下的元素排序，使得第二小的元素到达顶部，同样的方法直到所有元素排序完成。</p>\n<h3 id=\"2、步骤\"><a href=\"#2、步骤\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li><strong>①</strong> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li><strong>②</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li><strong>③</strong> 针对所有的元素重复步骤 <strong>①</strong> ~ <strong>②</strong>，除了最后一个元素，直到排序完成。</li>\n</ul>\n<h3 id=\"3、动画演示\"><a href=\"#3、动画演示\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"qSort/1.gif\" alt></p>\n<h3 id=\"4、代码实现\"><a href=\"#4、代码实现\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void bubble_sort()\n{\n    for (int i = n-1; i &gt;= 1; i -- )\n    {\n        bool flag = true;\n        for (int j = 1; j &lt;= i; j ++ )\n            if (a[j-1] &gt; a[j])\n            {\n                swap(a[j-1], a[j]);\n                flag = false;\n            }\n        if (flag) return;\n    }\n}</code></pre>\n<h2 id=\"二、选择排序（Selection-Sort）\"><a href=\"#二、选择排序（Selection-Sort）\" class=\"headerlink\" title=\"二、选择排序（Selection Sort）\"></a>二、选择排序（Selection Sort）</h2><h3 id=\"1、原理-1\"><a href=\"#1、原理-1\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3 id=\"2、步骤-1\"><a href=\"#2、步骤-1\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为<code>R[1..n]</code>，有序区为空；</li>\n<li>第i趟排序<code>(i=1,2,3…n-1)</code>开始时，当前有序区和无序区分别为<code>R[1..i-1]</code>和<code>R(i..n）</code>。该趟排序从当前无序区中-选出关键字最小的记录 <code>R[k]</code>，将它与无序区的第1个记录R交换，使<code>R[1..i]</code>和<code>R[i+1..n)</code>分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li><code>n-1</code>趟结束，数组有序化了。</li>\n</ul>\n<h3 id=\"3、动画演示-1\"><a href=\"#3、动画演示-1\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"2.gif\" alt></p>\n<h3 id=\"4、代码实现-1\"><a href=\"#4、代码实现-1\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void select_sort()\n{\n    for (int i = 0; i &lt; n; i ++ )\n    {\n        int k = i;\n        for (int j = i+1; j &lt; n; j ++ )\n        {\n            if (a[j] &lt; a[k])\n                k = j;\n        }\n        swap(a[i], a[k]);\n    }\n}</code></pre>\n<h2 id=\"三、插入排序（Insertion-Sort）\"><a href=\"#三、插入排序（Insertion-Sort）\" class=\"headerlink\" title=\"三、插入排序（Insertion Sort）\"></a>三、插入排序（Insertion Sort）</h2><h3 id=\"1、原理-2\"><a href=\"#1、原理-2\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>  这里主要针对直接插入排序。将元素与已经排序的有序序列比较，找到对应的位置插入。</p>\n<h3 id=\"2、步骤-2\"><a href=\"#2、步骤-2\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>① 从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>② 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>③ 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>④ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>⑤ 将新元素插入到该位置后；</li>\n<li>⑥ 重复步骤2~5。</li>\n</ul>\n<h3 id=\"3、动画演示-2\"><a href=\"#3、动画演示-2\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"3.gif\" alt></p>\n<h3 id=\"4、代码实现-2\"><a href=\"#4、代码实现-2\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void insert_sort()\n{\n    for (int i = 1; i &lt; n; i ++ )\n    {\n        int x = a[i];\n        int j = i-1;\n\n        while (j &gt;= 0 &amp;&amp; x &lt; a[j])\n        {\n            a[j+1] = a[j];\n            j -- ;\n        }\n        a[j+1] = x;\n    }\n}</code></pre>\n<h2 id=\"四、快速排序（Quick-Sort）\"><a href=\"#四、快速排序（Quick-Sort）\" class=\"headerlink\" title=\"四、快速排序（Quick Sort）\"></a>四、快速排序（Quick Sort）</h2><h3 id=\"1、原理-3\"><a href=\"#1、原理-3\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    一般选择将待排序序列分为两个序列，正中间的那个数作为关键字，然后两个指针一个从头到关键字遍历，遇到大于（小于）关键字的元素就停下来，另一个指针从尾到关键字遍历，遇到小于（大于）关键字的元素停下来，交换两个指针的元素完成排序；将序列递归分治按照前面的原理排序，直到序列有序。</p>\n<h3 id=\"2、步骤-3\"><a href=\"#2、步骤-3\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<ul>\n<li>选取基准元素（pivot）</li>\n<li>划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分</li>\n<li>递归求解小于pivot和大于pivot的部分</li>\n</ul>\n<p>基准元素可以选择第一个元素或者最后一个元素即 Lomuto Partition Scheme，但是这样划分成两部分的时候有一部分是空的，这样可能造成死循环；从中间划分可以保证两部分都不为空，即 Hoare Partition Scheme。</p>\n<h3 id=\"3、动画演示-3\"><a href=\"#3、动画演示-3\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"4.gif\" alt></p>\n<h3 id=\"4、代码实现-3\"><a href=\"#4、代码实现-3\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void quick_sort(int q[], int l, int r)\n{\n    if (l &gt;= r) return;\n\n    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    {\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    }\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n}</code></pre>\n<p><strong>快速排序的边界问题</strong></p>\n<p>快排属于分治算法，最怕的就是 <code>n</code>分成<code>0</code>和<code>n</code>，或 <code>n</code>分成<code>n</code>和<code>0</code>,导致死循环。</p>\n<ol>\n<li><p><strong>以<code>j</code>为划分时，<code>x</code>不能选<code>q[r]</code> (若以<code>i</code>为划分,则<code>x</code>不能选<code>q[l]</code>)</strong></p>\n<p>​    假设 <code>x = q[r]</code></p>\n<p>​    关键句子<code>quick_sort(q, l, j), quick_sort(q, j + 1, r);</code></p>\n<p>​    由于j的最小值是l,所以<code>q[j+1..r]</code>不会造成无限划分</p>\n<p>​    但<code>q[l..j]（即quick_sort(q, l, j)）</code>却可能造成无限划分，因为j可能为r</p>\n<p>​    举例来说，若<code>x</code>选为<code>q[r]</code>，数组中<code>q[l..r-1] &lt; x</code>,</p>\n<p>​    那么这一轮循环结束时<code>i = r, j = r</code>，显然会造成无限划分</p>\n</li>\n<li><p><strong>do i++; while(q[i] &lt; x)和do j–; while(q[j] &gt; x)不能用q[i] &lt;= x 和 q[j] &gt;= x</strong></p>\n<p>​    假设<code>q[l..r]</code>全相等</p>\n<p>​    则执行完<code>do i++; while(q[i] &lt;= x);</code>之后，<code>i</code>会自增到<code>r+1</code></p>\n<p>​    然后继续执行<code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)</p>\n<p>​    并且如果之后的<code>q[i] &lt;= x</code> (此时i &gt; r) 条件也不幸成立，</p>\n<p>​    就会造成一直循环下去(亲身实验)，造成内存超限(Memory Limit Exceeded)</p>\n</li>\n<li><p><strong><code>if(i &lt; j) swap(q[i], q[j])</code>能否使用 <code>i &lt;= j</code></strong></p>\n<p>​    可以使用<code>if(i &lt;= j) swap(q[i], q[j])</code>;</p>\n<p>​    因为 <code>i = j</code> 时，交换一下<code>q[i],q[j]</code> 无影响，因为马上就会跳出循环了</p>\n</li>\n<li><p><strong>最后一句能否改用quick_sort(q, l, j-1), quick_sort(q, j, r)作为划分(用i做划分时也是同样的道理,)</strong></p>\n<p>​    不能</p>\n<p>​    根据之前的证明，最后一轮循环可以得到这些结论</p>\n<p>​    <code>j &lt;= i</code> 和 <code>q[l..i-1] &lt;= x</code>, <code>q[i] &gt;= x</code> 和 <code>q[j+1..r] &gt;= x</code>, <code>q[j] &lt;= x</code></p>\n<p>​    所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p>\n<p>​    但<code>quick_sort(q, j, r)</code>中的<code>q[j]</code> 却是 <code>q[j] &lt;= x</code>，这不符合快排的要求</p>\n<p>​    另外一点，注意<code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code>可能会造成无线划分</p>\n<p>​    当x选为q[l]时会造成无限划分，报错为(MLE),</p>\n<p>​    如果手动改为 <code>x = q[r]</code>,可以避免无限划分</p>\n<p>​    但是上面所说的<code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 WA (Wrong Answer)</p>\n</li>\n<li><p><strong><code>j</code>的取值范围为<code>[l..r-1]</code></strong></p>\n<p>​    <strong>证明:</strong></p>\n<p>​    假设 <code>j</code> 最终的值为 <code>r</code> ,说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p>\n<p>​    说明<code>q[r] &lt;= x</code> (因为要跳出do-while循环)</p>\n<p>​    说明 <code>i &gt;= r(while循环的结束条件)</code>, i 为 r 或 r + 1(必不可能成立)</p>\n<p>​    说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>,</p>\n<p>​    得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论,但这与 <code>x = q[l + r &gt;&gt; 1]</code>矛盾</p>\n<p>​    反证法得出 <code>j &lt; r</code></p>\n<p>​    假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> ,矛盾</p>\n<p>​    反证法得出 <code>j &gt;= l</code></p>\n</li>\n</ol>\n<p><strong>所以 <code>j</code>的取值范围为<code>[l..r-1]</code>,不会造成无限划分和数组越界。</strong></p>\n<h2 id=\"五、希尔排序（Shell-Sort）\"><a href=\"#五、希尔排序（Shell-Sort）\" class=\"headerlink\" title=\"五、希尔排序（Shell Sort）\"></a>五、希尔排序（Shell Sort）</h2><h3 id=\"1、原理-4\"><a href=\"#1、原理-4\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    希尔排序又叫<strong>缩小增量排序</strong>，也是一种插入排序方法（通常快于直接插入法），具体做法是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序；</p>\n<h3 id=\"2、步骤-4\"><a href=\"#2、步骤-4\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…</li>\n<li>2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</li>\n</ul>\n<p>对于增量的选定无一定论，但最后一个增量必须等于1，也就是说，每趟后一个增量是前一个增量的1/2。</p>\n<h3 id=\"3、动画演示-4\"><a href=\"#3、动画演示-4\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"5.gif\" alt></p>\n<h3 id=\"4、代码实现-4\"><a href=\"#4、代码实现-4\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void shell_sort()\n{\n    for (int gap = n &gt;&gt; 1; gap; gap &gt;&gt;= 1)\n    {\n        for (int i = gap; i &lt; n; i ++ )\n        {\n            int x = a[i];\n            int j;\n            for (j = i; j &gt;= gap &amp;&amp; a[j-gap] &gt; x; j -= gap)\n                a[j] = a[j-gap];\n            a[j] = x;\n        }\n    }\n}\n</code></pre>\n<h2 id=\"六、归并排序（Merge-Sort）\"><a href=\"#六、归并排序（Merge-Sort）\" class=\"headerlink\" title=\"六、归并排序（Merge Sort）\"></a>六、归并排序（Merge Sort）</h2><h3 id=\"1、原理-5\"><a href=\"#1、原理-5\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>   归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>\n<h3 id=\"2、步骤-5\"><a href=\"#2、步骤-5\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列</li>\n</ul>\n<h3 id=\"3、动画演示-5\"><a href=\"#3、动画演示-5\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"6.gif\" alt></p>\n<h3 id=\"4、代码实现-5\"><a href=\"#4、代码实现-5\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void merge_sort(int q[], int l, int r)\n{\n    //递归的终止情况\n    if(l &gt;= r) return;\n\n    //第一步：分成子问题\n    int mid = l + r &gt;&gt; 1;\n\n    //第二步：递归处理子问题\n    merge_sort(q, l, mid ), merge_sort(q, mid + 1, r);\n\n    //第三步：合并子问题\n    int k = 0, i = l, j = mid + 1, tmp[r - l + 1];\n    while(i &lt;= mid &amp;&amp; j &lt;= r)\n        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    while(i &lt;= mid) tmp[k++] = q[i++];\n    while(j &lt;= r) tmp[k++] = q[j++];\n\n    for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];\n}</code></pre>\n<p><strong>tmp 保存的是 q[l..mid] , q[mid+1..r] 中从小到大排序的所有数</strong><br>    证明(第一个 <code>while</code> 循环)<br>    循环不变式: <code>tmp[0..k-1]</code> 保存上述俩数组中从小到大排序的最小 <code>k</code> 个数</p>\n<p><strong>1.初始</strong></p>\n<p>​    <code>k = 0, tmp[0..k-1]</code> 为空，显然成立</p>\n<p><strong>2.保持</strong></p>\n<p>​    假设某轮循环开始之前，循环不变式成立</p>\n<p>​    若 <code>q[i] &lt;= q[j], 则 tmp[k] = q[i]</code></p>\n<p>​    其中 <code>q[i] &lt;= q[i+1..mid], q[i] &lt;= q[j] &lt;= q[j+1..r]</code></p>\n<p>​    ∴ q[i] 是剩下的所有数中最小的一个</p>\n<p>​    当 q[i] &gt; q[j] 时，同理可以得到 <code>tmp[k] = q[j]</code> 是剩下数中最小的一个</p>\n<p>​    ∴ <code>tmp[k]</code> 是剩下数中最小的一个</p>\n<p>​    ∴ <code>k</code>自增之后，下轮循环开始之前，<code>tmp[0..k-1]</code>保存从小到大排序的最小k个数</p>\n<p><strong>3.终止</strong></p>\n<p>​    <code>i &gt; mid</code> 或 <code>j &gt; r</code></p>\n<p>​    则 <code>q[l..mid]</code> 和 <code>q[mid+1..r]</code> 其中一个数组的数都已遍历</p>\n<p>​    <code>tmp[0..k-1]</code>保存从小到大排序的最小k个数</p>\n<h2 id=\"七、计数排序（Counting-Sort）\"><a href=\"#七、计数排序（Counting-Sort）\" class=\"headerlink\" title=\"七、计数排序（Counting Sort）\"></a>七、计数排序（Counting Sort）</h2><h3 id=\"1、原理-6\"><a href=\"#1、原理-6\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>​    计数排序，又叫非比较排序，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数</p>\n<h3 id=\"2、步骤-6\"><a href=\"#2、步骤-6\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>\n</ul>\n<h3 id=\"3、动画演示-6\"><a href=\"#3、动画演示-6\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"7.gif\" alt></p>\n<h3 id=\"4、代码实现-6\"><a href=\"#4、代码实现-6\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void counting_sort()\n{\n    int sorted[N];\n    int maxv = a[0];\n    for (int i = 1; i &lt; n; i ++ )\n        if (maxv &lt; a[i])\n            maxv = a[i];\n    int count[maxv+1];\n    for (int i = 0; i &lt; n; i ++ ) count[a[i]] ++ ;\n    for (int i = 1; i &lt;= maxv; i ++ ) count[i] += count[i-1];\n    for (int i = n-1; i &gt;= 0; i -- )\n    {\n        sorted[count[a[i]]-1] = a[i];\n        count[a[i]] -- ;\n    }\n    for (int i = 0; i &lt; n; i ++ ) a[i] = sorted[i];\n}</code></pre>\n<h2 id=\"八、基数排序（Radix-Sort）\"><a href=\"#八、基数排序（Radix-Sort）\" class=\"headerlink\" title=\"八、基数排序（Radix Sort）\"></a>八、基数排序（Radix Sort）</h2><h3 id=\"1、原理-7\"><a href=\"#1、原理-7\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n<h3 id=\"2、步骤-7\"><a href=\"#2、步骤-7\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点)。</li>\n</ul>\n<h3 id=\"3、动画演示-7\"><a href=\"#3、动画演示-7\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"8.gif\" alt></p>\n<h3 id=\"4、代码实现-7\"><a href=\"#4、代码实现-7\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">int maxbit()\n{\n    int maxv = a[0];\n    for (int i = 1; i &lt; n; i ++ )\n        if (maxv &lt; a[i])\n            maxv = a[i];\n    int cnt = 1;\n    while (maxv &gt;= 10) maxv /= 10, cnt ++ ;\n\n    return cnt;\n}\nvoid radixsort()\n{\n    int t = maxbit();\n    int radix = 1;\n\n    for (int i = 1; i &lt;= t; i ++ )\n    {\n        for (int j = 0; j &lt; 10; j ++ ) count[j] = 0;\n        for (int j = 0; j &lt; n; j ++ )\n        {\n            int k = (a[j] / radix) % 10;\n            count[k] ++ ;\n        }\n        for (int j = 1; j &lt; 10; j ++ ) count[j] += count[j-1];\n        for (int j = n-1; j &gt;= 0; j -- )\n        {\n            int k = (a[j] / radix) % 10;\n            temp[count[k]-1] = a[j];\n            count[k] -- ;\n        }\n        for (int j = 0; j &lt; n; j ++ ) a[j] = temp[j];\n        radix *= 10;\n    }\n\n}\n</code></pre>\n<h2 id=\"九、桶排序（Bucket-Sort）\"><a href=\"#九、桶排序（Bucket-Sort）\" class=\"headerlink\" title=\"九、桶排序（Bucket Sort）\"></a>九、桶排序（Bucket Sort）</h2><h3 id=\"1、原理-8\"><a href=\"#1、原理-8\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p> 遍历原始序列确定最大值 <code>maxval</code> 和最小值 <code>minval</code>，并确定桶的个数 <code>n</code>; 然后，将待排序集合中处于同一个值域的元素存入同一个桶中,在桶内使用各种现有的算法进行排序; 最后按照从小到大的顺序依次收集桶中的每一个元素, 即为最终结果。</p>\n<h3 id=\"2、步骤-8\"><a href=\"#2、步骤-8\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>1.设置一个定量的数组当作空桶；</li>\n<li>2.遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>3.对每个不是空的桶进行排序；</li>\n<li>4.从不是空的桶里把排好序的数据拼接起来。 </li>\n</ul>\n<p>桶排序是一种用空间换取时间的排序。桶的个数和大小都是我们人为设置的，而每个桶又要避免空桶的情况，所以我们在使用桶排序的时候即需要对待排序数列要求偏均匀，又要要求桶的设计兼顾效率和空间；数要相对均匀分布，桶的个数也要合理设计。在设计桶排序时，需要知道输入数据的上界和下界。</p>\n<h3 id=\"3、动画演示-8\"><a href=\"#3、动画演示-8\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"9.gif\" alt></p>\n<p><font color=\"red\" size=\"4\"><code>（动图来源于@五分钟学算法，侵删）</code></font></p>\n<h3 id=\"4、代码实现-8\"><a href=\"#4、代码实现-8\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">//桶排序 \nvoid BucketSort(int a[], int n){\n    int minval = a[0], maxval = a[0];\n    for(int i = 0; i &lt; n; i ++){//寻找原序列数组元素的最大值和最小值 \n        minval = min(minval, a[i]);\n        maxval = max(maxval, a[i]);\n    }\n\n    int bnum = 10;//桶中元素个数 \n    int m = (maxval - minval) / bnum + 1;//桶的个数 \n    vector&lt; vector&lt;int&gt; &gt; bucket(m);\n\n    //收集,将元素入相应的桶中. 减偏移量是为了将元素映射到更小的区间内,省内存 \n    for(int i = 0; i &lt; n; i ++) bucket[(a[i] - minval) / bnum].push_back(a[i]);\n\n    //将桶内元素排序 \n    for(int i = 0; i &lt; m; i ++) sort(bucket.begin(), bucket.end());\n\n    //收集, 将各个桶中的元素收集到一起 \n    for(int i = 0, k = 0; i &lt; m; i ++){\n        for(int j = 0; j &lt; bucket[i].size(); j ++){\n            data[k ++] = bucket[i][j];\n        }\n    }\n}</code></pre>\n<h2 id=\"十、堆排序（Heap-Sort）\"><a href=\"#十、堆排序（Heap-Sort）\" class=\"headerlink\" title=\"十、堆排序（Heap Sort）\"></a>十、堆排序（Heap Sort）</h2><h3 id=\"1、原理-9\"><a href=\"#1、原理-9\" class=\"headerlink\" title=\"1、原理\"></a>1、原理</h3><p>先看看堆的特性：</p>\n<blockquote>\n<p>堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。</p>\n</blockquote>\n<p><img src=\"12.png\" alt></p>\n<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<h3 id=\"2、步骤-9\"><a href=\"#2、步骤-9\" class=\"headerlink\" title=\"2、步骤\"></a>2、步骤</h3><ul>\n<li>1.构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；</li>\n<li>2.此时的堆顶元素，为最大或者最小元素；</li>\n<li>3.把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；</li>\n<li>4.此时堆顶元素为第二大元素；</li>\n<li>5.重复以上步骤，直到堆变空。</li>\n</ul>\n<h3 id=\"3、动画演示-9\"><a href=\"#3、动画演示-9\" class=\"headerlink\" title=\"3、动画演示\"></a>3、动画演示</h3><p><img src=\"qSort/10.gif\" alt></p>\n<h3 id=\"4、代码实现-9\"><a href=\"#4、代码实现-9\" class=\"headerlink\" title=\"4、代码实现\"></a>4、代码实现</h3><pre><code class=\"cpp\">void down(int u)\n{\n    int t = u;\n    if (u&lt;&lt;1 &lt;= n &amp;&amp; h[u&lt;&lt;1] &lt; h[t]) t = u&lt;&lt;1;\n    if ((u&lt;&lt;1|1) &lt;= n &amp;&amp; h[u&lt;&lt;1|1] &lt; h[t]) t = u&lt;&lt;1|1;\n    if (u != t)\n    {\n        swap(h[u], h[t]);\n        down(t);\n    }\n}\n\nint main()\n{\n    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; h[i];\n    for (int i = n/2; i; i -- ) down(i);\n    while (true)\n    {\n        if (!n) break;\n        cout &lt;&lt; h[1] &lt;&lt; &#39; &#39;;\n        h[1] = h[n];\n        n -- ;\n        down(1);\n    }\n    return 0;\n}</code></pre>\n","path":"qsort.html","permalink":"https://www.yshawlon.cn/qsort.html","tags":[{"name":"排序","_id":"clq6dy4b90054ikw07hiiu245","slug":"排序","path":"tags/排序/","permalink":"https://www.yshawlon.cn/tags/排序/","length":2}],"categories":[{"name":"算法","_id":"clq6dy491001eikw044hl9f0q","slug":"算法","path":"categories/算法/","permalink":"https://www.yshawlon.cn/categories/算法/","length":5},{"name":"C++","_id":"clq6dy4an003gikw0dm68thq5","slug":"算法/C","path":"categories/算法/C/","permalink":"https://www.yshawlon.cn/categories/算法/C/","length":1}],"prev":{"title":"高级数据结构-AC自动机总结","date":"2022-02-01T14:23:13.000Z","summary":null,"slug":"高级数据结构-AC自动机总结","published":true,"updated":"2022-04-01T14:59:48.398Z","_id":"clq6dy4au003tikw09ffhenpd","layout":"post","photos":[],"link":"","excerpt":"","path":"gao-ji-shu-ju-jie-gou-ac-zi-dong-ji-zong-jie.html","permalink":"https://www.yshawlon.cn/gao-ji-shu-ju-jie-gou-ac-zi-dong-ji-zong-jie.html","__post":true},"next":{"title":"使用Java Arrays类进行排序","date":"2021-10-21T06:02:24.000Z","summary":"C语言有qsort()函数，C++有sort()函数，java语言有Arrays类（与Array区分）","slug":"使用Java-Arrays类进行排序","published":true,"updated":"2021-10-21T06:58:21.958Z","_id":"clq6dy4a7002likw040vcio4s","layout":"post","photos":[],"link":"","excerpt":"","path":"shi-yong-java-arrays-lei-jin-xing-pai-xu.html","permalink":"https://www.yshawlon.cn/shi-yong-java-arrays-lei-jin-xing-pai-xu.html","__post":true},"__post":true}