{"title":"如何实现一个公平的洗牌算法","date":"2021-01-10T05:02:38.000Z","toc":true,"summary":"每一个元素都能独立等概率的出现在每一个位置，每一个位置都能独立等概率的放置每个元素","source":"_posts/如何实现一个公平的洗牌算法.md","raw":"---\ntitle: 如何实现一个公平的洗牌算法\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-01-10 13:02:38\npassword:\nsummary: 每一个元素都能独立等概率的出现在每一个位置，每一个位置都能独立等概率的放置每个元素\ntags:\n- 洗牌\n- 随机\ncategories:\n- 算法\n---\n\n\n\n\n\n### 问题描述：\n\n设计一个公平的洗牌算法\n\n就像打牌的时候一样，我们洗牌之后并不知道牌的顺序变成什么样，当然，前提是这个牌洗转了。正如这个问题，核心的点是**公平**，怎样才叫公平呢？\n\n### 暴力解法：\n\nn个数的全排列有n！个，那么随机拿出这里面任意一个结果也算公平。但是它的时间复杂度是O(n!)！原地爆炸boom~boom~\n\n\n\n### Knuth 洗牌算法:\n\n至于Knuth何许人也，感兴趣的可以去查一下。微软是 IT 界老大的年代，比尔盖茨直接说，如果你看完了Knuth写的《The Art of Computer Programming》第一卷本，请给我发简历。\n\n生成的排列中，也就是我们的结果，**每一个元素都能独立等概率的出现在每一个位置**。或者反过来，**每一个位置都能独立等概率的放置每个元素**。\n\n```cpp\nfor(int i = n - 1; i >= 0 ; i -- )\n    swap(arr[i], arr[rand(0, i)]) // rand(0, i) 生成 [0, i] 之间的随机整数\n```\n\n很好理解，i从后向前，每次生成0~i之间的一个随机数，然后将i和这个随机数交换， swap(arr[i], arr[rand(0, i)]) 看出，i可以跟自己交换。（**假想rand()无偏**）\n\n\n\n####  为什么公平呢？\n\n**对于生成的排列，每一个元素都能等概率的出现在每一个位置**\n\n**示例：**现有6个数从小到大排列：1 2 3 4 5 6\n\n- 首先随机选择一个数和6进行交换，假设是3\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/洗牌算法/1.png)\n\n因为可以和自己交换，我们可以知道3出现在最后的概率是1/6\n\n- 选择到5，假设和2交换\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/洗牌算法/2.png)\n\n同样的第一轮2没有被选中，那么它逃掉的概率是5/6，第二轮被选中的概率是1/5，那么它被选中的概论等于5/6x1/5=1/6\n\n- 到4，假设和1交换\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/洗牌算法/3.png)\n\n1被选中的概率等于5/6x4/5x1/4=1/6\n\n\n\n**看到这里，应该知道后面的概率也是1/6了，所以这个算法是公平的，可以自己去实验一下。最后这个算法的时间复杂度是O(n)**","slug":"如何实现一个公平的洗牌算法","published":true,"updated":"2021-02-19T15:33:42.494Z","_id":"clq6dy4ag002zikw0t95tsm48","comments":true,"layout":"post","photos":[],"link":"","html":"<h3 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h3><p>设计一个公平的洗牌算法</p>\n<p>就像打牌的时候一样，我们洗牌之后并不知道牌的顺序变成什么样，当然，前提是这个牌洗转了。正如这个问题，核心的点是<strong>公平</strong>，怎样才叫公平呢？</p>\n<h3 id=\"暴力解法：\"><a href=\"#暴力解法：\" class=\"headerlink\" title=\"暴力解法：\"></a>暴力解法：</h3><p>n个数的全排列有n！个，那么随机拿出这里面任意一个结果也算公平。但是它的时间复杂度是O(n!)！原地爆炸boom<del>boom</del></p>\n<h3 id=\"Knuth-洗牌算法\"><a href=\"#Knuth-洗牌算法\" class=\"headerlink\" title=\"Knuth 洗牌算法:\"></a>Knuth 洗牌算法:</h3><p>至于Knuth何许人也，感兴趣的可以去查一下。微软是 IT 界老大的年代，比尔盖茨直接说，如果你看完了Knuth写的《The Art of Computer Programming》第一卷本，请给我发简历。</p>\n<p>生成的排列中，也就是我们的结果，<strong>每一个元素都能独立等概率的出现在每一个位置</strong>。或者反过来，<strong>每一个位置都能独立等概率的放置每个元素</strong>。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">--</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// rand(0, i) 生成 [0, i] 之间的随机整数</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>很好理解，i从后向前，每次生成0~i之间的一个随机数，然后将i和这个随机数交换， swap(arr[i], arr[rand(0, i)]) 看出，i可以跟自己交换。（<strong>假想rand()无偏</strong>）</p>\n<h4 id=\"为什么公平呢？\"><a href=\"#为什么公平呢？\" class=\"headerlink\" title=\"为什么公平呢？\"></a>为什么公平呢？</h4><p><strong>对于生成的排列，每一个元素都能等概率的出现在每一个位置</strong></p>\n<p><strong>示例：</strong>现有6个数从小到大排列：1 2 3 4 5 6</p>\n<ul>\n<li>首先随机选择一个数和6进行交换，假设是3</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/1.png\" alt></p>\n<p>因为可以和自己交换，我们可以知道3出现在最后的概率是1/6</p>\n<ul>\n<li>选择到5，假设和2交换</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/2.png\" alt></p>\n<p>同样的第一轮2没有被选中，那么它逃掉的概率是5/6，第二轮被选中的概率是1/5，那么它被选中的概论等于5/6x1/5=1/6</p>\n<ul>\n<li>到4，假设和1交换</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/3.png\" alt></p>\n<p>1被选中的概率等于5/6x4/5x1/4=1/6</p>\n<p><strong>看到这里，应该知道后面的概率也是1/6了，所以这个算法是公平的，可以自己去实验一下。最后这个算法的时间复杂度是O(n)</strong></p>\n","excerpt":"","more":"<h3 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h3><p>设计一个公平的洗牌算法</p>\n<p>就像打牌的时候一样，我们洗牌之后并不知道牌的顺序变成什么样，当然，前提是这个牌洗转了。正如这个问题，核心的点是<strong>公平</strong>，怎样才叫公平呢？</p>\n<h3 id=\"暴力解法：\"><a href=\"#暴力解法：\" class=\"headerlink\" title=\"暴力解法：\"></a>暴力解法：</h3><p>n个数的全排列有n！个，那么随机拿出这里面任意一个结果也算公平。但是它的时间复杂度是O(n!)！原地爆炸boom<del>boom</del></p>\n<h3 id=\"Knuth-洗牌算法\"><a href=\"#Knuth-洗牌算法\" class=\"headerlink\" title=\"Knuth 洗牌算法:\"></a>Knuth 洗牌算法:</h3><p>至于Knuth何许人也，感兴趣的可以去查一下。微软是 IT 界老大的年代，比尔盖茨直接说，如果你看完了Knuth写的《The Art of Computer Programming》第一卷本，请给我发简历。</p>\n<p>生成的排列中，也就是我们的结果，<strong>每一个元素都能独立等概率的出现在每一个位置</strong>。或者反过来，<strong>每一个位置都能独立等概率的放置每个元素</strong>。</p>\n<pre><code class=\"cpp\">for(int i = n - 1; i &gt;= 0 ; i -- )\n    swap(arr[i], arr[rand(0, i)]) // rand(0, i) 生成 [0, i] 之间的随机整数</code></pre>\n<p>很好理解，i从后向前，每次生成0~i之间的一个随机数，然后将i和这个随机数交换， swap(arr[i], arr[rand(0, i)]) 看出，i可以跟自己交换。（<strong>假想rand()无偏</strong>）</p>\n<h4 id=\"为什么公平呢？\"><a href=\"#为什么公平呢？\" class=\"headerlink\" title=\"为什么公平呢？\"></a>为什么公平呢？</h4><p><strong>对于生成的排列，每一个元素都能等概率的出现在每一个位置</strong></p>\n<p><strong>示例：</strong>现有6个数从小到大排列：1 2 3 4 5 6</p>\n<ul>\n<li>首先随机选择一个数和6进行交换，假设是3</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/1.png\" alt></p>\n<p>因为可以和自己交换，我们可以知道3出现在最后的概率是1/6</p>\n<ul>\n<li>选择到5，假设和2交换</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/2.png\" alt></p>\n<p>同样的第一轮2没有被选中，那么它逃掉的概率是5/6，第二轮被选中的概率是1/5，那么它被选中的概论等于5/6x1/5=1/6</p>\n<ul>\n<li>到4，假设和1交换</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/3.png\" alt></p>\n<p>1被选中的概率等于5/6x4/5x1/4=1/6</p>\n<p><strong>看到这里，应该知道后面的概率也是1/6了，所以这个算法是公平的，可以自己去实验一下。最后这个算法的时间复杂度是O(n)</strong></p>\n","path":"ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html","permalink":"https://www.yshawlon.cn/ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html","tags":[{"name":"洗牌","_id":"clq6dy4bf005mikw01pduogji","slug":"洗牌","path":"tags/洗牌/","permalink":"https://www.yshawlon.cn/tags/洗牌/","length":1},{"name":"随机","_id":"clq6dy4bg005pikw0y7fc6kbm","slug":"随机","path":"tags/随机/","permalink":"https://www.yshawlon.cn/tags/随机/","length":1}],"categories":[{"name":"算法","_id":"clq6dy491001eikw044hl9f0q","slug":"算法","path":"categories/算法/","permalink":"https://www.yshawlon.cn/categories/算法/","length":5}],"prev":{"title":"用具体数学解决约瑟夫环问题","date":"2021-01-10T05:03:34.000Z","summary":"有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？","slug":"用具体数学解决约瑟夫环问题","published":true,"updated":"2021-01-13T08:18:22.955Z","_id":"clq6dy4aq003likw0gs1n6h0p","layout":"post","photos":[],"link":"","excerpt":"","path":"yong-ju-ti-shu-xue-jie-jue-yue-se-fu-huan-wen-ti.html","permalink":"https://www.yshawlon.cn/yong-ju-ti-shu-xue-jie-jue-yue-se-fu-huan-wen-ti.html","__post":true},"next":{"title":"寻找多数元素（主元素）问题","date":"2021-01-06T16:31:05.000Z","summary":"给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数","slug":"寻找多数元素（主元素）问题","published":true,"updated":"2021-03-25T06:51:37.432Z","_id":"clq6dy4al003aikw0necd4gos","layout":"post","photos":[],"link":"","excerpt":"","path":"xun-zhao-duo-shu-yuan-su-zhu-yuan-su-wen-ti.html","permalink":"https://www.yshawlon.cn/xun-zhao-duo-shu-yuan-su-zhu-yuan-su-wen-ti.html","__post":true},"__post":true}