{"title":"暑假LeetCode刷题集合（上）","date":"2021-06-27T13:12:16.000Z","toc":true,"summary":"练习一下算法，由于单个文章新建太麻烦了，索性把一个月的放在一起。","source":"_posts/暑假LeetCode刷题集合（上）.md","raw":"---\ntitle: 暑假LeetCode刷题集合（上）\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-06-27 21:12:16\npassword:\nsummary: 练习一下算法，由于单个文章新建太麻烦了，索性把一个月的放在一起。\ntags:\n- LeetCode\ncategories:\n- 每日一题\n---\n\n**最近决定巩固一下算法，开始刷leetcode每日一题，具体刷多久还不知道，刚开始是有点吃力，慢慢来。**\n\n## 【Day01】938.二叉搜索树的范围和\n\n**题目：**\n\n给定二叉搜索树的根结点 `root`，返回值位于范围 *`[low, high]`* 之间的所有结点的值的和。\n\n**示例1：**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)\n\n```\n输入：root = [10,5,15,3,7,null,18], low = 7, high = 15\n输出：32\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg)\n\n```\n输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n输出：23\n```\n\n**提示：**\n\n- 树中节点数目在范围 [1, 2 * 104] 内\n- 1 <= Node.val <= 105\n- 1 <= low <= high <= 105\n- 所有 Node.val 互不相同\n\n\n\n**题解：**\n\n**递归**\n\n```c++\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (!root) return 0;\n        int sum = 0;\n        sum += rangeSumBST(root->left, low, high);\n        if (root->val >= low && root->val <= high) sum += root->val;\n        sum += rangeSumBST(root->right, low, high);\n        return sum;\n    }\n};\n```\n\n\n\n\n\n**非递归**\n\n```c++\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (!root) return 0;\n        queue<TreeNode*> q;\n        TreeNode* p = root;\n        int sum = 0;\n        while (p || q.size()) {\n            while (p) {\n                q.push(p);\n                p = p->left;\n            }\n            if (q.size()) {\n                p = q.front();\n                q.pop();\n                if (p->val >= low && p->val <= high) {\n                    sum += p->val;\n                }\n                p = p->right;       \n            }    \n        }\n        return sum;\n    }\n};\n```\n\n\n\n## 【Day02】633.平方数之和\n\n**题目：**\n\n给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。\n\n**示例 1：**\n\n```\n输入：c = 5\n输出：true\n解释：1 * 1 + 2 * 2 = 5\n```\n\n**示例 2：**\n\n```\n输入：c = 3\n输出：false\n```\n\n**示例 3：**\n\n```\n输入：c = 4\n输出：true\n```\n\n**示例 4：**\n\n```\n输入：c = 2\n输出：true\n```\n\n**示例 5：**\n\n```\n输入：c = 1\n输出：true\n```\n\n**枚举**\n\n对 a 从 0 开始到 n√n 枚举，然后判断是否存在 b。\n\n\n```c++\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        for (int i = 0; (long long)(i) * i <= c; i++) {\n            int j = sqrt(c - i * i);\n            if (i * i + j * j == c)\n                return true;\n        }\n        return false;\n    }\n};\n```\n\n\n\n**预处理+查询**\n\n如果存在符合条件的a，b，那么a和b一定在1和sqrt(c)之间。\n\n```c++\nclass Solution {\npublic:\n    typedef unsigned long long ULL;\n    bool judgeSquareSum(int c) {\n        if (c == 0) return true;\n        unordered_map<ULL, ULL> um;\n        for (int i = 1; i <= sqrt(c); i++) {\n            um[i*i]++;\n        }\n\n        for (int i = 1; i <= sqrt(c); i++) {\n            if (i*i == c || um.count(c - i*i)) return true;\n        }\n        return false;\n    }\n};\n```\n\n\n\n**双指针**\n\n```c++\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        int j = sqrt(c);\n        int i = 0;\n        while (i <= j) {\n            if (i*i > c - j*j) {\n                j--;\n            } else if (i*i < c - j*j) {\n                i++;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n\n\n## 【Day03】403.青蛙过河\n\n### [403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/)\n\n**题目描述：**\n\n一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。\n\n给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。\n\n开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。\n\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n\n \n\n  **示例 1：**\n\n```\n输入：stones = [0,1,3,5,6,8,12,17]\n输出：true\n解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。\n```\n\n\n\n**示例 2：**\n\n```\n输入：stones = [0,1,2,3,4,8,9,11]\n输出：false\n解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。\n```\n\n**提示：**\n\n- 2 <= stones.length <= 2000\n- 0 <= stones[i] <= 231 - 1\n- stones[0] == 0\n\n**题解：**\n\n**递归:**\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> um;\n    bool canCross(vector<int>& stones) {\n        \n        for (int i = 0; i < stones.size(); i++) {\n            um[stones[i]] = i;  // key:石子值 value是第几块石子\n        }\n        if (!um.count(1)) return false;\n        return dfs(stones, stones.size(), 1, 1);\n    }\n    bool dfs(vector<int>& stones, int n, int cur, int k) {\n        if (cur == n - 1) return true;\n        for (int i = -1; i <= 1; i++) {\n            if (k + i == 0) continue;\n            int next = stones[cur] + k + i;\n            if (um.count(next)) { // 存在\n                bool choose = dfs(stones, n, um[next], k + i);\n                if (choose) return true;\n            }\n        }\n        return false;\n    }\n    \n};\n```\n\n**dfs记忆化搜索:**\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> um;\n    vector<vector<int>> memo;\n    bool canCross(vector<int>& stones) {\n        \n        for (int i = 0; i < stones.size(); i++) {\n            um[stones[i]] = i;  // key:石子值 value是第几块石子\n        }\n        if (!um.count(1)) return false;\n        memo = vector<vector<int>>(stones.size(), vector<int>(stones.size(), -1));\n        return dfs(stones, stones.size(), 1, 1);\n    }\n    bool dfs(vector<int>& stones, int n, int cur, int k) {\n        if (memo[cur][k] != -1) return memo[cur][k];\n        if (cur == n - 1) return memo[cur][k] = true;\n        for (int i = -1; i <= 1; i++) {\n            if (k + i == 0) continue;  // 原地跳过\n            int next = stones[cur] + k + i;\n            if (um.count(next)) { // 存在\n                bool choose = dfs(stones, n, um[next], k + i);\n                if (choose) return memo[cur][k] = true;\n            }\n        }\n        return memo[cur][k] = false;\n    }\n    \n};\n```\n\n**动态规划：**\n\n```c++\nclass Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        int n = stones.size();\n        if (stones[1] != 1) return false;\n        vector<vector<bool>> dp(n, vector<bool>(n));\n        // dp[i][k] 表示在第i个位置且跳k个单位到第i块石子。\n        dp[1][1] = true;\n        for (int i = 2; i < n; i++) {\n            for (int j = 1; j < i; j++) {\n                int k = stones[i] - stones[j];\n                if (k > j + 1) continue;\n                // 因为题目要求 青蛙第一次只能跳1步，那么第二次至多跳2步，以此类推，青蛙在第i块（i从0开始）石头上至多只能跳i+1步。在第j块石头上至多只能跳 j+1 步 ，如果k > j+1，说明石头 i 隔石头 j 太远了，远到不满足题目的隐藏规则，所以青蛙必定跳不过去。\n                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k+1];\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            if (dp[n-1][i]) return true;\n        }        \n        return false;\n    }\n};\n```\n\n**另一种动态规划:**\n\n```c++\nclass Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        // dp[i][j] 表示 第 i 个石头是否可以跳 j 步\n        int n = stones.size();\n        vector<vector<bool>> dp(n, vector<bool>(n));\n        dp[0][1] = true;\n        for (int i = 1; i < n; i++) {\n            bool flag = false;\n            for (int j = i - 1; j >= 0; j--) {\n                int k = stones[i] - stones[j];\n                if (k > i) break;\n                if (dp[j][k]) {\n                    dp[i][k - 1] = dp[i][k] = dp[i][k + 1] = true;\n                    flag = true;\n                }\n            }\n            if (i == n - 1 && !flag) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n\n\n## 【Day04】137.只出现一次的数字II\n\n#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)\n\n给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。\n\n **示例1：**\n\n```\n输入：nums = [2,2,3,2]\n输出：3\n```\n\n**示例2：**\n\n```\n输入：nums = [0,1,0,1,0,1,99]\n输出：99\n```\n\n**提示：**\n\n- 1 <= nums.length <= 3 * 104\n- -231 <= nums[i] <= 231 - 1\n- nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次\n\n\n\n**题解：**\n\n **有限状态自动机：**\n\n\n\n使用二进制表示每个元素，对应二进制位的1相加，最后相加对3取余\n\n对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0,1,2 。由于二进制只能表示 0, 10,1 ，因此需要使用两个二进制位来表示 3 个状态。设此两位分别为 one，two.\n\n**计算 one方法：**\n\n设当前状态为 one ，two 此时输入二进制位 nn 。如下图所示，通过对状态表的情况拆分，可推出 one的计算方法为：\n\n```\nif two == 0:\n  if n == 0:\n    one = one\n  if n == 1:\n    one = ~one\nif two == 1:\n    one = 0\n```\n\n\n引入 异或运算 ，可将以上拆分简化为：\n\n```\nif two == 0:\n    one = one ^ n\nif two == 1:\n    one = 0\n```\n\n\n引入 与运算 ，可继续简化为：\n\n```\none = one ^ n & ~two\n```\n\n同理：\n\n```\ntwo = two ^ n & ~one\n```\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int two = 0, one = 0;\n        for (auto x: nums) {\n            one = (one ^ x) & ~two;\n            two = (two ^ x) & ~one;\n        }\n        return one;\n    }\n};\n```\n\n\n\n**哈希表：**\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int, int> um;\n        for (auto x : nums) {\n            um[x]++;\n        }\n        \n        for (auto x : um) {\n            if (x.second == 1) return x.first;\n        }\n        return -1;\n    }\n};\n```\n\n\n\n## 【Day05】690.员工的重要性\n\n#### [690. 员工的重要性](https://leetcode-cn.com/problems/employee-importance/)\n\n给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。\n\n比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。\n\n现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。\n\n \n\n**示例：**\n\n```\n输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出：11\n解释：\n员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。\n```\n\n**提示：**\n\n- 一个员工最多有一个 直系 领导，但是可以有多个 直系 下属\n- 员工数量不超过 2000 。\n\n**题解：**\n\n今天的题不是很难，直接遍历所有节点相加就行了，使用哈希表将id指向映射到指针，遍历一遍。\n\n**dfs**\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, Employee*> hash;\n\n    int getImportance(vector<Employee*> employees, int id) {\n        for (auto& p: employees) hash[p->id] = p;\n        return dfs(id);\n    }\n\n    int dfs(int id) {\n        auto p = hash[id];\n        int res = p->importance;\n        for (auto son: p->subordinates)\n            res += dfs(son);\n        return res;\n    }\n};\n\n```\n\n\n\n## 【Day06】554.砖墙\n\n#### [554. 砖墙](https://leetcode-cn.com/problems/brick-wall/)\n\n你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg)\n\n```\n输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：wall = [[1],[1],[1]]\n输出：3\n```\n\n**提示：**\n\n- n == wall.length\n- 1 <= n <= 104\n- 1 <= wall[i].length <= 104\n- 1 <= sum(wall[i].length) <= 2 * 104\n- 对于每一行 i ，sum(wall[i]) 应当是相同的\n- 1 <= wall[i][j] <= 231 - 1\n\n\n\n**题解：**\n\n**贪心，哈希表**\n\n显然最优的线一定是沿某个块砖的边缘穿过的。\n统计每一行的砖可以从左到右可以构成的长度值，用 unordered_map 哈希表统计长度值出现的次数。出现次数最多的值就应该是这条线所在的位置。\n\n\n\n```c++\nclass Solution {\npublic:\n    int leastBricks(vector<vector<int>>& wall) {\n        unordered_map<int, int> cnt;\n        for (auto& line: wall) {\n            for (int i = 0, s = 0; i + 1 < line.size(); i ++ ) {\n                s += line[i];\n                cnt[s] ++ ;\n            }\n        }\n        int res = 0;\n        for (auto [k, v]: cnt) res = max(res, v);\n        return wall.size() - res;\n    }\n};\n\n```\n\n\n\n\n\n## 【Day07】7.整数反转[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n\n假设环境不允许存储 64 位整数（有符号或无符号）。\n\n**示例 1：**\n\n```\n输入：x = 123\n输出：321\n```\n\n**示例 2：**\n\n```\n输入：x = -123\n输出：-321\n```\n\n**示例 3：**\n\n```\n输入：x = 120\n输出：21\n```\n\n**示例 4：**\n\n```\n输入：x = 0\n输出：0\n```\n\n**提示：**\n\n- -231 <= x <= 231 - 1\n\n**题解：**\n\n**(循环) O(logn)**\n依次从右往左计算出每位数字，然后逆序累加在一个整数中。\n另外，这题有两点需要注意：\n\n- 因为int型整数逆序后可能会溢出，所以我们要用long long记录中间结果；\n\n- 在C++中，负数的取模运算和数学意义上的取模运算不同，结果还是负数，比如 −12%10=−2−12%10=−2，所以我们不需要对负数进行额外处理。\n\n  \n\n时间复杂度分析：一共有 O(logn) 位，对于每一位的计算量是常数级的，所以总时间复杂度是  O(logn)\n\n```c++\nclass Solution {\npublic:\n    int reverse(int x) {\n        int res = 0;\n        while (x) {\n            if (x > 0 && res > (INT_MAX - x % 10) / 10) return 0;\n            if (x < 0 && res < (INT_MIN - x % 10) / 10) return 0;\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        return res;\n    }\n};\n\n```\n\n\n\n## 【Day08】1473.粉刷房子III\n\n#### [1473. 粉刷房子 III](https://leetcode-cn.com/problems/paint-house-iii/)\n\n在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。\n\n我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）\n\n给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：\n\n- houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。\n- cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。\n\n请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。\n\n\n\n\n\n**示例 1：**\n\n```\n输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n输出：9\n解释：房子涂色方案为 [1,2,2,1,1]\n此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。\n涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。\n```\n\n\n**示例 2：**\n\n```\n输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n输出：11\n解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]\n此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。\n给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。\n```\n\n\n**示例 3：**\n\n```\n输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\n输出：5\n```\n\n\n**示例 4：**\n\n```\n输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n输出：-1\n解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。\n```\n\n**提示：**\n\n- m == houses.length == cost.length\n- n == cost[i].length\n- 1 <= m <= 100\n- 1 <= n <= 20\n- 1 <= target <= m\n- 0 <= houses[i] <= n\n- 1 <= cost[i][j] <= 10^4\n\n**题解·：**\n\n很明显的DP\n\n1. 设状态  f(i,j,k) 表示处理了前 i 个房屋，有 j 个社区，最后一个房屋的颜色为 k 的最小花费，其中房屋的有效下标从 1 开始。建立辅助数组 g(i,j,k) 表示同样含义下，最后一个房屋颜色 不是 k 的最小花费。\n\n2. 初始时，f(0,0,k)=g(0,0,k)=0，其余为正无穷或者待定。\n   转移时，分两种情况\n\n3. 如果第 i 个房屋已经有了颜色 c，则有两种选择，上一个房屋颜色为 c 或者不为 c，转移 \n   $$\n   f(i, j, c)=\\min (f(i-1, j, c), g(i-1, j-1, c))\n   $$\n\n4. 如果第 i 个房屋没有颜色，则枚举一个颜色 k，然后同样根据上一个房屋的颜色，转移 \n   $$\n   f(i, j, k)=\\min (f(i-1, j, k), g(i-1, j-1, k))+\\operatorname{cost}(i, k-1)_{\\text {。 }}\n   $$\n\n5. 对于 g 数组的维护如下，假设当前需要维护前 i 个房屋且有 j 个社区下的 g 数组，则我们找 f(i,j,k) 中的最小值 m1 和次小值 m2。如果 m1=m2，则说明对于所有 k， g(i,j,k)=m1；否则，对于 f(i,j,k0)=m1 的那个 k0，其 g(i,j,k0)=m2g，其余 k≠k0都有 g(i,j,k)=m1。\n\n6. 最终答案为 \n   $$\n   \\min (f(m, \\text { target }, k)\n   $$\n\n\n\n```c++\nclass Solution {\npublic:\n    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {\n        const int MAX = 0x3f3f3f3f;\n        const int M = 110;\n        const int N = 30;\n\n        int f[M][M][N], g[M][M][N];\n        memset(f, 0x3f, sizeof(f));\n        memset(g, 0x3f, sizeof(g));\n\n        for (int k = 1; k <= n; k++)\n            f[0][0][k] = g[0][0][k] = 0;\n\n        for (int i = 1; i <= m; i++)\n            for (int j = 1; j <= min(i, target); j++) {\n                if (houses[i - 1] > 0) {\n                    int c = houses[i - 1];\n                    f[i][j][c] = min(f[i - 1][j][c], g[i - 1][j - 1][c]);\n                } else {\n                    for (int k = 1; k <= n; k++)\n                        f[i][j][k] = min(f[i - 1][j][k], g[i - 1][j - 1][k])\n                                        + cost[i - 1][k - 1];\n                }\n\n                int m1 = MAX, m2 = MAX;\n                for (int k = 1; k <= n; k++)\n                    if (m1 > f[i][j][k]) {\n                        m2 = m1;\n                        m1 = f[i][j][k];\n                    } else if (m2 > f[i][j][k])\n                        m2 = f[i][j][k];\n\n                if (m1 == m2) {\n                    for (int k = 1; k <= n; k++)\n                        g[i][j][k] = m1;\n                } else {\n                    for (int k = 1; k <= n; k++)\n                        if (f[i][j][k] == m1) g[i][j][k] = m2;\n                        else g[i][j][k] = m1;\n                }\n            }\n\n        int ans = MAX;\n        for (int k = 1; k <= n; k++)\n            ans = min(ans, f[m][target][k]);\n\n        if (ans == MAX)\n            ans = -1;\n\n        return ans;\n    }\n};\n\n```\n\n\n\n## 【Day09】740.删除并获得点数\n\n#### 740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)\n\n给你一个整数数组 nums ，你可以对它进行一些操作。\n\n每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。\n\n开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,4,2]\n输出：6\n解释：\n删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,3,3,3,4]\n输出：9\n解释：\n删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。\n```\n\n**提示：**\n\n- 1 <= nums.length <= 2 * 104\n- 1 <= nums[i] <= 104\n\n**题解：**\n\n首先，我们先明确一个概念，就是每个位置上的数字是可以在两种前结果之上进行选择的：\n\n如果你不删除当前位置的数字，那么你得到就是前一个数字的位置的最优结果。\n如果你觉得当前的位置数字i需要被删，那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数。\n以上两个结果，你每次取最大的，记录下来，然后答案就是最后那个数字了。\n\n如果你看到现在有点迷糊，那么我们先把数字进行整理一下。\n\n我们在原来的 nums 的基础上构造一个临时的数组 all，这个数组，以元素的值来做下标，下标对应的元素是原来的元素的个数。\n\n举个例子：\n\n```\nnums = [2, 2, 3, 3, 3, 4]\n```\n\n构造后：\n\n```\nall=[0, 0, 2, 3, 1];\n```\n\n就是代表着 22 的个数有两个，33 的个数有 33 个，44 的个数有 11 个。\n\n其实这样就可以变成打家劫舍的问题了呗。\n\n我们来看看，打家劫舍的最优子结构的公式：\n\n$$\n\\mathrm{dp}[\\mathrm{i}]=\\text { Math.max }(\\mathrm{d} \\mathrm{p}[\\mathrm{i}-1], \\mathrm{dp}[\\mathrm{i}-2]+\\mathrm{nums}[\\mathrm{i}])\n$$\n再来看看现在对这个问题的最优子结构公式：\n\n$$\n\\mathrm{dp}[\\mathrm{i}]=\\text { Math.max }\\left(\\mathrm{dp}[\\mathrm{i}-1], \\mathrm{dp}[\\mathrm{i}-2]+\\mathrm{i}^{\\star} \\mathrm{all}[\\mathrm{i}]\\right)\n$$\n\n\n```c++\nclass Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        if(nums.size() < 1) return 0;\n        int maxn = 0;\n        for(int it : nums)\n            maxn = max(maxn, it);\n        vector<int> cnt(maxn+1), dp(maxn+1);\n        for(int it : nums)\n            cnt[it]++;\n        dp[1] = cnt[1];\n        for(int i = 2; i <= maxn; i++)\n            dp[i] = max(dp[i-1], dp[i-2] + cnt[i] * i);\n        return dp[maxn];\n    }\n};\n```\n\n\n\n## 【Day10】1720. 解码异或后的数组\n\n#### [1720. 解码异或后的数组](https://leetcode-cn.com/problems/decode-xored-array/)\n\n未知 整数数组 arr 由 n 个非负整数组成。\n\n经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。\n\n给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。\n\n请解码返回原数组 arr 。可以证明答案存在并且是唯一的。\n\n \n\n**示例 1：**\n\n```\n输入：encoded = [1,2,3], first = 1\n输出：[1,0,2,1]\n解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n```\n\n\n**示例 2：**\n\n```\n输入：encoded = [6,2,7,3], first = 4\n输出：[4,2,0,7,4]\n```\n\n**提示：**\n\n- 2 <= n <= 104\n- encoded.length == n - 1\n- 0 <= encoded[i] <= 105\n- 0 <= first <= 105\n\n**题解：**\n\n异或运算满足交换律和结合律；\n\n任意整数和自身做异或运算的结果都等于 0，即 x⊕x=0；\n\n任意整数和 0 做异或运算的结果都等于其自身，即 x⊕0=0⊕x=x。\n\n在等号两边同时异或 arr[i]\n\n```c++\nclass Solution {\npublic:\n    vector<int> decode(vector<int>& encoded, int first) {\n        int n = encoded.size();\n        vector<int> arr(n + 1);\n        arr[0] = first;\n        for (int i = 0; i < n; i ++)\n            arr[i + 1] = arr[i] ^ encoded[i];\n        return arr;\n    }\n};\n\n```\n\n\n\n## 【Day11】1486.数组异或操作\n\n#### [1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)\n\n给你两个整数，n 和 start 。\n\n数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。\n\n请返回 nums 中所有元素按位异或（XOR）后得到的结果。\n\n \n\n**示例 1：**\n\n```\n输入：n = 5, start = 0\n输出：8\n解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     \"^\" 为按位异或 XOR 运算符。\n```\n\n\n**示例 2：**\n\n```\n输入：n = 4, start = 3\n输出：8\n解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.\n```\n\n\n**示例 3：**\n\n```\n输入：n = 1, start = 7\n输出：7\n```\n\n\n**示例 4：**\n\n```\n输入：n = 10, start = 5\n输出：2\n```\n\n**提示：**\n\n- 1 <= n <= 1000\n- 0 <= start <= 1000\n- n == nums.length\n\n**题解：**\n\n```c++\nclass Solution {\npublic:\n\tint xorOperation(int n, int start)\n\t{\n    \tint result = start, i;\n    \tfor (i = 1; i < n; i++)\n    \t{\n        \tresult = result ^ (start + i * 2);\n    \t}\n    \treturn result;\n\t}\n};\n```\n\n\n\n## 【Day12】1723.完成所有工作的最短时间\n\n#### [1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)\n\n给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。\n\n请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。\n\n返回分配方案中尽可能 最小 的 最大工作时间 。\n\n \n\n**示例 1：**\n\n```\n输入：jobs = [3,2,3], k = 3\n输出：3\n解释：给每位工人分配一项工作，最大工作时间是 3 。\n```\n\n\n**示例 2：**\n\n```\n输入：jobs = [1,2,4,7,8], k = 2\n输出：11\n解释：按下述方式分配工作：\n1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）\n2 号工人：4、7（工作时间 = 4 + 7 = 11）\n最大工作时间是 11 。\n```\n\n**提示：**\n\n- 1 <= k <= jobs.length <= 12\n- 1 <= jobs[i] <= 107\n\n**题解：**\n\n**回溯法+剪枝**\n\n用一个 vector<int> block 记录每个人分配到的工作量，尝试将一份工作分配给一个人，且它的工作时间不超过lim要求，之后开启递归分配下一项工作，尝试找到一个成功分配全部工作的路径\n\n递归深度为 n=jobs.length 工作数量，每次递归需要检测范围为 k 员工数量并开启分支，最坏情况下走满树时间复杂度为 O(k^n)\n题设 1 <= k <= jobs.length <= 12，最坏情况下 12^12 = 8.9E12，外面还套了一个二分，还要再乘 log12 = 3.xxxx，远超1s极限算量1E8\n\n因此我们需要考虑一些剪枝的方法，首先我们可以 sort 一下 jobs ，时长从大到小开始分配，进而能够更快的超出限制，被剪枝掉，其次是朴素写法中存在很多重复的路径\n\n例如对于第一份工作的分配，所有人工作时长全部是0，我们只需要分配一次\n\n```\n[t1,0,0,0,0]\n之后的\n[0,t1,0,0,0]\n...\n```\n\n都是重复操作。\n\n 56号测试用例：\n\n```\n[5,5,4,4,4]\n2\n```\n\n如果先将 5h 分配给两个人block [5,5]，之后分配4时，只需要走一次 [9,5]，后面的[5,9] 是重复操作\n\n由于jobs已排序，因此我们每次枚举到的 block[i] 应当和上一次不一样，才是没走过的路径，进而排除全0时的重复放置，或是出现相同工作时长分配时的重复放置\n\n```c++\nclass Solution {\npublic:\n    int k;\n    vector<int>  block;\n    bool backtracking(vector<int>& jobs,int id,int lim) {\n        if(id==-1) return true; //出口 全部放完了\n\n        bool res=false;\n        int last=INT_MIN; \n\n        for(int i=0;i<k;++i) {\n            if(res) \n                break;\n            if(block[i]==last) \n                continue; //剪枝 因为jobs已排序所以应枚举和上一次不一样的结果\n\n            last=block[i];\n\n            if(block[i]<=lim-jobs[id]){ //小心越界\n                block[i]+=jobs[id];\n                res = backtracking(jobs,id-1,lim);\n                block[i]-=jobs[id];\n            }\n        }\n        return res;\n    }\n    int minimumTimeRequired(vector<int>& jobs, int k) {\n        this->k = k;\n        int s=0; //区间左端点（最小）\n        int e=0; //区间右端点（最大）\n        int m;//中间\n        int n = jobs.size()-1;//起手下标\n        block = vector<int>(k,0); // 拷贝初始化\n        sort(jobs.begin(),jobs.end());    \n        s=jobs[n];//结果最小应是 jobs[i] 的最大值\n\n        for(auto i : jobs) { //最大应是 sum(jobs.begin(),jobs.end()) 小心越界\n            if(e<=INT_MAX-i) e+=i;\n            else e=INT_MAX;\n        }        \n        while(s!=e) {\n            int m = (s+e)/2;\n            if(backtracking(jobs,n,m)) { //成功 尝试缩减区间\n                e=m;//m无法排除\n            }else {//失败 扩大\n                s=m+1;//m肯定不对最少加1\n            }\n        }\n        return s;\n    }\n};\n```\n\n\n\n## 【Day13】1482.制作m束花所需的最少天数\n\n#### [1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)\n\n给你一个整数数组 bloomDay，以及两个整数 m 和 k 。\n\n现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。\n\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n\n \n\n**示例 1：**\n\n```\n输入：bloomDay = [1,10,3,10,2], m = 3, k = 1\n输出：3\n解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3\n```\n\n\n**示例 2：**\n\n```\n输入：bloomDay = [1,10,3,10,2], m = 3, k = 2\n输出：-1\n解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。\n```\n\n\n**示例 3：**\n\n```\n输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n输出：12\n解释：要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。\n```\n\n\n**示例 4：**\n\n```\n输入：bloomDay = [1000000000,1000000000], m = 1, k = 1\n输出：1000000000\n解释：需要等 1000000000 天才能采到花来制作花束\n```\n\n\n**示例 5：**\n\n```\n输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n输出：9\n```\n\n**提示：**\n\n- bloomDay.length == n\n- 1 <= n <= 10^5\n- 1 <= bloomDay[i] <= 10^9\n- 1 <= m <= 10^6\n- 1 <= k <= n\n\n**题解：**\n\n假设制作m束花需要等待的最少天数是x天，那么有：\n\n- [0, x)天无法制作出来m束\n- [x,maxDay]可以制作出m束\n\n求出给定花开数组中最大值，进行二分计算即可。\n\n```c++\nclass Solution {\npublic:\n    int minDays(vector<int>& bloomDay, int m, int k) {\n        int n = bloomDay.size();\n        if (m * k  > n) return -1;\n        int l = 0, r = 0;\n        for (auto x : bloomDay) {\n            r = max(r, x);\n        }\n        while(l < r) {\n            int mid = l + r >> 1;\n            if (check(bloomDay, mid, m, k)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n    bool check(vector<int>& bloomDay, int mid, int m, int k) {\n        int sum = 0;\n        // 计算是否满足m束花且每一束都有相邻的k个\n        for (int i = 0; i < bloomDay.size() && sum < m; i++) {\n            int cur_sum = 0;\n            if (bloomDay[i] <= mid) { // 可以开\n                cur_sum++;\n                int j = i + 1;\n                while (j < bloomDay.size() && bloomDay[j] <= mid && cur_sum < k) {\n                    j++;\n                    cur_sum++;\n                }\n                if (cur_sum == k) sum++;\n                i = j - 1;\n            } \n        }\n        return sum >= m;\n    }\n};\n```\n\n\n\n## 【Day14】872.叶子相似的树\n\n#### [872. 叶子相似的树](https://leetcode-cn.com/problems/leaf-similar-trees/)\n\n请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png)\n\n举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。\n\n如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。\n\n如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg)\n\n```\n输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：root1 = [1], root2 = [1]\n输出：true\n```\n\n\n**示例 3：**\n\n```\n输入：root1 = [1], root2 = [2]\n输出：false\n```\n\n\n**示例 4：**\n\n```\n输入：root1 = [1,2], root2 = [2,2]\n输出：true\n```\n\n\n**示例 5：**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg)\n\n```\n输入：root1 = [1,2,3], root2 = [1,3,2]\n输出：false\n```\n\n**提示：**\n\n- 给定的两棵树可能会有 1 到 200 个结点。\n- 给定的两棵树上的值介于 0 到 200 之间。\n\n**题解：**\n\n将第一次的结果存储下来后，后面直接比较并返回结果。\n\n```c++\nclass Solution {\npublic:\n    int index = 0;\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector<int> r1;\n        dfs1(root1, r1);\n        return dfs2(root2, r1) && index == r1.size();\n    }\n    void dfs1(TreeNode* root, vector<int>& res) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            res.push_back(root->val);\n            return;\n        }\n        dfs1(root->left, res);\n        dfs1(root->right, res);\n    }\n    bool dfs2(TreeNode* root, vector<int>& res) {\n        if (!root) return true;\n        if (!root->left && !root->right) {\n            if (index >= res.size()) return false;\n            if (root->val != res[index]) return false;\n            index++;\n            return true;\n        }\n        return dfs2(root->left, res) && dfs2(root->right, res);\n    }\n   \n};\n```\n\n## 【Day15】1734.解码异或后的排列\n\n#### [1734. 解码异或后的排列](https://leetcode-cn.com/problems/decode-xored-permutation/)\n\n给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。\n\n它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。\n\n给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。\n\n \n\n**示例 1：**\n\n```\n输入：encoded = [3,1]\n输出：[1,2,3]\n解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n```\n\n\n**示例 2：**\n\n```\n输入：encoded = [6,5,4,6]\n输出：[2,4,1,5,3]\n```\n\n**提示：**\n\n- 3 <= n < 105\n- n 是奇数。\n- encoded.length == n - 1\n\n**题解：**\n\nperm = [A,B,C,D,E]\n\nencoded = [A^B, B^C, C^D, D^E]\n\n而B^C^D^E = encoded[1] ^ encode[3]\n\nA^B^C^D^E = total\n\ntotal ^ (B^C^D^E) = first\n\n```c++\nclass Solution {\npublic:\n    vector<int> decode(vector<int>& encoded) {\n        int n = encoded.size() + 1;\n        int total = 0;\n        for (int i = 1; i <= n; i++) {\n            total ^= i;\n        }\n\n        int e = 0;\n        for (int i = 1; i < n - 1; i += 2) {\n            e ^= encoded[i];\n        }\n        \n        vector<int> ans(n);\n        ans[0] = total ^ e;\n        for (int i = 1; i < n; i++) {\n            ans[i] = ans[i-1] ^ encoded[i-1];\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## 【Day16】1310.子数组异或查询\n\n#### [1310. 子数组异或查询](https://leetcode-cn.com/problems/xor-queries-of-a-subarray/)\n\n有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。\n\n对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。\n\n并返回一个包含给定查询 queries 所有结果的数组。\n\n \n\n**示例 1：**\n\n```\n输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n输出：[2,7,14,8] \n解释：\n数组中元素的二进制表示形式是：\n1 = 0001 \n3 = 0011 \n4 = 0100 \n8 = 1000 \n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2 \n[1,2] = 3 xor 4 = 7 \n[0,3] = 1 xor 3 xor 4 xor 8 = 14 \n[3,3] = 8\n```\n\n**示例 2：**\n\n```\n输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n输出：[8,0,4,4]\n```\n\n\n\n**提示：**\n\n- 1 <= arr.length <= 3 * 10^4\n- 1 <= arr[i] <= 10^9\n- 1 <= queries.length <= 3 * 10^4\n- queries[i].length == 2\n- 0 <= queries[i][0] <= queries[i][1] < arr.length\n\n\n\n**题解：**\n\n利用前缀和思想：sum(i,j) = sum(j) - sum(i-1);\n\n```c++\nclass Solution {\npublic:\n    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {\n        vector<int> ans;\n        int sum[arr.size() + 1];\n        for (int i = 1; i <= arr.size(); i++) {\n            sum[i] = sum[i - 1] ^ arr[i - 1];\n        }\n\n        for (auto q : queries) {\n            ans.push_back(sum[q[1] + 1] ^ sum[q[0]]);\n        }\n        return ans;\n    }\n```\n\n\n\n## 【Day17】1269.停在原地的方案数\n\n#### [1269. 停在原地的方案数](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/)\n\n有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。\n\n每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。\n\n给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。\n\n由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。\n\n \n\n**示例 1：**\n\n```\n输入：steps = 3, arrLen = 2\n输出：4\n解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n```\n\n\n**示例  2：**\n\n```\n输入：steps = 2, arrLen = 4\n输出：2\n解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n```\n\n**示例 3：**\n\n```\n输入：steps = 4, arrLen = 2\n输出：8\n```\n\n**提示：**\n\n```\n1 <= steps <= 500\n1 <= arrLen <= 10^6\n```\n\n\n\n**题解：**\n\n**暴力递归**\n\npos表示移动的index,st表示当前还剩步数。结果超时- _ -\n\n```c++\nclass Solution {\n public:\n  const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      int res = dfs(steps, arrLen, 0);\n      return res % N; \n  }\n\n  int dfs(int st, int arrLen, int pos) {\n    if (st < 0 || pos < 0 || pos >= arrLen) return 0;\n    if (st == 0 && pos == 0) {\n      return 1;\n    }\n    int ans = 0;\n    if (pos >= 0 && pos <= arrLen - 1)\n      // 不动\n      ans = dfs(st - 1, arrLen, pos);\n    if (pos >= 1)\n      // 向左\n      ans += dfs(st - 1, arrLen, pos - 1);\n    if (pos <= arrLen - 2)\n      // 向右\n      ans += dfs(st- 1, arrLen, pos + 1);\n    return ans;\n  }\n};\n```\n\n**记忆化搜索**\n\n**一开始开辟空间太大，过不了，发现开辟很大空间后，使用map性能比vector好，而实际只需要开辟steps\\*steps即可。**\n\n```c++\nint memo[505][505];\n// vector<vector<int>> memo;\nclass Solution {\n public:\n  static const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      memset(memo, -1, sizeof(memo));\n    //   memo = vector<vector<int>>(505, vector<int>(505,-1));\n      int res = dfs(steps, arrLen, 0);\n      return res % N; \n  }\n\n  int dfs(int st, int arrLen, int pos) {\n    if (st < 0 || pos < 0 || pos >= arrLen) return 0;\n    if (memo[st][pos] != -1) return memo[st][pos];\n    if (st == 0 && pos == 0) {\n      return memo[st][pos] = 1;\n    }\n    int ans = 0;\n    if (pos >= 0 && pos <= arrLen - 1) \n      // 不动\n      ans = dfs(st - 1, arrLen, pos) % N;\n    if (pos >= 1)\n      // 向左\n      ans =  ans % N + dfs(st - 1, arrLen, pos - 1) % N;\n    if (pos <= arrLen - 2)\n      // 向右\n      ans = ans % N + dfs(st- 1, arrLen, pos + 1) % N;\n    return memo[st][pos] = ans;\n  }\n};\n```\n\n**动态规划**\n\n```c++\nclass Solution {\n public:\n  static const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      int maxLen = min(steps, arrLen);\n      long long dp[steps + 1][maxLen + 1];\n      memset(dp, 0, sizeof dp);\n      dp[1][0] = 1;\n      dp[1][1] = 1; // step=1 pos=1\n\n      for (int s = 1; s <= steps; s++) {\n          for (int l = 0; l < maxLen; l++) {\n            // 原地\n            \tdp[s][l] = dp[s][l] + dp[s - 1][l];\n            // 右\n            \tdp[s][l] = dp[s][l]  + dp[s - 1][l + 1];\n            // 左\n\n            \tif (l - 1 >= 0)\n            \t\tdp[s][l] =  dp[s][l] + dp[s - 1][l - 1];\n              \n              dp[s][l] %= N;\n          }\n      }     \n      return dp[steps][0]; \n  }\n};\n```\n\n## 【Day18】12.整数转罗马数字\n\n\n\n#### [12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)\n\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n\n给你一个整数，将其转为罗马数字。\n\n \n\n**示例 1:**\n\n```\n输入: num = 3\n输出: \"III\"\n```\n\n**示例 2:**\n\n```\n输入: num = 4\n输出: \"IV\"\n```\n\n**示例 3:**\n\n```\n输入: num = 9\n输出: \"IX\"\n```\n\n**示例 4:**\n\n```\n输入: num = 58\n输出: \"LVIII\"\n解释: L = 50, V = 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: num = 1994\n输出: \"MCMXCIV\"\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n**提示：**\n\n- 1 <= num <= 3999\n\n**题解：**\n\n第一想到贪心，使用哈希表排序罗马数字并遍历，从高到低进行匹配。暴力匹配也可以的，\n\n```c++\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string reps[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n        string ans;\n        int \n        for (int i = 0; i < 13; i ++ ) \n            while(num >= values[i])\n            {\n                num -= values[i];\n                ans += reps[i];\n            }\n        return ans;\n    }\n};\n```\n\n## 【Day19】13.罗马数字转整数\n\n#### [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)\n\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n \n\n**示例 1:**\n\n```\n输入: \"III\"\n输出: 3\n```\n\n\n**示例 2:**\n\n```\n输入: \"IV\"\n输出: 4\n```\n\n\n**示例 3:**\n\n```\n输入: \"IX\"\n输出: 9\n```\n\n\n**示例 4:**\n\n```\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n```\n\n\n**示例 5:**\n\n```\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n**提示：**\n\n- 1 <= s.length <= 15\n- s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')\n- 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n- 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。\n\n**题解：**\n\n\n\n- 当小值在大值的左边，则减小值，如 IV=5-1=4；\n- 当小值在大值的右边，则加小值，如 VI=5+1=6；\n\n- 小值放在大值的左边，就是做减法，否则为加法。\n\n```c++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n    int r=0;\n\n    for(int i=0;i<s.length();i++)\n\t{\n\t\tswitch(s[i])\n\t\t{\n\t\t\tcase 'I' : r += ('V' == s[i+1] || 'X' == s[i+1]) ?-1 : 1 ; break;\n\t\t\tcase 'V' : r += 5; break;\n\t\t\tcase 'X' : r += ('L' == s[i+1] || 'C' == s[i+1]) ?-10: 10 ; break;\n\t\t\tcase 'L' : r += 50; break;\n\t\t\tcase 'C' : r += ('D' == s[i+1] || 'M' == s[i+1]) ?-100: 100 ; break;\n\t\t\tcase 'D' : r += 500; break;\n\t\t\tcase 'M' : r += 1000; break;\n\t\t}\n\t}\n\treturn r;\n    }\n};\n```\n\n## 【Day20】421.数组中两个数的最大异或值\n\n#### [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)\n\n给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。\n\n进阶：你可以在 O(n) 的时间解决这个问题吗？\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,10,5,25,2,8]\n输出：28\n解释：最大运算结果是 5 XOR 25 = 28.\n```\n\n**示例 2：**\n\n```\n输入：nums = [0]\n输出：0\n```\n\n\n**示例 3：**\n\n```\n输入：nums = [2,4]\n输出：6\n```\n\n\n**示例 4：**\n\n```\n输入：nums = [8,10,2]\n输出：10\n```\n\n\n**示例 5：**\n\n```\n输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n输出：127\n```\n\n**提示：**\n\n- 1 <= nums.length <= 2 * 104\n- 0 <= nums[i] <= 231 - 1\n\n**题解：**\n\n**前缀树**\n\n将所有数据从最高位开始取每一个bit，构建出树形结构，尽可能保证最高位为1，也就是说当循环到当前数的时候，如果当前数的bit与当前数中某一个数的某一位是相反的，那么可以保证为1，也就是最大，否则向低位继续循环。\n\n```c++\nstruct Node{\n    Node* next[2] = {nullptr};\n};\nclass Solution {\npublic:\n    void insert(int num, Node* root) {\n        for (int i = 30; i >= 0; --i) {\n            int t = (num >> i & 1);\n            if (!root->next[t]) {\n                root->next[t] = new Node();\n            }\n            root = root->next[t];\n        }\n    }\n    int findMaximumXOR(vector<int>& nums) {\n        Node* root = new Node();\n        for (auto val : nums) {\n            insert(val, root);\n        }\n        int res = 0, tmp = 0;\n        Node* p = root;\n        for (auto val : nums) {\n            p = root; tmp = 0;\n            for (int i = 30; i >= 0; --i) {\n                int t = (val >> i) & 1;\n                if (p->next[!t]) {\n                    p = p->next[!t];\n                    tmp += (1 << i);\n                }else p = p->next[t];\n            }\n            res = max(res, tmp);\n        }\n        return res;\n    }\n};\n```\n\n**暴力+剪枝**\n\n剪枝策略两数异或最大不超过两数之和，先排序再剪枝。\n\n```c++\nclass Solution {\npublic:\n    int findMaximumXOR(vector<int>& nums) {\n        sort(nums.begin(), nums.end(), [](auto a, auto b) {return a > b;});\n        int ans = 0;\n        for (int i = 0; i < nums.size() - 1; i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                long long x = (long long)nums[i] + nums[j];\n                if (ans > x) break;\n                ans = max(ans, nums[i] ^ nums[j]);\n            }\n        }\n        return ans;     \n    }\n};\n```\n\n\n\n## 【Day21】993.二叉树的堂兄弟节点\n\n#### [993. 二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree/)\n\n在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n\n如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。\n\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\n\n \n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png)\n\n```\n输入：root = [1,2,3,4], x = 4, y = 3\n输出：false\n```\n\n**示例 2：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png)\n\n```\n输入：root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出：true\n```\n\n**示例 3：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png)\n\n```\n输入：root = [1,2,3,null,4], x = 2, y = 3\n输出：false\n```\n\n**提示：**\n\n- 二叉树的节点数介于 2 到 100 之间。\n- 每个节点的值都是唯一的、范围为 1 到 100 的整数。\n\n**题解：**\n\n假设从根节点开始编号1，依次往后编号，其两个孩子是`2*n`与`2*n+1`。反过来便是根据两个孩子节点判断是否是同一个父亲，那便是直接除以2，向下取整，看两者是否一样即可。\n\n例如：2、3是同一父亲，2、4不是。\n\n在BFS过程中记录节点编号以及x、y节点，最后判断即可。\n\n```c++\nclass Solution {\npublic:\n    bool isCousins(TreeNode* root, int x, int y) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int cnt = 1;\n        while (q.size()) {\n            int sz = q.size();\n            bool xt = false, yt = false;\n            int xcnt, ycnt;\n            while (sz--) {\n                auto p = q.front();\n                q.pop();\n                if (p) {\n                    if (x == p->val) {\n                        xt = true;\n                        xcnt = cnt;\n                    }\n                    if (y == p->val) { \n                        yt = true;\n                        ycnt = cnt;\n                    }\n                    \n                    if (xt && yt && int(xcnt / 2) != int(ycnt / 2) ) {\n                        return true;\n                    }\n                    q.push(p->left); q.push(p->right);\n                }\n                cnt++;\n            }\n        }\n        return false;\n    }\n};\n```\n\n## 【Day22】1442.形成两个异或相等数组的三元组数目\n\n#### [1442. 形成两个异或相等数组的三元组数目](https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)\n\n 给你一个整数数组 arr 。\n\n现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。\n\na 和 b 定义如下：\n\n- a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\n- b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\n\n注意：^ 表示 按位异或 操作。\n\n请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：arr = [2,3,1,6,7]\n输出：4\n解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)\n```\n\n\n**示例 2：**\n\n```\n输入：arr = [1,1,1,1,1]\n输出：10\n```\n\n\n**示例 3：**\n\n```\n输入：arr = [2,3]\n输出：0\n```\n\n\n**示例 4：**\n\n```\n输入：arr = [1,3,5,7,9]\n输出：3\n```\n\n\n**示例 5：**\n\n```\n输入：arr = [7,11,12,9,5,2,7,17,22]\n输出：8\n```\n\n**提示：**\n\n- 1 <= arr.length <= 300\n- 1 <= arr[i] <= 10^8\n\n**题解：**\n\n∵   a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\n\n​     b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\n\n∴  arr[i] ^ arr[i + 1] ^ ... ^ arr[k] = a ^ b = 0;\n\na^b=0得到区间[i,k]中有k-i个元组，全部累加即可。区间内三元组的个数为 k - i（因为区间内的任意一个j，都和i，k组成满足题目的一个三元组）。\n\n```c++\nclass Solution {\npublic:\n    int countTriplets(vector<int>& arr) {\n        int ans = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            int s = arr[i];\n            for (int k = i + 1; k < arr.size(); k++) {\n                s ^= arr[k];\n                if (s == 0) ans += k - i;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 【Day23】1738.找出第 K 大的异或坐标值\n\n#### [1738. 找出第 K 大的异或坐标值](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/)\n\n给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。\n\n矩阵中坐标 (a, b) 的 值 可由对所有满足 0 <= i <= a < m 且 0 <= j <= b < n 的元素 matrix[i][j]（**下标从 0 开始计数**）执行异或运算得到。\n\n请你找出 matrix 的所有坐标中第 k 大的值（**k 的值从 1 开始计数**）。\n\n \n\n**示例 1：**\n\n```\n输入：matrix = [[5,2],[1,6]], k = 1\n输出：7\n解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。\n```\n\n\n**示例 2：**\n\n```\n输入：matrix = [[5,2],[1,6]], k = 2\n输出：5\n解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。\n```\n\n\n**示例 3：**\n\n```\n输入：matrix = [[5,2],[1,6]], k = 3\n输出：4\n解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。\n```\n\n\n**示例 4：**\n\n```\n输入：matrix = [[5,2],[1,6]], k = 4\n输出：0\n解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。\n```\n\n**提示：**\n\n- m == matrix.length\n- n == matrix[i].length\n- 1 <= m, n <= 1000\n- 0 <= matrix[i][j] <= 106\n- 1 <= k <= m * n\n\n**题解：**\n\n**二维差分+最小堆**\n\n前缀和模板+维护k个元素的最小堆\n\n```c++\nclass Solution {\npublic:\n    int prefix[1000][1000];\n    int kthLargestValue(vector<vector<int>>& matrix, int k) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        prefix[0][0] = matrix[0][0];\n        // 处理第一行\n        for (int i = 1; i < n; i++) {\n            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];\n        }\n        // 处理第一列\n        for (int i = 1; i < m; i++) {\n            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];\n            }\n        }\n\n        priority_queue<int, vector<int>, std::greater<int>> pq;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                pq.push(prefix[i][j]);\n                if (pq.size() > k) pq.pop();\n            }\n        }\n        return pq.top();\n    }\n};\n```\n\n**二分搜值**\n\n每次猜测一个值x，然后遍历前缀和矩阵，统计有多少个元素大于等于x，如果count小于k，那么x肯定不可能是答案，我们将猜测的上界下调至x-1；否则，我们就将猜测的下界调整至x。可以看到问题可以转换为查找最后一个小于等于target的数。因为当查找到大于等于target时要往上不断压缩区间，直到小于等于k为止。\n\n```c++\nclass Solution {\npublic:\n    int prefix[1000][1000];\n    int m, n;\n    int kthLargestValue(vector<vector<int>>& matrix, int k) {\n        m = matrix.size();\n        n = matrix[0].size();\n        prefix[0][0] = matrix[0][0];\n        // 处理第一行\n        for (int i = 1; i < n; i++) {\n            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];\n        }\n        // 处理第一列\n        for (int i = 1; i < m; i++) {\n            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];\n            }\n        }\n\n        int left = 0, right = 1e6;\n        while (left < right) {\n            int mid = right - (right - left - 1) / 2;\n            if (count(mid) < k) { // 缩小值\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n    int count (int mid) {\n        int cnt = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (prefix[i][j] >= mid) cnt++;\n            }\n        }\n        return cnt;\n    }\n};\n```\n\n## 【Day24】692.前K个高频单词\n\n#### [692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)\n\n给一非空的单词列表，返回前 k 个出现次数最多的单词。\n\n返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。\n\n**示例 1：**\n\n```\n输入: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\n输出: [\"i\", \"love\"]\n解析: \"i\" 和 \"love\" 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 \"i\" 在 \"love\" 之前。\n```\n\n**示例 2：**\n\n```\n输入: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\n输出: [\"the\", \"is\", \"sunny\", \"day\"]\n解析: \"the\", \"is\", \"sunny\" 和 \"day\" 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。\n```\n\n**注意：**\n\n- 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。\n- 输入的单词均由小写字母组成。\n\n**扩展练习：**\n\n> 尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。\n\n**题解：**\n\n```c++\nstruct Cmp {\n    bool operator()(const pair<string, int>& p1, const pair<string, int>& p2) {\n        if(p1.second != p2.second) return p1.second > p2.second;\n        else return p1.first < p2.first;\n    }\n};\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> m;\n        for(string& word : words) m[word]++;\n        vector<pair<string, int>> sorted_list(m.begin(), m.end());\n        sort(sorted_list.begin(), sorted_list.end(), Cmp());\n        vector<string> res;\n        for(int i = 0; i < k; i++) res.push_back(sorted_list[i].first);\n        return res;\n    }\n};\n```\n\n## 【Day25】1035.不相交的线\n\n#### [1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)\n\n在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：\n\n-  nums1[i] == nums2[j]\n-  且绘制的直线不与任何其他连线（非水平线）相交。\n\n请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n\n \n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png)\n\n```\n输入：nums1 = [1,4,2], nums2 = [1,2,4]\n输出：2\n解释：可以画出两条不交叉的线，如上图所示。 \n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n```\n\n\n**示例 2：**\n\n```\n输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n输出：3\n```\n\n\n**示例 3：**\n\n```\n输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n输出：2\n```\n\n**提示：**\n\n- 1 <= nums1.length <= 500\n- 1 <= nums2.length <= 500\n- 1 <= nums1[i], nums2[i] <= 2000\n\n**题解：**\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> dp;\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size();\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n```\n\n## 【Day26】810.黑板异或游戏\n\n#### [810. 黑板异或游戏](https://leetcode-cn.com/problems/chalkboard-xor-game/)\n\n黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）\n\n换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。\n\n假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。\n\n \n\n**示例：**\n\n```\n输入: nums = [1, 1, 2]\n输出: false\n解释: \nAlice 有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。\n```\n\n**提示：**\n\n- 1 <= N <= 1000\n- 0 <= nums[i] <= 2^16\n\n**题解：**\n\n```c++\nclass Solution {\npublic:\n    bool xorGame(vector<int>& nums) {\n        //数组元素个数是奇数/偶数，有决定性作用：\n        //如果是偶数，先手必胜；\n        //如果是奇数，只有当一上来所有元素异或的结果为0，先手才获胜，\n        //否则，接下来轮到后手，此时元素个数为偶数，则后手必胜，先手必败！\n        int len = nums.size(), t = 0;\n        if(len % 2)\n        {\n            for(auto& x:nums) t ^= x; //所有元素异或的结果\n            if(t) return false;\n            else return true;\n        }\n        else return true;\n    }\n};\n```\n\n## 【Day27】1707.与数组中元素的最大异或值\n\n#### [1707. 与数组中元素的最大异或值](https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/)\n\n\n\n给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。\n\n第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] <= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。\n\n返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n输出：[3,3,7]\n解释：\n1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n```\n\n\n**示例 2：**\n\n```\n输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n输出：[15,-1,5]\n```\n\n**提示：**\n\n- 1 <= nums.length, queries.length <= 105\n- queries[i].length == 2\n- 0 <= nums[j], xi, mi <= 109\n\n\n\n**题解：**\n\n```c++\nconst int N = 1e5 + 50, M = 32 * N;\nint son[M][2];\nint idx;\n\nvoid insert(int x){\n    int p = 0;\n    for(int i = 31; i >= 0; i--){\n        int u = (x >> i) & 1;\n        if(!son[p][u]) son[p][u] = ++idx;\n        p = son[p][u];\n    }\n}\nint query(int x){\n    int ans = 0, p = 0;\n    for(int i = 31; i >= 0; i--){\n        int u = (x >> i) & 1;\n        if(son[p][!u]) {\n            ans += (1 << i);\n            p = son[p][!u];\n        }\n        else p = son[p][u];\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\n        memset(son,0,sizeof son);\n        idx = 0;\n        sort(nums.begin(),nums.end());\n        //离线思想，因此需要对queries加一个pos，因为回答是乱序的\n        int pos = 0;\n        for(auto& q: queries){\n            q.push_back(pos++);\n        }\n        sort(queries.begin(),queries.end(),[](const auto& a,const auto& b){\n            return a[1] < b[1];\n        });\n        vector<int> ans(queries.size());\n        int cur = 0;\n        for(const auto& q : queries){\n            int xi = q[0], mi = q[1],id = q[2];\n            while(cur < nums.size() and nums[cur] <= mi){\n                insert(nums[cur]);\n                cur++;\n            }\n            if(cur == 0) ans[id] = -1;\n            else ans[id] = query(xi);\n        }\n        return ans;\n    }\n};\n```\n\n## 【Day28】664.奇怪的打印机\n\n#### [664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)\n\n有台奇怪的打印机有以下两个特殊要求：\n\n- 打印机每次只能打印由 同一个字符 组成的序列。\n- 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。\n\n给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。\n\n**示例 1：**\n\n```\n输入：s = \"aaabbb\"\n输出：2\n解释：首先打印 \"aaa\" 然后打印 \"bbb\"。\n```\n\n\n**示例 2：**\n\n```\n输入：s = \"aba\"\n输出：2\n解释：首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\n```\n\n**提示：**\n\n- 1 <= s.length <= 100\n- s 由小写英文字母组成\n\n**题解：**\n\n区间dp问题，对于[i,j]区间i<j，如果s[i] == s[j]，那么dp[i][j] = dp[i - 1][j] 或者dp[i + 1][j]，例如：aba 等于 ab或者 ba\n\n如果s[i]!=s[j]，那么对于区间[i,j]的所有组合，进行累加求min即可。\n\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n\n目标是求dp[0][n - 1]，因此，对于这道题有两种遍历方式。\n\n\n\n**第一种：从下往上，从左到右。**\n\n```c++\nclass Solution {\npublic:\n    int strangePrinter(string s) {\n        // aba\n        // aaabbb\n        int n = s.size();\n        int dp[n][n];\n        memset(dp, 0x3f3f3f3f, sizeof(dp));\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    for (int k = i; k < j; k++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }     \n        return dp[0][n - 1];\n    }\n};\n```\n\n**第二种：斜着遍历。**\n\n```c++\nclass Solution {\npublic:\n    int strangePrinter(string s) {\n        // aba\n        // aaabbb\n        int n = s.size();\n        int dp[n][n];\n        memset(dp, 0x3f3f3f3f, sizeof(dp));\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int l = 2; l <= n; l++) {\n            for (int i = 0; i < n - l + 1; i++) {\n                int j = l + i - 1;\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    for (int k = i; k < j; k++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }\n\n        \n        return dp[0][n - 1];\n    }\n};\n```\n\n## 【Day29】1787.使所有区间的异或结果为零\n\n#### [1787. 使所有区间的异或结果为零](https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/)\n\n给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left <= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR ... XOR nums[right] 。\n\n返回数组中 **要更改的最小元素数** ，以使所有长度为 k 的区间异或结果等于零。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,0,3,0], k = 1\n输出：3\n解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]\n```\n\n\n**示例 2：**\n\n```\n输入：nums = [3,4,5,2,1,7,3,4,7], k = 3\n输出：3\n解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]\n```\n\n\n**示例 3：**\n\n```\n输入：nums = [1,2,4,1,2,5,1,2,6], k = 3\n输出：3\n解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]\n```\n\n**提示：**\n\n- 1 <= k <= nums.length <= 2000\n- 0 <= nums[i] < 210\n\n **题解：**\n\n第一种情况采用贪心的方法求得最优解。因为修改后的元素可能是原序列中没有出现过的元素。如果修改的某一列的元素是原序列中没有出现过的元素，那么这种情况下一定可以用贪心的办法求出最优解，做法是将众数最小的一列中的每个数变成一个全新的，该列中没有出现的，使得每个周期内的元素的异或和为0的数。\n\n\n\n第二种情况采用dp的方法求得最优解在这种情况下，由于没有最终修改后的元素是原数组中存在的数，因此可以从前往后枚举每一列，然后枚举选择第几行的数作为这列元素修改后的元素，由于异或具有交换性质，因此不具有顺序的问题，所以可以采用dp的方法递推出将序列变成数组中本来存在的某个数的情况。边界，f[0] [0] = 0，目标状态是f[k] [0]，状态表示f[i] [j]为前i列异或和为j的情况下的最小值。\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    // 1.某一列用了一个全新的数\n    // 2.每一列用了原来的数\n    \n    const int N = 1024, INF = 1e8;\n    int s[1024]; // 求众数\n    int minChanges(vector<int>& nums, int k) {\n        int n = nums.size(), m = (n + k - 1) / k;\n        vector<vector<int>> f(k + 1, vector<int>(N, INF));\n        int cnt = 0, minv = INF; // 每一列代价\n        // f[i][j] 第i列的异或和为j\n        f[0][0] = 0;\n        for (int i = 1; i <= k; i++) {\n            int len = m;\n            memset(s, 0 , sizeof s);\n            if (n % k && n % k < i) len--;\n            for (int j = 0; j < len; j ++) {\n                s[nums[j * k + i - 1]]++;\n            }\n            int maxv = 0;\n            for (int j = 0; j < N; j++) {\n                maxv = max(maxv, s[j]);\n            }\n            cnt += len - maxv;\n            minv = min(minv, maxv); // 众数最少的那一列  不用众数  而用全新的数\n\n            for (int j = 0; j < N; j++) { // 异或和为j\n                for (int u = 0; u < len; u++) { // 每一行\n                    int x = nums[u * k + i - 1], cost = len - s[x];\n                    f[i][j] = min(f[i][j], f[i - 1][j ^ x] + cost);\n                }\n            }\n        }\n        // cnt: 每一列的代价\n        // minv表示 某一列不用众数时的代价 si - maxv -> si 变成全新的数代价\n        return min(cnt + minv, f[k][0]);\n    }\n};\n```\n\n## 【Day30】1190.反转每对括号间的子串\n\n#### [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)\n\n给出一个字符串 s（仅含有小写英文字母和括号）。\n\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n\n**注意，您的结果中 不应 包含任何括号。**\n\n**示例 1：**\n\n```\n输入：s = \"(abcd)\"\n输出：\"dcba\"\n```\n\n\n**示例 2：**\n\n```\n输入：s = \"(u(love)i)\"\n输出：\"iloveu\"\n```\n\n\n**示例 3：**\n\n```\n输入：s = \"(ed(et(oc))el)\"\n输出：\"leetcode\"\n```\n\n\n**示例 4：**\n\n```\n输入：s = \"a(bcdefghijkl(mno)p)q\"\n输出：\"apmnolkjihgfedcbq\"\n```\n\n**提示：**\n\n- 0 <= s.length <= 2000\n- s 中只有小写英文字母和括号\n- 我们确保所有括号都是成对出现的\n\n**题解：**\n\n![](https://cdn.acwing.com/media/article/image/2021/05/26/30502_ed3e6737bd-aa.gif)\n\n挨个遍历， 左括号和普通字符直接入栈；遇到右括号 ，就依次出栈直到栈顶为左括号 ，出栈的这些字符按出栈顺序链接自然也就是逆序的，然后栈顶左括号出栈 把组合成的逆序串重新压入栈。\n\n遍历完字符串 栈中从栈底到栈顶 自然也就想要的结果，如果依次出栈 要注意连接顺序，还需要一次整体反转。\n\n**代码：**\n\n```c++\nclass Solution {\npublic:\n    string reverseParentheses(string s) {\n        stack<char> st;\n        for (auto c : s) {\n            if (c != ')') {\n                st.push(c);\n            } else {\n                string tmp;\n                while (st.top() != '(') {\n                    tmp += st.top();\n                    st.pop();\n                }\n                st.pop();\n                for (auto s : tmp) {\n                    st.push(s);\n                }\n            }\n        }\n        string ans;\n        while (!st.empty()) {\n            ans = st.top() + ans; st.pop();\n        }\n        return ans;\n    }\n};\n                                                                      \n```\n\n\n\n几天刚好一个月结束啦，收获还是很多的，困难我唯唯诺诺，简单重拳出击！！！hhh~","slug":"暑假LeetCode刷题集合（上）","published":true,"updated":"2021-10-20T13:18:37.250Z","_id":"clq6dy4bv0067ikw0ck478qbn","comments":true,"layout":"post","photos":[],"link":"","html":"<p><strong>最近决定巩固一下算法，开始刷leetcode每日一题，具体刷多久还不知道，刚开始是有点吃力，慢慢来。</strong></p>\n<h2 id=\"【Day01】938-二叉搜索树的范围和\"><a href=\"#【Day01】938-二叉搜索树的范围和\" class=\"headerlink\" title=\"【Day01】938.二叉搜索树的范围和\"></a>【Day01】938.二叉搜索树的范围和</h2><p><strong>题目：</strong></p>\n<p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>\n<p><strong>示例1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg\" alt></p>\n<pre><code>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15\n输出：32</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg\" alt></p>\n<pre><code>输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n输出：23</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 [1, 2 * 104] 内</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>1 &lt;= low &lt;= high &lt;= 105</li>\n<li>所有 Node.val 互不相同</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>递归</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (!root) return 0;\n        int sum = 0;\n        sum += rangeSumBST(root->left, low, high);\n        if (root->val >= low && root->val <= high) sum += root->val;\n        sum += rangeSumBST(root->right, low, high);\n        return sum;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>非递归</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (!root) return 0;\n        queue<TreeNode*> q;\n        TreeNode* p = root;\n        int sum = 0;\n        while (p || q.size()) {\n            while (p) {\n                q.push(p);\n                p = p->left;\n            }\n            if (q.size()) {\n                p = q.front();\n                q.pop();\n                if (p->val >= low && p->val <= high) {\n                    sum += p->val;\n                }\n                p = p->right;       \n            }    \n        }\n        return sum;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day02】633-平方数之和\"><a href=\"#【Day02】633-平方数之和\" class=\"headerlink\" title=\"【Day02】633.平方数之和\"></a>【Day02】633.平方数之和</h2><p><strong>题目：</strong></p>\n<p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：c = 5\n输出：true\n解释：1 * 1 + 2 * 2 = 5</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：c = 3\n输出：false</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：c = 4\n输出：true</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：c = 2\n输出：true</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：c = 1\n输出：true</code></pre><p><strong>枚举</strong></p>\n<p>对 a 从 0 开始到 n√n 枚举，然后判断是否存在 b。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        for (int i = 0; (long long)(i) * i <= c; i++) {\n            int j = sqrt(c - i * i);\n            if (i * i + j * j == c)\n                return true;\n        }\n        return false;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>预处理+查询</strong></p>\n<p>如果存在符合条件的a，b，那么a和b一定在1和sqrt(c)之间。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    typedef unsigned long long ULL;\n    bool judgeSquareSum(int c) {\n        if (c == 0) return true;\n        unordered_map<ULL, ULL> um;\n        for (int i = 1; i <= sqrt(c); i++) {\n            um[i*i]++;\n        }\n\n        for (int i = 1; i <= sqrt(c); i++) {\n            if (i*i == c || um.count(c - i*i)) return true;\n        }\n        return false;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>双指针</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        int j = sqrt(c);\n        int i = 0;\n        while (i <= j) {\n            if (i*i > c - j*j) {\n                j--;\n            } else if (i*i < c - j*j) {\n                i++;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day03】403-青蛙过河\"><a href=\"#【Day03】403-青蛙过河\" class=\"headerlink\" title=\"【Day03】403.青蛙过河\"></a>【Day03】403.青蛙过河</h2><h3 id=\"403-青蛙过河\"><a href=\"#403-青蛙过河\" class=\"headerlink\" title=\"403. 青蛙过河\"></a><a href=\"https://leetcode-cn.com/problems/frog-jump/\" target=\"_blank\" rel=\"noopener\">403. 青蛙过河</a></h3><p><strong>题目描述：</strong></p>\n<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>\n<p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>\n<p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p>\n<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>\n<p>  <strong>示例 1：</strong></p>\n<pre><code>输入：stones = [0,1,3,5,6,8,12,17]\n输出：true\n解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：stones = [0,1,2,3,4,8,9,11]\n输出：false\n解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>2 &lt;= stones.length &lt;= 2000</li>\n<li>0 &lt;= stones[i] &lt;= 231 - 1</li>\n<li>stones[0] == 0</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>递归:</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    unordered_map<int, int> um;\n    bool canCross(vector<int>& stones) {\n\n        for (int i = 0; i < stones.size(); i++) {\n            um[stones[i]] = i;  // key:石子值 value是第几块石子\n        }\n        if (!um.count(1)) return false;\n        return dfs(stones, stones.size(), 1, 1);\n    }\n    bool dfs(vector<int>& stones, int n, int cur, int k) {\n        if (cur == n - 1) return true;\n        for (int i = -1; i <= 1; i++) {\n            if (k + i == 0) continue;\n            int next = stones[cur] + k + i;\n            if (um.count(next)) { // 存在\n                bool choose = dfs(stones, n, um[next], k + i);\n                if (choose) return true;\n            }\n        }\n        return false;\n    }\n\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>dfs记忆化搜索:</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    unordered_map<int, int> um;\n    vector<vector<int>> memo;\n    bool canCross(vector<int>& stones) {\n\n        for (int i = 0; i < stones.size(); i++) {\n            um[stones[i]] = i;  // key:石子值 value是第几块石子\n        }\n        if (!um.count(1)) return false;\n        memo = vector<vector<int>>(stones.size(), vector<int>(stones.size(), -1));\n        return dfs(stones, stones.size(), 1, 1);\n    }\n    bool dfs(vector<int>& stones, int n, int cur, int k) {\n        if (memo[cur][k] != -1) return memo[cur][k];\n        if (cur == n - 1) return memo[cur][k] = true;\n        for (int i = -1; i <= 1; i++) {\n            if (k + i == 0) continue;  // 原地跳过\n            int next = stones[cur] + k + i;\n            if (um.count(next)) { // 存在\n                bool choose = dfs(stones, n, um[next], k + i);\n                if (choose) return memo[cur][k] = true;\n            }\n        }\n        return memo[cur][k] = false;\n    }\n\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>动态规划：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        int n = stones.size();\n        if (stones[1] != 1) return false;\n        vector<vector<bool>> dp(n, vector<bool>(n));\n        // dp[i][k] 表示在第i个位置且跳k个单位到第i块石子。\n        dp[1][1] = true;\n        for (int i = 2; i < n; i++) {\n            for (int j = 1; j < i; j++) {\n                int k = stones[i] - stones[j];\n                if (k > j + 1) continue;\n                // 因为题目要求 青蛙第一次只能跳1步，那么第二次至多跳2步，以此类推，青蛙在第i块（i从0开始）石头上至多只能跳i+1步。在第j块石头上至多只能跳 j+1 步 ，如果k > j+1，说明石头 i 隔石头 j 太远了，远到不满足题目的隐藏规则，所以青蛙必定跳不过去。\n                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k+1];\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            if (dp[n-1][i]) return true;\n        }        \n        return false;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>另一种动态规划:</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        // dp[i][j] 表示 第 i 个石头是否可以跳 j 步\n        int n = stones.size();\n        vector<vector<bool>> dp(n, vector<bool>(n));\n        dp[0][1] = true;\n        for (int i = 1; i < n; i++) {\n            bool flag = false;\n            for (int j = i - 1; j >= 0; j--) {\n                int k = stones[i] - stones[j];\n                if (k > i) break;\n                if (dp[j][k]) {\n                    dp[i][k - 1] = dp[i][k] = dp[i][k + 1] = true;\n                    flag = true;\n                }\n            }\n            if (i == n - 1 && !flag) {\n                return false;\n            }\n        }\n        return true;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day04】137-只出现一次的数字II\"><a href=\"#【Day04】137-只出现一次的数字II\" class=\"headerlink\" title=\"【Day04】137.只出现一次的数字II\"></a>【Day04】137.只出现一次的数字II</h2><h4 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137. 只出现一次的数字 II\"></a><a href=\"https://leetcode-cn.com/problems/single-number-ii/\" target=\"_blank\" rel=\"noopener\">137. 只出现一次的数字 II</a></h4><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n<p> <strong>示例1：</strong></p>\n<pre><code>输入：nums = [2,2,3,2]\n输出：3</code></pre><p><strong>示例2：</strong></p>\n<pre><code>输入：nums = [0,1,0,1,0,1,99]\n输出：99</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 3 * 104</li>\n<li>-231 &lt;= nums[i] &lt;= 231 - 1</li>\n<li>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p> <strong>有限状态自动机：</strong></p>\n<p>使用二进制表示每个元素，对应二进制位的1相加，最后相加对3取余</p>\n<p>对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0,1,2 。由于二进制只能表示 0, 10,1 ，因此需要使用两个二进制位来表示 3 个状态。设此两位分别为 one，two.</p>\n<p><strong>计算 one方法：</strong></p>\n<p>设当前状态为 one ，two 此时输入二进制位 nn 。如下图所示，通过对状态表的情况拆分，可推出 one的计算方法为：</p>\n<pre><code>if two == 0:\n  if n == 0:\n    one = one\n  if n == 1:\n    one = ~one\nif two == 1:\n    one = 0</code></pre><p>引入 异或运算 ，可将以上拆分简化为：</p>\n<pre><code>if two == 0:\n    one = one ^ n\nif two == 1:\n    one = 0</code></pre><p>引入 与运算 ，可继续简化为：</p>\n<pre><code>one = one ^ n &amp; ~two</code></pre><p>同理：</p>\n<pre><code>two = two ^ n &amp; ~one</code></pre><p>代码：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int two = 0, one = 0;\n        for (auto x: nums) {\n            one = (one ^ x) & ~two;\n            two = (two ^ x) & ~one;\n        }\n        return one;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>哈希表：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int, int> um;\n        for (auto x : nums) {\n            um[x]++;\n        }\n\n        for (auto x : um) {\n            if (x.second == 1) return x.first;\n        }\n        return -1;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day05】690-员工的重要性\"><a href=\"#【Day05】690-员工的重要性\" class=\"headerlink\" title=\"【Day05】690.员工的重要性\"></a>【Day05】690.员工的重要性</h2><h4 id=\"690-员工的重要性\"><a href=\"#690-员工的重要性\" class=\"headerlink\" title=\"690. 员工的重要性\"></a><a href=\"https://leetcode-cn.com/problems/employee-importance/\" target=\"_blank\" rel=\"noopener\">690. 员工的重要性</a></h4><p>给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。</p>\n<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。</p>\n<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出：11\n解释：\n员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>一个员工最多有一个 直系 领导，但是可以有多个 直系 下属</li>\n<li>员工数量不超过 2000 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>今天的题不是很难，直接遍历所有节点相加就行了，使用哈希表将id指向映射到指针，遍历一遍。</p>\n<p><strong>dfs</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    unordered_map<int, Employee*> hash;\n\n    int getImportance(vector<Employee*> employees, int id) {\n        for (auto& p: employees) hash[p->id] = p;\n        return dfs(id);\n    }\n\n    int dfs(int id) {\n        auto p = hash[id];\n        int res = p->importance;\n        for (auto son: p->subordinates)\n            res += dfs(son);\n        return res;\n    }\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day06】554-砖墙\"><a href=\"#【Day06】554-砖墙\" class=\"headerlink\" title=\"【Day06】554.砖墙\"></a>【Day06】554.砖墙</h2><h4 id=\"554-砖墙\"><a href=\"#554-砖墙\" class=\"headerlink\" title=\"554. 砖墙\"></a><a href=\"https://leetcode-cn.com/problems/brick-wall/\" target=\"_blank\" rel=\"noopener\">554. 砖墙</a></h4><p>你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。</p>\n<p>你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</p>\n<p>给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" alt></p>\n<pre><code>输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n输出：2</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：wall = [[1],[1],[1]]\n输出：3</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>n == wall.length</li>\n<li>1 &lt;= n &lt;= 104</li>\n<li>1 &lt;= wall[i].length &lt;= 104</li>\n<li>1 &lt;= sum(wall[i].length) &lt;= 2 * 104</li>\n<li>对于每一行 i ，sum(wall[i]) 应当是相同的</li>\n<li>1 &lt;= wall[i][j] &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>贪心，哈希表</strong></p>\n<p>显然最优的线一定是沿某个块砖的边缘穿过的。<br>统计每一行的砖可以从左到右可以构成的长度值，用 unordered_map 哈希表统计长度值出现的次数。出现次数最多的值就应该是这条线所在的位置。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int leastBricks(vector<vector<int>>& wall) {\n        unordered_map<int, int> cnt;\n        for (auto& line: wall) {\n            for (int i = 0, s = 0; i + 1 < line.size(); i ++ ) {\n                s += line[i];\n                cnt[s] ++ ;\n            }\n        }\n        int res = 0;\n        for (auto [k, v]: cnt) res = max(res, v);\n        return wall.size() - res;\n    }\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day07】7-整数反转7-整数反转\"><a href=\"#【Day07】7-整数反转7-整数反转\" class=\"headerlink\" title=\"【Day07】7.整数反转7. 整数反转\"></a>【Day07】7.整数反转<a href=\"https://leetcode-cn.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">7. 整数反转</a></h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>\n<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>\n<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：x = 123\n输出：321</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：x = -123\n输出：-321</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：x = 120\n输出：21</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：x = 0\n输出：0</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>-231 &lt;= x &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>(循环) O(logn)</strong><br>依次从右往左计算出每位数字，然后逆序累加在一个整数中。<br>另外，这题有两点需要注意：</p>\n<ul>\n<li><p>因为int型整数逆序后可能会溢出，所以我们要用long long记录中间结果；</p>\n</li>\n<li><p>在C++中，负数的取模运算和数学意义上的取模运算不同，结果还是负数，比如 −12%10=−2−12%10=−2，所以我们不需要对负数进行额外处理。</p>\n</li>\n</ul>\n<p>时间复杂度分析：一共有 O(logn) 位，对于每一位的计算量是常数级的，所以总时间复杂度是  O(logn)</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int reverse(int x) {\n        int res = 0;\n        while (x) {\n            if (x > 0 && res > (INT_MAX - x % 10) / 10) return 0;\n            if (x < 0 && res < (INT_MIN - x % 10) / 10) return 0;\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        return res;\n    }\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day08】1473-粉刷房子III\"><a href=\"#【Day08】1473-粉刷房子III\" class=\"headerlink\" title=\"【Day08】1473.粉刷房子III\"></a>【Day08】1473.粉刷房子III</h2><h4 id=\"1473-粉刷房子-III\"><a href=\"#1473-粉刷房子-III\" class=\"headerlink\" title=\"1473. 粉刷房子 III\"></a><a href=\"https://leetcode-cn.com/problems/paint-house-iii/\" target=\"_blank\" rel=\"noopener\">1473. 粉刷房子 III</a></h4><p>在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p>\n<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）</p>\n<p>给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：</p>\n<ul>\n<li>houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。</li>\n<li>cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。</li>\n</ul>\n<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n输出：9\n解释：房子涂色方案为 [1,2,2,1,1]\n此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。\n涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n输出：11\n解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]\n此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。\n给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\n输出：5</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n输出：-1\n解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>m == houses.length == cost.length</li>\n<li>n == cost[i].length</li>\n<li>1 &lt;= m &lt;= 100</li>\n<li>1 &lt;= n &lt;= 20</li>\n<li>1 &lt;= target &lt;= m</li>\n<li>0 &lt;= houses[i] &lt;= n</li>\n<li>1 &lt;= cost[i][j] &lt;= 10^4</li>\n</ul>\n<p><strong>题解·：</strong></p>\n<p>很明显的DP</p>\n<ol>\n<li><p>设状态  f(i,j,k) 表示处理了前 i 个房屋，有 j 个社区，最后一个房屋的颜色为 k 的最小花费，其中房屋的有效下标从 1 开始。建立辅助数组 g(i,j,k) 表示同样含义下，最后一个房屋颜色 不是 k 的最小花费。</p>\n</li>\n<li><p>初始时，f(0,0,k)=g(0,0,k)=0，其余为正无穷或者待定。<br>转移时，分两种情况</p>\n</li>\n<li><p>如果第 i 个房屋已经有了颜色 c，则有两种选择，上一个房屋颜色为 c 或者不为 c，转移<br>$$<br>f(i, j, c)=\\min (f(i-1, j, c), g(i-1, j-1, c))<br>$$</p>\n</li>\n<li><p>如果第 i 个房屋没有颜色，则枚举一个颜色 k，然后同样根据上一个房屋的颜色，转移<br>$$<br>f(i, j, k)=\\min (f(i-1, j, k), g(i-1, j-1, k))+\\operatorname{cost}(i, k-1)_{\\text {。 }}<br>$$</p>\n</li>\n<li><p>对于 g 数组的维护如下，假设当前需要维护前 i 个房屋且有 j 个社区下的 g 数组，则我们找 f(i,j,k) 中的最小值 m1 和次小值 m2。如果 m1=m2，则说明对于所有 k， g(i,j,k)=m1；否则，对于 f(i,j,k0)=m1 的那个 k0，其 g(i,j,k0)=m2g，其余 k≠k0都有 g(i,j,k)=m1。</p>\n</li>\n<li><p>最终答案为<br>$$<br>\\min (f(m, \\text { target }, k)<br>$$</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {\n        const int MAX = 0x3f3f3f3f;\n        const int M = 110;\n        const int N = 30;\n\n        int f[M][M][N], g[M][M][N];\n        memset(f, 0x3f, sizeof(f));\n        memset(g, 0x3f, sizeof(g));\n\n        for (int k = 1; k <= n; k++)\n            f[0][0][k] = g[0][0][k] = 0;\n\n        for (int i = 1; i <= m; i++)\n            for (int j = 1; j <= min(i, target); j++) {\n                if (houses[i - 1] > 0) {\n                    int c = houses[i - 1];\n                    f[i][j][c] = min(f[i - 1][j][c], g[i - 1][j - 1][c]);\n                } else {\n                    for (int k = 1; k <= n; k++)\n                        f[i][j][k] = min(f[i - 1][j][k], g[i - 1][j - 1][k])\n                                        + cost[i - 1][k - 1];\n                }\n\n                int m1 = MAX, m2 = MAX;\n                for (int k = 1; k <= n; k++)\n                    if (m1 > f[i][j][k]) {\n                        m2 = m1;\n                        m1 = f[i][j][k];\n                    } else if (m2 > f[i][j][k])\n                        m2 = f[i][j][k];\n\n                if (m1 == m2) {\n                    for (int k = 1; k <= n; k++)\n                        g[i][j][k] = m1;\n                } else {\n                    for (int k = 1; k <= n; k++)\n                        if (f[i][j][k] == m1) g[i][j][k] = m2;\n                        else g[i][j][k] = m1;\n                }\n            }\n\n        int ans = MAX;\n        for (int k = 1; k <= n; k++)\n            ans = min(ans, f[m][target][k]);\n\n        if (ans == MAX)\n            ans = -1;\n\n        return ans;\n    }\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day09】740-删除并获得点数\"><a href=\"#【Day09】740-删除并获得点数\" class=\"headerlink\" title=\"【Day09】740.删除并获得点数\"></a>【Day09】740.删除并获得点数</h2><h4 id=\"740-删除并获得点数-https-leetcode-cn-com-problems-delete-and-earn\"><a href=\"#740-删除并获得点数-https-leetcode-cn-com-problems-delete-and-earn\" class=\"headerlink\" title=\"740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)\"></a>740. 删除并获得点数](<a href=\"https://leetcode-cn.com/problems/delete-and-earn/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/delete-and-earn/</a>)</h4><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>\n<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。</p>\n<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [3,4,2]\n输出：6\n解释：\n删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [2,2,3,3,3,4]\n输出：9\n解释：\n删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 2 * 104</li>\n<li>1 &lt;= nums[i] &lt;= 104</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>首先，我们先明确一个概念，就是每个位置上的数字是可以在两种前结果之上进行选择的：</p>\n<p>如果你不删除当前位置的数字，那么你得到就是前一个数字的位置的最优结果。<br>如果你觉得当前的位置数字i需要被删，那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数。<br>以上两个结果，你每次取最大的，记录下来，然后答案就是最后那个数字了。</p>\n<p>如果你看到现在有点迷糊，那么我们先把数字进行整理一下。</p>\n<p>我们在原来的 nums 的基础上构造一个临时的数组 all，这个数组，以元素的值来做下标，下标对应的元素是原来的元素的个数。</p>\n<p>举个例子：</p>\n<pre><code>nums = [2, 2, 3, 3, 3, 4]</code></pre><p>构造后：</p>\n<pre><code>all=[0, 0, 2, 3, 1];</code></pre><p>就是代表着 22 的个数有两个，33 的个数有 33 个，44 的个数有 11 个。</p>\n<p>其实这样就可以变成打家劫舍的问题了呗。</p>\n<p>我们来看看，打家劫舍的最优子结构的公式：</p>\n<p>$$<br>\\mathrm{dp}[\\mathrm{i}]=\\text { Math.max }(\\mathrm{d} \\mathrm{p}[\\mathrm{i}-1], \\mathrm{dp}[\\mathrm{i}-2]+\\mathrm{nums}[\\mathrm{i}])<br>$$<br>再来看看现在对这个问题的最优子结构公式：</p>\n<p>$$<br>\\mathrm{dp}[\\mathrm{i}]=\\text { Math.max }\\left(\\mathrm{dp}[\\mathrm{i}-1], \\mathrm{dp}[\\mathrm{i}-2]+\\mathrm{i}^{\\star} \\mathrm{all}[\\mathrm{i}]\\right)<br>$$</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        if(nums.size() < 1) return 0;\n        int maxn = 0;\n        for(int it : nums)\n            maxn = max(maxn, it);\n        vector<int> cnt(maxn+1), dp(maxn+1);\n        for(int it : nums)\n            cnt[it]++;\n        dp[1] = cnt[1];\n        for(int i = 2; i <= maxn; i++)\n            dp[i] = max(dp[i-1], dp[i-2] + cnt[i] * i);\n        return dp[maxn];\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day10】1720-解码异或后的数组\"><a href=\"#【Day10】1720-解码异或后的数组\" class=\"headerlink\" title=\"【Day10】1720. 解码异或后的数组\"></a>【Day10】1720. 解码异或后的数组</h2><h4 id=\"1720-解码异或后的数组\"><a href=\"#1720-解码异或后的数组\" class=\"headerlink\" title=\"1720. 解码异或后的数组\"></a><a href=\"https://leetcode-cn.com/problems/decode-xored-array/\" target=\"_blank\" rel=\"noopener\">1720. 解码异或后的数组</a></h4><p>未知 整数数组 arr 由 n 个非负整数组成。</p>\n<p>经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。</p>\n<p>给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。</p>\n<p>请解码返回原数组 arr 。可以证明答案存在并且是唯一的。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：encoded = [1,2,3], first = 1\n输出：[1,0,2,1]\n解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：encoded = [6,2,7,3], first = 4\n输出：[4,2,0,7,4]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>2 &lt;= n &lt;= 104</li>\n<li>encoded.length == n - 1</li>\n<li>0 &lt;= encoded[i] &lt;= 105</li>\n<li>0 &lt;= first &lt;= 105</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>异或运算满足交换律和结合律；</p>\n<p>任意整数和自身做异或运算的结果都等于 0，即 x⊕x=0；</p>\n<p>任意整数和 0 做异或运算的结果都等于其自身，即 x⊕0=0⊕x=x。</p>\n<p>在等号两边同时异或 arr[i]</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    vector<int> decode(vector<int>& encoded, int first) {\n        int n = encoded.size();\n        vector<int> arr(n + 1);\n        arr[0] = first;\n        for (int i = 0; i < n; i ++)\n            arr[i + 1] = arr[i] ^ encoded[i];\n        return arr;\n    }\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day11】1486-数组异或操作\"><a href=\"#【Day11】1486-数组异或操作\" class=\"headerlink\" title=\"【Day11】1486.数组异或操作\"></a>【Day11】1486.数组异或操作</h2><h4 id=\"1486-数组异或操作\"><a href=\"#1486-数组异或操作\" class=\"headerlink\" title=\"1486. 数组异或操作\"></a><a href=\"https://leetcode-cn.com/problems/xor-operation-in-an-array/\" target=\"_blank\" rel=\"noopener\">1486. 数组异或操作</a></h4><p>给你两个整数，n 和 start 。</p>\n<p>数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。</p>\n<p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 5, start = 0\n输出：8\n解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     &quot;^&quot; 为按位异或 XOR 运算符。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 4, start = 3\n输出：8\n解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 1, start = 7\n输出：7</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：n = 10, start = 5\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 1000</li>\n<li>0 &lt;= start &lt;= 1000</li>\n<li>n == nums.length</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int xorOperation(int n, int start)\n    {\n        int result = start, i;\n        for (i = 1; i < n; i++)\n        {\n            result = result ^ (start + i * 2);\n        }\n        return result;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day12】1723-完成所有工作的最短时间\"><a href=\"#【Day12】1723-完成所有工作的最短时间\" class=\"headerlink\" title=\"【Day12】1723.完成所有工作的最短时间\"></a>【Day12】1723.完成所有工作的最短时间</h2><h4 id=\"1723-完成所有工作的最短时间\"><a href=\"#1723-完成所有工作的最短时间\" class=\"headerlink\" title=\"1723. 完成所有工作的最短时间\"></a><a href=\"https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/\" target=\"_blank\" rel=\"noopener\">1723. 完成所有工作的最短时间</a></h4><p>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。</p>\n<p>请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。</p>\n<p>返回分配方案中尽可能 最小 的 最大工作时间 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：jobs = [3,2,3], k = 3\n输出：3\n解释：给每位工人分配一项工作，最大工作时间是 3 。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：jobs = [1,2,4,7,8], k = 2\n输出：11\n解释：按下述方式分配工作：\n1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）\n2 号工人：4、7（工作时间 = 4 + 7 = 11）\n最大工作时间是 11 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= k &lt;= jobs.length &lt;= 12</li>\n<li>1 &lt;= jobs[i] &lt;= 107</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>回溯法+剪枝</strong></p>\n<p>用一个 vector<int> block 记录每个人分配到的工作量，尝试将一份工作分配给一个人，且它的工作时间不超过lim要求，之后开启递归分配下一项工作，尝试找到一个成功分配全部工作的路径</int></p>\n<p>递归深度为 n=jobs.length 工作数量，每次递归需要检测范围为 k 员工数量并开启分支，最坏情况下走满树时间复杂度为 O(k^n)<br>题设 1 &lt;= k &lt;= jobs.length &lt;= 12，最坏情况下 12^12 = 8.9E12，外面还套了一个二分，还要再乘 log12 = 3.xxxx，远超1s极限算量1E8</p>\n<p>因此我们需要考虑一些剪枝的方法，首先我们可以 sort 一下 jobs ，时长从大到小开始分配，进而能够更快的超出限制，被剪枝掉，其次是朴素写法中存在很多重复的路径</p>\n<p>例如对于第一份工作的分配，所有人工作时长全部是0，我们只需要分配一次</p>\n<pre><code>[t1,0,0,0,0]\n之后的\n[0,t1,0,0,0]\n...</code></pre><p>都是重复操作。</p>\n<p> 56号测试用例：</p>\n<pre><code>[5,5,4,4,4]\n2</code></pre><p>如果先将 5h 分配给两个人block [5,5]，之后分配4时，只需要走一次 [9,5]，后面的[5,9] 是重复操作</p>\n<p>由于jobs已排序，因此我们每次枚举到的 block[i] 应当和上一次不一样，才是没走过的路径，进而排除全0时的重复放置，或是出现相同工作时长分配时的重复放置</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int k;\n    vector<int>  block;\n    bool backtracking(vector<int>& jobs,int id,int lim) {\n        if(id==-1) return true; //出口 全部放完了\n\n        bool res=false;\n        int last=INT_MIN; \n\n        for(int i=0;i<k;++i) {\n            if(res) \n                break;\n            if(block[i]==last) \n                continue; //剪枝 因为jobs已排序所以应枚举和上一次不一样的结果\n\n            last=block[i];\n\n            if(block[i]<=lim-jobs[id]){ //小心越界\n                block[i]+=jobs[id];\n                res = backtracking(jobs,id-1,lim);\n                block[i]-=jobs[id];\n            }\n        }\n        return res;\n    }\n    int minimumTimeRequired(vector<int>& jobs, int k) {\n        this->k = k;\n        int s=0; //区间左端点（最小）\n        int e=0; //区间右端点（最大）\n        int m;//中间\n        int n = jobs.size()-1;//起手下标\n        block = vector<int>(k,0); // 拷贝初始化\n        sort(jobs.begin(),jobs.end());    \n        s=jobs[n];//结果最小应是 jobs[i] 的最大值\n\n        for(auto i : jobs) { //最大应是 sum(jobs.begin(),jobs.end()) 小心越界\n            if(e<=INT_MAX-i) e+=i;\n            else e=INT_MAX;\n        }        \n        while(s!=e) {\n            int m = (s+e)/2;\n            if(backtracking(jobs,n,m)) { //成功 尝试缩减区间\n                e=m;//m无法排除\n            }else {//失败 扩大\n                s=m+1;//m肯定不对最少加1\n            }\n        }\n        return s;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day13】1482-制作m束花所需的最少天数\"><a href=\"#【Day13】1482-制作m束花所需的最少天数\" class=\"headerlink\" title=\"【Day13】1482.制作m束花所需的最少天数\"></a>【Day13】1482.制作m束花所需的最少天数</h2><h4 id=\"1482-制作-m-束花所需的最少天数\"><a href=\"#1482-制作-m-束花所需的最少天数\" class=\"headerlink\" title=\"1482. 制作 m 束花所需的最少天数\"></a><a href=\"https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/\" target=\"_blank\" rel=\"noopener\">1482. 制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</p>\n<p>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。</p>\n<p>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。</p>\n<p>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1\n输出：3\n解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：bloomDay = [1,10,3,10,2], m = 3, k = 2\n输出：-1\n解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n输出：12\n解释：要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：bloomDay = [1000000000,1000000000], m = 1, k = 1\n输出：1000000000\n解释：需要等 1000000000 天才能采到花来制作花束</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n输出：9</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>bloomDay.length == n</li>\n<li>1 &lt;= n &lt;= 10^5</li>\n<li>1 &lt;= bloomDay[i] &lt;= 10^9</li>\n<li>1 &lt;= m &lt;= 10^6</li>\n<li>1 &lt;= k &lt;= n</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>假设制作m束花需要等待的最少天数是x天，那么有：</p>\n<ul>\n<li>[0, x)天无法制作出来m束</li>\n<li>[x,maxDay]可以制作出m束</li>\n</ul>\n<p>求出给定花开数组中最大值，进行二分计算即可。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int minDays(vector<int>& bloomDay, int m, int k) {\n        int n = bloomDay.size();\n        if (m * k  > n) return -1;\n        int l = 0, r = 0;\n        for (auto x : bloomDay) {\n            r = max(r, x);\n        }\n        while(l < r) {\n            int mid = l + r >> 1;\n            if (check(bloomDay, mid, m, k)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n    bool check(vector<int>& bloomDay, int mid, int m, int k) {\n        int sum = 0;\n        // 计算是否满足m束花且每一束都有相邻的k个\n        for (int i = 0; i < bloomDay.size() && sum < m; i++) {\n            int cur_sum = 0;\n            if (bloomDay[i] <= mid) { // 可以开\n                cur_sum++;\n                int j = i + 1;\n                while (j < bloomDay.size() && bloomDay[j] <= mid && cur_sum < k) {\n                    j++;\n                    cur_sum++;\n                }\n                if (cur_sum == k) sum++;\n                i = j - 1;\n            } \n        }\n        return sum >= m;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day14】872-叶子相似的树\"><a href=\"#【Day14】872-叶子相似的树\" class=\"headerlink\" title=\"【Day14】872.叶子相似的树\"></a>【Day14】872.叶子相似的树</h2><h4 id=\"872-叶子相似的树\"><a href=\"#872-叶子相似的树\" class=\"headerlink\" title=\"872. 叶子相似的树\"></a><a href=\"https://leetcode-cn.com/problems/leaf-similar-trees/\" target=\"_blank\" rel=\"noopener\">872. 叶子相似的树</a></h4><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" alt></p>\n<p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。</p>\n<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p>\n<p>如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" alt></p>\n<pre><code>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n输出：true</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：root1 = [1], root2 = [1]\n输出：true</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：root1 = [1], root2 = [2]\n输出：false</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：root1 = [1,2], root2 = [2,2]\n输出：true</code></pre><p><strong>示例 5：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" alt></p>\n<pre><code>输入：root1 = [1,2,3], root2 = [1,3,2]\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>给定的两棵树可能会有 1 到 200 个结点。</li>\n<li>给定的两棵树上的值介于 0 到 200 之间。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>将第一次的结果存储下来后，后面直接比较并返回结果。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int index = 0;\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector<int> r1;\n        dfs1(root1, r1);\n        return dfs2(root2, r1) && index == r1.size();\n    }\n    void dfs1(TreeNode* root, vector<int>& res) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            res.push_back(root->val);\n            return;\n        }\n        dfs1(root->left, res);\n        dfs1(root->right, res);\n    }\n    bool dfs2(TreeNode* root, vector<int>& res) {\n        if (!root) return true;\n        if (!root->left && !root->right) {\n            if (index >= res.size()) return false;\n            if (root->val != res[index]) return false;\n            index++;\n            return true;\n        }\n        return dfs2(root->left, res) && dfs2(root->right, res);\n    }\n\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day15】1734-解码异或后的排列\"><a href=\"#【Day15】1734-解码异或后的排列\" class=\"headerlink\" title=\"【Day15】1734.解码异或后的排列\"></a>【Day15】1734.解码异或后的排列</h2><h4 id=\"1734-解码异或后的排列\"><a href=\"#1734-解码异或后的排列\" class=\"headerlink\" title=\"1734. 解码异或后的排列\"></a><a href=\"https://leetcode-cn.com/problems/decode-xored-permutation/\" target=\"_blank\" rel=\"noopener\">1734. 解码异或后的排列</a></h4><p>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。</p>\n<p>它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。</p>\n<p>给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：encoded = [3,1]\n输出：[1,2,3]\n解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：encoded = [6,5,4,6]\n输出：[2,4,1,5,3]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>3 &lt;= n &lt; 105</li>\n<li>n 是奇数。</li>\n<li>encoded.length == n - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>perm = [A,B,C,D,E]</p>\n<p>encoded = [A^B, B^C, C^D, D^E]</p>\n<p>而B^C^D^E = encoded[1] ^ encode[3]</p>\n<p>A^B^C^D^E = total</p>\n<p>total ^ (B^C^D^E) = first</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    vector<int> decode(vector<int>& encoded) {\n        int n = encoded.size() + 1;\n        int total = 0;\n        for (int i = 1; i <= n; i++) {\n            total ^= i;\n        }\n\n        int e = 0;\n        for (int i = 1; i < n - 1; i += 2) {\n            e ^= encoded[i];\n        }\n\n        vector<int> ans(n);\n        ans[0] = total ^ e;\n        for (int i = 1; i < n; i++) {\n            ans[i] = ans[i-1] ^ encoded[i-1];\n        }\n        return ans;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day16】1310-子数组异或查询\"><a href=\"#【Day16】1310-子数组异或查询\" class=\"headerlink\" title=\"【Day16】1310.子数组异或查询\"></a>【Day16】1310.子数组异或查询</h2><h4 id=\"1310-子数组异或查询\"><a href=\"#1310-子数组异或查询\" class=\"headerlink\" title=\"1310. 子数组异或查询\"></a><a href=\"https://leetcode-cn.com/problems/xor-queries-of-a-subarray/\" target=\"_blank\" rel=\"noopener\">1310. 子数组异或查询</a></h4><p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</p>\n<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>\n<p>并返回一个包含给定查询 queries 所有结果的数组。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n输出：[2,7,14,8] \n解释：\n数组中元素的二进制表示形式是：\n1 = 0001 \n3 = 0011 \n4 = 0100 \n8 = 1000 \n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2 \n[1,2] = 3 xor 4 = 7 \n[0,3] = 1 xor 3 xor 4 xor 8 = 14 \n[3,3] = 8</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n输出：[8,0,4,4]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= arr.length &lt;= 3 * 10^4</li>\n<li>1 &lt;= arr[i] &lt;= 10^9</li>\n<li>1 &lt;= queries.length &lt;= 3 * 10^4</li>\n<li>queries[i].length == 2</li>\n<li>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>利用前缀和思想：sum(i,j) = sum(j) - sum(i-1);</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {\n        vector<int> ans;\n        int sum[arr.size() + 1];\n        for (int i = 1; i <= arr.size(); i++) {\n            sum[i] = sum[i - 1] ^ arr[i - 1];\n        }\n\n        for (auto q : queries) {\n            ans.push_back(sum[q[1] + 1] ^ sum[q[0]]);\n        }\n        return ans;\n    }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day17】1269-停在原地的方案数\"><a href=\"#【Day17】1269-停在原地的方案数\" class=\"headerlink\" title=\"【Day17】1269.停在原地的方案数\"></a>【Day17】1269.停在原地的方案数</h2><h4 id=\"1269-停在原地的方案数\"><a href=\"#1269-停在原地的方案数\" class=\"headerlink\" title=\"1269. 停在原地的方案数\"></a><a href=\"https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\" target=\"_blank\" rel=\"noopener\">1269. 停在原地的方案数</a></h4><p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</p>\n<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>\n<p>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</p>\n<p>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：steps = 3, arrLen = 2\n输出：4\n解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动</code></pre><p><strong>示例  2：</strong></p>\n<pre><code>输入：steps = 2, arrLen = 4\n输出：2\n解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：steps = 4, arrLen = 2\n输出：8</code></pre><p><strong>提示：</strong></p>\n<pre><code>1 &lt;= steps &lt;= 500\n1 &lt;= arrLen &lt;= 10^6</code></pre><p><strong>题解：</strong></p>\n<p><strong>暴力递归</strong></p>\n<p>pos表示移动的index,st表示当前还剩步数。结果超时- _ -</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\n public:\n  const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      int res = dfs(steps, arrLen, 0);\n      return res % N; \n  }\n\n  int dfs(int st, int arrLen, int pos) {\n    if (st < 0 || pos < 0 || pos >= arrLen) return 0;\n    if (st == 0 && pos == 0) {\n      return 1;\n    }\n    int ans = 0;\n    if (pos >= 0 && pos <= arrLen - 1)\n      // 不动\n      ans = dfs(st - 1, arrLen, pos);\n    if (pos >= 1)\n      // 向左\n      ans += dfs(st - 1, arrLen, pos - 1);\n    if (pos <= arrLen - 2)\n      // 向右\n      ans += dfs(st- 1, arrLen, pos + 1);\n    return ans;\n  }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>记忆化搜索</strong></p>\n<p><strong>一开始开辟空间太大，过不了，发现开辟很大空间后，使用map性能比vector好，而实际只需要开辟steps*steps即可。</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int memo[505][505];\n// vector<vector<int>> memo;\nclass Solution {\n public:\n  static const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      memset(memo, -1, sizeof(memo));\n    //   memo = vector<vector<int>>(505, vector<int>(505,-1));\n      int res = dfs(steps, arrLen, 0);\n      return res % N; \n  }\n\n  int dfs(int st, int arrLen, int pos) {\n    if (st < 0 || pos < 0 || pos >= arrLen) return 0;\n    if (memo[st][pos] != -1) return memo[st][pos];\n    if (st == 0 && pos == 0) {\n      return memo[st][pos] = 1;\n    }\n    int ans = 0;\n    if (pos >= 0 && pos <= arrLen - 1) \n      // 不动\n      ans = dfs(st - 1, arrLen, pos) % N;\n    if (pos >= 1)\n      // 向左\n      ans =  ans % N + dfs(st - 1, arrLen, pos - 1) % N;\n    if (pos <= arrLen - 2)\n      // 向右\n      ans = ans % N + dfs(st- 1, arrLen, pos + 1) % N;\n    return memo[st][pos] = ans;\n  }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>动态规划</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\n public:\n  static const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      int maxLen = min(steps, arrLen);\n      long long dp[steps + 1][maxLen + 1];\n      memset(dp, 0, sizeof dp);\n      dp[1][0] = 1;\n      dp[1][1] = 1; // step=1 pos=1\n\n      for (int s = 1; s <= steps; s++) {\n          for (int l = 0; l < maxLen; l++) {\n            // 原地\n                dp[s][l] = dp[s][l] + dp[s - 1][l];\n            // 右\n                dp[s][l] = dp[s][l]  + dp[s - 1][l + 1];\n            // 左\n\n                if (l - 1 >= 0)\n                    dp[s][l] =  dp[s][l] + dp[s - 1][l - 1];\n\n              dp[s][l] %= N;\n          }\n      }     \n      return dp[steps][0]; \n  }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day18】12-整数转罗马数字\"><a href=\"#【Day18】12-整数转罗马数字\" class=\"headerlink\" title=\"【Day18】12.整数转罗马数字\"></a>【Day18】12.整数转罗马数字</h2><h4 id=\"12-整数转罗马数字\"><a href=\"#12-整数转罗马数字\" class=\"headerlink\" title=\"12. 整数转罗马数字\"></a><a href=\"https://leetcode-cn.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">12. 整数转罗马数字</a></h4><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>\n<pre><code>字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre><blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n</blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给你一个整数，将其转为罗马数字。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: num = 3\n输出: &quot;III&quot;</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: num = 4\n输出: &quot;IV&quot;</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: num = 9\n输出: &quot;IX&quot;</code></pre><p><strong>示例 4:</strong></p>\n<pre><code>输入: num = 58\n输出: &quot;LVIII&quot;\n解释: L = 50, V = 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>\n<pre><code>输入: num = 1994\n输出: &quot;MCMXCIV&quot;\n解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= num &lt;= 3999</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>第一想到贪心，使用哈希表排序罗马数字并遍历，从高到低进行匹配。暴力匹配也可以的，</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    string intToRoman(int num) {\n        int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string reps[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n        string ans;\n        int \n        for (int i = 0; i < 13; i ++ ) \n            while(num >= values[i])\n            {\n                num -= values[i];\n                ans += reps[i];\n            }\n        return ans;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day19】13-罗马数字转整数\"><a href=\"#【Day19】13-罗马数字转整数\" class=\"headerlink\" title=\"【Day19】13.罗马数字转整数\"></a>【Day19】13.罗马数字转整数</h2><h4 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a><a href=\"https://leetcode-cn.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">13. 罗马数字转整数</a></h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<pre><code>字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre><blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n</blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: &quot;III&quot;\n输出: 3</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: &quot;IV&quot;\n输出: 4</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: &quot;IX&quot;\n输出: 9</code></pre><p><strong>示例 4:</strong></p>\n<pre><code>输入: &quot;LVIII&quot;\n输出: 58\n解释: L = 50, V= 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>\n<pre><code>输入: &quot;MCMXCIV&quot;\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= s.length &lt;= 15</li>\n<li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li>\n<li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<ul>\n<li><p>当小值在大值的左边，则减小值，如 IV=5-1=4；</p>\n</li>\n<li><p>当小值在大值的右边，则加小值，如 VI=5+1=6；</p>\n</li>\n<li><p>小值放在大值的左边，就是做减法，否则为加法。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int romanToInt(string s) {\n    int r=0;\n\n    for(int i=0;i<s.length();i++)\n    {\n        switch(s[i])\n        {\n            case 'I' : r += ('V' == s[i+1] || 'X' == s[i+1]) ?-1 : 1 ; break;\n            case 'V' : r += 5; break;\n            case 'X' : r += ('L' == s[i+1] || 'C' == s[i+1]) ?-10: 10 ; break;\n            case 'L' : r += 50; break;\n            case 'C' : r += ('D' == s[i+1] || 'M' == s[i+1]) ?-100: 100 ; break;\n            case 'D' : r += 500; break;\n            case 'M' : r += 1000; break;\n        }\n    }\n    return r;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day20】421-数组中两个数的最大异或值\"><a href=\"#【Day20】421-数组中两个数的最大异或值\" class=\"headerlink\" title=\"【Day20】421.数组中两个数的最大异或值\"></a>【Day20】421.数组中两个数的最大异或值</h2><h4 id=\"421-数组中两个数的最大异或值\"><a href=\"#421-数组中两个数的最大异或值\" class=\"headerlink\" title=\"421. 数组中两个数的最大异或值\"></a><a href=\"https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/\" target=\"_blank\" rel=\"noopener\">421. 数组中两个数的最大异或值</a></h4><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p>\n<p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [3,10,5,25,2,8]\n输出：28\n解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [0]\n输出：0</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [2,4]\n输出：6</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：nums = [8,10,2]\n输出：10</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n输出：127</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 2 * 104</li>\n<li>0 &lt;= nums[i] &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>前缀树</strong></p>\n<p>将所有数据从最高位开始取每一个bit，构建出树形结构，尽可能保证最高位为1，也就是说当循环到当前数的时候，如果当前数的bit与当前数中某一个数的某一位是相反的，那么可以保证为1，也就是最大，否则向低位继续循环。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">struct Node{\n    Node* next[2] = {nullptr};\n};\nclass Solution {\npublic:\n    void insert(int num, Node* root) {\n        for (int i = 30; i >= 0; --i) {\n            int t = (num >> i & 1);\n            if (!root->next[t]) {\n                root->next[t] = new Node();\n            }\n            root = root->next[t];\n        }\n    }\n    int findMaximumXOR(vector<int>& nums) {\n        Node* root = new Node();\n        for (auto val : nums) {\n            insert(val, root);\n        }\n        int res = 0, tmp = 0;\n        Node* p = root;\n        for (auto val : nums) {\n            p = root; tmp = 0;\n            for (int i = 30; i >= 0; --i) {\n                int t = (val >> i) & 1;\n                if (p->next[!t]) {\n                    p = p->next[!t];\n                    tmp += (1 << i);\n                }else p = p->next[t];\n            }\n            res = max(res, tmp);\n        }\n        return res;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>暴力+剪枝</strong></p>\n<p>剪枝策略两数异或最大不超过两数之和，先排序再剪枝。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int findMaximumXOR(vector<int>& nums) {\n        sort(nums.begin(), nums.end(), [](auto a, auto b) {return a > b;});\n        int ans = 0;\n        for (int i = 0; i < nums.size() - 1; i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                long long x = (long long)nums[i] + nums[j];\n                if (ans > x) break;\n                ans = max(ans, nums[i] ^ nums[j]);\n            }\n        }\n        return ans;     \n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day21】993-二叉树的堂兄弟节点\"><a href=\"#【Day21】993-二叉树的堂兄弟节点\" class=\"headerlink\" title=\"【Day21】993.二叉树的堂兄弟节点\"></a>【Day21】993.二叉树的堂兄弟节点</h2><h4 id=\"993-二叉树的堂兄弟节点\"><a href=\"#993-二叉树的堂兄弟节点\" class=\"headerlink\" title=\"993. 二叉树的堂兄弟节点\"></a><a href=\"https://leetcode-cn.com/problems/cousins-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>\n<p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>\n<p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p>\n<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\" alt></p>\n<pre><code>输入：root = [1,2,3,4], x = 4, y = 3\n输出：false</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\" alt></p>\n<pre><code>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出：true</code></pre><p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\" alt></p>\n<pre><code>输入：root = [1,2,3,null,4], x = 2, y = 3\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>二叉树的节点数介于 2 到 100 之间。</li>\n<li>每个节点的值都是唯一的、范围为 1 到 100 的整数。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>假设从根节点开始编号1，依次往后编号，其两个孩子是<code>2*n</code>与<code>2*n+1</code>。反过来便是根据两个孩子节点判断是否是同一个父亲，那便是直接除以2，向下取整，看两者是否一样即可。</p>\n<p>例如：2、3是同一父亲，2、4不是。</p>\n<p>在BFS过程中记录节点编号以及x、y节点，最后判断即可。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    bool isCousins(TreeNode* root, int x, int y) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int cnt = 1;\n        while (q.size()) {\n            int sz = q.size();\n            bool xt = false, yt = false;\n            int xcnt, ycnt;\n            while (sz--) {\n                auto p = q.front();\n                q.pop();\n                if (p) {\n                    if (x == p->val) {\n                        xt = true;\n                        xcnt = cnt;\n                    }\n                    if (y == p->val) { \n                        yt = true;\n                        ycnt = cnt;\n                    }\n\n                    if (xt && yt && int(xcnt / 2) != int(ycnt / 2) ) {\n                        return true;\n                    }\n                    q.push(p->left); q.push(p->right);\n                }\n                cnt++;\n            }\n        }\n        return false;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day22】1442-形成两个异或相等数组的三元组数目\"><a href=\"#【Day22】1442-形成两个异或相等数组的三元组数目\" class=\"headerlink\" title=\"【Day22】1442.形成两个异或相等数组的三元组数目\"></a>【Day22】1442.形成两个异或相等数组的三元组数目</h2><h4 id=\"1442-形成两个异或相等数组的三元组数目\"><a href=\"#1442-形成两个异或相等数组的三元组数目\" class=\"headerlink\" title=\"1442. 形成两个异或相等数组的三元组数目\"></a><a href=\"https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/\" target=\"_blank\" rel=\"noopener\">1442. 形成两个异或相等数组的三元组数目</a></h4><p> 给你一个整数数组 arr 。</p>\n<p>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。</p>\n<p>a 和 b 定义如下：</p>\n<ul>\n<li>a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>\n<li>b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>\n</ul>\n<p>注意：^ 表示 按位异或 操作。</p>\n<p>请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [2,3,1,6,7]\n输出：4\n解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [1,1,1,1,1]\n输出：10</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：arr = [2,3]\n输出：0</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：arr = [1,3,5,7,9]\n输出：3</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：arr = [7,11,12,9,5,2,7,17,22]\n输出：8</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= arr.length &lt;= 300</li>\n<li>1 &lt;= arr[i] &lt;= 10^8</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>∵   a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</p>\n<p>​     b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</p>\n<p>∴  arr[i] ^ arr[i + 1] ^ … ^ arr[k] = a ^ b = 0;</p>\n<p>a^b=0得到区间[i,k]中有k-i个元组，全部累加即可。区间内三元组的个数为 k - i（因为区间内的任意一个j，都和i，k组成满足题目的一个三元组）。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int countTriplets(vector<int>& arr) {\n        int ans = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            int s = arr[i];\n            for (int k = i + 1; k < arr.size(); k++) {\n                s ^= arr[k];\n                if (s == 0) ans += k - i;\n            }\n        }\n        return ans;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day23】1738-找出第-K-大的异或坐标值\"><a href=\"#【Day23】1738-找出第-K-大的异或坐标值\" class=\"headerlink\" title=\"【Day23】1738.找出第 K 大的异或坐标值\"></a>【Day23】1738.找出第 K 大的异或坐标值</h2><h4 id=\"1738-找出第-K-大的异或坐标值\"><a href=\"#1738-找出第-K-大的异或坐标值\" class=\"headerlink\" title=\"1738. 找出第 K 大的异或坐标值\"></a><a href=\"https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/\" target=\"_blank\" rel=\"noopener\">1738. 找出第 K 大的异或坐标值</a></h4><p>给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。</p>\n<p>矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>\n<p>请你找出 matrix 的所有坐标中第 k 大的值（<strong>k 的值从 1 开始计数</strong>）。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 1\n输出：7\n解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 2\n输出：5\n解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 3\n输出：4\n解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 4\n输出：0\n解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>m == matrix.length</li>\n<li>n == matrix[i].length</li>\n<li>1 &lt;= m, n &lt;= 1000</li>\n<li>0 &lt;= matrix[i][j] &lt;= 106</li>\n<li>1 &lt;= k &lt;= m * n</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>二维差分+最小堆</strong></p>\n<p>前缀和模板+维护k个元素的最小堆</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int prefix[1000][1000];\n    int kthLargestValue(vector<vector<int>>& matrix, int k) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        prefix[0][0] = matrix[0][0];\n        // 处理第一行\n        for (int i = 1; i < n; i++) {\n            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];\n        }\n        // 处理第一列\n        for (int i = 1; i < m; i++) {\n            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];\n            }\n        }\n\n        priority_queue<int, vector<int>, std::greater<int>> pq;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                pq.push(prefix[i][j]);\n                if (pq.size() > k) pq.pop();\n            }\n        }\n        return pq.top();\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>二分搜值</strong></p>\n<p>每次猜测一个值x，然后遍历前缀和矩阵，统计有多少个元素大于等于x，如果count小于k，那么x肯定不可能是答案，我们将猜测的上界下调至x-1；否则，我们就将猜测的下界调整至x。可以看到问题可以转换为查找最后一个小于等于target的数。因为当查找到大于等于target时要往上不断压缩区间，直到小于等于k为止。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int prefix[1000][1000];\n    int m, n;\n    int kthLargestValue(vector<vector<int>>& matrix, int k) {\n        m = matrix.size();\n        n = matrix[0].size();\n        prefix[0][0] = matrix[0][0];\n        // 处理第一行\n        for (int i = 1; i < n; i++) {\n            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];\n        }\n        // 处理第一列\n        for (int i = 1; i < m; i++) {\n            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];\n            }\n        }\n\n        int left = 0, right = 1e6;\n        while (left < right) {\n            int mid = right - (right - left - 1) / 2;\n            if (count(mid) < k) { // 缩小值\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n    int count (int mid) {\n        int cnt = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (prefix[i][j] >= mid) cnt++;\n            }\n        }\n        return cnt;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day24】692-前K个高频单词\"><a href=\"#【Day24】692-前K个高频单词\" class=\"headerlink\" title=\"【Day24】692.前K个高频单词\"></a>【Day24】692.前K个高频单词</h2><h4 id=\"692-前K个高频单词\"><a href=\"#692-前K个高频单词\" class=\"headerlink\" title=\"692. 前K个高频单词\"></a><a href=\"https://leetcode-cn.com/problems/top-k-frequent-words/\" target=\"_blank\" rel=\"noopener\">692. 前K个高频单词</a></h4><p>给一非空的单词列表，返回前 k 个出现次数最多的单词。</p>\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2\n输出: [&quot;i&quot;, &quot;love&quot;]\n解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4\n输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]\n解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。</code></pre><p><strong>注意：</strong></p>\n<ul>\n<li>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。</li>\n<li>输入的单词均由小写字母组成。</li>\n</ul>\n<p><strong>扩展练习：</strong></p>\n<blockquote>\n<p>尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">struct Cmp {\n    bool operator()(const pair<string, int>& p1, const pair<string, int>& p2) {\n        if(p1.second != p2.second) return p1.second > p2.second;\n        else return p1.first < p2.first;\n    }\n};\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> m;\n        for(string& word : words) m[word]++;\n        vector<pair<string, int>> sorted_list(m.begin(), m.end());\n        sort(sorted_list.begin(), sorted_list.end(), Cmp());\n        vector<string> res;\n        for(int i = 0; i < k; i++) res.push_back(sorted_list[i].first);\n        return res;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day25】1035-不相交的线\"><a href=\"#【Day25】1035-不相交的线\" class=\"headerlink\" title=\"【Day25】1035.不相交的线\"></a>【Day25】1035.不相交的线</h2><h4 id=\"1035-不相交的线\"><a href=\"#1035-不相交的线\" class=\"headerlink\" title=\"1035. 不相交的线\"></a><a href=\"https://leetcode-cn.com/problems/uncrossed-lines/\" target=\"_blank\" rel=\"noopener\">1035. 不相交的线</a></h4><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>\n<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p>\n<ul>\n<li>nums1[i] == nums2[j]</li>\n<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>\n</ul>\n<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>\n<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png\" alt></p>\n<pre><code>输入：nums1 = [1,4,2], nums2 = [1,2,4]\n输出：2\n解释：可以画出两条不交叉的线，如上图所示。 \n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n输出：3</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums1.length &lt;= 500</li>\n<li>1 &lt;= nums2.length &lt;= 500</li>\n<li>1 &lt;= nums1[i], nums2[i] &lt;= 2000</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    vector<vector<int>> dp;\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size();\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        return dp[n][m];\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day26】810-黑板异或游戏\"><a href=\"#【Day26】810-黑板异或游戏\" class=\"headerlink\" title=\"【Day26】810.黑板异或游戏\"></a>【Day26】810.黑板异或游戏</h2><h4 id=\"810-黑板异或游戏\"><a href=\"#810-黑板异或游戏\" class=\"headerlink\" title=\"810. 黑板异或游戏\"></a><a href=\"https://leetcode-cn.com/problems/chalkboard-xor-game/\" target=\"_blank\" rel=\"noopener\">810. 黑板异或游戏</a></h4><p>黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p>\n<p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>\n<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入: nums = [1, 1, 2]\n输出: false\n解释: \nAlice 有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= N &lt;= 1000</li>\n<li>0 &lt;= nums[i] &lt;= 2^16</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    bool xorGame(vector<int>& nums) {\n        //数组元素个数是奇数/偶数，有决定性作用：\n        //如果是偶数，先手必胜；\n        //如果是奇数，只有当一上来所有元素异或的结果为0，先手才获胜，\n        //否则，接下来轮到后手，此时元素个数为偶数，则后手必胜，先手必败！\n        int len = nums.size(), t = 0;\n        if(len % 2)\n        {\n            for(auto& x:nums) t ^= x; //所有元素异或的结果\n            if(t) return false;\n            else return true;\n        }\n        else return true;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day27】1707-与数组中元素的最大异或值\"><a href=\"#【Day27】1707-与数组中元素的最大异或值\" class=\"headerlink\" title=\"【Day27】1707.与数组中元素的最大异或值\"></a>【Day27】1707.与数组中元素的最大异或值</h2><h4 id=\"1707-与数组中元素的最大异或值\"><a href=\"#1707-与数组中元素的最大异或值\" class=\"headerlink\" title=\"1707. 与数组中元素的最大异或值\"></a><a href=\"https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/\" target=\"_blank\" rel=\"noopener\">1707. 与数组中元素的最大异或值</a></h4><p>给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。</p>\n<p>第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] &lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。</p>\n<p>返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n输出：[3,3,7]\n解释：\n1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n输出：[15,-1,5]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length, queries.length &lt;= 105</li>\n<li>queries[i].length == 2</li>\n<li>0 &lt;= nums[j], xi, mi &lt;= 109</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">const int N = 1e5 + 50, M = 32 * N;\nint son[M][2];\nint idx;\n\nvoid insert(int x){\n    int p = 0;\n    for(int i = 31; i >= 0; i--){\n        int u = (x >> i) & 1;\n        if(!son[p][u]) son[p][u] = ++idx;\n        p = son[p][u];\n    }\n}\nint query(int x){\n    int ans = 0, p = 0;\n    for(int i = 31; i >= 0; i--){\n        int u = (x >> i) & 1;\n        if(son[p][!u]) {\n            ans += (1 << i);\n            p = son[p][!u];\n        }\n        else p = son[p][u];\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\n        memset(son,0,sizeof son);\n        idx = 0;\n        sort(nums.begin(),nums.end());\n        //离线思想，因此需要对queries加一个pos，因为回答是乱序的\n        int pos = 0;\n        for(auto& q: queries){\n            q.push_back(pos++);\n        }\n        sort(queries.begin(),queries.end(),[](const auto& a,const auto& b){\n            return a[1] < b[1];\n        });\n        vector<int> ans(queries.size());\n        int cur = 0;\n        for(const auto& q : queries){\n            int xi = q[0], mi = q[1],id = q[2];\n            while(cur < nums.size() and nums[cur] <= mi){\n                insert(nums[cur]);\n                cur++;\n            }\n            if(cur == 0) ans[id] = -1;\n            else ans[id] = query(xi);\n        }\n        return ans;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day28】664-奇怪的打印机\"><a href=\"#【Day28】664-奇怪的打印机\" class=\"headerlink\" title=\"【Day28】664.奇怪的打印机\"></a>【Day28】664.奇怪的打印机</h2><h4 id=\"664-奇怪的打印机\"><a href=\"#664-奇怪的打印机\" class=\"headerlink\" title=\"664. 奇怪的打印机\"></a><a href=\"https://leetcode-cn.com/problems/strange-printer/\" target=\"_blank\" rel=\"noopener\">664. 奇怪的打印机</a></h4><p>有台奇怪的打印机有以下两个特殊要求：</p>\n<ul>\n<li>打印机每次只能打印由 同一个字符 组成的序列。</li>\n<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>\n</ul>\n<p>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;aaabbb&quot;\n输出：2\n解释：首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;aba&quot;\n输出：2\n解释：首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 &#39;a&#39;。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= s.length &lt;= 100</li>\n<li>s 由小写英文字母组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>区间dp问题，对于[i,j]区间i&lt;j，如果s[i] == s[j]，那么dp[i][j] = dp[i - 1][j] 或者dp[i + 1][j]，例如：aba 等于 ab或者 ba</p>\n<p>如果s[i]!=s[j]，那么对于区间[i,j]的所有组合，进行累加求min即可。</p>\n<p>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])</p>\n<p>目标是求dp[0][n - 1]，因此，对于这道题有两种遍历方式。</p>\n<p><strong>第一种：从下往上，从左到右。</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int strangePrinter(string s) {\n        // aba\n        // aaabbb\n        int n = s.size();\n        int dp[n][n];\n        memset(dp, 0x3f3f3f3f, sizeof(dp));\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    for (int k = i; k < j; k++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }     \n        return dp[0][n - 1];\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>第二种：斜着遍历。</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int strangePrinter(string s) {\n        // aba\n        // aaabbb\n        int n = s.size();\n        int dp[n][n];\n        memset(dp, 0x3f3f3f3f, sizeof(dp));\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int l = 2; l <= n; l++) {\n            for (int i = 0; i < n - l + 1; i++) {\n                int j = l + i - 1;\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    for (int k = i; k < j; k++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }\n\n\n        return dp[0][n - 1];\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day29】1787-使所有区间的异或结果为零\"><a href=\"#【Day29】1787-使所有区间的异或结果为零\" class=\"headerlink\" title=\"【Day29】1787.使所有区间的异或结果为零\"></a>【Day29】1787.使所有区间的异或结果为零</h2><h4 id=\"1787-使所有区间的异或结果为零\"><a href=\"#1787-使所有区间的异或结果为零\" class=\"headerlink\" title=\"1787. 使所有区间的异或结果为零\"></a><a href=\"https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/\" target=\"_blank\" rel=\"noopener\">1787. 使所有区间的异或结果为零</a></h4><p>给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left &lt;= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR … XOR nums[right] 。</p>\n<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 k 的区间异或结果等于零。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [1,2,0,3,0], k = 1\n输出：3\n解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [3,4,5,2,1,7,3,4,7], k = 3\n输出：3\n解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [1,2,4,1,2,5,1,2,6], k = 3\n输出：3\n解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li><p>1 &lt;= k &lt;= nums.length &lt;= 2000</p>\n</li>\n<li><p>0 &lt;= nums[i] &lt; 210</p>\n<p><strong>题解：</strong></p>\n</li>\n</ul>\n<p>第一种情况采用贪心的方法求得最优解。因为修改后的元素可能是原序列中没有出现过的元素。如果修改的某一列的元素是原序列中没有出现过的元素，那么这种情况下一定可以用贪心的办法求出最优解，做法是将众数最小的一列中的每个数变成一个全新的，该列中没有出现的，使得每个周期内的元素的异或和为0的数。</p>\n<p>第二种情况采用dp的方法求得最优解在这种情况下，由于没有最终修改后的元素是原数组中存在的数，因此可以从前往后枚举每一列，然后枚举选择第几行的数作为这列元素修改后的元素，由于异或具有交换性质，因此不具有顺序的问题，所以可以采用dp的方法递推出将序列变成数组中本来存在的某个数的情况。边界，f[0] [0] = 0，目标状态是f[k] [0]，状态表示f[i] [j]为前i列异或和为j的情况下的最小值。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    // 1.某一列用了一个全新的数\n    // 2.每一列用了原来的数\n\n    const int N = 1024, INF = 1e8;\n    int s[1024]; // 求众数\n    int minChanges(vector<int>& nums, int k) {\n        int n = nums.size(), m = (n + k - 1) / k;\n        vector<vector<int>> f(k + 1, vector<int>(N, INF));\n        int cnt = 0, minv = INF; // 每一列代价\n        // f[i][j] 第i列的异或和为j\n        f[0][0] = 0;\n        for (int i = 1; i <= k; i++) {\n            int len = m;\n            memset(s, 0 , sizeof s);\n            if (n % k && n % k < i) len--;\n            for (int j = 0; j < len; j ++) {\n                s[nums[j * k + i - 1]]++;\n            }\n            int maxv = 0;\n            for (int j = 0; j < N; j++) {\n                maxv = max(maxv, s[j]);\n            }\n            cnt += len - maxv;\n            minv = min(minv, maxv); // 众数最少的那一列  不用众数  而用全新的数\n\n            for (int j = 0; j < N; j++) { // 异或和为j\n                for (int u = 0; u < len; u++) { // 每一行\n                    int x = nums[u * k + i - 1], cost = len - s[x];\n                    f[i][j] = min(f[i][j], f[i - 1][j ^ x] + cost);\n                }\n            }\n        }\n        // cnt: 每一列的代价\n        // minv表示 某一列不用众数时的代价 si - maxv -> si 变成全新的数代价\n        return min(cnt + minv, f[k][0]);\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day30】1190-反转每对括号间的子串\"><a href=\"#【Day30】1190-反转每对括号间的子串\" class=\"headerlink\" title=\"【Day30】1190.反转每对括号间的子串\"></a>【Day30】1190.反转每对括号间的子串</h2><h4 id=\"1190-反转每对括号间的子串\"><a href=\"#1190-反转每对括号间的子串\" class=\"headerlink\" title=\"1190. 反转每对括号间的子串\"></a><a href=\"https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/\" target=\"_blank\" rel=\"noopener\">1190. 反转每对括号间的子串</a></h4><p>给出一个字符串 s（仅含有小写英文字母和括号）。</p>\n<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>\n<p><strong>注意，您的结果中 不应 包含任何括号。</strong></p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;(abcd)&quot;\n输出：&quot;dcba&quot;</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;(u(love)i)&quot;\n输出：&quot;iloveu&quot;</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;(ed(et(oc))el)&quot;\n输出：&quot;leetcode&quot;</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;\n输出：&quot;apmnolkjihgfedcbq&quot;</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>0 &lt;= s.length &lt;= 2000</li>\n<li>s 中只有小写英文字母和括号</li>\n<li>我们确保所有括号都是成对出现的</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><img src=\"https://cdn.acwing.com/media/article/image/2021/05/26/30502_ed3e6737bd-aa.gif\" alt></p>\n<p>挨个遍历， 左括号和普通字符直接入栈；遇到右括号 ，就依次出栈直到栈顶为左括号 ，出栈的这些字符按出栈顺序链接自然也就是逆序的，然后栈顶左括号出栈 把组合成的逆序串重新压入栈。</p>\n<p>遍历完字符串 栈中从栈底到栈顶 自然也就想要的结果，如果依次出栈 要注意连接顺序，还需要一次整体反转。</p>\n<p><strong>代码：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    string reverseParentheses(string s) {\n        stack<char> st;\n        for (auto c : s) {\n            if (c != ')') {\n                st.push(c);\n            } else {\n                string tmp;\n                while (st.top() != '(') {\n                    tmp += st.top();\n                    st.pop();\n                }\n                st.pop();\n                for (auto s : tmp) {\n                    st.push(s);\n                }\n            }\n        }\n        string ans;\n        while (!st.empty()) {\n            ans = st.top() + ans; st.pop();\n        }\n        return ans;\n    }\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>几天刚好一个月结束啦，收获还是很多的，困难我唯唯诺诺，简单重拳出击！！！hhh~</p>\n","excerpt":"","more":"<p><strong>最近决定巩固一下算法，开始刷leetcode每日一题，具体刷多久还不知道，刚开始是有点吃力，慢慢来。</strong></p>\n<h2 id=\"【Day01】938-二叉搜索树的范围和\"><a href=\"#【Day01】938-二叉搜索树的范围和\" class=\"headerlink\" title=\"【Day01】938.二叉搜索树的范围和\"></a>【Day01】938.二叉搜索树的范围和</h2><p><strong>题目：</strong></p>\n<p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>\n<p><strong>示例1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg\" alt></p>\n<pre><code>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15\n输出：32</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg\" alt></p>\n<pre><code>输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n输出：23</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 [1, 2 * 104] 内</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>1 &lt;= low &lt;= high &lt;= 105</li>\n<li>所有 Node.val 互不相同</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>递归</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (!root) return 0;\n        int sum = 0;\n        sum += rangeSumBST(root-&gt;left, low, high);\n        if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) sum += root-&gt;val;\n        sum += rangeSumBST(root-&gt;right, low, high);\n        return sum;\n    }\n};</code></pre>\n<p><strong>非递归</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (!root) return 0;\n        queue&lt;TreeNode*&gt; q;\n        TreeNode* p = root;\n        int sum = 0;\n        while (p || q.size()) {\n            while (p) {\n                q.push(p);\n                p = p-&gt;left;\n            }\n            if (q.size()) {\n                p = q.front();\n                q.pop();\n                if (p-&gt;val &gt;= low &amp;&amp; p-&gt;val &lt;= high) {\n                    sum += p-&gt;val;\n                }\n                p = p-&gt;right;       \n            }    \n        }\n        return sum;\n    }\n};</code></pre>\n<h2 id=\"【Day02】633-平方数之和\"><a href=\"#【Day02】633-平方数之和\" class=\"headerlink\" title=\"【Day02】633.平方数之和\"></a>【Day02】633.平方数之和</h2><p><strong>题目：</strong></p>\n<p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：c = 5\n输出：true\n解释：1 * 1 + 2 * 2 = 5</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：c = 3\n输出：false</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：c = 4\n输出：true</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：c = 2\n输出：true</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：c = 1\n输出：true</code></pre><p><strong>枚举</strong></p>\n<p>对 a 从 0 开始到 n√n 枚举，然后判断是否存在 b。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        for (int i = 0; (long long)(i) * i &lt;= c; i++) {\n            int j = sqrt(c - i * i);\n            if (i * i + j * j == c)\n                return true;\n        }\n        return false;\n    }\n};</code></pre>\n<p><strong>预处理+查询</strong></p>\n<p>如果存在符合条件的a，b，那么a和b一定在1和sqrt(c)之间。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    typedef unsigned long long ULL;\n    bool judgeSquareSum(int c) {\n        if (c == 0) return true;\n        unordered_map&lt;ULL, ULL&gt; um;\n        for (int i = 1; i &lt;= sqrt(c); i++) {\n            um[i*i]++;\n        }\n\n        for (int i = 1; i &lt;= sqrt(c); i++) {\n            if (i*i == c || um.count(c - i*i)) return true;\n        }\n        return false;\n    }\n};</code></pre>\n<p><strong>双指针</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        int j = sqrt(c);\n        int i = 0;\n        while (i &lt;= j) {\n            if (i*i &gt; c - j*j) {\n                j--;\n            } else if (i*i &lt; c - j*j) {\n                i++;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n};</code></pre>\n<h2 id=\"【Day03】403-青蛙过河\"><a href=\"#【Day03】403-青蛙过河\" class=\"headerlink\" title=\"【Day03】403.青蛙过河\"></a>【Day03】403.青蛙过河</h2><h3 id=\"403-青蛙过河\"><a href=\"#403-青蛙过河\" class=\"headerlink\" title=\"403. 青蛙过河\"></a><a href=\"https://leetcode-cn.com/problems/frog-jump/\" target=\"_blank\" rel=\"noopener\">403. 青蛙过河</a></h3><p><strong>题目描述：</strong></p>\n<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>\n<p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>\n<p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p>\n<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>\n<p>  <strong>示例 1：</strong></p>\n<pre><code>输入：stones = [0,1,3,5,6,8,12,17]\n输出：true\n解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：stones = [0,1,2,3,4,8,9,11]\n输出：false\n解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>2 &lt;= stones.length &lt;= 2000</li>\n<li>0 &lt;= stones[i] &lt;= 231 - 1</li>\n<li>stones[0] == 0</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>递归:</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    unordered_map&lt;int, int&gt; um;\n    bool canCross(vector&lt;int&gt;&amp; stones) {\n\n        for (int i = 0; i &lt; stones.size(); i++) {\n            um[stones[i]] = i;  // key:石子值 value是第几块石子\n        }\n        if (!um.count(1)) return false;\n        return dfs(stones, stones.size(), 1, 1);\n    }\n    bool dfs(vector&lt;int&gt;&amp; stones, int n, int cur, int k) {\n        if (cur == n - 1) return true;\n        for (int i = -1; i &lt;= 1; i++) {\n            if (k + i == 0) continue;\n            int next = stones[cur] + k + i;\n            if (um.count(next)) { // 存在\n                bool choose = dfs(stones, n, um[next], k + i);\n                if (choose) return true;\n            }\n        }\n        return false;\n    }\n\n};</code></pre>\n<p><strong>dfs记忆化搜索:</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    unordered_map&lt;int, int&gt; um;\n    vector&lt;vector&lt;int&gt;&gt; memo;\n    bool canCross(vector&lt;int&gt;&amp; stones) {\n\n        for (int i = 0; i &lt; stones.size(); i++) {\n            um[stones[i]] = i;  // key:石子值 value是第几块石子\n        }\n        if (!um.count(1)) return false;\n        memo = vector&lt;vector&lt;int&gt;&gt;(stones.size(), vector&lt;int&gt;(stones.size(), -1));\n        return dfs(stones, stones.size(), 1, 1);\n    }\n    bool dfs(vector&lt;int&gt;&amp; stones, int n, int cur, int k) {\n        if (memo[cur][k] != -1) return memo[cur][k];\n        if (cur == n - 1) return memo[cur][k] = true;\n        for (int i = -1; i &lt;= 1; i++) {\n            if (k + i == 0) continue;  // 原地跳过\n            int next = stones[cur] + k + i;\n            if (um.count(next)) { // 存在\n                bool choose = dfs(stones, n, um[next], k + i);\n                if (choose) return memo[cur][k] = true;\n            }\n        }\n        return memo[cur][k] = false;\n    }\n\n};</code></pre>\n<p><strong>动态规划：</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    bool canCross(vector&lt;int&gt;&amp; stones) {\n        int n = stones.size();\n        if (stones[1] != 1) return false;\n        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n));\n        // dp[i][k] 表示在第i个位置且跳k个单位到第i块石子。\n        dp[1][1] = true;\n        for (int i = 2; i &lt; n; i++) {\n            for (int j = 1; j &lt; i; j++) {\n                int k = stones[i] - stones[j];\n                if (k &gt; j + 1) continue;\n                // 因为题目要求 青蛙第一次只能跳1步，那么第二次至多跳2步，以此类推，青蛙在第i块（i从0开始）石头上至多只能跳i+1步。在第j块石头上至多只能跳 j+1 步 ，如果k &gt; j+1，说明石头 i 隔石头 j 太远了，远到不满足题目的隐藏规则，所以青蛙必定跳不过去。\n                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k+1];\n            }\n        }\n        for (int i = 1; i &lt; n; i++) {\n            if (dp[n-1][i]) return true;\n        }        \n        return false;\n    }\n};</code></pre>\n<p><strong>另一种动态规划:</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    bool canCross(vector&lt;int&gt;&amp; stones) {\n        // dp[i][j] 表示 第 i 个石头是否可以跳 j 步\n        int n = stones.size();\n        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n));\n        dp[0][1] = true;\n        for (int i = 1; i &lt; n; i++) {\n            bool flag = false;\n            for (int j = i - 1; j &gt;= 0; j--) {\n                int k = stones[i] - stones[j];\n                if (k &gt; i) break;\n                if (dp[j][k]) {\n                    dp[i][k - 1] = dp[i][k] = dp[i][k + 1] = true;\n                    flag = true;\n                }\n            }\n            if (i == n - 1 &amp;&amp; !flag) {\n                return false;\n            }\n        }\n        return true;\n    }\n};</code></pre>\n<h2 id=\"【Day04】137-只出现一次的数字II\"><a href=\"#【Day04】137-只出现一次的数字II\" class=\"headerlink\" title=\"【Day04】137.只出现一次的数字II\"></a>【Day04】137.只出现一次的数字II</h2><h4 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137. 只出现一次的数字 II\"></a><a href=\"https://leetcode-cn.com/problems/single-number-ii/\" target=\"_blank\" rel=\"noopener\">137. 只出现一次的数字 II</a></h4><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n<p> <strong>示例1：</strong></p>\n<pre><code>输入：nums = [2,2,3,2]\n输出：3</code></pre><p><strong>示例2：</strong></p>\n<pre><code>输入：nums = [0,1,0,1,0,1,99]\n输出：99</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 3 * 104</li>\n<li>-231 &lt;= nums[i] &lt;= 231 - 1</li>\n<li>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p> <strong>有限状态自动机：</strong></p>\n<p>使用二进制表示每个元素，对应二进制位的1相加，最后相加对3取余</p>\n<p>对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0,1,2 。由于二进制只能表示 0, 10,1 ，因此需要使用两个二进制位来表示 3 个状态。设此两位分别为 one，two.</p>\n<p><strong>计算 one方法：</strong></p>\n<p>设当前状态为 one ，two 此时输入二进制位 nn 。如下图所示，通过对状态表的情况拆分，可推出 one的计算方法为：</p>\n<pre><code>if two == 0:\n  if n == 0:\n    one = one\n  if n == 1:\n    one = ~one\nif two == 1:\n    one = 0</code></pre><p>引入 异或运算 ，可将以上拆分简化为：</p>\n<pre><code>if two == 0:\n    one = one ^ n\nif two == 1:\n    one = 0</code></pre><p>引入 与运算 ，可继续简化为：</p>\n<pre><code>one = one ^ n &amp; ~two</code></pre><p>同理：</p>\n<pre><code>two = two ^ n &amp; ~one</code></pre><p>代码：</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int two = 0, one = 0;\n        for (auto x: nums) {\n            one = (one ^ x) &amp; ~two;\n            two = (two ^ x) &amp; ~one;\n        }\n        return one;\n    }\n};</code></pre>\n<p><strong>哈希表：</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; um;\n        for (auto x : nums) {\n            um[x]++;\n        }\n\n        for (auto x : um) {\n            if (x.second == 1) return x.first;\n        }\n        return -1;\n    }\n};</code></pre>\n<h2 id=\"【Day05】690-员工的重要性\"><a href=\"#【Day05】690-员工的重要性\" class=\"headerlink\" title=\"【Day05】690.员工的重要性\"></a>【Day05】690.员工的重要性</h2><h4 id=\"690-员工的重要性\"><a href=\"#690-员工的重要性\" class=\"headerlink\" title=\"690. 员工的重要性\"></a><a href=\"https://leetcode-cn.com/problems/employee-importance/\" target=\"_blank\" rel=\"noopener\">690. 员工的重要性</a></h4><p>给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。</p>\n<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。</p>\n<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出：11\n解释：\n员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>一个员工最多有一个 直系 领导，但是可以有多个 直系 下属</li>\n<li>员工数量不超过 2000 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>今天的题不是很难，直接遍历所有节点相加就行了，使用哈希表将id指向映射到指针，遍历一遍。</p>\n<p><strong>dfs</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    unordered_map&lt;int, Employee*&gt; hash;\n\n    int getImportance(vector&lt;Employee*&gt; employees, int id) {\n        for (auto&amp; p: employees) hash[p-&gt;id] = p;\n        return dfs(id);\n    }\n\n    int dfs(int id) {\n        auto p = hash[id];\n        int res = p-&gt;importance;\n        for (auto son: p-&gt;subordinates)\n            res += dfs(son);\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"【Day06】554-砖墙\"><a href=\"#【Day06】554-砖墙\" class=\"headerlink\" title=\"【Day06】554.砖墙\"></a>【Day06】554.砖墙</h2><h4 id=\"554-砖墙\"><a href=\"#554-砖墙\" class=\"headerlink\" title=\"554. 砖墙\"></a><a href=\"https://leetcode-cn.com/problems/brick-wall/\" target=\"_blank\" rel=\"noopener\">554. 砖墙</a></h4><p>你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。</p>\n<p>你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</p>\n<p>给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" alt></p>\n<pre><code>输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n输出：2</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：wall = [[1],[1],[1]]\n输出：3</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>n == wall.length</li>\n<li>1 &lt;= n &lt;= 104</li>\n<li>1 &lt;= wall[i].length &lt;= 104</li>\n<li>1 &lt;= sum(wall[i].length) &lt;= 2 * 104</li>\n<li>对于每一行 i ，sum(wall[i]) 应当是相同的</li>\n<li>1 &lt;= wall[i][j] &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>贪心，哈希表</strong></p>\n<p>显然最优的线一定是沿某个块砖的边缘穿过的。<br>统计每一行的砖可以从左到右可以构成的长度值，用 unordered_map 哈希表统计长度值出现的次数。出现次数最多的值就应该是这条线所在的位置。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int leastBricks(vector&lt;vector&lt;int&gt;&gt;&amp; wall) {\n        unordered_map&lt;int, int&gt; cnt;\n        for (auto&amp; line: wall) {\n            for (int i = 0, s = 0; i + 1 &lt; line.size(); i ++ ) {\n                s += line[i];\n                cnt[s] ++ ;\n            }\n        }\n        int res = 0;\n        for (auto [k, v]: cnt) res = max(res, v);\n        return wall.size() - res;\n    }\n};\n</code></pre>\n<h2 id=\"【Day07】7-整数反转7-整数反转\"><a href=\"#【Day07】7-整数反转7-整数反转\" class=\"headerlink\" title=\"【Day07】7.整数反转7. 整数反转\"></a>【Day07】7.整数反转<a href=\"https://leetcode-cn.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">7. 整数反转</a></h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>\n<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>\n<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：x = 123\n输出：321</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：x = -123\n输出：-321</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：x = 120\n输出：21</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：x = 0\n输出：0</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>-231 &lt;= x &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>(循环) O(logn)</strong><br>依次从右往左计算出每位数字，然后逆序累加在一个整数中。<br>另外，这题有两点需要注意：</p>\n<ul>\n<li><p>因为int型整数逆序后可能会溢出，所以我们要用long long记录中间结果；</p>\n</li>\n<li><p>在C++中，负数的取模运算和数学意义上的取模运算不同，结果还是负数，比如 −12%10=−2−12%10=−2，所以我们不需要对负数进行额外处理。</p>\n</li>\n</ul>\n<p>时间复杂度分析：一共有 O(logn) 位，对于每一位的计算量是常数级的，所以总时间复杂度是  O(logn)</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int reverse(int x) {\n        int res = 0;\n        while (x) {\n            if (x &gt; 0 &amp;&amp; res &gt; (INT_MAX - x % 10) / 10) return 0;\n            if (x &lt; 0 &amp;&amp; res &lt; (INT_MIN - x % 10) / 10) return 0;\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        return res;\n    }\n};\n</code></pre>\n<h2 id=\"【Day08】1473-粉刷房子III\"><a href=\"#【Day08】1473-粉刷房子III\" class=\"headerlink\" title=\"【Day08】1473.粉刷房子III\"></a>【Day08】1473.粉刷房子III</h2><h4 id=\"1473-粉刷房子-III\"><a href=\"#1473-粉刷房子-III\" class=\"headerlink\" title=\"1473. 粉刷房子 III\"></a><a href=\"https://leetcode-cn.com/problems/paint-house-iii/\" target=\"_blank\" rel=\"noopener\">1473. 粉刷房子 III</a></h4><p>在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p>\n<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）</p>\n<p>给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：</p>\n<ul>\n<li>houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。</li>\n<li>cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。</li>\n</ul>\n<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n输出：9\n解释：房子涂色方案为 [1,2,2,1,1]\n此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。\n涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n输出：11\n解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]\n此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。\n给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\n输出：5</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n输出：-1\n解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>m == houses.length == cost.length</li>\n<li>n == cost[i].length</li>\n<li>1 &lt;= m &lt;= 100</li>\n<li>1 &lt;= n &lt;= 20</li>\n<li>1 &lt;= target &lt;= m</li>\n<li>0 &lt;= houses[i] &lt;= n</li>\n<li>1 &lt;= cost[i][j] &lt;= 10^4</li>\n</ul>\n<p><strong>题解·：</strong></p>\n<p>很明显的DP</p>\n<ol>\n<li><p>设状态  f(i,j,k) 表示处理了前 i 个房屋，有 j 个社区，最后一个房屋的颜色为 k 的最小花费，其中房屋的有效下标从 1 开始。建立辅助数组 g(i,j,k) 表示同样含义下，最后一个房屋颜色 不是 k 的最小花费。</p>\n</li>\n<li><p>初始时，f(0,0,k)=g(0,0,k)=0，其余为正无穷或者待定。<br>转移时，分两种情况</p>\n</li>\n<li><p>如果第 i 个房屋已经有了颜色 c，则有两种选择，上一个房屋颜色为 c 或者不为 c，转移<br>$$<br>f(i, j, c)=\\min (f(i-1, j, c), g(i-1, j-1, c))<br>$$</p>\n</li>\n<li><p>如果第 i 个房屋没有颜色，则枚举一个颜色 k，然后同样根据上一个房屋的颜色，转移<br>$$<br>f(i, j, k)=\\min (f(i-1, j, k), g(i-1, j-1, k))+\\operatorname{cost}(i, k-1)_{\\text {。 }}<br>$$</p>\n</li>\n<li><p>对于 g 数组的维护如下，假设当前需要维护前 i 个房屋且有 j 个社区下的 g 数组，则我们找 f(i,j,k) 中的最小值 m1 和次小值 m2。如果 m1=m2，则说明对于所有 k， g(i,j,k)=m1；否则，对于 f(i,j,k0)=m1 的那个 k0，其 g(i,j,k0)=m2g，其余 k≠k0都有 g(i,j,k)=m1。</p>\n</li>\n<li><p>最终答案为<br>$$<br>\\min (f(m, \\text { target }, k)<br>$$</p>\n</li>\n</ol>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int minCost(vector&lt;int&gt;&amp; houses, vector&lt;vector&lt;int&gt;&gt;&amp; cost, int m, int n, int target) {\n        const int MAX = 0x3f3f3f3f;\n        const int M = 110;\n        const int N = 30;\n\n        int f[M][M][N], g[M][M][N];\n        memset(f, 0x3f, sizeof(f));\n        memset(g, 0x3f, sizeof(g));\n\n        for (int k = 1; k &lt;= n; k++)\n            f[0][0][k] = g[0][0][k] = 0;\n\n        for (int i = 1; i &lt;= m; i++)\n            for (int j = 1; j &lt;= min(i, target); j++) {\n                if (houses[i - 1] &gt; 0) {\n                    int c = houses[i - 1];\n                    f[i][j][c] = min(f[i - 1][j][c], g[i - 1][j - 1][c]);\n                } else {\n                    for (int k = 1; k &lt;= n; k++)\n                        f[i][j][k] = min(f[i - 1][j][k], g[i - 1][j - 1][k])\n                                        + cost[i - 1][k - 1];\n                }\n\n                int m1 = MAX, m2 = MAX;\n                for (int k = 1; k &lt;= n; k++)\n                    if (m1 &gt; f[i][j][k]) {\n                        m2 = m1;\n                        m1 = f[i][j][k];\n                    } else if (m2 &gt; f[i][j][k])\n                        m2 = f[i][j][k];\n\n                if (m1 == m2) {\n                    for (int k = 1; k &lt;= n; k++)\n                        g[i][j][k] = m1;\n                } else {\n                    for (int k = 1; k &lt;= n; k++)\n                        if (f[i][j][k] == m1) g[i][j][k] = m2;\n                        else g[i][j][k] = m1;\n                }\n            }\n\n        int ans = MAX;\n        for (int k = 1; k &lt;= n; k++)\n            ans = min(ans, f[m][target][k]);\n\n        if (ans == MAX)\n            ans = -1;\n\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"【Day09】740-删除并获得点数\"><a href=\"#【Day09】740-删除并获得点数\" class=\"headerlink\" title=\"【Day09】740.删除并获得点数\"></a>【Day09】740.删除并获得点数</h2><h4 id=\"740-删除并获得点数-https-leetcode-cn-com-problems-delete-and-earn\"><a href=\"#740-删除并获得点数-https-leetcode-cn-com-problems-delete-and-earn\" class=\"headerlink\" title=\"740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)\"></a>740. 删除并获得点数](<a href=\"https://leetcode-cn.com/problems/delete-and-earn/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/delete-and-earn/</a>)</h4><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>\n<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。</p>\n<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [3,4,2]\n输出：6\n解释：\n删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [2,2,3,3,3,4]\n输出：9\n解释：\n删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 2 * 104</li>\n<li>1 &lt;= nums[i] &lt;= 104</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>首先，我们先明确一个概念，就是每个位置上的数字是可以在两种前结果之上进行选择的：</p>\n<p>如果你不删除当前位置的数字，那么你得到就是前一个数字的位置的最优结果。<br>如果你觉得当前的位置数字i需要被删，那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数。<br>以上两个结果，你每次取最大的，记录下来，然后答案就是最后那个数字了。</p>\n<p>如果你看到现在有点迷糊，那么我们先把数字进行整理一下。</p>\n<p>我们在原来的 nums 的基础上构造一个临时的数组 all，这个数组，以元素的值来做下标，下标对应的元素是原来的元素的个数。</p>\n<p>举个例子：</p>\n<pre><code>nums = [2, 2, 3, 3, 3, 4]</code></pre><p>构造后：</p>\n<pre><code>all=[0, 0, 2, 3, 1];</code></pre><p>就是代表着 22 的个数有两个，33 的个数有 33 个，44 的个数有 11 个。</p>\n<p>其实这样就可以变成打家劫舍的问题了呗。</p>\n<p>我们来看看，打家劫舍的最优子结构的公式：</p>\n<p>$$<br>\\mathrm{dp}[\\mathrm{i}]=\\text { Math.max }(\\mathrm{d} \\mathrm{p}[\\mathrm{i}-1], \\mathrm{dp}[\\mathrm{i}-2]+\\mathrm{nums}[\\mathrm{i}])<br>$$<br>再来看看现在对这个问题的最优子结构公式：</p>\n<p>$$<br>\\mathrm{dp}[\\mathrm{i}]=\\text { Math.max }\\left(\\mathrm{dp}[\\mathrm{i}-1], \\mathrm{dp}[\\mathrm{i}-2]+\\mathrm{i}^{\\star} \\mathrm{all}[\\mathrm{i}]\\right)<br>$$</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int deleteAndEarn(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() &lt; 1) return 0;\n        int maxn = 0;\n        for(int it : nums)\n            maxn = max(maxn, it);\n        vector&lt;int&gt; cnt(maxn+1), dp(maxn+1);\n        for(int it : nums)\n            cnt[it]++;\n        dp[1] = cnt[1];\n        for(int i = 2; i &lt;= maxn; i++)\n            dp[i] = max(dp[i-1], dp[i-2] + cnt[i] * i);\n        return dp[maxn];\n    }\n};</code></pre>\n<h2 id=\"【Day10】1720-解码异或后的数组\"><a href=\"#【Day10】1720-解码异或后的数组\" class=\"headerlink\" title=\"【Day10】1720. 解码异或后的数组\"></a>【Day10】1720. 解码异或后的数组</h2><h4 id=\"1720-解码异或后的数组\"><a href=\"#1720-解码异或后的数组\" class=\"headerlink\" title=\"1720. 解码异或后的数组\"></a><a href=\"https://leetcode-cn.com/problems/decode-xored-array/\" target=\"_blank\" rel=\"noopener\">1720. 解码异或后的数组</a></h4><p>未知 整数数组 arr 由 n 个非负整数组成。</p>\n<p>经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。</p>\n<p>给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。</p>\n<p>请解码返回原数组 arr 。可以证明答案存在并且是唯一的。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：encoded = [1,2,3], first = 1\n输出：[1,0,2,1]\n解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：encoded = [6,2,7,3], first = 4\n输出：[4,2,0,7,4]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>2 &lt;= n &lt;= 104</li>\n<li>encoded.length == n - 1</li>\n<li>0 &lt;= encoded[i] &lt;= 105</li>\n<li>0 &lt;= first &lt;= 105</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>异或运算满足交换律和结合律；</p>\n<p>任意整数和自身做异或运算的结果都等于 0，即 x⊕x=0；</p>\n<p>任意整数和 0 做异或运算的结果都等于其自身，即 x⊕0=0⊕x=x。</p>\n<p>在等号两边同时异或 arr[i]</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) {\n        int n = encoded.size();\n        vector&lt;int&gt; arr(n + 1);\n        arr[0] = first;\n        for (int i = 0; i &lt; n; i ++)\n            arr[i + 1] = arr[i] ^ encoded[i];\n        return arr;\n    }\n};\n</code></pre>\n<h2 id=\"【Day11】1486-数组异或操作\"><a href=\"#【Day11】1486-数组异或操作\" class=\"headerlink\" title=\"【Day11】1486.数组异或操作\"></a>【Day11】1486.数组异或操作</h2><h4 id=\"1486-数组异或操作\"><a href=\"#1486-数组异或操作\" class=\"headerlink\" title=\"1486. 数组异或操作\"></a><a href=\"https://leetcode-cn.com/problems/xor-operation-in-an-array/\" target=\"_blank\" rel=\"noopener\">1486. 数组异或操作</a></h4><p>给你两个整数，n 和 start 。</p>\n<p>数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。</p>\n<p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 5, start = 0\n输出：8\n解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     &quot;^&quot; 为按位异或 XOR 运算符。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 4, start = 3\n输出：8\n解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 1, start = 7\n输出：7</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：n = 10, start = 5\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 1000</li>\n<li>0 &lt;= start &lt;= 1000</li>\n<li>n == nums.length</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int xorOperation(int n, int start)\n    {\n        int result = start, i;\n        for (i = 1; i &lt; n; i++)\n        {\n            result = result ^ (start + i * 2);\n        }\n        return result;\n    }\n};</code></pre>\n<h2 id=\"【Day12】1723-完成所有工作的最短时间\"><a href=\"#【Day12】1723-完成所有工作的最短时间\" class=\"headerlink\" title=\"【Day12】1723.完成所有工作的最短时间\"></a>【Day12】1723.完成所有工作的最短时间</h2><h4 id=\"1723-完成所有工作的最短时间\"><a href=\"#1723-完成所有工作的最短时间\" class=\"headerlink\" title=\"1723. 完成所有工作的最短时间\"></a><a href=\"https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/\" target=\"_blank\" rel=\"noopener\">1723. 完成所有工作的最短时间</a></h4><p>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。</p>\n<p>请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。</p>\n<p>返回分配方案中尽可能 最小 的 最大工作时间 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：jobs = [3,2,3], k = 3\n输出：3\n解释：给每位工人分配一项工作，最大工作时间是 3 。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：jobs = [1,2,4,7,8], k = 2\n输出：11\n解释：按下述方式分配工作：\n1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）\n2 号工人：4、7（工作时间 = 4 + 7 = 11）\n最大工作时间是 11 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= k &lt;= jobs.length &lt;= 12</li>\n<li>1 &lt;= jobs[i] &lt;= 107</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>回溯法+剪枝</strong></p>\n<p>用一个 vector<int> block 记录每个人分配到的工作量，尝试将一份工作分配给一个人，且它的工作时间不超过lim要求，之后开启递归分配下一项工作，尝试找到一个成功分配全部工作的路径</int></p>\n<p>递归深度为 n=jobs.length 工作数量，每次递归需要检测范围为 k 员工数量并开启分支，最坏情况下走满树时间复杂度为 O(k^n)<br>题设 1 &lt;= k &lt;= jobs.length &lt;= 12，最坏情况下 12^12 = 8.9E12，外面还套了一个二分，还要再乘 log12 = 3.xxxx，远超1s极限算量1E8</p>\n<p>因此我们需要考虑一些剪枝的方法，首先我们可以 sort 一下 jobs ，时长从大到小开始分配，进而能够更快的超出限制，被剪枝掉，其次是朴素写法中存在很多重复的路径</p>\n<p>例如对于第一份工作的分配，所有人工作时长全部是0，我们只需要分配一次</p>\n<pre><code>[t1,0,0,0,0]\n之后的\n[0,t1,0,0,0]\n...</code></pre><p>都是重复操作。</p>\n<p> 56号测试用例：</p>\n<pre><code>[5,5,4,4,4]\n2</code></pre><p>如果先将 5h 分配给两个人block [5,5]，之后分配4时，只需要走一次 [9,5]，后面的[5,9] 是重复操作</p>\n<p>由于jobs已排序，因此我们每次枚举到的 block[i] 应当和上一次不一样，才是没走过的路径，进而排除全0时的重复放置，或是出现相同工作时长分配时的重复放置</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int k;\n    vector&lt;int&gt;  block;\n    bool backtracking(vector&lt;int&gt;&amp; jobs,int id,int lim) {\n        if(id==-1) return true; //出口 全部放完了\n\n        bool res=false;\n        int last=INT_MIN; \n\n        for(int i=0;i&lt;k;++i) {\n            if(res) \n                break;\n            if(block[i]==last) \n                continue; //剪枝 因为jobs已排序所以应枚举和上一次不一样的结果\n\n            last=block[i];\n\n            if(block[i]&lt;=lim-jobs[id]){ //小心越界\n                block[i]+=jobs[id];\n                res = backtracking(jobs,id-1,lim);\n                block[i]-=jobs[id];\n            }\n        }\n        return res;\n    }\n    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) {\n        this-&gt;k = k;\n        int s=0; //区间左端点（最小）\n        int e=0; //区间右端点（最大）\n        int m;//中间\n        int n = jobs.size()-1;//起手下标\n        block = vector&lt;int&gt;(k,0); // 拷贝初始化\n        sort(jobs.begin(),jobs.end());    \n        s=jobs[n];//结果最小应是 jobs[i] 的最大值\n\n        for(auto i : jobs) { //最大应是 sum(jobs.begin(),jobs.end()) 小心越界\n            if(e&lt;=INT_MAX-i) e+=i;\n            else e=INT_MAX;\n        }        \n        while(s!=e) {\n            int m = (s+e)/2;\n            if(backtracking(jobs,n,m)) { //成功 尝试缩减区间\n                e=m;//m无法排除\n            }else {//失败 扩大\n                s=m+1;//m肯定不对最少加1\n            }\n        }\n        return s;\n    }\n};</code></pre>\n<h2 id=\"【Day13】1482-制作m束花所需的最少天数\"><a href=\"#【Day13】1482-制作m束花所需的最少天数\" class=\"headerlink\" title=\"【Day13】1482.制作m束花所需的最少天数\"></a>【Day13】1482.制作m束花所需的最少天数</h2><h4 id=\"1482-制作-m-束花所需的最少天数\"><a href=\"#1482-制作-m-束花所需的最少天数\" class=\"headerlink\" title=\"1482. 制作 m 束花所需的最少天数\"></a><a href=\"https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/\" target=\"_blank\" rel=\"noopener\">1482. 制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</p>\n<p>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。</p>\n<p>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。</p>\n<p>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1\n输出：3\n解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：bloomDay = [1,10,3,10,2], m = 3, k = 2\n输出：-1\n解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n输出：12\n解释：要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：bloomDay = [1000000000,1000000000], m = 1, k = 1\n输出：1000000000\n解释：需要等 1000000000 天才能采到花来制作花束</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n输出：9</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>bloomDay.length == n</li>\n<li>1 &lt;= n &lt;= 10^5</li>\n<li>1 &lt;= bloomDay[i] &lt;= 10^9</li>\n<li>1 &lt;= m &lt;= 10^6</li>\n<li>1 &lt;= k &lt;= n</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>假设制作m束花需要等待的最少天数是x天，那么有：</p>\n<ul>\n<li>[0, x)天无法制作出来m束</li>\n<li>[x,maxDay]可以制作出m束</li>\n</ul>\n<p>求出给定花开数组中最大值，进行二分计算即可。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) {\n        int n = bloomDay.size();\n        if (m * k  &gt; n) return -1;\n        int l = 0, r = 0;\n        for (auto x : bloomDay) {\n            r = max(r, x);\n        }\n        while(l &lt; r) {\n            int mid = l + r &gt;&gt; 1;\n            if (check(bloomDay, mid, m, k)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n    bool check(vector&lt;int&gt;&amp; bloomDay, int mid, int m, int k) {\n        int sum = 0;\n        // 计算是否满足m束花且每一束都有相邻的k个\n        for (int i = 0; i &lt; bloomDay.size() &amp;&amp; sum &lt; m; i++) {\n            int cur_sum = 0;\n            if (bloomDay[i] &lt;= mid) { // 可以开\n                cur_sum++;\n                int j = i + 1;\n                while (j &lt; bloomDay.size() &amp;&amp; bloomDay[j] &lt;= mid &amp;&amp; cur_sum &lt; k) {\n                    j++;\n                    cur_sum++;\n                }\n                if (cur_sum == k) sum++;\n                i = j - 1;\n            } \n        }\n        return sum &gt;= m;\n    }\n};</code></pre>\n<h2 id=\"【Day14】872-叶子相似的树\"><a href=\"#【Day14】872-叶子相似的树\" class=\"headerlink\" title=\"【Day14】872.叶子相似的树\"></a>【Day14】872.叶子相似的树</h2><h4 id=\"872-叶子相似的树\"><a href=\"#872-叶子相似的树\" class=\"headerlink\" title=\"872. 叶子相似的树\"></a><a href=\"https://leetcode-cn.com/problems/leaf-similar-trees/\" target=\"_blank\" rel=\"noopener\">872. 叶子相似的树</a></h4><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" alt></p>\n<p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。</p>\n<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p>\n<p>如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" alt></p>\n<pre><code>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n输出：true</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：root1 = [1], root2 = [1]\n输出：true</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：root1 = [1], root2 = [2]\n输出：false</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：root1 = [1,2], root2 = [2,2]\n输出：true</code></pre><p><strong>示例 5：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" alt></p>\n<pre><code>输入：root1 = [1,2,3], root2 = [1,3,2]\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>给定的两棵树可能会有 1 到 200 个结点。</li>\n<li>给定的两棵树上的值介于 0 到 200 之间。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>将第一次的结果存储下来后，后面直接比较并返回结果。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int index = 0;\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector&lt;int&gt; r1;\n        dfs1(root1, r1);\n        return dfs2(root2, r1) &amp;&amp; index == r1.size();\n    }\n    void dfs1(TreeNode* root, vector&lt;int&gt;&amp; res) {\n        if (!root) return;\n        if (!root-&gt;left &amp;&amp; !root-&gt;right) {\n            res.push_back(root-&gt;val);\n            return;\n        }\n        dfs1(root-&gt;left, res);\n        dfs1(root-&gt;right, res);\n    }\n    bool dfs2(TreeNode* root, vector&lt;int&gt;&amp; res) {\n        if (!root) return true;\n        if (!root-&gt;left &amp;&amp; !root-&gt;right) {\n            if (index &gt;= res.size()) return false;\n            if (root-&gt;val != res[index]) return false;\n            index++;\n            return true;\n        }\n        return dfs2(root-&gt;left, res) &amp;&amp; dfs2(root-&gt;right, res);\n    }\n\n};</code></pre>\n<h2 id=\"【Day15】1734-解码异或后的排列\"><a href=\"#【Day15】1734-解码异或后的排列\" class=\"headerlink\" title=\"【Day15】1734.解码异或后的排列\"></a>【Day15】1734.解码异或后的排列</h2><h4 id=\"1734-解码异或后的排列\"><a href=\"#1734-解码异或后的排列\" class=\"headerlink\" title=\"1734. 解码异或后的排列\"></a><a href=\"https://leetcode-cn.com/problems/decode-xored-permutation/\" target=\"_blank\" rel=\"noopener\">1734. 解码异或后的排列</a></h4><p>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。</p>\n<p>它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。</p>\n<p>给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：encoded = [3,1]\n输出：[1,2,3]\n解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：encoded = [6,5,4,6]\n输出：[2,4,1,5,3]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>3 &lt;= n &lt; 105</li>\n<li>n 是奇数。</li>\n<li>encoded.length == n - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>perm = [A,B,C,D,E]</p>\n<p>encoded = [A^B, B^C, C^D, D^E]</p>\n<p>而B^C^D^E = encoded[1] ^ encode[3]</p>\n<p>A^B^C^D^E = total</p>\n<p>total ^ (B^C^D^E) = first</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded) {\n        int n = encoded.size() + 1;\n        int total = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            total ^= i;\n        }\n\n        int e = 0;\n        for (int i = 1; i &lt; n - 1; i += 2) {\n            e ^= encoded[i];\n        }\n\n        vector&lt;int&gt; ans(n);\n        ans[0] = total ^ e;\n        for (int i = 1; i &lt; n; i++) {\n            ans[i] = ans[i-1] ^ encoded[i-1];\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day16】1310-子数组异或查询\"><a href=\"#【Day16】1310-子数组异或查询\" class=\"headerlink\" title=\"【Day16】1310.子数组异或查询\"></a>【Day16】1310.子数组异或查询</h2><h4 id=\"1310-子数组异或查询\"><a href=\"#1310-子数组异或查询\" class=\"headerlink\" title=\"1310. 子数组异或查询\"></a><a href=\"https://leetcode-cn.com/problems/xor-queries-of-a-subarray/\" target=\"_blank\" rel=\"noopener\">1310. 子数组异或查询</a></h4><p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</p>\n<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>\n<p>并返回一个包含给定查询 queries 所有结果的数组。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n输出：[2,7,14,8] \n解释：\n数组中元素的二进制表示形式是：\n1 = 0001 \n3 = 0011 \n4 = 0100 \n8 = 1000 \n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2 \n[1,2] = 3 xor 4 = 7 \n[0,3] = 1 xor 3 xor 4 xor 8 = 14 \n[3,3] = 8</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n输出：[8,0,4,4]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= arr.length &lt;= 3 * 10^4</li>\n<li>1 &lt;= arr[i] &lt;= 10^9</li>\n<li>1 &lt;= queries.length &lt;= 3 * 10^4</li>\n<li>queries[i].length == 2</li>\n<li>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>利用前缀和思想：sum(i,j) = sum(j) - sum(i-1);</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {\n        vector&lt;int&gt; ans;\n        int sum[arr.size() + 1];\n        for (int i = 1; i &lt;= arr.size(); i++) {\n            sum[i] = sum[i - 1] ^ arr[i - 1];\n        }\n\n        for (auto q : queries) {\n            ans.push_back(sum[q[1] + 1] ^ sum[q[0]]);\n        }\n        return ans;\n    }</code></pre>\n<h2 id=\"【Day17】1269-停在原地的方案数\"><a href=\"#【Day17】1269-停在原地的方案数\" class=\"headerlink\" title=\"【Day17】1269.停在原地的方案数\"></a>【Day17】1269.停在原地的方案数</h2><h4 id=\"1269-停在原地的方案数\"><a href=\"#1269-停在原地的方案数\" class=\"headerlink\" title=\"1269. 停在原地的方案数\"></a><a href=\"https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\" target=\"_blank\" rel=\"noopener\">1269. 停在原地的方案数</a></h4><p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</p>\n<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>\n<p>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</p>\n<p>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：steps = 3, arrLen = 2\n输出：4\n解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动</code></pre><p><strong>示例  2：</strong></p>\n<pre><code>输入：steps = 2, arrLen = 4\n输出：2\n解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：steps = 4, arrLen = 2\n输出：8</code></pre><p><strong>提示：</strong></p>\n<pre><code>1 &lt;= steps &lt;= 500\n1 &lt;= arrLen &lt;= 10^6</code></pre><p><strong>题解：</strong></p>\n<p><strong>暴力递归</strong></p>\n<p>pos表示移动的index,st表示当前还剩步数。结果超时- _ -</p>\n<pre><code class=\"c++\">class Solution {\n public:\n  const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      int res = dfs(steps, arrLen, 0);\n      return res % N; \n  }\n\n  int dfs(int st, int arrLen, int pos) {\n    if (st &lt; 0 || pos &lt; 0 || pos &gt;= arrLen) return 0;\n    if (st == 0 &amp;&amp; pos == 0) {\n      return 1;\n    }\n    int ans = 0;\n    if (pos &gt;= 0 &amp;&amp; pos &lt;= arrLen - 1)\n      // 不动\n      ans = dfs(st - 1, arrLen, pos);\n    if (pos &gt;= 1)\n      // 向左\n      ans += dfs(st - 1, arrLen, pos - 1);\n    if (pos &lt;= arrLen - 2)\n      // 向右\n      ans += dfs(st- 1, arrLen, pos + 1);\n    return ans;\n  }\n};</code></pre>\n<p><strong>记忆化搜索</strong></p>\n<p><strong>一开始开辟空间太大，过不了，发现开辟很大空间后，使用map性能比vector好，而实际只需要开辟steps*steps即可。</strong></p>\n<pre><code class=\"c++\">int memo[505][505];\n// vector&lt;vector&lt;int&gt;&gt; memo;\nclass Solution {\n public:\n  static const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      memset(memo, -1, sizeof(memo));\n    //   memo = vector&lt;vector&lt;int&gt;&gt;(505, vector&lt;int&gt;(505,-1));\n      int res = dfs(steps, arrLen, 0);\n      return res % N; \n  }\n\n  int dfs(int st, int arrLen, int pos) {\n    if (st &lt; 0 || pos &lt; 0 || pos &gt;= arrLen) return 0;\n    if (memo[st][pos] != -1) return memo[st][pos];\n    if (st == 0 &amp;&amp; pos == 0) {\n      return memo[st][pos] = 1;\n    }\n    int ans = 0;\n    if (pos &gt;= 0 &amp;&amp; pos &lt;= arrLen - 1) \n      // 不动\n      ans = dfs(st - 1, arrLen, pos) % N;\n    if (pos &gt;= 1)\n      // 向左\n      ans =  ans % N + dfs(st - 1, arrLen, pos - 1) % N;\n    if (pos &lt;= arrLen - 2)\n      // 向右\n      ans = ans % N + dfs(st- 1, arrLen, pos + 1) % N;\n    return memo[st][pos] = ans;\n  }\n};</code></pre>\n<p><strong>动态规划</strong></p>\n<pre><code class=\"c++\">class Solution {\n public:\n  static const int N = 1000000007;\n  int numWays(int steps, int arrLen) { \n      int maxLen = min(steps, arrLen);\n      long long dp[steps + 1][maxLen + 1];\n      memset(dp, 0, sizeof dp);\n      dp[1][0] = 1;\n      dp[1][1] = 1; // step=1 pos=1\n\n      for (int s = 1; s &lt;= steps; s++) {\n          for (int l = 0; l &lt; maxLen; l++) {\n            // 原地\n                dp[s][l] = dp[s][l] + dp[s - 1][l];\n            // 右\n                dp[s][l] = dp[s][l]  + dp[s - 1][l + 1];\n            // 左\n\n                if (l - 1 &gt;= 0)\n                    dp[s][l] =  dp[s][l] + dp[s - 1][l - 1];\n\n              dp[s][l] %= N;\n          }\n      }     \n      return dp[steps][0]; \n  }\n};</code></pre>\n<h2 id=\"【Day18】12-整数转罗马数字\"><a href=\"#【Day18】12-整数转罗马数字\" class=\"headerlink\" title=\"【Day18】12.整数转罗马数字\"></a>【Day18】12.整数转罗马数字</h2><h4 id=\"12-整数转罗马数字\"><a href=\"#12-整数转罗马数字\" class=\"headerlink\" title=\"12. 整数转罗马数字\"></a><a href=\"https://leetcode-cn.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">12. 整数转罗马数字</a></h4><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>\n<pre><code>字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre><blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n</blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给你一个整数，将其转为罗马数字。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: num = 3\n输出: &quot;III&quot;</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: num = 4\n输出: &quot;IV&quot;</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: num = 9\n输出: &quot;IX&quot;</code></pre><p><strong>示例 4:</strong></p>\n<pre><code>输入: num = 58\n输出: &quot;LVIII&quot;\n解释: L = 50, V = 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>\n<pre><code>输入: num = 1994\n输出: &quot;MCMXCIV&quot;\n解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= num &lt;= 3999</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>第一想到贪心，使用哈希表排序罗马数字并遍历，从高到低进行匹配。暴力匹配也可以的，</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    string intToRoman(int num) {\n        int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string reps[] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};\n\n        string ans;\n        int \n        for (int i = 0; i &lt; 13; i ++ ) \n            while(num &gt;= values[i])\n            {\n                num -= values[i];\n                ans += reps[i];\n            }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day19】13-罗马数字转整数\"><a href=\"#【Day19】13-罗马数字转整数\" class=\"headerlink\" title=\"【Day19】13.罗马数字转整数\"></a>【Day19】13.罗马数字转整数</h2><h4 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a><a href=\"https://leetcode-cn.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">13. 罗马数字转整数</a></h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<pre><code>字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre><blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n</blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: &quot;III&quot;\n输出: 3</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: &quot;IV&quot;\n输出: 4</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: &quot;IX&quot;\n输出: 9</code></pre><p><strong>示例 4:</strong></p>\n<pre><code>输入: &quot;LVIII&quot;\n输出: 58\n解释: L = 50, V= 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>\n<pre><code>输入: &quot;MCMXCIV&quot;\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= s.length &lt;= 15</li>\n<li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li>\n<li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<ul>\n<li><p>当小值在大值的左边，则减小值，如 IV=5-1=4；</p>\n</li>\n<li><p>当小值在大值的右边，则加小值，如 VI=5+1=6；</p>\n</li>\n<li><p>小值放在大值的左边，就是做减法，否则为加法。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int romanToInt(string s) {\n    int r=0;\n\n    for(int i=0;i&lt;s.length();i++)\n    {\n        switch(s[i])\n        {\n            case &#39;I&#39; : r += (&#39;V&#39; == s[i+1] || &#39;X&#39; == s[i+1]) ?-1 : 1 ; break;\n            case &#39;V&#39; : r += 5; break;\n            case &#39;X&#39; : r += (&#39;L&#39; == s[i+1] || &#39;C&#39; == s[i+1]) ?-10: 10 ; break;\n            case &#39;L&#39; : r += 50; break;\n            case &#39;C&#39; : r += (&#39;D&#39; == s[i+1] || &#39;M&#39; == s[i+1]) ?-100: 100 ; break;\n            case &#39;D&#39; : r += 500; break;\n            case &#39;M&#39; : r += 1000; break;\n        }\n    }\n    return r;\n    }\n};</code></pre>\n<h2 id=\"【Day20】421-数组中两个数的最大异或值\"><a href=\"#【Day20】421-数组中两个数的最大异或值\" class=\"headerlink\" title=\"【Day20】421.数组中两个数的最大异或值\"></a>【Day20】421.数组中两个数的最大异或值</h2><h4 id=\"421-数组中两个数的最大异或值\"><a href=\"#421-数组中两个数的最大异或值\" class=\"headerlink\" title=\"421. 数组中两个数的最大异或值\"></a><a href=\"https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/\" target=\"_blank\" rel=\"noopener\">421. 数组中两个数的最大异或值</a></h4><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p>\n<p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [3,10,5,25,2,8]\n输出：28\n解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [0]\n输出：0</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [2,4]\n输出：6</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：nums = [8,10,2]\n输出：10</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n输出：127</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 2 * 104</li>\n<li>0 &lt;= nums[i] &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>前缀树</strong></p>\n<p>将所有数据从最高位开始取每一个bit，构建出树形结构，尽可能保证最高位为1，也就是说当循环到当前数的时候，如果当前数的bit与当前数中某一个数的某一位是相反的，那么可以保证为1，也就是最大，否则向低位继续循环。</p>\n<pre><code class=\"c++\">struct Node{\n    Node* next[2] = {nullptr};\n};\nclass Solution {\npublic:\n    void insert(int num, Node* root) {\n        for (int i = 30; i &gt;= 0; --i) {\n            int t = (num &gt;&gt; i &amp; 1);\n            if (!root-&gt;next[t]) {\n                root-&gt;next[t] = new Node();\n            }\n            root = root-&gt;next[t];\n        }\n    }\n    int findMaximumXOR(vector&lt;int&gt;&amp; nums) {\n        Node* root = new Node();\n        for (auto val : nums) {\n            insert(val, root);\n        }\n        int res = 0, tmp = 0;\n        Node* p = root;\n        for (auto val : nums) {\n            p = root; tmp = 0;\n            for (int i = 30; i &gt;= 0; --i) {\n                int t = (val &gt;&gt; i) &amp; 1;\n                if (p-&gt;next[!t]) {\n                    p = p-&gt;next[!t];\n                    tmp += (1 &lt;&lt; i);\n                }else p = p-&gt;next[t];\n            }\n            res = max(res, tmp);\n        }\n        return res;\n    }\n};</code></pre>\n<p><strong>暴力+剪枝</strong></p>\n<p>剪枝策略两数异或最大不超过两数之和，先排序再剪枝。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int findMaximumXOR(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end(), [](auto a, auto b) {return a &gt; b;});\n        int ans = 0;\n        for (int i = 0; i &lt; nums.size() - 1; i++) {\n            for (int j = i + 1; j &lt; nums.size(); j++) {\n                long long x = (long long)nums[i] + nums[j];\n                if (ans &gt; x) break;\n                ans = max(ans, nums[i] ^ nums[j]);\n            }\n        }\n        return ans;     \n    }\n};</code></pre>\n<h2 id=\"【Day21】993-二叉树的堂兄弟节点\"><a href=\"#【Day21】993-二叉树的堂兄弟节点\" class=\"headerlink\" title=\"【Day21】993.二叉树的堂兄弟节点\"></a>【Day21】993.二叉树的堂兄弟节点</h2><h4 id=\"993-二叉树的堂兄弟节点\"><a href=\"#993-二叉树的堂兄弟节点\" class=\"headerlink\" title=\"993. 二叉树的堂兄弟节点\"></a><a href=\"https://leetcode-cn.com/problems/cousins-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>\n<p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>\n<p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p>\n<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\" alt></p>\n<pre><code>输入：root = [1,2,3,4], x = 4, y = 3\n输出：false</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\" alt></p>\n<pre><code>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出：true</code></pre><p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\" alt></p>\n<pre><code>输入：root = [1,2,3,null,4], x = 2, y = 3\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>二叉树的节点数介于 2 到 100 之间。</li>\n<li>每个节点的值都是唯一的、范围为 1 到 100 的整数。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>假设从根节点开始编号1，依次往后编号，其两个孩子是<code>2*n</code>与<code>2*n+1</code>。反过来便是根据两个孩子节点判断是否是同一个父亲，那便是直接除以2，向下取整，看两者是否一样即可。</p>\n<p>例如：2、3是同一父亲，2、4不是。</p>\n<p>在BFS过程中记录节点编号以及x、y节点，最后判断即可。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    bool isCousins(TreeNode* root, int x, int y) {\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        int cnt = 1;\n        while (q.size()) {\n            int sz = q.size();\n            bool xt = false, yt = false;\n            int xcnt, ycnt;\n            while (sz--) {\n                auto p = q.front();\n                q.pop();\n                if (p) {\n                    if (x == p-&gt;val) {\n                        xt = true;\n                        xcnt = cnt;\n                    }\n                    if (y == p-&gt;val) { \n                        yt = true;\n                        ycnt = cnt;\n                    }\n\n                    if (xt &amp;&amp; yt &amp;&amp; int(xcnt / 2) != int(ycnt / 2) ) {\n                        return true;\n                    }\n                    q.push(p-&gt;left); q.push(p-&gt;right);\n                }\n                cnt++;\n            }\n        }\n        return false;\n    }\n};</code></pre>\n<h2 id=\"【Day22】1442-形成两个异或相等数组的三元组数目\"><a href=\"#【Day22】1442-形成两个异或相等数组的三元组数目\" class=\"headerlink\" title=\"【Day22】1442.形成两个异或相等数组的三元组数目\"></a>【Day22】1442.形成两个异或相等数组的三元组数目</h2><h4 id=\"1442-形成两个异或相等数组的三元组数目\"><a href=\"#1442-形成两个异或相等数组的三元组数目\" class=\"headerlink\" title=\"1442. 形成两个异或相等数组的三元组数目\"></a><a href=\"https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/\" target=\"_blank\" rel=\"noopener\">1442. 形成两个异或相等数组的三元组数目</a></h4><p> 给你一个整数数组 arr 。</p>\n<p>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。</p>\n<p>a 和 b 定义如下：</p>\n<ul>\n<li>a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>\n<li>b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>\n</ul>\n<p>注意：^ 表示 按位异或 操作。</p>\n<p>请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [2,3,1,6,7]\n输出：4\n解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [1,1,1,1,1]\n输出：10</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：arr = [2,3]\n输出：0</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：arr = [1,3,5,7,9]\n输出：3</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：arr = [7,11,12,9,5,2,7,17,22]\n输出：8</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= arr.length &lt;= 300</li>\n<li>1 &lt;= arr[i] &lt;= 10^8</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>∵   a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</p>\n<p>​     b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</p>\n<p>∴  arr[i] ^ arr[i + 1] ^ … ^ arr[k] = a ^ b = 0;</p>\n<p>a^b=0得到区间[i,k]中有k-i个元组，全部累加即可。区间内三元组的个数为 k - i（因为区间内的任意一个j，都和i，k组成满足题目的一个三元组）。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int countTriplets(vector&lt;int&gt;&amp; arr) {\n        int ans = 0;\n        for (int i = 0; i &lt; arr.size(); i++) {\n            int s = arr[i];\n            for (int k = i + 1; k &lt; arr.size(); k++) {\n                s ^= arr[k];\n                if (s == 0) ans += k - i;\n            }\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day23】1738-找出第-K-大的异或坐标值\"><a href=\"#【Day23】1738-找出第-K-大的异或坐标值\" class=\"headerlink\" title=\"【Day23】1738.找出第 K 大的异或坐标值\"></a>【Day23】1738.找出第 K 大的异或坐标值</h2><h4 id=\"1738-找出第-K-大的异或坐标值\"><a href=\"#1738-找出第-K-大的异或坐标值\" class=\"headerlink\" title=\"1738. 找出第 K 大的异或坐标值\"></a><a href=\"https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/\" target=\"_blank\" rel=\"noopener\">1738. 找出第 K 大的异或坐标值</a></h4><p>给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。</p>\n<p>矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>\n<p>请你找出 matrix 的所有坐标中第 k 大的值（<strong>k 的值从 1 开始计数</strong>）。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 1\n输出：7\n解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 2\n输出：5\n解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 3\n输出：4\n解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：matrix = [[5,2],[1,6]], k = 4\n输出：0\n解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>m == matrix.length</li>\n<li>n == matrix[i].length</li>\n<li>1 &lt;= m, n &lt;= 1000</li>\n<li>0 &lt;= matrix[i][j] &lt;= 106</li>\n<li>1 &lt;= k &lt;= m * n</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>二维差分+最小堆</strong></p>\n<p>前缀和模板+维护k个元素的最小堆</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int prefix[1000][1000];\n    int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        prefix[0][0] = matrix[0][0];\n        // 处理第一行\n        for (int i = 1; i &lt; n; i++) {\n            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];\n        }\n        // 处理第一列\n        for (int i = 1; i &lt; m; i++) {\n            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];\n        }\n\n        for (int i = 1; i &lt; m; i++) {\n            for (int j = 1; j &lt; n; j++) {\n                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];\n            }\n        }\n\n        priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq;\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                pq.push(prefix[i][j]);\n                if (pq.size() &gt; k) pq.pop();\n            }\n        }\n        return pq.top();\n    }\n};</code></pre>\n<p><strong>二分搜值</strong></p>\n<p>每次猜测一个值x，然后遍历前缀和矩阵，统计有多少个元素大于等于x，如果count小于k，那么x肯定不可能是答案，我们将猜测的上界下调至x-1；否则，我们就将猜测的下界调整至x。可以看到问题可以转换为查找最后一个小于等于target的数。因为当查找到大于等于target时要往上不断压缩区间，直到小于等于k为止。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int prefix[1000][1000];\n    int m, n;\n    int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        m = matrix.size();\n        n = matrix[0].size();\n        prefix[0][0] = matrix[0][0];\n        // 处理第一行\n        for (int i = 1; i &lt; n; i++) {\n            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];\n        }\n        // 处理第一列\n        for (int i = 1; i &lt; m; i++) {\n            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];\n        }\n\n        for (int i = 1; i &lt; m; i++) {\n            for (int j = 1; j &lt; n; j++) {\n                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];\n            }\n        }\n\n        int left = 0, right = 1e6;\n        while (left &lt; right) {\n            int mid = right - (right - left - 1) / 2;\n            if (count(mid) &lt; k) { // 缩小值\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n    int count (int mid) {\n        int cnt = 0;\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (prefix[i][j] &gt;= mid) cnt++;\n            }\n        }\n        return cnt;\n    }\n};</code></pre>\n<h2 id=\"【Day24】692-前K个高频单词\"><a href=\"#【Day24】692-前K个高频单词\" class=\"headerlink\" title=\"【Day24】692.前K个高频单词\"></a>【Day24】692.前K个高频单词</h2><h4 id=\"692-前K个高频单词\"><a href=\"#692-前K个高频单词\" class=\"headerlink\" title=\"692. 前K个高频单词\"></a><a href=\"https://leetcode-cn.com/problems/top-k-frequent-words/\" target=\"_blank\" rel=\"noopener\">692. 前K个高频单词</a></h4><p>给一非空的单词列表，返回前 k 个出现次数最多的单词。</p>\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2\n输出: [&quot;i&quot;, &quot;love&quot;]\n解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4\n输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]\n解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。</code></pre><p><strong>注意：</strong></p>\n<ul>\n<li>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。</li>\n<li>输入的单词均由小写字母组成。</li>\n</ul>\n<p><strong>扩展练习：</strong></p>\n<blockquote>\n<p>尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<pre><code class=\"c++\">struct Cmp {\n    bool operator()(const pair&lt;string, int&gt;&amp; p1, const pair&lt;string, int&gt;&amp; p2) {\n        if(p1.second != p2.second) return p1.second &gt; p2.second;\n        else return p1.first &lt; p2.first;\n    }\n};\n\nclass Solution {\npublic:\n    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {\n        unordered_map&lt;string, int&gt; m;\n        for(string&amp; word : words) m[word]++;\n        vector&lt;pair&lt;string, int&gt;&gt; sorted_list(m.begin(), m.end());\n        sort(sorted_list.begin(), sorted_list.end(), Cmp());\n        vector&lt;string&gt; res;\n        for(int i = 0; i &lt; k; i++) res.push_back(sorted_list[i].first);\n        return res;\n    }\n};</code></pre>\n<h2 id=\"【Day25】1035-不相交的线\"><a href=\"#【Day25】1035-不相交的线\" class=\"headerlink\" title=\"【Day25】1035.不相交的线\"></a>【Day25】1035.不相交的线</h2><h4 id=\"1035-不相交的线\"><a href=\"#1035-不相交的线\" class=\"headerlink\" title=\"1035. 不相交的线\"></a><a href=\"https://leetcode-cn.com/problems/uncrossed-lines/\" target=\"_blank\" rel=\"noopener\">1035. 不相交的线</a></h4><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>\n<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p>\n<ul>\n<li>nums1[i] == nums2[j]</li>\n<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>\n</ul>\n<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>\n<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png\" alt></p>\n<pre><code>输入：nums1 = [1,4,2], nums2 = [1,2,4]\n输出：2\n解释：可以画出两条不交叉的线，如上图所示。 \n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n输出：3</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums1.length &lt;= 500</li>\n<li>1 &lt;= nums2.length &lt;= 500</li>\n<li>1 &lt;= nums1[i], nums2[i] &lt;= 2000</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int n = nums1.size(), m = nums2.size();\n        dp = vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(m + 1, 0));\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= m; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        return dp[n][m];\n    }\n};</code></pre>\n<h2 id=\"【Day26】810-黑板异或游戏\"><a href=\"#【Day26】810-黑板异或游戏\" class=\"headerlink\" title=\"【Day26】810.黑板异或游戏\"></a>【Day26】810.黑板异或游戏</h2><h4 id=\"810-黑板异或游戏\"><a href=\"#810-黑板异或游戏\" class=\"headerlink\" title=\"810. 黑板异或游戏\"></a><a href=\"https://leetcode-cn.com/problems/chalkboard-xor-game/\" target=\"_blank\" rel=\"noopener\">810. 黑板异或游戏</a></h4><p>黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p>\n<p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>\n<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入: nums = [1, 1, 2]\n输出: false\n解释: \nAlice 有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= N &lt;= 1000</li>\n<li>0 &lt;= nums[i] &lt;= 2^16</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    bool xorGame(vector&lt;int&gt;&amp; nums) {\n        //数组元素个数是奇数/偶数，有决定性作用：\n        //如果是偶数，先手必胜；\n        //如果是奇数，只有当一上来所有元素异或的结果为0，先手才获胜，\n        //否则，接下来轮到后手，此时元素个数为偶数，则后手必胜，先手必败！\n        int len = nums.size(), t = 0;\n        if(len % 2)\n        {\n            for(auto&amp; x:nums) t ^= x; //所有元素异或的结果\n            if(t) return false;\n            else return true;\n        }\n        else return true;\n    }\n};</code></pre>\n<h2 id=\"【Day27】1707-与数组中元素的最大异或值\"><a href=\"#【Day27】1707-与数组中元素的最大异或值\" class=\"headerlink\" title=\"【Day27】1707.与数组中元素的最大异或值\"></a>【Day27】1707.与数组中元素的最大异或值</h2><h4 id=\"1707-与数组中元素的最大异或值\"><a href=\"#1707-与数组中元素的最大异或值\" class=\"headerlink\" title=\"1707. 与数组中元素的最大异或值\"></a><a href=\"https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/\" target=\"_blank\" rel=\"noopener\">1707. 与数组中元素的最大异或值</a></h4><p>给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。</p>\n<p>第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] &lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。</p>\n<p>返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n输出：[3,3,7]\n解释：\n1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n输出：[15,-1,5]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length, queries.length &lt;= 105</li>\n<li>queries[i].length == 2</li>\n<li>0 &lt;= nums[j], xi, mi &lt;= 109</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"c++\">const int N = 1e5 + 50, M = 32 * N;\nint son[M][2];\nint idx;\n\nvoid insert(int x){\n    int p = 0;\n    for(int i = 31; i &gt;= 0; i--){\n        int u = (x &gt;&gt; i) &amp; 1;\n        if(!son[p][u]) son[p][u] = ++idx;\n        p = son[p][u];\n    }\n}\nint query(int x){\n    int ans = 0, p = 0;\n    for(int i = 31; i &gt;= 0; i--){\n        int u = (x &gt;&gt; i) &amp; 1;\n        if(son[p][!u]) {\n            ans += (1 &lt;&lt; i);\n            p = son[p][!u];\n        }\n        else p = son[p][u];\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    vector&lt;int&gt; maximizeXor(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {\n        memset(son,0,sizeof son);\n        idx = 0;\n        sort(nums.begin(),nums.end());\n        //离线思想，因此需要对queries加一个pos，因为回答是乱序的\n        int pos = 0;\n        for(auto&amp; q: queries){\n            q.push_back(pos++);\n        }\n        sort(queries.begin(),queries.end(),[](const auto&amp; a,const auto&amp; b){\n            return a[1] &lt; b[1];\n        });\n        vector&lt;int&gt; ans(queries.size());\n        int cur = 0;\n        for(const auto&amp; q : queries){\n            int xi = q[0], mi = q[1],id = q[2];\n            while(cur &lt; nums.size() and nums[cur] &lt;= mi){\n                insert(nums[cur]);\n                cur++;\n            }\n            if(cur == 0) ans[id] = -1;\n            else ans[id] = query(xi);\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day28】664-奇怪的打印机\"><a href=\"#【Day28】664-奇怪的打印机\" class=\"headerlink\" title=\"【Day28】664.奇怪的打印机\"></a>【Day28】664.奇怪的打印机</h2><h4 id=\"664-奇怪的打印机\"><a href=\"#664-奇怪的打印机\" class=\"headerlink\" title=\"664. 奇怪的打印机\"></a><a href=\"https://leetcode-cn.com/problems/strange-printer/\" target=\"_blank\" rel=\"noopener\">664. 奇怪的打印机</a></h4><p>有台奇怪的打印机有以下两个特殊要求：</p>\n<ul>\n<li>打印机每次只能打印由 同一个字符 组成的序列。</li>\n<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>\n</ul>\n<p>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;aaabbb&quot;\n输出：2\n解释：首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;aba&quot;\n输出：2\n解释：首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 &#39;a&#39;。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= s.length &lt;= 100</li>\n<li>s 由小写英文字母组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>区间dp问题，对于[i,j]区间i&lt;j，如果s[i] == s[j]，那么dp[i][j] = dp[i - 1][j] 或者dp[i + 1][j]，例如：aba 等于 ab或者 ba</p>\n<p>如果s[i]!=s[j]，那么对于区间[i,j]的所有组合，进行累加求min即可。</p>\n<p>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])</p>\n<p>目标是求dp[0][n - 1]，因此，对于这道题有两种遍历方式。</p>\n<p><strong>第一种：从下往上，从左到右。</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int strangePrinter(string s) {\n        // aba\n        // aaabbb\n        int n = s.size();\n        int dp[n][n];\n        memset(dp, 0x3f3f3f3f, sizeof(dp));\n        for (int i = 0; i &lt; n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int i = n - 1; i &gt;= 0; i--) {\n            for (int j = i + 1; j &lt; n; j++) {\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    for (int k = i; k &lt; j; k++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }     \n        return dp[0][n - 1];\n    }\n};</code></pre>\n<p><strong>第二种：斜着遍历。</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int strangePrinter(string s) {\n        // aba\n        // aaabbb\n        int n = s.size();\n        int dp[n][n];\n        memset(dp, 0x3f3f3f3f, sizeof(dp));\n        for (int i = 0; i &lt; n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int l = 2; l &lt;= n; l++) {\n            for (int i = 0; i &lt; n - l + 1; i++) {\n                int j = l + i - 1;\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    for (int k = i; k &lt; j; k++) {\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }\n\n\n        return dp[0][n - 1];\n    }\n};</code></pre>\n<h2 id=\"【Day29】1787-使所有区间的异或结果为零\"><a href=\"#【Day29】1787-使所有区间的异或结果为零\" class=\"headerlink\" title=\"【Day29】1787.使所有区间的异或结果为零\"></a>【Day29】1787.使所有区间的异或结果为零</h2><h4 id=\"1787-使所有区间的异或结果为零\"><a href=\"#1787-使所有区间的异或结果为零\" class=\"headerlink\" title=\"1787. 使所有区间的异或结果为零\"></a><a href=\"https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/\" target=\"_blank\" rel=\"noopener\">1787. 使所有区间的异或结果为零</a></h4><p>给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left &lt;= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR … XOR nums[right] 。</p>\n<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 k 的区间异或结果等于零。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [1,2,0,3,0], k = 1\n输出：3\n解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [3,4,5,2,1,7,3,4,7], k = 3\n输出：3\n解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [1,2,4,1,2,5,1,2,6], k = 3\n输出：3\n解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li><p>1 &lt;= k &lt;= nums.length &lt;= 2000</p>\n</li>\n<li><p>0 &lt;= nums[i] &lt; 210</p>\n<p><strong>题解：</strong></p>\n</li>\n</ul>\n<p>第一种情况采用贪心的方法求得最优解。因为修改后的元素可能是原序列中没有出现过的元素。如果修改的某一列的元素是原序列中没有出现过的元素，那么这种情况下一定可以用贪心的办法求出最优解，做法是将众数最小的一列中的每个数变成一个全新的，该列中没有出现的，使得每个周期内的元素的异或和为0的数。</p>\n<p>第二种情况采用dp的方法求得最优解在这种情况下，由于没有最终修改后的元素是原数组中存在的数，因此可以从前往后枚举每一列，然后枚举选择第几行的数作为这列元素修改后的元素，由于异或具有交换性质，因此不具有顺序的问题，所以可以采用dp的方法递推出将序列变成数组中本来存在的某个数的情况。边界，f[0] [0] = 0，目标状态是f[k] [0]，状态表示f[i] [j]为前i列异或和为j的情况下的最小值。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    // 1.某一列用了一个全新的数\n    // 2.每一列用了原来的数\n\n    const int N = 1024, INF = 1e8;\n    int s[1024]; // 求众数\n    int minChanges(vector&lt;int&gt;&amp; nums, int k) {\n        int n = nums.size(), m = (n + k - 1) / k;\n        vector&lt;vector&lt;int&gt;&gt; f(k + 1, vector&lt;int&gt;(N, INF));\n        int cnt = 0, minv = INF; // 每一列代价\n        // f[i][j] 第i列的异或和为j\n        f[0][0] = 0;\n        for (int i = 1; i &lt;= k; i++) {\n            int len = m;\n            memset(s, 0 , sizeof s);\n            if (n % k &amp;&amp; n % k &lt; i) len--;\n            for (int j = 0; j &lt; len; j ++) {\n                s[nums[j * k + i - 1]]++;\n            }\n            int maxv = 0;\n            for (int j = 0; j &lt; N; j++) {\n                maxv = max(maxv, s[j]);\n            }\n            cnt += len - maxv;\n            minv = min(minv, maxv); // 众数最少的那一列  不用众数  而用全新的数\n\n            for (int j = 0; j &lt; N; j++) { // 异或和为j\n                for (int u = 0; u &lt; len; u++) { // 每一行\n                    int x = nums[u * k + i - 1], cost = len - s[x];\n                    f[i][j] = min(f[i][j], f[i - 1][j ^ x] + cost);\n                }\n            }\n        }\n        // cnt: 每一列的代价\n        // minv表示 某一列不用众数时的代价 si - maxv -&gt; si 变成全新的数代价\n        return min(cnt + minv, f[k][0]);\n    }\n};</code></pre>\n<h2 id=\"【Day30】1190-反转每对括号间的子串\"><a href=\"#【Day30】1190-反转每对括号间的子串\" class=\"headerlink\" title=\"【Day30】1190.反转每对括号间的子串\"></a>【Day30】1190.反转每对括号间的子串</h2><h4 id=\"1190-反转每对括号间的子串\"><a href=\"#1190-反转每对括号间的子串\" class=\"headerlink\" title=\"1190. 反转每对括号间的子串\"></a><a href=\"https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/\" target=\"_blank\" rel=\"noopener\">1190. 反转每对括号间的子串</a></h4><p>给出一个字符串 s（仅含有小写英文字母和括号）。</p>\n<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>\n<p><strong>注意，您的结果中 不应 包含任何括号。</strong></p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;(abcd)&quot;\n输出：&quot;dcba&quot;</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;(u(love)i)&quot;\n输出：&quot;iloveu&quot;</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;(ed(et(oc))el)&quot;\n输出：&quot;leetcode&quot;</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;\n输出：&quot;apmnolkjihgfedcbq&quot;</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>0 &lt;= s.length &lt;= 2000</li>\n<li>s 中只有小写英文字母和括号</li>\n<li>我们确保所有括号都是成对出现的</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><img src=\"https://cdn.acwing.com/media/article/image/2021/05/26/30502_ed3e6737bd-aa.gif\" alt></p>\n<p>挨个遍历， 左括号和普通字符直接入栈；遇到右括号 ，就依次出栈直到栈顶为左括号 ，出栈的这些字符按出栈顺序链接自然也就是逆序的，然后栈顶左括号出栈 把组合成的逆序串重新压入栈。</p>\n<p>遍历完字符串 栈中从栈底到栈顶 自然也就想要的结果，如果依次出栈 要注意连接顺序，还需要一次整体反转。</p>\n<p><strong>代码：</strong></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    string reverseParentheses(string s) {\n        stack&lt;char&gt; st;\n        for (auto c : s) {\n            if (c != &#39;)&#39;) {\n                st.push(c);\n            } else {\n                string tmp;\n                while (st.top() != &#39;(&#39;) {\n                    tmp += st.top();\n                    st.pop();\n                }\n                st.pop();\n                for (auto s : tmp) {\n                    st.push(s);\n                }\n            }\n        }\n        string ans;\n        while (!st.empty()) {\n            ans = st.top() + ans; st.pop();\n        }\n        return ans;\n    }\n};\n</code></pre>\n<p>几天刚好一个月结束啦，收获还是很多的，困难我唯唯诺诺，简单重拳出击！！！hhh~</p>\n","path":"shu-jia-leetcode-shua-ti-ji-he-shang.html","permalink":"https://www.yshawlon.cn/shu-jia-leetcode-shua-ti-ji-he-shang.html","tags":[{"name":"LeetCode","_id":"clq6dy4bk0061ikw0iij4um88","slug":"LeetCode","path":"tags/LeetCode/","permalink":"https://www.yshawlon.cn/tags/LeetCode/","length":2}],"categories":[{"name":"每日一题","_id":"clq6dy4b4004oikw0s0mv2rlx","slug":"每日一题","path":"categories/每日一题/","permalink":"https://www.yshawlon.cn/categories/每日一题/","length":2}],"prev":{"title":"使用Java开发一个记事本","date":"2021-07-17T14:20:07.000Z","summary":"大二下的Java课程设计，仿的Windows记事本，使用Java Swing组件开发。","slug":"使用Java开发一个记事本","published":true,"updated":"2021-10-20T13:17:18.866Z","_id":"clq6dy4a9002nikw0ng08ymvi","layout":"post","photos":[],"link":"","excerpt":"","path":"shi-yong-java-kai-fa-yi-ge-ji-shi-ben.html","permalink":"https://www.yshawlon.cn/shi-yong-java-kai-fa-yi-ge-ji-shi-ben.html","__post":true},"next":{"title":"《X86汇编语言从实模式到保护模式》阅读笔记","date":"2021-05-16T14:57:10.000Z","summary":"能够了解常见的汇编命令，实现能够看懂基本的汇编操作，理解所表示含义。","slug":"《X86汇编语言从实模式到保护模式》阅读笔记","published":true,"updated":"2021-10-29T08:40:26.833Z","_id":"clq6dy49m001rikw0427xduwm","layout":"post","photos":[],"link":"","excerpt":"","path":"x86-hui-bian-yu-yan-cong-shi-mo-shi-dao-bao-hu-mo-shi-yue-du-bi-ji.html","permalink":"https://www.yshawlon.cn/x86-hui-bian-yu-yan-cong-shi-mo-shi-dao-bao-hu-mo-shi-yue-du-bi-ji.html","__post":true},"__post":true}