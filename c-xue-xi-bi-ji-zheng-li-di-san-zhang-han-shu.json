{"title":"C++学习笔记整理-函数","date":"2020-05-08T11:54:09.000Z","toc":true,"summary":"前面两章和C差不多，就从第三章《函数》开始吧，错误之处欢迎指正。","source":"_posts/C-学习笔记整理-第三章《函数》.md","raw":"---\ntitle: C++学习笔记整理-函数\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-05-08 19:54:09\npassword:\nsummary: 前面两章和C差不多，就从第三章《函数》开始吧，错误之处欢迎指正。\ntags:\n- 学习笔记\ncategories:\n- C++\n---\n\n\n\n**前面几章大体上和C差不多，就从函数开始吧。**\n\n## 第三章 函数\n\n## 1 .函数的定义与使用\n\n### 函数定义的语法形式：\n\n```c++\n类型标识符  函数名（形式参数表）\n{  \n   语句序列\n}\n```\n\n-  若无返回值，类型标识符写void \n-  形式参数表：是被初始化的内部变量，寿命和可见性仅限于函数内部 \n\n### 函数的调用\n\n**调用前先声明函数：**\n\n-  若函数定义在调用点之前，则无需另外声明； \n-  若函数定义在调用点之后，则需要在调用函数前按如下形式声明函数原型： \n\n类型标识符 被调用函数名（含类型说明的形参表）;\n\n**调用形式：** \n\n函数名（实参列表）\n\n-  嵌套调用：     在一个函数的函数体中，可以调用另一函数，称为嵌套调用。 \n-  递归调用：     函数直接或间接调用自身。 \n\n```c++\n//1.编写一个求x的n次方的函数\n\n#include <iostream>\nusing namespace std;\n\n//计算x的n次方\ndouble power(double x,int n)\n{\n    double val=1.0;\n    while(n--)\n        val*=x;\n    return val;\n}\n\nint main()\n{\n    cout << \"5 to the power 2 is :\"<< power(5, 2) << endl;\n    return 0;\n}\n\n\n\n\n\n```\n\n\n\n```c++\n//2.数制转换\n//输入一个8位二进制数，将其转换为十进制数输出。\n//例如：11012=1(23)+1(22)+0(21)+1(20)=1310 \n//所以，如果输入1101，则应输出13\n\n#include <iostream>\nusing namespace std;\n\ndouble power (double x,int n); //计算x的n次方\n\nint main()\n{\n    int  value=0;\n    cout <<\"Enter an 8 bit binary number \";\n    for (int i=7;i>=0;i--) \n    {\n      char ch;\n      cin>>ch;\n      if (ch =='1')\n            value+=static_cast<int>(power(2, i));\n    }\n    cout<<\"Decimal value is \"<<value<<endl;\n    return 0;\n}\n\ndouble power(double x,int n)\n{\n    double val=1.0;\n    while(n--) \n      val*=x;\n    return val;\n}\n```\n\n\n\n\n\n```c++\n\n/*3.编写程序求π的值\nπ=16arctan(1/5)-4arctan(1/239)\n其中arctan用如下形式的级数计算：\narctanx=x-x^3/3+x^/5-x^7/7+...\n直到级数某项绝对值不大于10-15为止；π和x均为double型。*/\n\n#include <iostream>\nusing namespace std;\n\ndouble arctan(double x)\n{\n    double sqr = x * x;\n    double e = x;\n    double r = 0;\n    int i = 1;\n    while (e / i > 1e-15) {\n        double f = e / i;\n        r = (i % 4 == 1) ? r + f : r - f;\n        e = e * sqr;\n        i += 2;\n    }\n    return r;\n}\n\nint main() \n{\n    double a = 16.0 * arctan(1 / 5.0); \n    double b = 4.0 * arctan(1 / 239.0); \n    /* 注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0 */\n\n    cout << \"PI = \" << a - b << endl;\n    return 0;\n}\n\n\n```\n\n\n\n\n```c++\n/*4.寻找并输出11~999之间的数m，它满足m、m2和m3均为回文数。\n回文：各位数字左右对称的整数。\n例如：11满足上述条件 \n112=121，113=1331。\n分析：\n10取余的方法，从最低位开始，依次取出该数的各位数字。按反序重新构成新的数，比较与原数是否相等，若相等，则原数为回文。*/\n\n#include <iostream>\nusing namespace std;\n//判断n是否为回文数\nbool symm(unsigned n)\n{\n  unsigned i = n;\n    unsigned m = 0;\n    while (i > 0) {\n      m = m*10+i%10;\n      i/=10;\n  }\n  return m==n;\n}\n\nint main()\n{\n    for(unsigned m = 11; m < 1000; m++)\n      if (symm(m) && symm(m * m) &&\n          symm(m * m * m)) {\n        cout << \"m = \" << m;\n        cout << \"  m * m = \" << m * m;\n        cout << \"  m * m * m = \"\n             << m * m * m << endl;\n      }\n    return 0;\n}\n\n\n```\n\n\n\n/*5.计算如下公式，并输出结果：*\n$$\nk =  \\begin{cases}     \\sqrt{sin^2r+sin^2s} & \\text{}\\  当r^2\\leqslant s^2\\     \\frac{1}{2}sin(rs) & \\text{}\\ 当r^2> s^2&  \\end{cases}\n$$\n其中r、s的值由键盘输入\n\nsin x的近似值按如下公式计算，计算精度为10-10：\n\n$$ sinx=\\frac{x}{1!}+\\frac{x^3}{3!}+\\frac{x^5}{5!}+\\frac{x^7}{7!}+...=\\displaystyle \\sum_{n=1}^∞(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!} $$\n\n```c++\n#include <iostream>\n#include <cmath>  /*对C++标准库中数学函数的说明*/\nusing namespace std;\n\nconst double TINY_VALUE = 1e-10;\n\ndouble tsin(double x) \n{\n    double g = 0;\n    double t = x;\n    int n = 1;\n    do {\n        g += t;\n        n++;\n        t = -t * x * x / (2 * n - 1) / (2 * n - 2);\n    } while (fabs(t) >= TINY_VALUE); \n    return g;\n} \n\nint main() \n{\n    double k, r, s;\n    cout << \"r = \";\n    cin >> r;\n    cout << \"s = \";\n    cin >> s;\n    if (r * r <= s * s)\n      k=sqrt(tsin(r)*tsin(r)+tsin(s)*tsin(s));\n    else\n      k = tsin(r * s) / 2;\n    cout << k << endl;\n    return 0;\n}\n\n\n\n//运行结果：\nr=5\ns=8\n1.37781\n\n```\n\n\n\n\n\n```c++\n/*6.投骰子的随机游戏\n\n每个骰子有六面，点数分别为1、2、3、4、5、6。游戏者在程序开始时输入一个无符号整数，作为产生随机数的种子。\n每轮投两次骰子，第一轮如果和数为7或11则为胜，游戏结束；和数为2、3或12则为负，游戏结束；和数为其它值则将此值作为自己的点数，继续第二轮、第三轮...直到某轮的和数等于点数则取胜，若在此前出现和数为7则为负。\n由rolldice函数负责模拟投骰子、计算和数并输出和数。\n\nrand\n函数原型：int rand(void);\n所需头文件：<cstdlib>\n功能和返回值：求出并返回一个伪随机数\n\nsrand\n函数原型：void srand(unsigned int seed);\n参数：seed产生随机数的种子。\n所需头文件：<cstdlib>\n功能：为使rand()产生一序列伪随机整数而设置起始点。使用1作为seed参数，可以重新初化rand()。*/\n\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\n//投骰子、计算和数、输出和数\nint rollDice() {\n    int die1 = 1 + rand() % 6;\n    int die2 = 1 + rand() % 6;\n    int sum = die1 + die2;\n    cout << \"player rolled \" << die1 << \" + \" << die2 << \" = \" << sum << endl;\n    return sum;\n}\n\nenum GameStatus { WIN, LOSE, PLAYING };\n\nint main() {\n    int sum, myPoint;\n    GameStatus status;\n\n    unsigned seed; \n    cout<<\"Please enter an unsigned integer: \";\n    cin >> seed;//输入随机数种子\n    srand(seed);//将种子传递给rand()\n\n    sum = rollDice(); //第一轮投骰子、计算和数\n\nswitch (sum) {\n    case 7:   //如果和数为7或11则为胜,状态为WIN\n    case 11:\n      status = WIN;\n      break;\n    case 2:   //和数为2、3或12则为负,状态为LOSE\n    case 3: \n    case 12:\n      status = LOSE;\n      break;\n    default: /*其它情况,游戏尚无结果,状态为\n            PLAYING,记下点数,为下一轮做准备 */\n      status = PLAYING;\n      myPoint = sum;\n      cout << \"point is \" << myPoint << endl;\n      break;\n    }\n\nwhile (status == PLAYING) { //只要状态仍为PLAYING,就继续进 行下一轮\n      sum = rollDice();\n      if (sum == myPoint)    //某轮的和数等于点数则取胜\n        status = WIN;\n      else if (sum == 7)    //出现和数为7则为负\n        status = LOSE;\n    }\n\n    //当状态不为PLAYING时上面的循环结束,以下程序段输出游戏结果\n    if (status == WIN)\n      cout << \"player wins\" << endl;\n    else\n      cout << \"player loses\" << endl;\n\n    return 0;\n}\n//运行结果：\nPlease enter an unsigned integer:23\nplayer rolled 6 + 3 = 9\npoint is 9\nplayer rolled 5 + 4 = 9\nplayer wins\n```\n\n\n\n\n\n**嵌套调用**\n\n```c++\n//1.输入两个整数，求平方和\n\n#include <iostream>\nusing namespace std;\n\nint fun2(int m) \n{\n    return m * m;\n}\n\nint fun1(int x,int y) \n{\n    return fun2(x) + fun2(y);\n}\n\nint main() \n{\n    int a, b;\n    cout<<\"Please enter two integers (a and b): \";\n    cin >> a >> b;\n    cout << \"The sum of square of a and  b: \" << fun1(a, b) << endl;\n    return 0;\n}\n\n\n//运行结果：\nPlease enter two integers(a and b): 3 4\nThe sum of square of a and b: 25\n```\n\n**递归调用**\n\n//1.求n!\n$$\nn!=  \\begin{cases}     1 & \\text{}\\ (n=0)  \\     n(n-1)! & \\text{}\\ (n> 0)  \\ \\end{cases} \n$$\n\n\n```c++\n#include <iostream>\nusing namespace std;\n\nunsigned fac(int n)\n{\n    unsigned f;\n    if (n == 0)\n      f = 1;\n  else\n      f = fac(n - 1) * n;\n  return f;\n}\n\nint main() \n{\n    unsigned n;\n    cout << \"Enter a positive integer:\";\n    cin >> n;\n    unsigned y = fac(n);\n    cout << n << \"! = \" << y << endl;\n    return 0;\n}\n\n//运行结果：\nEnter a positive integer:8\n8! = 40320\n\n```\n\n\n\n\n\n```c++\n/*2.用递归法计算从n个人中选择k个人组成一个委员会的不同组合数。\n\n分析：\n   由n个人里选k个人的组合数 = 由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数\n当n = k或k = 0时，组合数为1*/\n\n#include <iostream>\nusing namespace std;\n\nint comm(int n, int k) {\n    if (k > n)\n      return 0;\n    else if (n == k || k == 0)\n      return 1;\n    else\n      return comm(n - 1, k) + comm(n - 1, k - 1);\n}\n\nint main() {\n    int n, k;\n    cout << \"Please enter two integers n and k: \";\n    cin >> n >> k;\n    cout << \"C(n, k) = \" << comm(n, k) << endl;\n    return 0;\n}\n```\n\n\n\n**3.汉诺塔问题**\n\n有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。\n\n![img](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片1.png)\n\n分析：\n\n- **将n 个盘子从A针移到C针可以分解为下面三个步骤：**\n- ①将A 上n-1个盘子移到 B针上（借助C针）;\n- ②把A针上剩下的一个盘子移到C针上;\n-  ③将n-1个盘子从B针移到C针上（借助A针）; \n-  **事实上，上面三个步骤包含两种操作：** \n- ①将多个盘子从一个针移到另一个针上，这是一个递归的过程。 hanoi函数实现。\n- ②将1个盘子从一个针上移到另一针上。 用move函数实现\n\n```c++\n//3.汉诺塔问题\n\n#include <iostream>\nusing namespace std;\n\n//把src针的最上面一个盘子移动到dest针上\nvoid move(char src, char dest) { \n    cout << src << \" --> \" << dest << endl;\n}\n\n//把n个盘子从src针移动到dest针，以medium针作为中介\nvoid hanoi(int n, char src, char medium, char dest) {\n    if (n == 1)\n      move(src, dest);\n    else {\n      hanoi(n - 1, src, dest, medium);\n      move(src, dest);\n      hanoi(n - 1, medium, src, dest);\n    }\n}\n\nint main() {\n    int m;\n    cout << \"Enter the number of diskes: \";\n    cin >> m;\n    cout << \"the steps to moving \" << m << \" diskes:\" << endl;\n    hanoi(m,'A','B','C');\n    return 0;\n}\n\n//运行结果：\nEnter the number of diskes:3\nthe steps to moving 3 diskes:\nA --> C\nA --> B\nC --> B\nA --> C\nB --> A\nB --> C\nA --> C\n```\n\n### 函数的参数传递\n\n-  在函数被调用时才分配形参的存储单元。 \n-  实参可以是常量、变量或表达式。 \n-  实参类型必须与形参相符。 \n-  值传递是传递参数值，即单向传递。 \n-  引用传递可以实现双向传递 \n-  常引用作参数可以保障实参数据的安全 \n\n**引用传递**\n\n引用(&)是标识符的别名,例如:\n\n```c++\nint i,j;\nint &ri=i;//建立一个int型的引用ri,并将其初始化为变量i的一个别名\nj=10;\nri=j;//相当于 i = j;\n```\n\n声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。 一旦一个引用被初始化后，就不能改为指向其它对象。 引用可以作为形参:\n\n```c++\nvoid swap(int &a, int &b) {...}\n//1.输入两个整数交换后输出\n\n#include<iostream>\nusing namespace std;\nvoid swap(int& a, int& b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int x = 5, y = 10;\n    cout << \"x = \" << x << \"  y = \" << y << endl;\n    swap(x, y);\n    cout << \"x = \" << x << \"  y = \" << y << endl;\n    return 0;\n}\n\n//运行结果:\nx = 5   y = 10\nx = 10  y = 5\n\n```\n\n\n\n```c++\n//2.值传递与引用传递的比较\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\nvoid fiddle(int in1, int &in2) \n{\n    in1 = in1 + 100;\n    in2 = in2 + 100;\n    cout<<\"The values are \";\n    cout << setw(5) << in1;\n    cout << setw(5) << in2 << endl;\n}\n\nint main() { \n  int v1=7,v2=12;\n  cout << \"The values are \";\n  cout << setw(5) << v1;\n  cout << setw(5) << v2 << endl;\n  fiddle(v1, v2);\n  cout << \"The values are \";\n  cout << setw(5) << v1;\n  cout << setw(5) << v2 << endl;\n  return 0;\n}\n```\n\n\n\n\n\n## 2.内联函数\n\n-  声明时使用关键字 inline。 \n-  编译时在调用处用函数体进行替换,节省了参数传递、控制转移等开销。 \n-  内联函数体内不能有循环语句和switch语句。 \n-  内联函数的声明必须出现在内联函数第一次被调用之前。 \n-  对内联函数不能进行异常接口声明。 \n\n```c++\n//example:\n\n#include <iostream>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\ninline double calArea(double radius) {\n    return PI * radius * radius;\n}\n\nint main() {\n    double r = 3.0;\n    double area = calArea(r);\n    cout << area << endl;\n    return 0;\n}\n```\n\n## 3.带默认参数值的函数\n\n函数在声明时可以预先给出默认的形参值，调用时如给出实参，则采用实参值，否则采用预先给出的默认参数值。\n\n例如：\n\n```c++\nint add(int x = 5,int y = 6) {\n    return x + y;\n}\nint main() {\n    add(10,20);//10+20\n    add(10);  //10+6\n    add();  //5+6\n}\n```\n\n**默认参数值的说明次序**\n\n有默认参数的形参必须在形参列表的最后，也就是说默认参数值的右面不能有无默认值的参数。因为调用时实参与形参的结合是从左向右的顺序。\n\n例：\n\n```c++\nint add(int x, int y = 5, int z = 6);//正确\nint add(int x = 1, int y = 5, int z);//错误\nint add(int x = 1, int y, int z = 6);//错误\n```\n\n**默认参数值与函数的调用位置**\n\n如果一个函数有原型声明，且原型声明在定义之前，则默认参数值必须在函数原型声明中给出；而如果只有函数的定义，或函数定义在前，则默认参数值需在函数定义中给出。 例：\n\n```\nint add(int x = 5,int y = 6);        int add(int x = 5,int y = 6) {\n//原型声明在前                         //只有定义，没有原型声明\nint main() {                         return  x + y;\n  add();                             }\n}                                    int main() {\nint add(int x,int y) {               add();\n//此处不能再指定默认值                   }\n  return x + y;\n}\n\n```\n\n## 4.函数重载\n\nC++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。\n\n例：\n\n```c++\n//形参类型不同\nint add(int x, int y);\nfloat add(float x, float y);\n\n//形参个数不同\nint add(int x, int y);\nint add(int x, int y, int z);\n```\n\n\n\n```c++\n/*1.计算长方体的体积\n\n子函数getVolume是计算体积的函数，有三个形参：length（长）、width（宽）、height（高），其中width和height带有默认值。\n主函数中以不同形式调用getVolume函数，分析程序的运行结果。*/\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint getVolume(int length, int width = 2, int height = 3);\n\nint main() {\n    const int X = 10, Y = 12, Z = 15;\n    cout << \"Some box data is \" ;\n    cout << getVolume(X, Y, Z) << endl;\n    cout << \"Some box data is \" ;\n    cout << getVolume(X, Y) << endl;\n    cout << \"Some box data is \" ;\n    cout << getVolume(X) << endl;\n    return 0;\n}\n\nint getVolume(int length, int width/* = 2 */, int height/* = 3 */) {\n    cout << setw(5) << length << setw(5) << width << setw(5) << height << '\\t';\n    return length * width * height;\n}\n```\n\n\n\n\n\n**注意事项**\n\n-  重载函数的形参必须不同:个数不同或类型不同。 \n-  编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。 \n\n```c++\nint add(int x,int y);                     int add(int x,int y);\nint add(int a,int b);                     void add(int x,int y);\n//编译器不以形参名来区分                        //编译器不以返回值来区分\n```\n\n- 不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好：\n\n```c++\nint add(int x, int y)               float add(float x,float y)\n{  return x + y;  }                 {  return x - y;  }\n//编写两个名为sumOfSquare的重载函数，分别求两整数的平方和及两实数的平方和。\n\n\n\n#include <iostream>\nusing namespace std;\n\nint sumOfSquare(int a, int b) {\n    return a * a + b * b;\n}\ndouble sumOfSquare(double a, double b) {\n    return a * a + b * b;\n}\nint main() {\n    int m, n;\n    cout << \"Enter two integer: \";\n    cin >> m >> n;\n    cout << \"Their sum of square: \" << sumOfSquare(m, n) << endl;\n\n    double x, y;\n    cout << \"Enter two real number: \";\n    cin >> x >> y;\n    cout << \"Their sum of square: \" << sumOfSquare(x, y) << endl;\n\n    return 0;\n}\n\n\n//运行结果：\nEnter two integer: 3 5\nTheir sum of square: 34\nEnter two real number: 2.3 5.8\nTheir sum of square: 38.93\n```\n\n## 5.使用C++系统函数\n\nC++的系统库中提供了几百个函数可供程序员使用。 例如：求平方根函数（sprt）、求绝对值函数（abs）等。\n\n使用系统函数时要包含相应的头文件。 例如：cmath 或 math.h\n\n```c++\n/*1.从键盘输入一个角度值，求出该角度的正弦值、余弦值和正切值。\n\n分析：\n系统函数中提供了求正弦值、余弦值和正切值的函数：sin()、cos()、tan()，函数的说明在头文件cmath中。*/\n\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nint main() {\n    double angle;\n    cout << \"Please enter an angle: \";\n    cin >> angle;   //输入角度值\n\n    double radian = angle * PI / 180;   //转化为弧度值\n    cout << \"sin(\" << angle << \") = \" << sin(radian) <<endl;\n    cout << \"cos(\" << angle << \") = \" << cos(radian) <<endl;\n    cout << \"tan(\" << angle << \") = \" << tan(radian) <<endl;\n    return 0;\n}\n\n//运行结果：\n30\nsin(30)=0.5\ncos(30)=0.866025\ntan(30)=0.57735\n```","slug":"C-学习笔记整理-第三章《函数》","published":true,"updated":"2021-05-18T07:52:44.799Z","_id":"clq6dy488000bikw0x8vv0062","comments":true,"layout":"post","photos":[],"link":"","html":"<p><strong>前面几章大体上和C差不多，就从函数开始吧。</strong></p>\n<h2 id=\"第三章-函数\"><a href=\"#第三章-函数\" class=\"headerlink\" title=\"第三章 函数\"></a>第三章 函数</h2><h2 id=\"1-函数的定义与使用\"><a href=\"#1-函数的定义与使用\" class=\"headerlink\" title=\"1 .函数的定义与使用\"></a>1 .函数的定义与使用</h2><h3 id=\"函数定义的语法形式：\"><a href=\"#函数定义的语法形式：\" class=\"headerlink\" title=\"函数定义的语法形式：\"></a>函数定义的语法形式：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">类型标识符  函数名（形式参数表）\n{  \n   语句序列\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>若无返回值，类型标识符写void </li>\n<li>形式参数表：是被初始化的内部变量，寿命和可见性仅限于函数内部 </li>\n</ul>\n<h3 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h3><p><strong>调用前先声明函数：</strong></p>\n<ul>\n<li>若函数定义在调用点之前，则无需另外声明； </li>\n<li>若函数定义在调用点之后，则需要在调用函数前按如下形式声明函数原型： </li>\n</ul>\n<p>类型标识符 被调用函数名（含类型说明的形参表）;</p>\n<p><strong>调用形式：</strong> </p>\n<p>函数名（实参列表）</p>\n<ul>\n<li>嵌套调用：     在一个函数的函数体中，可以调用另一函数，称为嵌套调用。 </li>\n<li>递归调用：     函数直接或间接调用自身。 </li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//1.编写一个求x的n次方的函数\n\n#include <iostream>\nusing namespace std;\n\n//计算x的n次方\ndouble power(double x,int n)\n{\n    double val=1.0;\n    while(n--)\n        val*=x;\n    return val;\n}\n\nint main()\n{\n    cout << \"5 to the power 2 is :\"<< power(5, 2) << endl;\n    return 0;\n}\n\n\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//2.数制转换\n//输入一个8位二进制数，将其转换为十进制数输出。\n//例如：11012=1(23)+1(22)+0(21)+1(20)=1310 \n//所以，如果输入1101，则应输出13\n\n#include <iostream>\nusing namespace std;\n\ndouble power (double x,int n); //计算x的n次方\n\nint main()\n{\n    int  value=0;\n    cout <<\"Enter an 8 bit binary number \";\n    for (int i=7;i>=0;i--) \n    {\n      char ch;\n      cin>>ch;\n      if (ch =='1')\n            value+=static_cast<int>(power(2, i));\n    }\n    cout<<\"Decimal value is \"<<value<<endl;\n    return 0;\n}\n\ndouble power(double x,int n)\n{\n    double val=1.0;\n    while(n--) \n      val*=x;\n    return val;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">\n/*3.编写程序求π的值\nπ=16arctan(1/5)-4arctan(1/239)\n其中arctan用如下形式的级数计算：\narctanx=x-x^3/3+x^/5-x^7/7+...\n直到级数某项绝对值不大于10-15为止；π和x均为double型。*/\n\n#include <iostream>\nusing namespace std;\n\ndouble arctan(double x)\n{\n    double sqr = x * x;\n    double e = x;\n    double r = 0;\n    int i = 1;\n    while (e / i > 1e-15) {\n        double f = e / i;\n        r = (i % 4 == 1) ? r + f : r - f;\n        e = e * sqr;\n        i += 2;\n    }\n    return r;\n}\n\nint main() \n{\n    double a = 16.0 * arctan(1 / 5.0); \n    double b = 4.0 * arctan(1 / 239.0); \n    /* 注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0 */\n\n    cout << \"PI = \" << a - b << endl;\n    return 0;\n}\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">/*4.寻找并输出11~999之间的数m，它满足m、m2和m3均为回文数。\n回文：各位数字左右对称的整数。\n例如：11满足上述条件 \n112=121，113=1331。\n分析：\n10取余的方法，从最低位开始，依次取出该数的各位数字。按反序重新构成新的数，比较与原数是否相等，若相等，则原数为回文。*/\n\n#include <iostream>\nusing namespace std;\n//判断n是否为回文数\nbool symm(unsigned n)\n{\n  unsigned i = n;\n    unsigned m = 0;\n    while (i > 0) {\n      m = m*10+i%10;\n      i/=10;\n  }\n  return m==n;\n}\n\nint main()\n{\n    for(unsigned m = 11; m < 1000; m++)\n      if (symm(m) && symm(m * m) &&\n          symm(m * m * m)) {\n        cout << \"m = \" << m;\n        cout << \"  m * m = \" << m * m;\n        cout << \"  m * m * m = \"\n             << m * m * m << endl;\n      }\n    return 0;\n}\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>/<em>5.计算如下公式，并输出结果：</em><br>$$<br>k =  \\begin{cases}     \\sqrt{sin^2r+sin^2s} &amp; \\text{}\\  当r^2\\leqslant s^2\\     \\frac{1}{2}sin(rs) &amp; \\text{}\\ 当r^2&gt; s^2&amp;  \\end{cases}<br>$$<br>其中r、s的值由键盘输入</p>\n<p>sin x的近似值按如下公式计算，计算精度为10-10：</p>\n<p>$$ sinx=\\frac{x}{1!}+\\frac{x^3}{3!}+\\frac{x^5}{5!}+\\frac{x^7}{7!}+…=\\displaystyle \\sum_{n=1}^∞(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!} $$</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <cmath>  /*对C++标准库中数学函数的说明*/\nusing namespace std;\n\nconst double TINY_VALUE = 1e-10;\n\ndouble tsin(double x) \n{\n    double g = 0;\n    double t = x;\n    int n = 1;\n    do {\n        g += t;\n        n++;\n        t = -t * x * x / (2 * n - 1) / (2 * n - 2);\n    } while (fabs(t) >= TINY_VALUE); \n    return g;\n} \n\nint main() \n{\n    double k, r, s;\n    cout << \"r = \";\n    cin >> r;\n    cout << \"s = \";\n    cin >> s;\n    if (r * r <= s * s)\n      k=sqrt(tsin(r)*tsin(r)+tsin(s)*tsin(s));\n    else\n      k = tsin(r * s) / 2;\n    cout << k << endl;\n    return 0;\n}\n\n\n\n//运行结果：\nr=5\ns=8\n1.37781\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">/*6.投骰子的随机游戏\n\n每个骰子有六面，点数分别为1、2、3、4、5、6。游戏者在程序开始时输入一个无符号整数，作为产生随机数的种子。\n每轮投两次骰子，第一轮如果和数为7或11则为胜，游戏结束；和数为2、3或12则为负，游戏结束；和数为其它值则将此值作为自己的点数，继续第二轮、第三轮...直到某轮的和数等于点数则取胜，若在此前出现和数为7则为负。\n由rolldice函数负责模拟投骰子、计算和数并输出和数。\n\nrand\n函数原型：int rand(void);\n所需头文件：<cstdlib>\n功能和返回值：求出并返回一个伪随机数\n\nsrand\n函数原型：void srand(unsigned int seed);\n参数：seed产生随机数的种子。\n所需头文件：<cstdlib>\n功能：为使rand()产生一序列伪随机整数而设置起始点。使用1作为seed参数，可以重新初化rand()。*/\n\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\n//投骰子、计算和数、输出和数\nint rollDice() {\n    int die1 = 1 + rand() % 6;\n    int die2 = 1 + rand() % 6;\n    int sum = die1 + die2;\n    cout << \"player rolled \" << die1 << \" + \" << die2 << \" = \" << sum << endl;\n    return sum;\n}\n\nenum GameStatus { WIN, LOSE, PLAYING };\n\nint main() {\n    int sum, myPoint;\n    GameStatus status;\n\n    unsigned seed; \n    cout<<\"Please enter an unsigned integer: \";\n    cin >> seed;//输入随机数种子\n    srand(seed);//将种子传递给rand()\n\n    sum = rollDice(); //第一轮投骰子、计算和数\n\nswitch (sum) {\n    case 7:   //如果和数为7或11则为胜,状态为WIN\n    case 11:\n      status = WIN;\n      break;\n    case 2:   //和数为2、3或12则为负,状态为LOSE\n    case 3: \n    case 12:\n      status = LOSE;\n      break;\n    default: /*其它情况,游戏尚无结果,状态为\n            PLAYING,记下点数,为下一轮做准备 */\n      status = PLAYING;\n      myPoint = sum;\n      cout << \"point is \" << myPoint << endl;\n      break;\n    }\n\nwhile (status == PLAYING) { //只要状态仍为PLAYING,就继续进 行下一轮\n      sum = rollDice();\n      if (sum == myPoint)    //某轮的和数等于点数则取胜\n        status = WIN;\n      else if (sum == 7)    //出现和数为7则为负\n        status = LOSE;\n    }\n\n    //当状态不为PLAYING时上面的循环结束,以下程序段输出游戏结果\n    if (status == WIN)\n      cout << \"player wins\" << endl;\n    else\n      cout << \"player loses\" << endl;\n\n    return 0;\n}\n//运行结果：\nPlease enter an unsigned integer:23\nplayer rolled 6 + 3 = 9\npoint is 9\nplayer rolled 5 + 4 = 9\nplayer wins<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>嵌套调用</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//1.输入两个整数，求平方和\n\n#include <iostream>\nusing namespace std;\n\nint fun2(int m) \n{\n    return m * m;\n}\n\nint fun1(int x,int y) \n{\n    return fun2(x) + fun2(y);\n}\n\nint main() \n{\n    int a, b;\n    cout<<\"Please enter two integers (a and b): \";\n    cin >> a >> b;\n    cout << \"The sum of square of a and  b: \" << fun1(a, b) << endl;\n    return 0;\n}\n\n\n//运行结果：\nPlease enter two integers(a and b): 3 4\nThe sum of square of a and b: 25<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>递归调用</strong></p>\n<p>//1.求n!<br>$$<br>n!=  \\begin{cases}     1 &amp; \\text{}\\ (n=0)  \\     n(n-1)! &amp; \\text{}\\ (n&gt; 0)  \\ \\end{cases}<br>$$</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <iostream>\nusing namespace std;\n\nunsigned fac(int n)\n{\n    unsigned f;\n    if (n == 0)\n      f = 1;\n  else\n      f = fac(n - 1) * n;\n  return f;\n}\n\nint main() \n{\n    unsigned n;\n    cout << \"Enter a positive integer:\";\n    cin >> n;\n    unsigned y = fac(n);\n    cout << n << \"! = \" << y << endl;\n    return 0;\n}\n\n//运行结果：\nEnter a positive integer:8\n8! = 40320\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">/*2.用递归法计算从n个人中选择k个人组成一个委员会的不同组合数。\n\n分析：\n   由n个人里选k个人的组合数 = 由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数\n当n = k或k = 0时，组合数为1*/\n\n#include <iostream>\nusing namespace std;\n\nint comm(int n, int k) {\n    if (k > n)\n      return 0;\n    else if (n == k || k == 0)\n      return 1;\n    else\n      return comm(n - 1, k) + comm(n - 1, k - 1);\n}\n\nint main() {\n    int n, k;\n    cout << \"Please enter two integers n and k: \";\n    cin >> n >> k;\n    cout << \"C(n, k) = \" << comm(n, k) << endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3.汉诺塔问题</strong></p>\n<p>有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%871.png\" alt=\"img\"></p>\n<p>分析：</p>\n<ul>\n<li><strong>将n 个盘子从A针移到C针可以分解为下面三个步骤：</strong></li>\n<li>①将A 上n-1个盘子移到 B针上（借助C针）;</li>\n<li>②把A针上剩下的一个盘子移到C针上;</li>\n<li>③将n-1个盘子从B针移到C针上（借助A针）; </li>\n<li><strong>事实上，上面三个步骤包含两种操作：</strong> </li>\n<li>①将多个盘子从一个针移到另一个针上，这是一个递归的过程。 hanoi函数实现。</li>\n<li>②将1个盘子从一个针上移到另一针上。 用move函数实现</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//3.汉诺塔问题\n\n#include <iostream>\nusing namespace std;\n\n//把src针的最上面一个盘子移动到dest针上\nvoid move(char src, char dest) { \n    cout << src << \" --> \" << dest << endl;\n}\n\n//把n个盘子从src针移动到dest针，以medium针作为中介\nvoid hanoi(int n, char src, char medium, char dest) {\n    if (n == 1)\n      move(src, dest);\n    else {\n      hanoi(n - 1, src, dest, medium);\n      move(src, dest);\n      hanoi(n - 1, medium, src, dest);\n    }\n}\n\nint main() {\n    int m;\n    cout << \"Enter the number of diskes: \";\n    cin >> m;\n    cout << \"the steps to moving \" << m << \" diskes:\" << endl;\n    hanoi(m,'A','B','C');\n    return 0;\n}\n\n//运行结果：\nEnter the number of diskes:3\nthe steps to moving 3 diskes:\nA --> C\nA --> B\nC --> B\nA --> C\nB --> A\nB --> C\nA --> C<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数的参数传递\"><a href=\"#函数的参数传递\" class=\"headerlink\" title=\"函数的参数传递\"></a>函数的参数传递</h3><ul>\n<li>在函数被调用时才分配形参的存储单元。 </li>\n<li>实参可以是常量、变量或表达式。 </li>\n<li>实参类型必须与形参相符。 </li>\n<li>值传递是传递参数值，即单向传递。 </li>\n<li>引用传递可以实现双向传递 </li>\n<li>常引用作参数可以保障实参数据的安全 </li>\n</ul>\n<p><strong>引用传递</strong></p>\n<p>引用(&amp;)是标识符的别名,例如:</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int i,j;\nint &ri=i;//建立一个int型的引用ri,并将其初始化为变量i的一个别名\nj=10;\nri=j;//相当于 i = j;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。 一旦一个引用被初始化后，就不能改为指向其它对象。 引用可以作为形参:</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void swap(int &a, int &b) {...}\n//1.输入两个整数交换后输出\n\n#include<iostream>\nusing namespace std;\nvoid swap(int& a, int& b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int x = 5, y = 10;\n    cout << \"x = \" << x << \"  y = \" << y << endl;\n    swap(x, y);\n    cout << \"x = \" << x << \"  y = \" << y << endl;\n    return 0;\n}\n\n//运行结果:\nx = 5   y = 10\nx = 10  y = 5\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//2.值传递与引用传递的比较\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\nvoid fiddle(int in1, int &in2) \n{\n    in1 = in1 + 100;\n    in2 = in2 + 100;\n    cout<<\"The values are \";\n    cout << setw(5) << in1;\n    cout << setw(5) << in2 << endl;\n}\n\nint main() { \n  int v1=7,v2=12;\n  cout << \"The values are \";\n  cout << setw(5) << v1;\n  cout << setw(5) << v2 << endl;\n  fiddle(v1, v2);\n  cout << \"The values are \";\n  cout << setw(5) << v1;\n  cout << setw(5) << v2 << endl;\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-内联函数\"><a href=\"#2-内联函数\" class=\"headerlink\" title=\"2.内联函数\"></a>2.内联函数</h2><ul>\n<li>声明时使用关键字 inline。 </li>\n<li>编译时在调用处用函数体进行替换,节省了参数传递、控制转移等开销。 </li>\n<li>内联函数体内不能有循环语句和switch语句。 </li>\n<li>内联函数的声明必须出现在内联函数第一次被调用之前。 </li>\n<li>对内联函数不能进行异常接口声明。 </li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//example:\n\n#include <iostream>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\ninline double calArea(double radius) {\n    return PI * radius * radius;\n}\n\nint main() {\n    double r = 3.0;\n    double area = calArea(r);\n    cout << area << endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-带默认参数值的函数\"><a href=\"#3-带默认参数值的函数\" class=\"headerlink\" title=\"3.带默认参数值的函数\"></a>3.带默认参数值的函数</h2><p>函数在声明时可以预先给出默认的形参值，调用时如给出实参，则采用实参值，否则采用预先给出的默认参数值。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int add(int x = 5,int y = 6) {\n    return x + y;\n}\nint main() {\n    add(10,20);//10+20\n    add(10);  //10+6\n    add();  //5+6\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>默认参数值的说明次序</strong></p>\n<p>有默认参数的形参必须在形参列表的最后，也就是说默认参数值的右面不能有无默认值的参数。因为调用时实参与形参的结合是从左向右的顺序。</p>\n<p>例：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int add(int x, int y = 5, int z = 6);//正确\nint add(int x = 1, int y = 5, int z);//错误\nint add(int x = 1, int y, int z = 6);//错误<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>默认参数值与函数的调用位置</strong></p>\n<p>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值必须在函数原型声明中给出；而如果只有函数的定义，或函数定义在前，则默认参数值需在函数定义中给出。 例：</p>\n<pre><code>int add(int x = 5,int y = 6);        int add(int x = 5,int y = 6) {\n//原型声明在前                         //只有定义，没有原型声明\nint main() {                         return  x + y;\n  add();                             }\n}                                    int main() {\nint add(int x,int y) {               add();\n//此处不能再指定默认值                   }\n  return x + y;\n}\n</code></pre><h2 id=\"4-函数重载\"><a href=\"#4-函数重载\" class=\"headerlink\" title=\"4.函数重载\"></a>4.函数重载</h2><p>C++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。</p>\n<p>例：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//形参类型不同\nint add(int x, int y);\nfloat add(float x, float y);\n\n//形参个数不同\nint add(int x, int y);\nint add(int x, int y, int z);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">/*1.计算长方体的体积\n\n子函数getVolume是计算体积的函数，有三个形参：length（长）、width（宽）、height（高），其中width和height带有默认值。\n主函数中以不同形式调用getVolume函数，分析程序的运行结果。*/\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint getVolume(int length, int width = 2, int height = 3);\n\nint main() {\n    const int X = 10, Y = 12, Z = 15;\n    cout << \"Some box data is \" ;\n    cout << getVolume(X, Y, Z) << endl;\n    cout << \"Some box data is \" ;\n    cout << getVolume(X, Y) << endl;\n    cout << \"Some box data is \" ;\n    cout << getVolume(X) << endl;\n    return 0;\n}\n\nint getVolume(int length, int width/* = 2 */, int height/* = 3 */) {\n    cout << setw(5) << length << setw(5) << width << setw(5) << height << '\\t';\n    return length * width * height;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>重载函数的形参必须不同:个数不同或类型不同。 </li>\n<li>编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。 </li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int add(int x,int y);                     int add(int x,int y);\nint add(int a,int b);                     void add(int x,int y);\n//编译器不以形参名来区分                        //编译器不以返回值来区分<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好：</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int add(int x, int y)               float add(float x,float y)\n{  return x + y;  }                 {  return x - y;  }\n//编写两个名为sumOfSquare的重载函数，分别求两整数的平方和及两实数的平方和。\n\n\n\n#include <iostream>\nusing namespace std;\n\nint sumOfSquare(int a, int b) {\n    return a * a + b * b;\n}\ndouble sumOfSquare(double a, double b) {\n    return a * a + b * b;\n}\nint main() {\n    int m, n;\n    cout << \"Enter two integer: \";\n    cin >> m >> n;\n    cout << \"Their sum of square: \" << sumOfSquare(m, n) << endl;\n\n    double x, y;\n    cout << \"Enter two real number: \";\n    cin >> x >> y;\n    cout << \"Their sum of square: \" << sumOfSquare(x, y) << endl;\n\n    return 0;\n}\n\n\n//运行结果：\nEnter two integer: 3 5\nTheir sum of square: 34\nEnter two real number: 2.3 5.8\nTheir sum of square: 38.93<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"5-使用C-系统函数\"><a href=\"#5-使用C-系统函数\" class=\"headerlink\" title=\"5.使用C++系统函数\"></a>5.使用C++系统函数</h2><p>C++的系统库中提供了几百个函数可供程序员使用。 例如：求平方根函数（sprt）、求绝对值函数（abs）等。</p>\n<p>使用系统函数时要包含相应的头文件。 例如：cmath 或 math.h</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">/*1.从键盘输入一个角度值，求出该角度的正弦值、余弦值和正切值。\n\n分析：\n系统函数中提供了求正弦值、余弦值和正切值的函数：sin()、cos()、tan()，函数的说明在头文件cmath中。*/\n\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nint main() {\n    double angle;\n    cout << \"Please enter an angle: \";\n    cin >> angle;   //输入角度值\n\n    double radian = angle * PI / 180;   //转化为弧度值\n    cout << \"sin(\" << angle << \") = \" << sin(radian) <<endl;\n    cout << \"cos(\" << angle << \") = \" << cos(radian) <<endl;\n    cout << \"tan(\" << angle << \") = \" << tan(radian) <<endl;\n    return 0;\n}\n\n//运行结果：\n30\nsin(30)=0.5\ncos(30)=0.866025\ntan(30)=0.57735<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","excerpt":"","more":"<p><strong>前面几章大体上和C差不多，就从函数开始吧。</strong></p>\n<h2 id=\"第三章-函数\"><a href=\"#第三章-函数\" class=\"headerlink\" title=\"第三章 函数\"></a>第三章 函数</h2><h2 id=\"1-函数的定义与使用\"><a href=\"#1-函数的定义与使用\" class=\"headerlink\" title=\"1 .函数的定义与使用\"></a>1 .函数的定义与使用</h2><h3 id=\"函数定义的语法形式：\"><a href=\"#函数定义的语法形式：\" class=\"headerlink\" title=\"函数定义的语法形式：\"></a>函数定义的语法形式：</h3><pre><code class=\"c++\">类型标识符  函数名（形式参数表）\n{  \n   语句序列\n}</code></pre>\n<ul>\n<li>若无返回值，类型标识符写void </li>\n<li>形式参数表：是被初始化的内部变量，寿命和可见性仅限于函数内部 </li>\n</ul>\n<h3 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h3><p><strong>调用前先声明函数：</strong></p>\n<ul>\n<li>若函数定义在调用点之前，则无需另外声明； </li>\n<li>若函数定义在调用点之后，则需要在调用函数前按如下形式声明函数原型： </li>\n</ul>\n<p>类型标识符 被调用函数名（含类型说明的形参表）;</p>\n<p><strong>调用形式：</strong> </p>\n<p>函数名（实参列表）</p>\n<ul>\n<li>嵌套调用：     在一个函数的函数体中，可以调用另一函数，称为嵌套调用。 </li>\n<li>递归调用：     函数直接或间接调用自身。 </li>\n</ul>\n<pre><code class=\"c++\">//1.编写一个求x的n次方的函数\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n//计算x的n次方\ndouble power(double x,int n)\n{\n    double val=1.0;\n    while(n--)\n        val*=x;\n    return val;\n}\n\nint main()\n{\n    cout &lt;&lt; &quot;5 to the power 2 is :&quot;&lt;&lt; power(5, 2) &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n</code></pre>\n<pre><code class=\"c++\">//2.数制转换\n//输入一个8位二进制数，将其转换为十进制数输出。\n//例如：11012=1(23)+1(22)+0(21)+1(20)=1310 \n//所以，如果输入1101，则应输出13\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ndouble power (double x,int n); //计算x的n次方\n\nint main()\n{\n    int  value=0;\n    cout &lt;&lt;&quot;Enter an 8 bit binary number &quot;;\n    for (int i=7;i&gt;=0;i--) \n    {\n      char ch;\n      cin&gt;&gt;ch;\n      if (ch ==&#39;1&#39;)\n            value+=static_cast&lt;int&gt;(power(2, i));\n    }\n    cout&lt;&lt;&quot;Decimal value is &quot;&lt;&lt;value&lt;&lt;endl;\n    return 0;\n}\n\ndouble power(double x,int n)\n{\n    double val=1.0;\n    while(n--) \n      val*=x;\n    return val;\n}</code></pre>\n<pre><code class=\"c++\">\n/*3.编写程序求π的值\nπ=16arctan(1/5)-4arctan(1/239)\n其中arctan用如下形式的级数计算：\narctanx=x-x^3/3+x^/5-x^7/7+...\n直到级数某项绝对值不大于10-15为止；π和x均为double型。*/\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ndouble arctan(double x)\n{\n    double sqr = x * x;\n    double e = x;\n    double r = 0;\n    int i = 1;\n    while (e / i &gt; 1e-15) {\n        double f = e / i;\n        r = (i % 4 == 1) ? r + f : r - f;\n        e = e * sqr;\n        i += 2;\n    }\n    return r;\n}\n\nint main() \n{\n    double a = 16.0 * arctan(1 / 5.0); \n    double b = 4.0 * arctan(1 / 239.0); \n    /* 注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0 */\n\n    cout &lt;&lt; &quot;PI = &quot; &lt;&lt; a - b &lt;&lt; endl;\n    return 0;\n}\n\n</code></pre>\n<pre><code class=\"c++\">/*4.寻找并输出11~999之间的数m，它满足m、m2和m3均为回文数。\n回文：各位数字左右对称的整数。\n例如：11满足上述条件 \n112=121，113=1331。\n分析：\n10取余的方法，从最低位开始，依次取出该数的各位数字。按反序重新构成新的数，比较与原数是否相等，若相等，则原数为回文。*/\n\n#include &lt;iostream&gt;\nusing namespace std;\n//判断n是否为回文数\nbool symm(unsigned n)\n{\n  unsigned i = n;\n    unsigned m = 0;\n    while (i &gt; 0) {\n      m = m*10+i%10;\n      i/=10;\n  }\n  return m==n;\n}\n\nint main()\n{\n    for(unsigned m = 11; m &lt; 1000; m++)\n      if (symm(m) &amp;&amp; symm(m * m) &amp;&amp;\n          symm(m * m * m)) {\n        cout &lt;&lt; &quot;m = &quot; &lt;&lt; m;\n        cout &lt;&lt; &quot;  m * m = &quot; &lt;&lt; m * m;\n        cout &lt;&lt; &quot;  m * m * m = &quot;\n             &lt;&lt; m * m * m &lt;&lt; endl;\n      }\n    return 0;\n}\n\n</code></pre>\n<p>/<em>5.计算如下公式，并输出结果：</em><br>$$<br>k =  \\begin{cases}     \\sqrt{sin^2r+sin^2s} &amp; \\text{}\\  当r^2\\leqslant s^2\\     \\frac{1}{2}sin(rs) &amp; \\text{}\\ 当r^2&gt; s^2&amp;  \\end{cases}<br>$$<br>其中r、s的值由键盘输入</p>\n<p>sin x的近似值按如下公式计算，计算精度为10-10：</p>\n<p>$$ sinx=\\frac{x}{1!}+\\frac{x^3}{3!}+\\frac{x^5}{5!}+\\frac{x^7}{7!}+…=\\displaystyle \\sum_{n=1}^∞(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!} $$</p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;  /*对C++标准库中数学函数的说明*/\nusing namespace std;\n\nconst double TINY_VALUE = 1e-10;\n\ndouble tsin(double x) \n{\n    double g = 0;\n    double t = x;\n    int n = 1;\n    do {\n        g += t;\n        n++;\n        t = -t * x * x / (2 * n - 1) / (2 * n - 2);\n    } while (fabs(t) &gt;= TINY_VALUE); \n    return g;\n} \n\nint main() \n{\n    double k, r, s;\n    cout &lt;&lt; &quot;r = &quot;;\n    cin &gt;&gt; r;\n    cout &lt;&lt; &quot;s = &quot;;\n    cin &gt;&gt; s;\n    if (r * r &lt;= s * s)\n      k=sqrt(tsin(r)*tsin(r)+tsin(s)*tsin(s));\n    else\n      k = tsin(r * s) / 2;\n    cout &lt;&lt; k &lt;&lt; endl;\n    return 0;\n}\n\n\n\n//运行结果：\nr=5\ns=8\n1.37781\n</code></pre>\n<pre><code class=\"c++\">/*6.投骰子的随机游戏\n\n每个骰子有六面，点数分别为1、2、3、4、5、6。游戏者在程序开始时输入一个无符号整数，作为产生随机数的种子。\n每轮投两次骰子，第一轮如果和数为7或11则为胜，游戏结束；和数为2、3或12则为负，游戏结束；和数为其它值则将此值作为自己的点数，继续第二轮、第三轮...直到某轮的和数等于点数则取胜，若在此前出现和数为7则为负。\n由rolldice函数负责模拟投骰子、计算和数并输出和数。\n\nrand\n函数原型：int rand(void);\n所需头文件：&lt;cstdlib&gt;\n功能和返回值：求出并返回一个伪随机数\n\nsrand\n函数原型：void srand(unsigned int seed);\n参数：seed产生随机数的种子。\n所需头文件：&lt;cstdlib&gt;\n功能：为使rand()产生一序列伪随机整数而设置起始点。使用1作为seed参数，可以重新初化rand()。*/\n\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\n\n//投骰子、计算和数、输出和数\nint rollDice() {\n    int die1 = 1 + rand() % 6;\n    int die2 = 1 + rand() % 6;\n    int sum = die1 + die2;\n    cout &lt;&lt; &quot;player rolled &quot; &lt;&lt; die1 &lt;&lt; &quot; + &quot; &lt;&lt; die2 &lt;&lt; &quot; = &quot; &lt;&lt; sum &lt;&lt; endl;\n    return sum;\n}\n\nenum GameStatus { WIN, LOSE, PLAYING };\n\nint main() {\n    int sum, myPoint;\n    GameStatus status;\n\n    unsigned seed; \n    cout&lt;&lt;&quot;Please enter an unsigned integer: &quot;;\n    cin &gt;&gt; seed;//输入随机数种子\n    srand(seed);//将种子传递给rand()\n\n    sum = rollDice(); //第一轮投骰子、计算和数\n\nswitch (sum) {\n    case 7:   //如果和数为7或11则为胜,状态为WIN\n    case 11:\n      status = WIN;\n      break;\n    case 2:   //和数为2、3或12则为负,状态为LOSE\n    case 3: \n    case 12:\n      status = LOSE;\n      break;\n    default: /*其它情况,游戏尚无结果,状态为\n            PLAYING,记下点数,为下一轮做准备 */\n      status = PLAYING;\n      myPoint = sum;\n      cout &lt;&lt; &quot;point is &quot; &lt;&lt; myPoint &lt;&lt; endl;\n      break;\n    }\n\nwhile (status == PLAYING) { //只要状态仍为PLAYING,就继续进 行下一轮\n      sum = rollDice();\n      if (sum == myPoint)    //某轮的和数等于点数则取胜\n        status = WIN;\n      else if (sum == 7)    //出现和数为7则为负\n        status = LOSE;\n    }\n\n    //当状态不为PLAYING时上面的循环结束,以下程序段输出游戏结果\n    if (status == WIN)\n      cout &lt;&lt; &quot;player wins&quot; &lt;&lt; endl;\n    else\n      cout &lt;&lt; &quot;player loses&quot; &lt;&lt; endl;\n\n    return 0;\n}\n//运行结果：\nPlease enter an unsigned integer:23\nplayer rolled 6 + 3 = 9\npoint is 9\nplayer rolled 5 + 4 = 9\nplayer wins</code></pre>\n<p><strong>嵌套调用</strong></p>\n<pre><code class=\"c++\">//1.输入两个整数，求平方和\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint fun2(int m) \n{\n    return m * m;\n}\n\nint fun1(int x,int y) \n{\n    return fun2(x) + fun2(y);\n}\n\nint main() \n{\n    int a, b;\n    cout&lt;&lt;&quot;Please enter two integers (a and b): &quot;;\n    cin &gt;&gt; a &gt;&gt; b;\n    cout &lt;&lt; &quot;The sum of square of a and  b: &quot; &lt;&lt; fun1(a, b) &lt;&lt; endl;\n    return 0;\n}\n\n\n//运行结果：\nPlease enter two integers(a and b): 3 4\nThe sum of square of a and b: 25</code></pre>\n<p><strong>递归调用</strong></p>\n<p>//1.求n!<br>$$<br>n!=  \\begin{cases}     1 &amp; \\text{}\\ (n=0)  \\     n(n-1)! &amp; \\text{}\\ (n&gt; 0)  \\ \\end{cases}<br>$$</p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nunsigned fac(int n)\n{\n    unsigned f;\n    if (n == 0)\n      f = 1;\n  else\n      f = fac(n - 1) * n;\n  return f;\n}\n\nint main() \n{\n    unsigned n;\n    cout &lt;&lt; &quot;Enter a positive integer:&quot;;\n    cin &gt;&gt; n;\n    unsigned y = fac(n);\n    cout &lt;&lt; n &lt;&lt; &quot;! = &quot; &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\n\n//运行结果：\nEnter a positive integer:8\n8! = 40320\n</code></pre>\n<pre><code class=\"c++\">/*2.用递归法计算从n个人中选择k个人组成一个委员会的不同组合数。\n\n分析：\n   由n个人里选k个人的组合数 = 由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数\n当n = k或k = 0时，组合数为1*/\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint comm(int n, int k) {\n    if (k &gt; n)\n      return 0;\n    else if (n == k || k == 0)\n      return 1;\n    else\n      return comm(n - 1, k) + comm(n - 1, k - 1);\n}\n\nint main() {\n    int n, k;\n    cout &lt;&lt; &quot;Please enter two integers n and k: &quot;;\n    cin &gt;&gt; n &gt;&gt; k;\n    cout &lt;&lt; &quot;C(n, k) = &quot; &lt;&lt; comm(n, k) &lt;&lt; endl;\n    return 0;\n}</code></pre>\n<p><strong>3.汉诺塔问题</strong></p>\n<p>有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%871.png\" alt=\"img\"></p>\n<p>分析：</p>\n<ul>\n<li><strong>将n 个盘子从A针移到C针可以分解为下面三个步骤：</strong></li>\n<li>①将A 上n-1个盘子移到 B针上（借助C针）;</li>\n<li>②把A针上剩下的一个盘子移到C针上;</li>\n<li>③将n-1个盘子从B针移到C针上（借助A针）; </li>\n<li><strong>事实上，上面三个步骤包含两种操作：</strong> </li>\n<li>①将多个盘子从一个针移到另一个针上，这是一个递归的过程。 hanoi函数实现。</li>\n<li>②将1个盘子从一个针上移到另一针上。 用move函数实现</li>\n</ul>\n<pre><code class=\"c++\">//3.汉诺塔问题\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n//把src针的最上面一个盘子移动到dest针上\nvoid move(char src, char dest) { \n    cout &lt;&lt; src &lt;&lt; &quot; --&gt; &quot; &lt;&lt; dest &lt;&lt; endl;\n}\n\n//把n个盘子从src针移动到dest针，以medium针作为中介\nvoid hanoi(int n, char src, char medium, char dest) {\n    if (n == 1)\n      move(src, dest);\n    else {\n      hanoi(n - 1, src, dest, medium);\n      move(src, dest);\n      hanoi(n - 1, medium, src, dest);\n    }\n}\n\nint main() {\n    int m;\n    cout &lt;&lt; &quot;Enter the number of diskes: &quot;;\n    cin &gt;&gt; m;\n    cout &lt;&lt; &quot;the steps to moving &quot; &lt;&lt; m &lt;&lt; &quot; diskes:&quot; &lt;&lt; endl;\n    hanoi(m,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);\n    return 0;\n}\n\n//运行结果：\nEnter the number of diskes:3\nthe steps to moving 3 diskes:\nA --&gt; C\nA --&gt; B\nC --&gt; B\nA --&gt; C\nB --&gt; A\nB --&gt; C\nA --&gt; C</code></pre>\n<h3 id=\"函数的参数传递\"><a href=\"#函数的参数传递\" class=\"headerlink\" title=\"函数的参数传递\"></a>函数的参数传递</h3><ul>\n<li>在函数被调用时才分配形参的存储单元。 </li>\n<li>实参可以是常量、变量或表达式。 </li>\n<li>实参类型必须与形参相符。 </li>\n<li>值传递是传递参数值，即单向传递。 </li>\n<li>引用传递可以实现双向传递 </li>\n<li>常引用作参数可以保障实参数据的安全 </li>\n</ul>\n<p><strong>引用传递</strong></p>\n<p>引用(&amp;)是标识符的别名,例如:</p>\n<pre><code class=\"c++\">int i,j;\nint &amp;ri=i;//建立一个int型的引用ri,并将其初始化为变量i的一个别名\nj=10;\nri=j;//相当于 i = j;</code></pre>\n<p>声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。 一旦一个引用被初始化后，就不能改为指向其它对象。 引用可以作为形参:</p>\n<pre><code class=\"c++\">void swap(int &amp;a, int &amp;b) {...}\n//1.输入两个整数交换后输出\n\n#include&lt;iostream&gt;\nusing namespace std;\nvoid swap(int&amp; a, int&amp; b) {\n    int t = a;\n    a = b;\n    b = t;\n}\nint main() {\n    int x = 5, y = 10;\n    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;  y = &quot; &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;  y = &quot; &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\n\n//运行结果:\nx = 5   y = 10\nx = 10  y = 5\n</code></pre>\n<pre><code class=\"c++\">//2.值传递与引用传递的比较\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\nvoid fiddle(int in1, int &amp;in2) \n{\n    in1 = in1 + 100;\n    in2 = in2 + 100;\n    cout&lt;&lt;&quot;The values are &quot;;\n    cout &lt;&lt; setw(5) &lt;&lt; in1;\n    cout &lt;&lt; setw(5) &lt;&lt; in2 &lt;&lt; endl;\n}\n\nint main() { \n  int v1=7,v2=12;\n  cout &lt;&lt; &quot;The values are &quot;;\n  cout &lt;&lt; setw(5) &lt;&lt; v1;\n  cout &lt;&lt; setw(5) &lt;&lt; v2 &lt;&lt; endl;\n  fiddle(v1, v2);\n  cout &lt;&lt; &quot;The values are &quot;;\n  cout &lt;&lt; setw(5) &lt;&lt; v1;\n  cout &lt;&lt; setw(5) &lt;&lt; v2 &lt;&lt; endl;\n  return 0;\n}</code></pre>\n<h2 id=\"2-内联函数\"><a href=\"#2-内联函数\" class=\"headerlink\" title=\"2.内联函数\"></a>2.内联函数</h2><ul>\n<li>声明时使用关键字 inline。 </li>\n<li>编译时在调用处用函数体进行替换,节省了参数传递、控制转移等开销。 </li>\n<li>内联函数体内不能有循环语句和switch语句。 </li>\n<li>内联函数的声明必须出现在内联函数第一次被调用之前。 </li>\n<li>对内联函数不能进行异常接口声明。 </li>\n</ul>\n<pre><code class=\"c++\">//example:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst double PI = 3.14159265358979;\ninline double calArea(double radius) {\n    return PI * radius * radius;\n}\n\nint main() {\n    double r = 3.0;\n    double area = calArea(r);\n    cout &lt;&lt; area &lt;&lt; endl;\n    return 0;\n}</code></pre>\n<h2 id=\"3-带默认参数值的函数\"><a href=\"#3-带默认参数值的函数\" class=\"headerlink\" title=\"3.带默认参数值的函数\"></a>3.带默认参数值的函数</h2><p>函数在声明时可以预先给出默认的形参值，调用时如给出实参，则采用实参值，否则采用预先给出的默认参数值。</p>\n<p>例如：</p>\n<pre><code class=\"c++\">int add(int x = 5,int y = 6) {\n    return x + y;\n}\nint main() {\n    add(10,20);//10+20\n    add(10);  //10+6\n    add();  //5+6\n}</code></pre>\n<p><strong>默认参数值的说明次序</strong></p>\n<p>有默认参数的形参必须在形参列表的最后，也就是说默认参数值的右面不能有无默认值的参数。因为调用时实参与形参的结合是从左向右的顺序。</p>\n<p>例：</p>\n<pre><code class=\"c++\">int add(int x, int y = 5, int z = 6);//正确\nint add(int x = 1, int y = 5, int z);//错误\nint add(int x = 1, int y, int z = 6);//错误</code></pre>\n<p><strong>默认参数值与函数的调用位置</strong></p>\n<p>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值必须在函数原型声明中给出；而如果只有函数的定义，或函数定义在前，则默认参数值需在函数定义中给出。 例：</p>\n<pre><code>int add(int x = 5,int y = 6);        int add(int x = 5,int y = 6) {\n//原型声明在前                         //只有定义，没有原型声明\nint main() {                         return  x + y;\n  add();                             }\n}                                    int main() {\nint add(int x,int y) {               add();\n//此处不能再指定默认值                   }\n  return x + y;\n}\n</code></pre><h2 id=\"4-函数重载\"><a href=\"#4-函数重载\" class=\"headerlink\" title=\"4.函数重载\"></a>4.函数重载</h2><p>C++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。</p>\n<p>例：</p>\n<pre><code class=\"c++\">//形参类型不同\nint add(int x, int y);\nfloat add(float x, float y);\n\n//形参个数不同\nint add(int x, int y);\nint add(int x, int y, int z);</code></pre>\n<pre><code class=\"c++\">/*1.计算长方体的体积\n\n子函数getVolume是计算体积的函数，有三个形参：length（长）、width（宽）、height（高），其中width和height带有默认值。\n主函数中以不同形式调用getVolume函数，分析程序的运行结果。*/\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n\nint getVolume(int length, int width = 2, int height = 3);\n\nint main() {\n    const int X = 10, Y = 12, Z = 15;\n    cout &lt;&lt; &quot;Some box data is &quot; ;\n    cout &lt;&lt; getVolume(X, Y, Z) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Some box data is &quot; ;\n    cout &lt;&lt; getVolume(X, Y) &lt;&lt; endl;\n    cout &lt;&lt; &quot;Some box data is &quot; ;\n    cout &lt;&lt; getVolume(X) &lt;&lt; endl;\n    return 0;\n}\n\nint getVolume(int length, int width/* = 2 */, int height/* = 3 */) {\n    cout &lt;&lt; setw(5) &lt;&lt; length &lt;&lt; setw(5) &lt;&lt; width &lt;&lt; setw(5) &lt;&lt; height &lt;&lt; &#39;\\t&#39;;\n    return length * width * height;\n}</code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>重载函数的形参必须不同:个数不同或类型不同。 </li>\n<li>编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。 </li>\n</ul>\n<pre><code class=\"c++\">int add(int x,int y);                     int add(int x,int y);\nint add(int a,int b);                     void add(int x,int y);\n//编译器不以形参名来区分                        //编译器不以返回值来区分</code></pre>\n<ul>\n<li>不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好：</li>\n</ul>\n<pre><code class=\"c++\">int add(int x, int y)               float add(float x,float y)\n{  return x + y;  }                 {  return x - y;  }\n//编写两个名为sumOfSquare的重载函数，分别求两整数的平方和及两实数的平方和。\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint sumOfSquare(int a, int b) {\n    return a * a + b * b;\n}\ndouble sumOfSquare(double a, double b) {\n    return a * a + b * b;\n}\nint main() {\n    int m, n;\n    cout &lt;&lt; &quot;Enter two integer: &quot;;\n    cin &gt;&gt; m &gt;&gt; n;\n    cout &lt;&lt; &quot;Their sum of square: &quot; &lt;&lt; sumOfSquare(m, n) &lt;&lt; endl;\n\n    double x, y;\n    cout &lt;&lt; &quot;Enter two real number: &quot;;\n    cin &gt;&gt; x &gt;&gt; y;\n    cout &lt;&lt; &quot;Their sum of square: &quot; &lt;&lt; sumOfSquare(x, y) &lt;&lt; endl;\n\n    return 0;\n}\n\n\n//运行结果：\nEnter two integer: 3 5\nTheir sum of square: 34\nEnter two real number: 2.3 5.8\nTheir sum of square: 38.93</code></pre>\n<h2 id=\"5-使用C-系统函数\"><a href=\"#5-使用C-系统函数\" class=\"headerlink\" title=\"5.使用C++系统函数\"></a>5.使用C++系统函数</h2><p>C++的系统库中提供了几百个函数可供程序员使用。 例如：求平方根函数（sprt）、求绝对值函数（abs）等。</p>\n<p>使用系统函数时要包含相应的头文件。 例如：cmath 或 math.h</p>\n<pre><code class=\"c++\">/*1.从键盘输入一个角度值，求出该角度的正弦值、余弦值和正切值。\n\n分析：\n系统函数中提供了求正弦值、余弦值和正切值的函数：sin()、cos()、tan()，函数的说明在头文件cmath中。*/\n\n\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nint main() {\n    double angle;\n    cout &lt;&lt; &quot;Please enter an angle: &quot;;\n    cin &gt;&gt; angle;   //输入角度值\n\n    double radian = angle * PI / 180;   //转化为弧度值\n    cout &lt;&lt; &quot;sin(&quot; &lt;&lt; angle &lt;&lt; &quot;) = &quot; &lt;&lt; sin(radian) &lt;&lt;endl;\n    cout &lt;&lt; &quot;cos(&quot; &lt;&lt; angle &lt;&lt; &quot;) = &quot; &lt;&lt; cos(radian) &lt;&lt;endl;\n    cout &lt;&lt; &quot;tan(&quot; &lt;&lt; angle &lt;&lt; &quot;) = &quot; &lt;&lt; tan(radian) &lt;&lt;endl;\n    return 0;\n}\n\n//运行结果：\n30\nsin(30)=0.5\ncos(30)=0.866025\ntan(30)=0.57735</code></pre>\n","path":"c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html","permalink":"https://www.yshawlon.cn/c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html","tags":[{"name":"学习笔记","_id":"clq6dy48u0013ikw0galx0575","slug":"学习笔记","path":"tags/学习笔记/","permalink":"https://www.yshawlon.cn/tags/学习笔记/","length":9}],"categories":[{"name":"C++","_id":"clq6dy48e000hikw0uy63x2a1","slug":"C","path":"categories/C/","permalink":"https://www.yshawlon.cn/categories/C/","length":5}],"prev":{"title":"个人博客、网站被恶意DDOS攻击怎么办","date":"2020-07-05T15:53:34.000Z","summary":"几天前我的博客遭受DDOS攻击，攻击次数高达85万次，记录一下我处理的过程。","slug":"个人博客、网站被恶意DDOS攻击怎么办","published":true,"updated":"2021-02-19T15:35:27.005Z","_id":"clq6dy4a00027ikw0evad2ofb","layout":"post","photos":[],"link":"","excerpt":"","path":"ge-ren-bo-ke-wang-zhan-bei-e-yi-ddos-gong-ji-zen-me-ban.html","permalink":"https://www.yshawlon.cn/ge-ren-bo-ke-wang-zhan-bei-e-yi-ddos-gong-ji-zen-me-ban.html","__post":true},"next":{"title":"C++学习笔记整理-类与对象","date":"2020-04-26T10:53:44.000Z","summary":"抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程.","slug":"C-学习笔记整理-第四章《类与对象》","published":true,"updated":"2021-05-18T07:56:39.107Z","_id":"clq6dy48c000fikw0d22mmt5l","layout":"post","photos":[],"link":"","excerpt":"","path":"c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html","permalink":"https://www.yshawlon.cn/c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html","__post":true},"__post":true}