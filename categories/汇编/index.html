<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Shawlon`s Blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script></head>


 <div id="loading-container">
     <p class="loading-text"></p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url()">
        </div>
    </section>
    <section class='menu'>
        <div>Shawlon`s Blog</div>
        
            <div>Yshawlon</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ 汇编 }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu-hou-ban-bu-fen.html">《汇编语言》王爽著学习笔记记录(后半部分)</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-08T15:08:22.000Z" itemprop="datePublished">
    2021-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/汇编/">汇编</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="第七章：更灵活的定位内存地址的方法"><a href="#第七章：更灵活的定位内存地址的方法" class="headerlink" title="第七章：更灵活的定位内存地址的方法"></a>第七章：更灵活的定位内存地址的方法</h3><ol>
<li><p>and 和 or 指令：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
<th align="center">例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">将操作对象的相应位设为0，其它位不变</td>
<td align="center">将al的第0位设为0：and al,11111110B</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">逻辑或指令，按位进行或运算</td>
<td align="center">将al的第6位设为1：or al,01000000B</td>
</tr>
</tbody></table>
<p>使用这两个命令可以帮助我们对内存中的数据按位置 0 或 1.</p>
</li>
<li><p>指明内存单元的另一个方法：<strong>[bx + idata]来访问一个内存单元(一个变量一个常量)，其代表的是一个偏移地址；</strong>这种内存访问方式为高级语言实现数组提供了便利机制。</p>
<p><strong>命令 mov ax,[200 + bx] 的含义为： (ax) = ((ds) * 16 + (bx) + 200)</strong></p>
<p>通用写法：</p>
<ol>
<li>mov ax,[bx + 200] </li>
<li>mov ax,200[bx] </li>
<li>mov ax,[bx].200 </li>
</ol>
</li>
<li><p>si 和 di 是8086CPU中两个和 bx 功能相近的寄存器， 但不能分为两个 8 为寄存器来使用。</p>
<ol>
<li><pre class="line-numbers language-asm"><code class="language-asm">mov bx，0
mov ax，[bx]
mov si，0
mov ax，[si]
mov di，0
mov ax，[di]
mov bx,0

mov ax,[bx + 123]
mov si,0
mov ax,[si + 123]
mov di,0
mov ax,[di + 123]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
<p>   上面的代码说明了si 与 di 同 bx 使用上的相同之处。</p>
<ol start="4">
<li><p>我们可以使用 [bx (si 或 di)]（一个变量） 、[bx (si 或 di) + idata] （一个变量和一个常量）来指明一个内存单元，还有 [bx + si] 、[bx + di] （两个变量）</p>
<blockquote>
<p>mov ax,[bx + si]         ;(ax) = ((ds) * 16 + (bx) + (si))</p>
<p>常用形式: mov ax,[bx] [si]</p>
</blockquote>
</li>
<li><p>更多的内存访问方式：[bx + si + idata] 、[bx + di + idata]（两个变量，一个常量）</p>
<blockquote>
<p>mov ax,[bx + si + idata]  ;(ax) = ((ds) * 16 + (bx) + (si) + idata) </p>
</blockquote>
<p>常用形式：</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,[bx + 200 + si]
mov ax,[200 + bx + si]
mov ax,200[bx][si]
mov ax,[bx].200[si]
mov ax,[bx] [si].200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将datasg中的每个单词改为大写字母：</p>
<pre class="line-numbers language-asm"><code class="language-asm"> ;版本1
 ;使用 dx 寄存器临时保存 cx 中的值
assume cs:codesg,ds:datasg

datasg segment
     db 'ibm             '
    db 'dec             '
    db 'dos             '
    db 'vax             '
datasg ends

codesg segment
start: mov ax,datasg
       mov ds,ax
       mov bx,0                  ;此时指向第一行第一个字节的字母

       mov cx,4

   s0: mov dx,cx                 ;将 cx 的值暂存到 dx 中
          mov si,0
          mov cx,3

    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))
       and al,11011111b          ;将小写字母改为大写字母
       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)
       inc si                    ;si + 1

       loop s

       add bx,16                 ;00 → 10 → 20 → 30 ...
       mov cx,dx                 ;将暂存的 cx 返回
       loop s0                   ;cx - 1

codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm"> ;版本2
 ;使用栈空间来暂存数据，前面我们使用的是寄存器，但有些时候寄存器是不足的，不是可取的办法
assume cs:codesg,ds:datasg,ss:stacksg

datasg segment
     db 'ibm             '
    db 'dec             '
    db 'dos             '
    db 'vax             '
datasg ends

stacksg segnebt
        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节
stacksg ends

codesg segment
start: mov ax,stacksg
       mov ss,ax
       mov sp,16
       mov ax,datasg
       mov ds,ax
       mov bx,0                  ;此时指向第一行第一个字节的字母

       mov cx,4

   s0: push cx                   ;将外循环 cx 的值压栈
          mov si,0
          mov cx,3                  ;内循环 cx 的值

    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))
       and al,11011111b          ;将小写字母改为大写字母
       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)
       inc si                    ;si + 1

       loop s

       add bx,16                 ;00 → 10 → 20 → 30 ...
       pop cx                    ;将暂存的 cx 返回
       loop s0                   ;cx - 1

       mov ax,4c00H
       int 21H

codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在需要暂存数据的时候，一般使用栈来操作</strong></p>
</li>
<li><p>将 datasg 段中每个单词前4个字母改为大写：</p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:codesg,ds:datasg,ss:stacksg

datasg segment
     db '1. display      '
    db '2. brows        '
    db '3. replace      '
    db '4. modify       '
datasg ends

stacksg segnebt
        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节
stacksg ends

codesg segment
start: mov ax,stacksg
       mov ss,ax
       mov sp,16
       mov ax,datasg
       mov ds,ax
       mov bx,0                  ;此时指向第一行第一个字节的字母

       mov cx,4

   s0: push cx                   ;将外循环 cx 的值压栈
          mov si,0
          mov cx,4                  ;内循环 cx 的值

    s: mov al,[bx + 3 + si]      ;(al) = ((ds) * 16 + (bx) + (si) + 3)
       and al,11011111b          ;将小写字母改为大写字母
       mov [bx + 3 + si],al      ;((ds) * 16 +(bx) + (si) + 3) = (al)
       inc si                    ;si + 1

       loop s

       add bx,16                 ;00 → 10 → 20 → 30 ...
       pop cx                    ;将暂存的 cx 返回
       loop s0                   ;cx - 1

       mov ax,4c00H
       int 21H

codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="第八章：数据处理的两个基本问题"><a href="#第八章：数据处理的两个基本问题" class="headerlink" title="第八章：数据处理的两个基本问题"></a>第八章：数据处理的两个基本问题</h3><ol>
<li><p>描述性符号：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">功能</th>
<th align="center">集合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reg</td>
<td align="center">代表一个寄存器</td>
<td align="center">ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</td>
</tr>
<tr>
<td align="center">sreg</td>
<td align="center">代表一个段寄存器</td>
<td align="center">ds、ss、cs、es</td>
</tr>
</tbody></table>
</li>
<li><p>在8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 […] 中来进行内存单元的寻址。</p>
<p>在 […] 中，这四个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,[bx]
mov ax,[si]
mov ax,[di]
mov ax,[bp]
mov ax,[bx + si]
mov ax,[bx + di]
mov ax,[bp + si]
mov ax,[bp + di]
mov ax,[bx + si + idata]
mov ax,[bx + di + idata]
mov ax,[bp + si + idata]
mov ax,[bp + di + idata]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用寄存器 bp 进行寻址，如果没有显性的给出段地址，那么段地址默认在 ss 段寄存器中</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,[bp] ;(ax) = ((ss) * 16 + (bp))
mov ax,[bp + si + idata] ;(ax) = ((ss) * 16 + (bp) + (si) + idata)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>处理指令大致分为3类：读取、写入、运算；指令执行前，数据一般在3个地方：CPU内部、内存、端口</p>
</li>
<li><p>数据的位置：</p>
<ol>
<li><p>立即数（idata）：在汇编指令中字节给出</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,1
add bx,2000H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>寄存器：要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名就可以。</p>
</li>
<li><p>段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，使用段地址+偏移地址定位内存单元。</p>
</li>
</ol>
</li>
<li><p><strong>寻址方式总结：</strong></p>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">含义</th>
<th align="center">名称</th>
<th align="center">常用格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[idata]</td>
<td align="center">EA = idata;SA = (ds)</td>
<td align="center">直接寻址</td>
<td align="center">[idata]</td>
</tr>
<tr>
<td align="center">[bx]</td>
<td align="center">EA = (bx);SA = (ds)</td>
<td align="center">寄存器间接寻址</td>
<td align="center">[bx]</td>
</tr>
<tr>
<td align="center">[si]</td>
<td align="center">EA = (si) ;SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[di]</td>
<td align="center">EA = (di);SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp]</td>
<td align="center">EA = (bp);SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bx + idata]</td>
<td align="center">EA = (bx) + idata;SA = (ds)</td>
<td align="center">寄存器相对寻址</td>
<td align="center">用于结构体:[bx].idata</td>
</tr>
<tr>
<td align="center">[si + idata]</td>
<td align="center">EA = (si) + idata;SA = (ds)</td>
<td align="center"></td>
<td align="center">用于数组:idata[si],idata[di]</td>
</tr>
<tr>
<td align="center">[di + idata]</td>
<td align="center">EA = (di) + idata;SA = (ds)</td>
<td align="center"></td>
<td align="center">用于二维数组:[bx] [idata]</td>
</tr>
<tr>
<td align="center">[bp + idata]</td>
<td align="center">EA = (bp) + idata;SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bx + si]</td>
<td align="center">EA = (bx) + (si);SA = (ds)</td>
<td align="center">基址变址寻址</td>
<td align="center">用于二维数组:[bx] [si]</td>
</tr>
<tr>
<td align="center">[bx + di]</td>
<td align="center">EA = (bx) + (di);SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp + si]</td>
<td align="center">EA = (bp) + (si);SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp + di]</td>
<td align="center">EA = (bp) + (di);SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bx + si + idata]</td>
<td align="center">EA = (bx) + (si) + idata;SA = (ds)</td>
<td align="center">相对基址变址寻址</td>
<td align="center">用于表格中的数组:[bx].idata[si]</td>
</tr>
<tr>
<td align="center">[bx + di + idata]</td>
<td align="center">EA = (bx) + (di) + idata;SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp + si + idata]</td>
<td align="center">EA = (bp) + (si) + idata;SA = (ss)</td>
<td align="center"></td>
<td align="center">用于二维数组:idata[bx] [si]</td>
</tr>
<tr>
<td align="center">[bp + di + idata]</td>
<td align="center">EA = (bp) + (di) + idata;SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>8086CPU 可以处理 byte 和 word 两种尺寸的数据。</p>
<ol>
<li><p>通过寄存器名指明要处理的数据的尺寸：</p>
<pre class="line-numbers language-asm"><code class="language-asm">;字操作
mov ax,1
add ax,1000
inc ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm">;字节操作
mov al
add al000
inc al<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>没有寄存器名存在得情况下，用操作符 X ptr 指明内存单元的长度，X 可以为 byte 或 word：</p>
<pre class="line-numbers language-asm"><code class="language-asm">;word ptr 表示访问一个字单元
mov word ptr ds:[0],1
inc word ptr [bx]
inc word ptr ds:[0]
add word ptr [bx],2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm">;byte ptr 表示访问一个字节单元
mov byte ptr ds:[0],1
inc byte ptr [bx]
inc byte ptr ds:[0]
add byte ptr [bx],2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>   <strong>在机器指令中指明要访问的是字单元还是字节单元是非常重要的，8086CPU中，一个byte为8bit，而一个字为2byte，如果不指明，那么在访问的时候是有区别的。</strong></p>
<ol start="8">
<li><p>使用 push 和 pop 指令就代表了是进行字操作，无需指明</p>
</li>
<li><p>div 除法指令：</p>
<p>(1)除数：8位和16位两种，在一个reg或内存单元中</p>
<p>(2)被除数：默认在AX或AX和DX中，除数位8位，被除数位16位，默认在AX中存放；除数位16位，则被除数位32位，DX存放高16位，AX存放低16位。</p>
<p>(3)结果：如果除数位8位，则AL存储除法操作的商，AH存放余数；如果除数位16位，AX存储除法操作的商，DX存放余数</p>
<pre class="line-numbers language-asm"><code class="language-asm">;格式
div reg
div 内存单元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm">;示例
div byte ptr ds:[0]      ;(al) = (ax) / ((ds) * 16 + 0 )的商
                       ;(ah) = (ax) / ((ds) * 16 + 0)的余数

div word ptr es:[0]      ;(ax) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的商
                       ;(dx) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的余数

div byte ptr [bx + si + 8]     ;(al) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的商
                             ;(ah) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的余数

div word ptr [bx + si + 8]     ;(ax) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的商
                             ;(dx) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的余数js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>计算：100001 / 100</p>
<pre class="line-numbers language-asm"><code class="language-asm">;100001 > 65535,所以除数得是32位，转为16进制为 186A1H，所以高16位在DX中，低16位在AX中
mov dx,1
mov ax,86A1H
mov bx,100
div bx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol start="11">
<li><p>伪指令 dd 、dup</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">db</td>
<td align="center">定义字节型数据</td>
<td align="center">db 1</td>
</tr>
<tr>
<td align="center">dw</td>
<td align="center">定义字型数据</td>
<td align="center">dw 100</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">定义dword双字型数据</td>
<td align="center">dd 100001</td>
</tr>
<tr>
<td align="center">dup</td>
<td align="center">与上面3个指令配合使用，用来进行数据的重复</td>
<td align="center">db(dw、dd) 重复次数 dup (重复的数据)</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="12">
<li><p>汇编语言实验七：</p>
<pre class="line-numbers language-asm"><code class="language-asm">;题目太长，只贴代码，先思考写代码，而后体会别人的代码
assume cs:code

data segment
 db '1975','1976','1977','1978','1979','1980','1981','1982','1983','1984','1985'
 db '1986','1987','1988','1989','1990','1991','1992','1993','1994','1995'

 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514,345980
 dd 590827,803530,1183000,1843000,2758000,3753000,4649000,5937000

 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
 dw 11542,14430,15257,17800
data ends

stack segment
 dw 0,0,0,0,0,0,0
stack ends

table segment
 db 21 dup ('year summ ne ?? ')
table ends

code segment

start:
    mov ax,data
    mov es,ax
    mov si,0

    mov ax,table
    mov ds,ax
    mov di,0

    mov ax,stack
    mov ss,ax
    mov sp,16

    mov bx,0
    mov cx,21
s0:
    mov ax,es:[si]    
    mov ds:[di+bx],ax
    add si,2
    add di,2
    mov ax,es:[si]
    mov ds:[di+bx],ax

    mov ax,es:[si+82]
    mov ds:[bx+di+3],ax
    mov ax,es:[si+84]
    mov ds:[bx+di+5],ax

    add si,2
    mov di,0
    add bx,16
    loop s0

    mov bx,0
    mov si,168
    mov di,5
    mov cx,21
s1:    
    mov ax,es:[si]
    mov ds:[bx+di+5],ax

    mov ax,ds:[bx+di]
    mov dx,ds:[bx+di+2]
    div word ptr ds:[bx+di+5]
    mov ds:[bx+di+8],ax

    add si,2
    add bx,16
    loop s1

    mov ax,4c00h
    int 21h

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="第九章：转移指令的原理"><a href="#第九章：转移指令的原理" class="headerlink" title="第九章：转移指令的原理"></a>第九章：转移指令的原理</h3><ol>
<li><p><strong>可以修改 IP ，或者同时修改 CS 和 IP 得指令统称为转移指令。</strong></p>
<ol>
<li>段内转移：jmp ax<ol>
<li>短转移IP修改范围：-128~127</li>
<li>近转移IP修改范围：-32768~32767</li>
</ol>
</li>
<li>段间转移：jmp 1000:0</li>
</ol>
</li>
<li><p>转移指令分为无条件转移指令（jmp）和条件转移指令、循环指令、过程、中断等等</p>
</li>
<li><p>操作符 offset ，能够取得标号的偏移地址：</p>
<pre class="line-numbers language-asm"><code class="language-asm">start: mov ax,offset start  ;取得start的偏移地址，相当于 mov ax，0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li></li>
</ol>
<h3 id="第十章：CALL和RET指令"><a href="#第十章：CALL和RET指令" class="headerlink" title="第十章：CALL和RET指令"></a>第十章：CALL和RET指令</h3><ol>
<li><h3 id="第十一章：标志寄存器"><a href="#第十一章：标志寄存器" class="headerlink" title="第十一章：标志寄存器"></a>第十一章：标志寄存器</h3></li>
<li></li>
</ol>
<h3 id="第十二章：内中断"><a href="#第十二章：内中断" class="headerlink" title="第十二章：内中断"></a>第十二章：内中断</h3><ol>
<li><h3 id="第十三章：int-指令"><a href="#第十三章：int-指令" class="headerlink" title="第十三章：int 指令"></a>第十三章：int 指令</h3></li>
<li></li>
</ol>
<h3 id="第十四章：端口"><a href="#第十四章：端口" class="headerlink" title="第十四章：端口"></a>第十四章：端口</h3><ol>
<li><h3 id="第十五章：外中断"><a href="#第十五章：外中断" class="headerlink" title="第十五章：外中断"></a>第十五章：外中断</h3></li>
<li></li>
</ol>
<h3 id="第十六章：直接定址表"><a href="#第十六章：直接定址表" class="headerlink" title="第十六章：直接定址表"></a>第十六章：直接定址表</h3><ol>
<li><h3 id="第十七章：使用BIOS进行键盘输入"><a href="#第十七章：使用BIOS进行键盘输入" class="headerlink" title="第十七章：使用BIOS进行键盘输入"></a>第十七章：使用BIOS进行键盘输入</h3></li>
<li></li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hui-bian-yu-yan-xue-xi-dosbox-masm-an-zhuang-ji-shi-yong-jiao-cheng.html">汇编语言学习 DOSBox+MASM 安装及使用教程</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-08T06:19:14.000Z" itemprop="datePublished">
    2021-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/DOSBox/">DOSBox</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/MASM/">MASM</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/汇编/">汇编</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>学校没有开设《汇编语言》这门课，但我觉得学习汇编挺重要的，对学习计组以及理解计算机原理很有帮助！</p>
<h2 id="1】安装DOSBox和MASM"><a href="#1】安装DOSBox和MASM" class="headerlink" title="1】安装DOSBox和MASM"></a>1】安装DOSBox和MASM</h2><h3 id="1-安装DOSBox"><a href="#1-安装DOSBox" class="headerlink" title="1)安装DOSBox"></a>1)安装DOSBox</h3><p>首先官网下载DOSBox<a href="https://www.dosbox.com/download.php?main=1" target="_blank" rel="noopener">传送门</a>，网盘链接：<a href="https://pan.baidu.com/s/13H0IU9xdYUJIQnwv1eE4Ag" target="_blank" rel="noopener">https://pan.baidu.com/s/13H0IU9xdYUJIQnwv1eE4Ag</a>  提取码：2g8s ，包含MASM</p>
<p>安装过程就不说了，建议安装在D盘，C盘也可以。我这里是安装在C盘，安装好后打开，<strong>注意有两个窗口，不要关闭</strong></p>
<p>找到文件：<strong>C:\Users\用户\AppData\Local\DOSBox\dosbox-0.74-3.conf</strong>，找不到AppData查看隐藏的文件，使用记事本打开dosbox-0.74-3.conf，在末尾添加下面两行代码：</p>
<pre><code>mount d d:\masm
 d:</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/01.png" alt></p>
<p>上面代码的意思就是把D盘映射为虚拟C盘，现在打开DOSBox可以看到自动映射了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/2.png" alt></p>
<h3 id="2）安装MASM"><a href="#2）安装MASM" class="headerlink" title="2）安装MASM"></a>2）安装MASM</h3><p>自己去下载也可以，网盘里面下载下来直接提取到<strong>D盘根目录</strong>就行了</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/3.png" alt></p>
<p>没有提取    MASM是无法进行debug的，现在打开就可以愉快的开始使用了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/4.png" alt></p>
<h2 id="2】使用DOSBox编写汇编程序"><a href="#2】使用DOSBox编写汇编程序" class="headerlink" title="2】使用DOSBox编写汇编程序"></a>2】使用DOSBox编写汇编程序</h2><h3 id="1）编写-helloword-汇编源程序"><a href="#1）编写-helloword-汇编源程序" class="headerlink" title="1）编写 helloword 汇编源程序"></a>1）编写 helloword 汇编源程序</h3><p>打开 DOSBox，输入 <strong>edit</strong> 编写一个汇编源程序</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/5.png" alt></p>
<p>代码：//</p>
<pre class="line-numbers language-asm"><code class="language-asm">data segment                   ;这里定义一个数据段
     tab db 'hello world$'     ;这里用内存存放字节数据 'hellow world!',$用来判断字符串是否输出完毕
data ends                      ;数据段的结束标志

code segment                   ;这里定义了一个代码段
assume cs:code, ds:data        ;这里把程序中定义的段与对应的段寄存器关联起来

start:                         ;这里是一个标号，根据end后面的标号判断这里是程序的开始位置
      mov ax,data
      mov ds,ax                ;这里把数据段的地址放到数据段寄存器ds中
      lea dx,tab               ;dx中放将要显示数据的偏移地址
      mov ah,9h
      int 21h                  ;调用21号中断的9号功能来显示字符串

      mov ah,4c00h
      int 21h                  ;程序返回在这里插入图片描述

code ends                      ;代码段的结束语
end start                      ;定义程序从哪个标号处开始执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编写好后点击 file ，选择 save as …，输入文件名称 <strong>hello</strong> ，后缀是 <strong>.asm</strong> ,然后点击 <strong>ok</strong></p>
<p>也可使用其他编辑器编写源代码，保存到 MASM 文件夹下，修改后缀为 .ASM就行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/6.png" alt></p>
<p>打开 D:\MASM 就可以看见我们编写的源程序了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/7.png" alt></p>
<h3 id="2）编译"><a href="#2）编译" class="headerlink" title="2）编译"></a>2）编译</h3><p>打开DOSBox，输入 <strong>masm</strong> ，确认后弹出的第一行输入要编译的源程序的名称：hello.asm ,也可以直接输入 MASM hello.asm ，都一样。</p>
<blockquote>
<p>“[.ASM]”提示我们，默认的文件扩展名是asm，比如，要编译的源程序文件名是“p1.asm”，只要在这里输入“p1”即可。可如果源程序文件不是以asm为扩展名的话，就要输入它的全名。比如源程序文件名为“p1.txt”，就要输入全名。</p>
<p>在输入源程序文件名的时候一定要指明它所在的路径。如果文件就在当前路径下，只输入文件名就可以，可如果文件在其他的目录中，则要输入路径，比如，要编译的文件p1.txt在“c:\windows\desktop”下，则要输入“c:\windows\desktop\p1.txt”。这里，我们要编译的文件是C盘根目录下的1.asm，所以此处输入“c:\1.asm”。</p>
</blockquote>
<p>在输入源程序文件名后，程序会继续提示我们要编译出的目标文件的名称，目标文件是我们对一个源程序编译要得到的最终结果。注意屏幕上的显示 “[ hello.OBJ ] “,因为我们已经输入了源程序文件名为 hello.asm ,则编译程序默认输出文件名为 hello.obj ，所以不必再指定文件名。直接按 ENTER ，在当前目录下生成 hello.obj 文件。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/8.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/9.png" alt></p>
<p>我们到MASM文件夹下可以看到多了一个 <strong>hello.obj</strong> 文件，源程序的编译最后两行如果出现警告和错误必须要改正，否则无法生成obj文件。</p>
<h3 id="3）连接"><a href="#3）连接" class="headerlink" title="3）连接"></a>3）连接</h3><p>接着上面的顺序，现在已经生成了一个<strong>hello.obj</strong> 文件，我们需要对目标文件进行连接，从而得到可执行文件。    输入 LINK ，弹出的第一行输入 <strong>obj</strong> 文件名称，比如 <strong>hello</strong>，也可以直接输入 <strong>LINK hello.obj</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/10.png" alt></p>
<p>这里出现一个警告：没有栈段，我们不予理会。</p>
<p>连接成功后会在 MASM 目录下生成一个 hello.exe 文件，如果出现错误，则无法生成。</p>
<p>连接的作用：</p>
<ol>
<li>当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件；</li>
<li>程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>
<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>
</ol>
<h3 id="4）执行我们编译好的-exe-文件"><a href="#4）执行我们编译好的-exe-文件" class="headerlink" title="4）执行我们编译好的 .exe 文件"></a>4）执行我们编译好的 <strong>.exe</strong> 文件</h3><p>输入:</p>
<pre><code>hello.exe
hello</code></pre><p>都可以执行exe文件，当然前提是在 MASM 状态下。如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.1/Images/posts/DOSBox/11.png" alt></p>
<p>至此就是编写汇编源程序以及运行的全部内容，我们还可以在此基础上进行debug，查看heelo.exe的执行情况，更多的知识请自行前往学习。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu.html">《汇编语言》王爽著学习笔记记录(前半部分)</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-08T06:17:32.000Z" itemprop="datePublished">
    2021-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/汇编/">汇编</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。</p>
<h3 id="第一章：基础知识"><a href="#第一章：基础知识" class="headerlink" title="第一章：基础知识"></a>第一章：基础知识</h3><ol>
<li><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p>
</li>
<li><p>每一种CPU都有自己的汇编指令集</p>
</li>
<li><p>在存储器中指令和数据没有任何区别，都是二进制信息。</p>
</li>
<li><p>CPU可以直接使用的信息在存储器中存放。</p>
</li>
<li><p>存储器单元从零开始顺序编号。</p>
</li>
<li><p>一个存储单元可以存储8 bit，即8个二进制位。</p>
</li>
<li><p>1Byte = 8bit….</p>
</li>
<li><p>每一个CPU芯片都有许多管脚，它们与总线相连。其分为三类：</p>
<ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其它器件进行数据传送时一次数据传送量</li>
<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>
</ul>
</li>
<li><p><strong>内存地址空间：</strong>最终运行程序的是CPU，对CPU来讲，系统中所有的存储器的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力（读取内存地址的范围）的限制。这个逻辑存储器即内存地址空间。</p>
</li>
</ol>
<h3 id="第二章：寄存器"><a href="#第二章：寄存器" class="headerlink" title="第二章：寄存器"></a>第二章：寄存器</h3><ol>
<li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p>
</li>
<li><p>AX、BX、CX、DX这四个寄存器用来存放一般性数据，称为通用寄存器。为了兼容，通常把它们掰为两半来使用,它们可以独立使用：</p>
<ul>
<li>AX → AH + AL</li>
<li>BX → BH + BL</li>
<li>CX → CH + CL</li>
<li>DX → DH + DL</li>
</ul>
</li>
<li><p>在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的。</p>
</li>
<li><p>8086cpu一次性能处理16位地址，但有20位地址总线，于是采用两个16位地址合成来形成一个20位的物理地址。</p>
</li>
<li><p><strong>物理地址 = 段地址 * 16 + 偏移地址</strong>，其含义是用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加得到物理地址。</p>
</li>
<li><p>将若干地址连续的内存单元看作是一个段，段地址就是该段的起始地址，用偏移地址定位段中的具体位置。其中段地址必然是16的倍数，偏移地址为16位，所以寻址能力为64K，故一个段的长度最大为64K</p>
</li>
<li><p><strong>段寄存器：CS、DS、SS、ES、</strong></p>
</li>
<li><p>8086pc机中，设CS中的内容为M(段地址)，IP中的内容为N(偏移地址)，任意时刻，CPU将从M * 16 + N内存单元读取指令执行。</p>
</li>
<li><p>“ jmp   某一合法寄存器”  ：用寄存器中的值修改 IP。</p>
</li>
<li><p><strong>Debug基本命令：</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R(Register)</td>
<td align="center">查看、改变CPU寄存器中的内容</td>
<td align="center">①查看：直接输入r，②修改寄存器值：r ax，按enter然后输入数据</td>
</tr>
<tr>
<td align="center">D(Dump)</td>
<td align="center">查看内存中的内容</td>
<td align="center">d 段地址：偏移地址 或者 d 段地址：偏移地址段 或d 起始位置  L长度</td>
</tr>
<tr>
<td align="center">E(Enter)</td>
<td align="center">改写内存中的内容</td>
<td align="center">e 起始地址 数据 数据 …  空格键表示处理完成</td>
</tr>
<tr>
<td align="center">U(Unassemble)</td>
<td align="center">将内存中的机器指令翻译为汇编指令</td>
<td align="center">u 段地址：偏移地址</td>
</tr>
<tr>
<td align="center">T(Trace)</td>
<td align="center">执行一条机器指令</td>
<td align="center">输入t ，CPU执行CS:IP指向的指令</td>
</tr>
<tr>
<td align="center">A(Assemble)</td>
<td align="center">以汇编指令的格式在内存中写入一条机器指令</td>
<td align="center">a 段地址：偏移地址，接着输入汇编指令</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="第三章：寄存器-内存访问"><a href="#第三章：寄存器-内存访问" class="headerlink" title="第三章：寄存器(内存访问)"></a>第三章：寄存器(内存访问)</h3><ol>
<li><p>8086CPU用16位来存储一个字，高8位存放在高位字节，低8位存放在低位字节。一个字用两个地址连续的内存单元存放，低位字节在低位地址，高位字节在高位地址。</p>
</li>
<li><p>DS寄存器通常用来存放要要访问的数据的段地址。不支持直接将数据送入段寄存器。</p>
</li>
<li><p>mov、add、sub指令</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">格式</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov</td>
<td align="center">寄存器，数据</td>
<td align="center">mov ax，6</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">寄存器，寄存器</td>
<td align="center">mov ax，bx</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">寄存器，内存单元</td>
<td align="center">mov ax，[8]</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">内存单元，寄存器</td>
<td align="center">mov [9]，ax</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">段寄存器，寄存器</td>
<td align="center">mov ds，ax</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">寄存器，数据</td>
<td align="center">add ax，0</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">寄存器，寄存器</td>
<td align="center">add  ax，bx</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">寄存器，内存单元</td>
<td align="center">add ax，[0]</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">内存单元，寄存器</td>
<td align="center">add [0]，ax</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">寄存器，数据</td>
<td align="center">sub ax，0</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">寄存器，寄存器</td>
<td align="center">aub ax，bx</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">寄存器，内存单元</td>
<td align="center">sub ax，[9]</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">内存单元，寄存器</td>
<td align="center">sub [9]，ax</td>
</tr>
</tbody></table>
</li>
<li><p>入栈：将新元素放到栈顶，出栈：从栈顶取出一个元素。遵循先入后出原则（LIFO）</p>
</li>
<li><p>PUSH（入栈），POP（出栈），以字为单位进行，</p>
</li>
<li><p><strong>任意时刻，SS:SP指向栈顶元素</strong>，push和pop执行时，cpu从ss：sp中得到栈顶地址。</p>
</li>
<li><p>执行PUSH指令时，SP=SP-2，表示栈顶向上移动；执行pop指令时，SP=SP+2，表示栈顶向下移动；当栈为空时，SS:SP指向栈顶内存地址+2的内存单元。</p>
</li>
<li><p>在使用栈的时候，应当注意不要出现越界。</p>
</li>
<li><p>出栈的顺序应该和入栈的顺序相反，这与栈后入先出的特性相关。</p>
</li>
<li><p>PUSH过程：①CPU先改变SP=SP+2，②向SS：SP处传送；</p>
<p>POP过程：①CPU先向SS：SP读取数据，②改变SP的值SP=SP-2。</p>
<p>push和pop指令操作栈的时候，修改的只是SP。</p>
</li>
<li><p>栈的栈顶变化范围：0~FFFFH，所以一个栈段最大容量为64K.</p>
</li>
</ol>
<h3 id="第四章：第一个程序"><a href="#第四章：第一个程序" class="headerlink" title="第四章：第一个程序"></a>第四章：第一个程序</h3><ol>
<li><p>伪指令：由编译器执行的指令，CPU是不知道它们的，由编译器执行它们</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">段名 segment … 段名 ends</td>
<td align="center">定义一个段，segment说明一个段开始，ends说明一个段结束</td>
</tr>
<tr>
<td align="center">ebd</td>
<td align="center">汇编程序结束的标志</td>
</tr>
<tr>
<td align="center">assume</td>
<td align="center">assume cs：code，将段code与寄存器cs关联起来</td>
</tr>
<tr>
<td align="center">mov ax，4c00H    int 21H</td>
<td align="center">两行汇编指令，实现程序返回</td>
</tr>
</tbody></table>
</li>
<li><p>连接（LINK）作用：</p>
<ol>
<li>当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件；</li>
<li>程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>
<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>
</ol>
</li>
<li><p>EXE文件加载过程：找到一段起始地址为0的空闲区，创建一个程序段前缀（PSP），在PSP后256字节开始，即SA+10H:0为段地址载入ds寄存器中，并初始化CS:IP指向这个地址。</p>
</li>
</ol>
<h3 id="第五章：-BX-和loop指令"><a href="#第五章：-BX-和loop指令" class="headerlink" title="第五章：[BX]和loop指令"></a>第五章：[BX]和loop指令</h3><ol>
<li><p>[BX]:</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov ax，[bx]</td>
<td align="center">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即(ax) = ((ds)*16 + (bx))</td>
</tr>
<tr>
<td align="center">mov [bx]，ax</td>
<td align="center">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA:EA处，即((ds)*16 + (bx)) = (ax)</td>
</tr>
</tbody></table>
</li>
<li><p>loop指令：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">格式</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">loop</td>
<td align="center">loop  标号</td>
<td align="center">实现循环功能，cx中存放着循环次数，就相当于for，cx为0向下执行，不为0循环</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">使用方法：</td>
<td align="center">①在cx中存放循环次数②loop指令中的标号所标识地址在前面③循环执行的程序段在标号和lpp指令之间</td>
</tr>
</tbody></table>
</li>
<li><p>loop指令框架：</p>
<pre class="line-numbers language-asm"><code class="language-asm">     mov cx，循环次数
s：
     循环执行的程序段
     loop s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在汇编源程序中，数据不能以字母开头。所以大于9FFFH的数要在前面加0。</p>
</li>
<li><p>loop指令的每一次都先判断cx的值，不为0则CS：IP指向下一步循环指令的地址，CPU执行。</p>
</li>
<li><p>在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须使用 “[…]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显示的给出段地址所在的段寄存器。</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov al,ds:[0]
//正确的表示

mov al,[0]
//masm就将[idata] 解释为 idata ，而不是一个内存单元地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>用于显示的指明内存单元的段地址的 “ds:” 、”cs:”、”ss:”、”es:”，在汇编语言中成为<strong>段前缀</strong>。</p>
</li>
<li><p>在pc机中，一般 0:200~0:2ff 的256个字节的空间是安全的，即没有其它应用使用这段内存单元。</p>
</li>
</ol>
<h3 id="第六章：包含多个段的程序"><a href="#第六章：包含多个段的程序" class="headerlink" title="第六章：包含多个段的程序"></a>第六章：包含多个段的程序</h3><ol>
<li><p>在操作系统环境中，合法的通过操作系统取得的空间都是安全的，需要在汇编源程序中做出说明</p>
</li>
<li><p>dw(define word) 关键字的意思是定义字型数据，数据之间使用逗号分隔。</p>
</li>
<li><p>将 start 放在第一条指令前面，然后在伪指令 end 后面加上 start，表示程序第一条指令从前面的 start 开始。</p>
</li>
<li><p>内存空间的开辟：使用 dw 关键字定义一些字型数据，通常为 0，然后将这一段空间当作栈段来使用。</p>
</li>
<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据:</p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:codesg
codesg segment
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

start:  mov ax,0
        mov ds,ax
        mov bx,0           ;ds = 0,bx = 0
        mov cx,8           ;循环8次

    s:  mov ax,[bx]        ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax
        mov cs:[bx],ax     ;将ax中的数据放入内存地址 ((cs)*16 + (bx)) 处，[bx]为偏移地址，段地址在cs中
        add bx,2           ;bx + 2
        loop s

        mov ax,4c00h
        int 21h
codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol start="6">
<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据（数据的传送用栈来进行。栈空间设置在程序内）：</p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:codesg
codesg segment
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
        dw 0,0,0,0,0,0,0,0,0,0

start:  mov ax,cs 
        mov ss,ax
        mov sp,24h          ;或mov sp, 36  ，ss:sp = cs:24h
        mov ax,0
        mov ds,ax           ;ds = 0
        mov bx,0            ;bx = 0
        mov cx,8            ;循环8次

    s:  push [bx]           ;将[bx]中的数据压入栈中
        pop cs:[bx]         ;或 pop ss:[bx],
        add bx,2            ;bx + 2
        loop s

        mov ax,4c00h
        int 21h
codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在汇编程序中，一个段的段名就代表了这个段的段地址，而偏移地址需要根据段中的数据来确定。</p>
</li>
<li><p>8086CPU不允许直接将一个数值送入段寄存器，应该由一个寄存器比如 ax 来中转。</p>
</li>
<li><p><strong>汇编语言实验五：</strong></p>
<p><strong>（1）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code,ds:data,ss:stack 

data segment 
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h 
data ends 

stack segment 
        dw 0,0,0,0,0,0,0,0 
stack ends 

code segment 

start:  mov ax,stack 
        mov ss,ax 
        mov sp,16 
        mov ax,data 
        mov ds,ax 

        push ds:[0] 
        push ds:[2] 
        pop ds:[2] 
        pop ds:[0] 

        mov ax,4c00h 
        int 21h 

code ends 
end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>
<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>
<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>
</li>
</ol>
<p><strong>（2）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code,ds:data,ss:stack 

data segment 
        dw 0123h,0456h
data ends 

stack segment 
        dw 0,0
stack ends 

code segment 

start:  mov ax,stack 
        mov ss,ax 
        mov sp,16 
        mov ax,data 
        mov ds,ax 

        push ds:[0] 
        push ds:[2] 
        pop ds:[2] 
        pop ds:[0] 

        mov ax,4c00h 
        int 21h 

code ends 
end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>
<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>
<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>
<p>④对于如下定义的段：</p>
<pre class="line-numbers language-asm"><code class="language-asm">name segment

……

name ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 ((N+15)/16)*16 。</p>
<p>④解析：</p>
<p>N分为被16整除和不被16整除。</p>
<p>当N被16整除时： 占有的空间为(N/16)*16</p>
<p>当N不被16整除时： 占有的空间为(N/16+1)*16，N/16得出的是可以整除的部分，还有一个余数，余数肯定小于16，加上一个16。</p>
<p>程序加载后分配空间是以16个字节为单位的，也就是说如果不足16个字节的也分配16个字节。</p>
<p>两种情况总结成一个通用的公式：((N+15)/16)*16</p>
<p><strong>（3）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code,ds:data,ss:stack 

code segment 

start:  mov ax,stack 
        mov ss,ax 
        mov sp,16 
        mov ax,data 
        mov ds,ax 

        push ds:[0] 
        push ds:[2] 
        pop ds:[2] 
        pop ds:[0] 

        mov ax,4c00h 
        int 21h 

code ends 

data segment 
        dw 0123h,0456h
data ends 

stack segment 
        dw 0,0
stack ends 

end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>
<p>②CPU执行程序，程序返回前，CS= 0C86H ，SS= 0C8AH ，DS= 0C89H 。</p>
<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X+3 ，STACK段的段地址为 X+4 。</p>
<p><strong>（4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。</strong></p>
<p>答：start 作为汇编程序的一个标号，定义了程序的入口，如果不指名入口，程序会从加载进内存的第一个单元起开始执行，前二个题中，前面定义的是数据段、栈段，CPU 能够执行，但在整个程序上来讲，逻辑顺序错误，这样会导致空间二次分配等等情况。</p>
<p>​     如果指明了程序的入口，CPU会直接从入口处开始执行真正的机器码，直到遇到中断指令返回，比如指令进行到需要栈段空间的时候，CPU 会跳到前面定义的栈段得到分配空间的地址。此种方式能够确保程序逻辑上的正确。因此有必要为程序来指明入口。</p>
<p>​    综上，只有（3）可以在没有指明程序入口的情况下正确执行。</p>
<p><strong>（5）程序如下，编写code段中代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cd:code

a segment
    db 1,2,3,4,5,6,7,8
a ends

b segment 
    db 1,2,3,4,5,6,7,8
b ends

c segment 
   db 0,0,0,0,0,0,0,0
c ends

code segment

start: mov ax,a
       mov ds,ax           ;ds段寄存器地址指向a

       mov ax,b
       mov es,ax           ;es段寄存器地址指向b

       mov ax,c
       mov ss,ax           ;ss段寄存器地址指向c

       mov bx,0            ;偏移地址为0
       mov cx,8            ;循环8次

    s: mov ax,[bx]         ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax
       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中
       mov ax,es:[bx]      ;(ax) = ((es)*16 + (bx)),将对应的数据送入ax
       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中
       inc bx              ;bx + 1
       loop s


       mov ax,4c00h
       int 21h

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（6）程序如下，编写 code 段中代码，用 push 指令将 a 段中的前8个字型数据，逆序存储到 b 段中。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code

a segment
    dw 1,2,3,4,5,6,7,8
a ends

b segment
    dw 0,0,0,0,0,0,0,0
b ends

code segment

start: mov ax,a
       mov ds,ax   ;ds指向a段

       mov ax,b
       mov bx,0    ;ds:bx 指向a段的第1个单元
       mov ss,ax

       mov sp,16   ;设置栈顶指向 b:16
       mov cx,8    ;循环8次

    s: push [bx]
       add bx,2    ;bx + 2
       loop s      ;将a段中0～16个单元逆次入栈

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2024 - Tyzhao </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>