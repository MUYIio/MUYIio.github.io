{"title":"《汇编语言》王爽著学习笔记记录(前半部分)","date":"2021-05-08T06:17:32.000Z","toc":true,"summary":"看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。","source":"_posts/《汇编语言》王爽著学习笔记记录.md","raw":"---\ntitle: 《汇编语言》王爽著学习笔记记录(前半部分)\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-05-08 14:17:32\npassword:\nsummary: 看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。\ntags:\n- 学习笔记\ncategories:\n- 汇编\n---\n\n看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。\n\n### 第一章：基础知识\n\n1. 汇编指令是机器指令的助记符，同机器指令一一对应。\n\n2. 每一种CPU都有自己的汇编指令集\n\n3. 在存储器中指令和数据没有任何区别，都是二进制信息。\n\n4. CPU可以直接使用的信息在存储器中存放。\n\n5. 存储器单元从零开始顺序编号。\n\n6. 一个存储单元可以存储8 bit，即8个二进制位。\n\n7. 1Byte = 8bit....\n\n8. 每一个CPU芯片都有许多管脚，它们与总线相连。其分为三类：\n\n   - 地址总线的宽度决定了CPU的寻址能力\n   - 数据总线的宽度决定了CPU与其它器件进行数据传送时一次数据传送量\n   - 控制总线的宽度决定了CPU对系统中其它器件的控制能力\n\n9. **内存地址空间：**最终运行程序的是CPU，对CPU来讲，系统中所有的存储器的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力（读取内存地址的范围）的限制。这个逻辑存储器即内存地址空间。\n\n   \n\n### 第二章：寄存器\n\n1. 8086CPU所有的寄存器都是16位的，可以存放两个字节。\n\n2. AX、BX、CX、DX这四个寄存器用来存放一般性数据，称为通用寄存器。为了兼容，通常把它们掰为两半来使用,它们可以独立使用：\n\n   - AX → AH + AL\n   - BX → BH + BL\n   - CX → CH + CL\n   - DX → DH + DL\n\n3. 在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的。\n\n4. 8086cpu一次性能处理16位地址，但有20位地址总线，于是采用两个16位地址合成来形成一个20位的物理地址。\n\n5. **物理地址 = 段地址 * 16 + 偏移地址**，其含义是用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加得到物理地址。\n\n6. 将若干地址连续的内存单元看作是一个段，段地址就是该段的起始地址，用偏移地址定位段中的具体位置。其中段地址必然是16的倍数，偏移地址为16位，所以寻址能力为64K，故一个段的长度最大为64K\n\n7. **段寄存器：CS、DS、SS、ES、**\n\n8. 8086pc机中，设CS中的内容为M(段地址)，IP中的内容为N(偏移地址)，任意时刻，CPU将从M * 16 + N内存单元读取指令执行。\n\n9. \" jmp   某一合法寄存器\"  ：用寄存器中的值修改 IP。\n\n10. **Debug基本命令：**\n    \n    |     命令      |                   功能                   |                             格式                             |\n    | :-----------: | :--------------------------------------: | :----------------------------------------------------------: |\n    |  R(Register)  |       查看、改变CPU寄存器中的内容        |  ①查看：直接输入r，②修改寄存器值：r ax，按enter然后输入数据  |\n|    D(Dump)    |             查看内存中的内容             | d 段地址：偏移地址 或者 d 段地址：偏移地址段 或d 起始位置  L长度 |\n    |   E(Enter)    |             改写内存中的内容             |         e 起始地址 数据 数据 ...  空格键表示处理完成         |\n    | U(Unassemble) |     将内存中的机器指令翻译为汇编指令     |                      u 段地址：偏移地址                      |\n    |   T(Trace)    |             执行一条机器指令             |                输入t ，CPU执行CS:IP指向的指令                |\n    |  A(Assemble)  | 以汇编指令的格式在内存中写入一条机器指令 |             a 段地址：偏移地址，接着输入汇编指令             |\n\n\n\n### 第三章：寄存器(内存访问)\n\n1. 8086CPU用16位来存储一个字，高8位存放在高位字节，低8位存放在低位字节。一个字用两个地址连续的内存单元存放，低位字节在低位地址，高位字节在高位地址。\n\n2. DS寄存器通常用来存放要要访问的数据的段地址。不支持直接将数据送入段寄存器。\n\n3. mov、add、sub指令\n\n   | 指令 |       格式       |    示例     |\n   | :--: | :--------------: | :---------: |\n   | mov  |   寄存器，数据   |  mov ax，6  |\n   | mov  |  寄存器，寄存器  | mov ax，bx  |\n   | mov  | 寄存器，内存单元 | mov ax，[8] |\n   | mov  | 内存单元，寄存器 | mov [9]，ax |\n   | mov  | 段寄存器，寄存器 | mov ds，ax  |\n   | add  |   寄存器，数据   |  add ax，0  |\n   | add  |  寄存器，寄存器  | add  ax，bx |\n   | add  | 寄存器，内存单元 | add ax，[0] |\n   | add  | 内存单元，寄存器 | add [0]，ax |\n   | sub  |   寄存器，数据   |  sub ax，0  |\n   | sub  |  寄存器，寄存器  | aub ax，bx  |\n   | sub  | 寄存器，内存单元 | sub ax，[9] |\n   | sub  | 内存单元，寄存器 | sub [9]，ax |\n\n4. 入栈：将新元素放到栈顶，出栈：从栈顶取出一个元素。遵循先入后出原则（LIFO）\n\n5. PUSH（入栈），POP（出栈），以字为单位进行，\n\n6. **任意时刻，SS:SP指向栈顶元素**，push和pop执行时，cpu从ss：sp中得到栈顶地址。\n\n7. 执行PUSH指令时，SP=SP-2，表示栈顶向上移动；执行pop指令时，SP=SP+2，表示栈顶向下移动；当栈为空时，SS:SP指向栈顶内存地址+2的内存单元。\n\n8. 在使用栈的时候，应当注意不要出现越界。\n\n9. 出栈的顺序应该和入栈的顺序相反，这与栈后入先出的特性相关。\n\n10. PUSH过程：①CPU先改变SP=SP+2，②向SS：SP处传送；\n\n    POP过程：①CPU先向SS：SP读取数据，②改变SP的值SP=SP-2。\n\n    push和pop指令操作栈的时候，修改的只是SP。\n\n11. 栈的栈顶变化范围：0~FFFFH，所以一个栈段最大容量为64K.\n\n\n\n### 第四章：第一个程序\n\n1. 伪指令：由编译器执行的指令，CPU是不知道它们的，由编译器执行它们\n\n   |            指令            |                         功能                          |\n   | :------------------------: | :---------------------------------------------------: |\n   | 段名 segment ... 段名 ends | 定义一个段，segment说明一个段开始，ends说明一个段结束 |\n   |            ebd             |                  汇编程序结束的标志                   |\n   |           assume           |      assume cs：code，将段code与寄存器cs关联起来      |\n   |  mov ax，4c00H    int 21H  |              两行汇编指令，实现程序返回               |\n\n2. 连接（LINK）作用：\n\n   1. 当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件；\n   2. 程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；\n   3. 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。\n\n3. EXE文件加载过程：找到一段起始地址为0的空闲区，创建一个程序段前缀（PSP），在PSP后256字节开始，即SA+10H:0为段地址载入ds寄存器中，并初始化CS:IP指向这个地址。\n\n### 第五章：[BX]和loop指令\n\n1. [BX]:\n\n   |     指令     |                             功能                             |\n   | :----------: | :----------------------------------------------------------: |\n   | mov ax，[bx] | bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即(ax) = ((ds)*16 + (bx)) |\n   | mov [bx]，ax | bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA:EA处，即((ds)*16 + (bx)) = (ax) |\n\n2. loop指令：\n\n   | 指令 |    格式    |                             功能                             |\n   | :--: | :--------: | :----------------------------------------------------------: |\n   | loop | loop  标号 | 实现循环功能，cx中存放着循环次数，就相当于for，cx为0向下执行，不为0循环 |\n   |      | 使用方法： | ①在cx中存放循环次数②loop指令中的标号所标识地址在前面③循环执行的程序段在标号和lpp指令之间 |\n\n3. loop指令框架：\n\n   ```asm\n        mov cx，循环次数\n   s：\n        循环执行的程序段\n        loop s\n   ```\n\n4. 在汇编源程序中，数据不能以字母开头。所以大于9FFFH的数要在前面加0。\n\n5. loop指令的每一次都先判断cx的值，不为0则CS：IP指向下一步循环指令的地址，CPU执行。\n\n6. 在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须使用 \"[...]\" 来表示内存单元，如果在 \"[]\" 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 \"[]\" 的前面显示的给出段地址所在的段寄存器。\n\n   ```asm\n   mov al,ds:[0]\n   //正确的表示\n   \n   mov al,[0]\n   //masm就将[idata] 解释为 idata ，而不是一个内存单元地址\n   ```\n\n7. 用于显示的指明内存单元的段地址的 \"ds:\" 、\"cs:\"、\"ss:\"、\"es:\"，在汇编语言中成为**段前缀**。\n\n8. 在pc机中，一般 0:200~0:2ff 的256个字节的空间是安全的，即没有其它应用使用这段内存单元。\n\n### 第六章：包含多个段的程序\n\n1. 在操作系统环境中，合法的通过操作系统取得的空间都是安全的，需要在汇编源程序中做出说明\n\n2. dw(define word) 关键字的意思是定义字型数据，数据之间使用逗号分隔。\n\n3. 将 start 放在第一条指令前面，然后在伪指令 end 后面加上 start，表示程序第一条指令从前面的 start 开始。\n\n4. 内存空间的开辟：使用 dw 关键字定义一些字型数据，通常为 0，然后将这一段空间当作栈段来使用。\n\n5. 使用内存 0:0~0:15 单元中的内容改写为程序中的数据:\n\n   ```asm\n   assume cs:codesg\n   codesg segment\n           dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n           \n   start:  mov ax,0\n           mov ds,ax\n           mov bx,0           ;ds = 0,bx = 0\n           mov cx,8           ;循环8次\n           \n       s:  mov ax,[bx]        ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax\n           mov cs:[bx],ax     ;将ax中的数据放入内存地址 ((cs)*16 + (bx)) 处，[bx]为偏移地址，段地址在cs中\n           add bx,2           ;bx + 2\n           loop s\n           \n           mov ax,4c00h\n           int 21h\n   codesg ends\n   end start\n   ```\n\n   \n\n6. 使用内存 0:0~0:15 单元中的内容改写为程序中的数据（数据的传送用栈来进行。栈空间设置在程序内）：\n\n   ```asm\n   assume cs:codesg\n   codesg segment\n           dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n           dw 0,0,0,0,0,0,0,0,0,0\n           \n   start:  mov ax,cs \n           mov ss,ax\n           mov sp,24h          ;或mov sp, 36  ，ss:sp = cs:24h\n           mov ax,0\n           mov ds,ax           ;ds = 0\n           mov bx,0            ;bx = 0\n           mov cx,8            ;循环8次\n           \n       s:  push [bx]           ;将[bx]中的数据压入栈中\n           pop cs:[bx]         ;或 pop ss:[bx],\n           add bx,2            ;bx + 2\n           loop s\n           \n           mov ax,4c00h\n           int 21h\n   codesg ends\n   end start\n   ```\n\n7. 在汇编程序中，一个段的段名就代表了这个段的段地址，而偏移地址需要根据段中的数据来确定。\n\n8. 8086CPU不允许直接将一个数值送入段寄存器，应该由一个寄存器比如 ax 来中转。\n\n9. **汇编语言实验五：**\n\n   **（1）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题**\n\n   ```asm\n   assume cs:code,ds:data,ss:stack \n   \n   data segment \n           dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h \n   data ends \n   \n   stack segment \n           dw 0,0,0,0,0,0,0,0 \n   stack ends \n   \n   code segment \n   \n   start:  mov ax,stack \n           mov ss,ax \n           mov sp,16 \n           mov ax,data \n           mov ds,ax \n           \n           push ds:[0] \n           push ds:[2] \n           pop ds:[2] \n           pop ds:[0] \n   \t\t\n           mov ax,4c00h \n           int 21h \n   \n   code ends \n   end start \n   ```\n\n   ①CPU执行程序，程序返回前，data段中的数据 不变 。\n\n   ②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。\n\n   ③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。\n\n**（2）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。**\n\n```asm\nassume cs:code,ds:data,ss:stack \n\ndata segment \n        dw 0123h,0456h\ndata ends \n\nstack segment \n        dw 0,0\nstack ends \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n        \n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \nend start \n```\n\n①CPU执行程序，程序返回前，data段中的数据 不变 。\n\n②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。\n\n③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。\n\n④对于如下定义的段：\n\n```asm\nname segment\n\n……\n\nname ends\n```\n\n如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 ((N+15)/16)*16 。\n\n④解析：\n\nN分为被16整除和不被16整除。\n\n当N被16整除时： 占有的空间为(N/16)*16\n\n当N不被16整除时： 占有的空间为(N/16+1)*16，N/16得出的是可以整除的部分，还有一个余数，余数肯定小于16，加上一个16。\n\n程序加载后分配空间是以16个字节为单位的，也就是说如果不足16个字节的也分配16个字节。\n\n两种情况总结成一个通用的公式：((N+15)/16)*16\n\n**（3）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。**\n\n```asm\nassume cs:code,ds:data,ss:stack \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n        \n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\t\t\n        mov ax,4c00h \n        int 21h \n\ncode ends \n\ndata segment \n        dw 0123h,0456h\ndata ends \n\nstack segment \n        dw 0,0\nstack ends \n\nend start \n```\n\n①CPU执行程序，程序返回前，data段中的数据 不变 。\n\n②CPU执行程序，程序返回前，CS= 0C86H ，SS= 0C8AH ，DS= 0C89H 。\n\n③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X+3 ，STACK段的段地址为 X+4 。\n\n**（4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。**\n\n答：start 作为汇编程序的一个标号，定义了程序的入口，如果不指名入口，程序会从加载进内存的第一个单元起开始执行，前二个题中，前面定义的是数据段、栈段，CPU 能够执行，但在整个程序上来讲，逻辑顺序错误，这样会导致空间二次分配等等情况。\n\n​     如果指明了程序的入口，CPU会直接从入口处开始执行真正的机器码，直到遇到中断指令返回，比如指令进行到需要栈段空间的时候，CPU 会跳到前面定义的栈段得到分配空间的地址。此种方式能够确保程序逻辑上的正确。因此有必要为程序来指明入口。\n\n​    综上，只有（3）可以在没有指明程序入口的情况下正确执行。\n\n**（5）程序如下，编写code段中代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。**\n\n```asm\nassume cd:code\n\na segment\n    db 1,2,3,4,5,6,7,8\na ends\n\nb segment \n    db 1,2,3,4,5,6,7,8\nb ends\n\nc segment \n   db 0,0,0,0,0,0,0,0\nc ends\n\ncode segment\n\t\nstart: mov ax,a\n\t   mov ds,ax           ;ds段寄存器地址指向a\n\t   \n\t   mov ax,b\n\t   mov es,ax           ;es段寄存器地址指向b\n\t   \n\t   mov ax,c\n\t   mov ss,ax           ;ss段寄存器地址指向c\n\t   \n\t   mov bx,0            ;偏移地址为0\n\t   mov cx,8            ;循环8次\n\t   \n\ts: mov ax,[bx]         ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax\n\t   mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中\n\t   mov ax,es:[bx]      ;(ax) = ((es)*16 + (bx)),将对应的数据送入ax\n\t   mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中\n\t   inc bx              ;bx + 1\n\t   loop s\n\t   \n\t   \n\t   mov ax,4c00h\n\t   int 21h\n\ncode ends\nend start\n```\n\n**（6）程序如下，编写 code 段中代码，用 push 指令将 a 段中的前8个字型数据，逆序存储到 b 段中。**\n\n```asm\nassume cs:code\n\na segment\n    dw 1,2,3,4,5,6,7,8\na ends\n\nb segment\n    dw 0,0,0,0,0,0,0,0\nb ends\n\ncode segment\n\nstart: mov ax,a\n       mov ds,ax   ;ds指向a段\n       \n       mov ax,b\n       mov bx,0    ;ds:bx 指向a段的第1个单元\n       mov ss,ax\n       \n       mov sp,16   ;设置栈顶指向 b:16\n       mov cx,8    ;循环8次\n\n    s: push [bx]\n       add bx,2    ;bx + 2\n       loop s      ;将a段中0～16个单元逆次入栈\n\ncode ends\nend start\n```\n\n","slug":"《汇编语言》王爽著学习笔记记录","published":true,"updated":"2021-10-20T13:12:16.826Z","_id":"clq6dy49x0022ikw0nxom9iws","comments":true,"layout":"post","photos":[],"link":"","html":"<p>看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。</p>\n<h3 id=\"第一章：基础知识\"><a href=\"#第一章：基础知识\" class=\"headerlink\" title=\"第一章：基础知识\"></a>第一章：基础知识</h3><ol>\n<li><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p>\n</li>\n<li><p>每一种CPU都有自己的汇编指令集</p>\n</li>\n<li><p>在存储器中指令和数据没有任何区别，都是二进制信息。</p>\n</li>\n<li><p>CPU可以直接使用的信息在存储器中存放。</p>\n</li>\n<li><p>存储器单元从零开始顺序编号。</p>\n</li>\n<li><p>一个存储单元可以存储8 bit，即8个二进制位。</p>\n</li>\n<li><p>1Byte = 8bit….</p>\n</li>\n<li><p>每一个CPU芯片都有许多管脚，它们与总线相连。其分为三类：</p>\n<ul>\n<li>地址总线的宽度决定了CPU的寻址能力</li>\n<li>数据总线的宽度决定了CPU与其它器件进行数据传送时一次数据传送量</li>\n<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>\n</ul>\n</li>\n<li><p><strong>内存地址空间：</strong>最终运行程序的是CPU，对CPU来讲，系统中所有的存储器的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力（读取内存地址的范围）的限制。这个逻辑存储器即内存地址空间。</p>\n</li>\n</ol>\n<h3 id=\"第二章：寄存器\"><a href=\"#第二章：寄存器\" class=\"headerlink\" title=\"第二章：寄存器\"></a>第二章：寄存器</h3><ol>\n<li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p>\n</li>\n<li><p>AX、BX、CX、DX这四个寄存器用来存放一般性数据，称为通用寄存器。为了兼容，通常把它们掰为两半来使用,它们可以独立使用：</p>\n<ul>\n<li>AX → AH + AL</li>\n<li>BX → BH + BL</li>\n<li>CX → CH + CL</li>\n<li>DX → DH + DL</li>\n</ul>\n</li>\n<li><p>在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的。</p>\n</li>\n<li><p>8086cpu一次性能处理16位地址，但有20位地址总线，于是采用两个16位地址合成来形成一个20位的物理地址。</p>\n</li>\n<li><p><strong>物理地址 = 段地址 * 16 + 偏移地址</strong>，其含义是用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加得到物理地址。</p>\n</li>\n<li><p>将若干地址连续的内存单元看作是一个段，段地址就是该段的起始地址，用偏移地址定位段中的具体位置。其中段地址必然是16的倍数，偏移地址为16位，所以寻址能力为64K，故一个段的长度最大为64K</p>\n</li>\n<li><p><strong>段寄存器：CS、DS、SS、ES、</strong></p>\n</li>\n<li><p>8086pc机中，设CS中的内容为M(段地址)，IP中的内容为N(偏移地址)，任意时刻，CPU将从M * 16 + N内存单元读取指令执行。</p>\n</li>\n<li><p>“ jmp   某一合法寄存器”  ：用寄存器中的值修改 IP。</p>\n</li>\n<li><p><strong>Debug基本命令：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">命令</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">R(Register)</td>\n<td align=\"center\">查看、改变CPU寄存器中的内容</td>\n<td align=\"center\">①查看：直接输入r，②修改寄存器值：r ax，按enter然后输入数据</td>\n</tr>\n<tr>\n<td align=\"center\">D(Dump)</td>\n<td align=\"center\">查看内存中的内容</td>\n<td align=\"center\">d 段地址：偏移地址 或者 d 段地址：偏移地址段 或d 起始位置  L长度</td>\n</tr>\n<tr>\n<td align=\"center\">E(Enter)</td>\n<td align=\"center\">改写内存中的内容</td>\n<td align=\"center\">e 起始地址 数据 数据 …  空格键表示处理完成</td>\n</tr>\n<tr>\n<td align=\"center\">U(Unassemble)</td>\n<td align=\"center\">将内存中的机器指令翻译为汇编指令</td>\n<td align=\"center\">u 段地址：偏移地址</td>\n</tr>\n<tr>\n<td align=\"center\">T(Trace)</td>\n<td align=\"center\">执行一条机器指令</td>\n<td align=\"center\">输入t ，CPU执行CS:IP指向的指令</td>\n</tr>\n<tr>\n<td align=\"center\">A(Assemble)</td>\n<td align=\"center\">以汇编指令的格式在内存中写入一条机器指令</td>\n<td align=\"center\">a 段地址：偏移地址，接着输入汇编指令</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h3 id=\"第三章：寄存器-内存访问\"><a href=\"#第三章：寄存器-内存访问\" class=\"headerlink\" title=\"第三章：寄存器(内存访问)\"></a>第三章：寄存器(内存访问)</h3><ol>\n<li><p>8086CPU用16位来存储一个字，高8位存放在高位字节，低8位存放在低位字节。一个字用两个地址连续的内存单元存放，低位字节在低位地址，高位字节在高位地址。</p>\n</li>\n<li><p>DS寄存器通常用来存放要要访问的数据的段地址。不支持直接将数据送入段寄存器。</p>\n</li>\n<li><p>mov、add、sub指令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">格式</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">寄存器，数据</td>\n<td align=\"center\">mov ax，6</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">寄存器，寄存器</td>\n<td align=\"center\">mov ax，bx</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">寄存器，内存单元</td>\n<td align=\"center\">mov ax，[8]</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">内存单元，寄存器</td>\n<td align=\"center\">mov [9]，ax</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">段寄存器，寄存器</td>\n<td align=\"center\">mov ds，ax</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">寄存器，数据</td>\n<td align=\"center\">add ax，0</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">寄存器，寄存器</td>\n<td align=\"center\">add  ax，bx</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">寄存器，内存单元</td>\n<td align=\"center\">add ax，[0]</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">内存单元，寄存器</td>\n<td align=\"center\">add [0]，ax</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">寄存器，数据</td>\n<td align=\"center\">sub ax，0</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">寄存器，寄存器</td>\n<td align=\"center\">aub ax，bx</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">寄存器，内存单元</td>\n<td align=\"center\">sub ax，[9]</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">内存单元，寄存器</td>\n<td align=\"center\">sub [9]，ax</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>入栈：将新元素放到栈顶，出栈：从栈顶取出一个元素。遵循先入后出原则（LIFO）</p>\n</li>\n<li><p>PUSH（入栈），POP（出栈），以字为单位进行，</p>\n</li>\n<li><p><strong>任意时刻，SS:SP指向栈顶元素</strong>，push和pop执行时，cpu从ss：sp中得到栈顶地址。</p>\n</li>\n<li><p>执行PUSH指令时，SP=SP-2，表示栈顶向上移动；执行pop指令时，SP=SP+2，表示栈顶向下移动；当栈为空时，SS:SP指向栈顶内存地址+2的内存单元。</p>\n</li>\n<li><p>在使用栈的时候，应当注意不要出现越界。</p>\n</li>\n<li><p>出栈的顺序应该和入栈的顺序相反，这与栈后入先出的特性相关。</p>\n</li>\n<li><p>PUSH过程：①CPU先改变SP=SP+2，②向SS：SP处传送；</p>\n<p>POP过程：①CPU先向SS：SP读取数据，②改变SP的值SP=SP-2。</p>\n<p>push和pop指令操作栈的时候，修改的只是SP。</p>\n</li>\n<li><p>栈的栈顶变化范围：0~FFFFH，所以一个栈段最大容量为64K.</p>\n</li>\n</ol>\n<h3 id=\"第四章：第一个程序\"><a href=\"#第四章：第一个程序\" class=\"headerlink\" title=\"第四章：第一个程序\"></a>第四章：第一个程序</h3><ol>\n<li><p>伪指令：由编译器执行的指令，CPU是不知道它们的，由编译器执行它们</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">段名 segment … 段名 ends</td>\n<td align=\"center\">定义一个段，segment说明一个段开始，ends说明一个段结束</td>\n</tr>\n<tr>\n<td align=\"center\">ebd</td>\n<td align=\"center\">汇编程序结束的标志</td>\n</tr>\n<tr>\n<td align=\"center\">assume</td>\n<td align=\"center\">assume cs：code，将段code与寄存器cs关联起来</td>\n</tr>\n<tr>\n<td align=\"center\">mov ax，4c00H    int 21H</td>\n<td align=\"center\">两行汇编指令，实现程序返回</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>连接（LINK）作用：</p>\n<ol>\n<li>当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件；</li>\n<li>程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>\n<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>\n</ol>\n</li>\n<li><p>EXE文件加载过程：找到一段起始地址为0的空闲区，创建一个程序段前缀（PSP），在PSP后256字节开始，即SA+10H:0为段地址载入ds寄存器中，并初始化CS:IP指向这个地址。</p>\n</li>\n</ol>\n<h3 id=\"第五章：-BX-和loop指令\"><a href=\"#第五章：-BX-和loop指令\" class=\"headerlink\" title=\"第五章：[BX]和loop指令\"></a>第五章：[BX]和loop指令</h3><ol>\n<li><p>[BX]:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">mov ax，[bx]</td>\n<td align=\"center\">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即(ax) = ((ds)*16 + (bx))</td>\n</tr>\n<tr>\n<td align=\"center\">mov [bx]，ax</td>\n<td align=\"center\">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA:EA处，即((ds)*16 + (bx)) = (ax)</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>loop指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">格式</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">loop</td>\n<td align=\"center\">loop  标号</td>\n<td align=\"center\">实现循环功能，cx中存放着循环次数，就相当于for，cx为0向下执行，不为0循环</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">使用方法：</td>\n<td align=\"center\">①在cx中存放循环次数②loop指令中的标号所标识地址在前面③循环执行的程序段在标号和lpp指令之间</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>loop指令框架：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">     mov cx，循环次数\ns：\n     循环执行的程序段\n     loop s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在汇编源程序中，数据不能以字母开头。所以大于9FFFH的数要在前面加0。</p>\n</li>\n<li><p>loop指令的每一次都先判断cx的值，不为0则CS：IP指向下一步循环指令的地址，CPU执行。</p>\n</li>\n<li><p>在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须使用 “[…]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显示的给出段地址所在的段寄存器。</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">mov al,ds:[0]\n//正确的表示\n\nmov al,[0]\n//masm就将[idata] 解释为 idata ，而不是一个内存单元地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>用于显示的指明内存单元的段地址的 “ds:” 、”cs:”、”ss:”、”es:”，在汇编语言中成为<strong>段前缀</strong>。</p>\n</li>\n<li><p>在pc机中，一般 0:200~0:2ff 的256个字节的空间是安全的，即没有其它应用使用这段内存单元。</p>\n</li>\n</ol>\n<h3 id=\"第六章：包含多个段的程序\"><a href=\"#第六章：包含多个段的程序\" class=\"headerlink\" title=\"第六章：包含多个段的程序\"></a>第六章：包含多个段的程序</h3><ol>\n<li><p>在操作系统环境中，合法的通过操作系统取得的空间都是安全的，需要在汇编源程序中做出说明</p>\n</li>\n<li><p>dw(define word) 关键字的意思是定义字型数据，数据之间使用逗号分隔。</p>\n</li>\n<li><p>将 start 放在第一条指令前面，然后在伪指令 end 后面加上 start，表示程序第一条指令从前面的 start 开始。</p>\n</li>\n<li><p>内存空间的开辟：使用 dw 关键字定义一些字型数据，通常为 0，然后将这一段空间当作栈段来使用。</p>\n</li>\n<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据:</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:codesg\ncodesg segment\n        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n\nstart:  mov ax,0\n        mov ds,ax\n        mov bx,0           ;ds = 0,bx = 0\n        mov cx,8           ;循环8次\n\n    s:  mov ax,[bx]        ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax\n        mov cs:[bx],ax     ;将ax中的数据放入内存地址 ((cs)*16 + (bx)) 处，[bx]为偏移地址，段地址在cs中\n        add bx,2           ;bx + 2\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol start=\"6\">\n<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据（数据的传送用栈来进行。栈空间设置在程序内）：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:codesg\ncodesg segment\n        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n        dw 0,0,0,0,0,0,0,0,0,0\n\nstart:  mov ax,cs \n        mov ss,ax\n        mov sp,24h          ;或mov sp, 36  ，ss:sp = cs:24h\n        mov ax,0\n        mov ds,ax           ;ds = 0\n        mov bx,0            ;bx = 0\n        mov cx,8            ;循环8次\n\n    s:  push [bx]           ;将[bx]中的数据压入栈中\n        pop cs:[bx]         ;或 pop ss:[bx],\n        add bx,2            ;bx + 2\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在汇编程序中，一个段的段名就代表了这个段的段地址，而偏移地址需要根据段中的数据来确定。</p>\n</li>\n<li><p>8086CPU不允许直接将一个数值送入段寄存器，应该由一个寄存器比如 ax 来中转。</p>\n</li>\n<li><p><strong>汇编语言实验五：</strong></p>\n<p><strong>（1）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题</strong></p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:code,ds:data,ss:stack \n\ndata segment \n        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h \ndata ends \n\nstack segment \n        dw 0,0,0,0,0,0,0,0 \nstack ends \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n\n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \nend start <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>\n<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>\n<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>\n</li>\n</ol>\n<p><strong>（2）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:code,ds:data,ss:stack \n\ndata segment \n        dw 0123h,0456h\ndata ends \n\nstack segment \n        dw 0,0\nstack ends \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n\n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \nend start <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>\n<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>\n<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>\n<p>④对于如下定义的段：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">name segment\n\n……\n\nname ends<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 ((N+15)/16)*16 。</p>\n<p>④解析：</p>\n<p>N分为被16整除和不被16整除。</p>\n<p>当N被16整除时： 占有的空间为(N/16)*16</p>\n<p>当N不被16整除时： 占有的空间为(N/16+1)*16，N/16得出的是可以整除的部分，还有一个余数，余数肯定小于16，加上一个16。</p>\n<p>程序加载后分配空间是以16个字节为单位的，也就是说如果不足16个字节的也分配16个字节。</p>\n<p>两种情况总结成一个通用的公式：((N+15)/16)*16</p>\n<p><strong>（3）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:code,ds:data,ss:stack \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n\n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \n\ndata segment \n        dw 0123h,0456h\ndata ends \n\nstack segment \n        dw 0,0\nstack ends \n\nend start <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>\n<p>②CPU执行程序，程序返回前，CS= 0C86H ，SS= 0C8AH ，DS= 0C89H 。</p>\n<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X+3 ，STACK段的段地址为 X+4 。</p>\n<p><strong>（4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。</strong></p>\n<p>答：start 作为汇编程序的一个标号，定义了程序的入口，如果不指名入口，程序会从加载进内存的第一个单元起开始执行，前二个题中，前面定义的是数据段、栈段，CPU 能够执行，但在整个程序上来讲，逻辑顺序错误，这样会导致空间二次分配等等情况。</p>\n<p>​     如果指明了程序的入口，CPU会直接从入口处开始执行真正的机器码，直到遇到中断指令返回，比如指令进行到需要栈段空间的时候，CPU 会跳到前面定义的栈段得到分配空间的地址。此种方式能够确保程序逻辑上的正确。因此有必要为程序来指明入口。</p>\n<p>​    综上，只有（3）可以在没有指明程序入口的情况下正确执行。</p>\n<p><strong>（5）程序如下，编写code段中代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</strong></p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cd:code\n\na segment\n    db 1,2,3,4,5,6,7,8\na ends\n\nb segment \n    db 1,2,3,4,5,6,7,8\nb ends\n\nc segment \n   db 0,0,0,0,0,0,0,0\nc ends\n\ncode segment\n\nstart: mov ax,a\n       mov ds,ax           ;ds段寄存器地址指向a\n\n       mov ax,b\n       mov es,ax           ;es段寄存器地址指向b\n\n       mov ax,c\n       mov ss,ax           ;ss段寄存器地址指向c\n\n       mov bx,0            ;偏移地址为0\n       mov cx,8            ;循环8次\n\n    s: mov ax,[bx]         ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax\n       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中\n       mov ax,es:[bx]      ;(ax) = ((es)*16 + (bx)),将对应的数据送入ax\n       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中\n       inc bx              ;bx + 1\n       loop s\n\n\n       mov ax,4c00h\n       int 21h\n\ncode ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>（6）程序如下，编写 code 段中代码，用 push 指令将 a 段中的前8个字型数据，逆序存储到 b 段中。</strong></p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:code\n\na segment\n    dw 1,2,3,4,5,6,7,8\na ends\n\nb segment\n    dw 0,0,0,0,0,0,0,0\nb ends\n\ncode segment\n\nstart: mov ax,a\n       mov ds,ax   ;ds指向a段\n\n       mov ax,b\n       mov bx,0    ;ds:bx 指向a段的第1个单元\n       mov ss,ax\n\n       mov sp,16   ;设置栈顶指向 b:16\n       mov cx,8    ;循环8次\n\n    s: push [bx]\n       add bx,2    ;bx + 2\n       loop s      ;将a段中0～16个单元逆次入栈\n\ncode ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","excerpt":"","more":"<p>看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。</p>\n<h3 id=\"第一章：基础知识\"><a href=\"#第一章：基础知识\" class=\"headerlink\" title=\"第一章：基础知识\"></a>第一章：基础知识</h3><ol>\n<li><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p>\n</li>\n<li><p>每一种CPU都有自己的汇编指令集</p>\n</li>\n<li><p>在存储器中指令和数据没有任何区别，都是二进制信息。</p>\n</li>\n<li><p>CPU可以直接使用的信息在存储器中存放。</p>\n</li>\n<li><p>存储器单元从零开始顺序编号。</p>\n</li>\n<li><p>一个存储单元可以存储8 bit，即8个二进制位。</p>\n</li>\n<li><p>1Byte = 8bit….</p>\n</li>\n<li><p>每一个CPU芯片都有许多管脚，它们与总线相连。其分为三类：</p>\n<ul>\n<li>地址总线的宽度决定了CPU的寻址能力</li>\n<li>数据总线的宽度决定了CPU与其它器件进行数据传送时一次数据传送量</li>\n<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>\n</ul>\n</li>\n<li><p><strong>内存地址空间：</strong>最终运行程序的是CPU，对CPU来讲，系统中所有的存储器的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力（读取内存地址的范围）的限制。这个逻辑存储器即内存地址空间。</p>\n</li>\n</ol>\n<h3 id=\"第二章：寄存器\"><a href=\"#第二章：寄存器\" class=\"headerlink\" title=\"第二章：寄存器\"></a>第二章：寄存器</h3><ol>\n<li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p>\n</li>\n<li><p>AX、BX、CX、DX这四个寄存器用来存放一般性数据，称为通用寄存器。为了兼容，通常把它们掰为两半来使用,它们可以独立使用：</p>\n<ul>\n<li>AX → AH + AL</li>\n<li>BX → BH + BL</li>\n<li>CX → CH + CL</li>\n<li>DX → DH + DL</li>\n</ul>\n</li>\n<li><p>在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的。</p>\n</li>\n<li><p>8086cpu一次性能处理16位地址，但有20位地址总线，于是采用两个16位地址合成来形成一个20位的物理地址。</p>\n</li>\n<li><p><strong>物理地址 = 段地址 * 16 + 偏移地址</strong>，其含义是用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加得到物理地址。</p>\n</li>\n<li><p>将若干地址连续的内存单元看作是一个段，段地址就是该段的起始地址，用偏移地址定位段中的具体位置。其中段地址必然是16的倍数，偏移地址为16位，所以寻址能力为64K，故一个段的长度最大为64K</p>\n</li>\n<li><p><strong>段寄存器：CS、DS、SS、ES、</strong></p>\n</li>\n<li><p>8086pc机中，设CS中的内容为M(段地址)，IP中的内容为N(偏移地址)，任意时刻，CPU将从M * 16 + N内存单元读取指令执行。</p>\n</li>\n<li><p>“ jmp   某一合法寄存器”  ：用寄存器中的值修改 IP。</p>\n</li>\n<li><p><strong>Debug基本命令：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">命令</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">R(Register)</td>\n<td align=\"center\">查看、改变CPU寄存器中的内容</td>\n<td align=\"center\">①查看：直接输入r，②修改寄存器值：r ax，按enter然后输入数据</td>\n</tr>\n<tr>\n<td align=\"center\">D(Dump)</td>\n<td align=\"center\">查看内存中的内容</td>\n<td align=\"center\">d 段地址：偏移地址 或者 d 段地址：偏移地址段 或d 起始位置  L长度</td>\n</tr>\n<tr>\n<td align=\"center\">E(Enter)</td>\n<td align=\"center\">改写内存中的内容</td>\n<td align=\"center\">e 起始地址 数据 数据 …  空格键表示处理完成</td>\n</tr>\n<tr>\n<td align=\"center\">U(Unassemble)</td>\n<td align=\"center\">将内存中的机器指令翻译为汇编指令</td>\n<td align=\"center\">u 段地址：偏移地址</td>\n</tr>\n<tr>\n<td align=\"center\">T(Trace)</td>\n<td align=\"center\">执行一条机器指令</td>\n<td align=\"center\">输入t ，CPU执行CS:IP指向的指令</td>\n</tr>\n<tr>\n<td align=\"center\">A(Assemble)</td>\n<td align=\"center\">以汇编指令的格式在内存中写入一条机器指令</td>\n<td align=\"center\">a 段地址：偏移地址，接着输入汇编指令</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h3 id=\"第三章：寄存器-内存访问\"><a href=\"#第三章：寄存器-内存访问\" class=\"headerlink\" title=\"第三章：寄存器(内存访问)\"></a>第三章：寄存器(内存访问)</h3><ol>\n<li><p>8086CPU用16位来存储一个字，高8位存放在高位字节，低8位存放在低位字节。一个字用两个地址连续的内存单元存放，低位字节在低位地址，高位字节在高位地址。</p>\n</li>\n<li><p>DS寄存器通常用来存放要要访问的数据的段地址。不支持直接将数据送入段寄存器。</p>\n</li>\n<li><p>mov、add、sub指令</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">格式</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">寄存器，数据</td>\n<td align=\"center\">mov ax，6</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">寄存器，寄存器</td>\n<td align=\"center\">mov ax，bx</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">寄存器，内存单元</td>\n<td align=\"center\">mov ax，[8]</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">内存单元，寄存器</td>\n<td align=\"center\">mov [9]，ax</td>\n</tr>\n<tr>\n<td align=\"center\">mov</td>\n<td align=\"center\">段寄存器，寄存器</td>\n<td align=\"center\">mov ds，ax</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">寄存器，数据</td>\n<td align=\"center\">add ax，0</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">寄存器，寄存器</td>\n<td align=\"center\">add  ax，bx</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">寄存器，内存单元</td>\n<td align=\"center\">add ax，[0]</td>\n</tr>\n<tr>\n<td align=\"center\">add</td>\n<td align=\"center\">内存单元，寄存器</td>\n<td align=\"center\">add [0]，ax</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">寄存器，数据</td>\n<td align=\"center\">sub ax，0</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">寄存器，寄存器</td>\n<td align=\"center\">aub ax，bx</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">寄存器，内存单元</td>\n<td align=\"center\">sub ax，[9]</td>\n</tr>\n<tr>\n<td align=\"center\">sub</td>\n<td align=\"center\">内存单元，寄存器</td>\n<td align=\"center\">sub [9]，ax</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>入栈：将新元素放到栈顶，出栈：从栈顶取出一个元素。遵循先入后出原则（LIFO）</p>\n</li>\n<li><p>PUSH（入栈），POP（出栈），以字为单位进行，</p>\n</li>\n<li><p><strong>任意时刻，SS:SP指向栈顶元素</strong>，push和pop执行时，cpu从ss：sp中得到栈顶地址。</p>\n</li>\n<li><p>执行PUSH指令时，SP=SP-2，表示栈顶向上移动；执行pop指令时，SP=SP+2，表示栈顶向下移动；当栈为空时，SS:SP指向栈顶内存地址+2的内存单元。</p>\n</li>\n<li><p>在使用栈的时候，应当注意不要出现越界。</p>\n</li>\n<li><p>出栈的顺序应该和入栈的顺序相反，这与栈后入先出的特性相关。</p>\n</li>\n<li><p>PUSH过程：①CPU先改变SP=SP+2，②向SS：SP处传送；</p>\n<p>POP过程：①CPU先向SS：SP读取数据，②改变SP的值SP=SP-2。</p>\n<p>push和pop指令操作栈的时候，修改的只是SP。</p>\n</li>\n<li><p>栈的栈顶变化范围：0~FFFFH，所以一个栈段最大容量为64K.</p>\n</li>\n</ol>\n<h3 id=\"第四章：第一个程序\"><a href=\"#第四章：第一个程序\" class=\"headerlink\" title=\"第四章：第一个程序\"></a>第四章：第一个程序</h3><ol>\n<li><p>伪指令：由编译器执行的指令，CPU是不知道它们的，由编译器执行它们</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">段名 segment … 段名 ends</td>\n<td align=\"center\">定义一个段，segment说明一个段开始，ends说明一个段结束</td>\n</tr>\n<tr>\n<td align=\"center\">ebd</td>\n<td align=\"center\">汇编程序结束的标志</td>\n</tr>\n<tr>\n<td align=\"center\">assume</td>\n<td align=\"center\">assume cs：code，将段code与寄存器cs关联起来</td>\n</tr>\n<tr>\n<td align=\"center\">mov ax，4c00H    int 21H</td>\n<td align=\"center\">两行汇编指令，实现程序返回</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>连接（LINK）作用：</p>\n<ol>\n<li>当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件；</li>\n<li>程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>\n<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>\n</ol>\n</li>\n<li><p>EXE文件加载过程：找到一段起始地址为0的空闲区，创建一个程序段前缀（PSP），在PSP后256字节开始，即SA+10H:0为段地址载入ds寄存器中，并初始化CS:IP指向这个地址。</p>\n</li>\n</ol>\n<h3 id=\"第五章：-BX-和loop指令\"><a href=\"#第五章：-BX-和loop指令\" class=\"headerlink\" title=\"第五章：[BX]和loop指令\"></a>第五章：[BX]和loop指令</h3><ol>\n<li><p>[BX]:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">mov ax，[bx]</td>\n<td align=\"center\">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即(ax) = ((ds)*16 + (bx))</td>\n</tr>\n<tr>\n<td align=\"center\">mov [bx]，ax</td>\n<td align=\"center\">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA:EA处，即((ds)*16 + (bx)) = (ax)</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>loop指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">格式</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">loop</td>\n<td align=\"center\">loop  标号</td>\n<td align=\"center\">实现循环功能，cx中存放着循环次数，就相当于for，cx为0向下执行，不为0循环</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">使用方法：</td>\n<td align=\"center\">①在cx中存放循环次数②loop指令中的标号所标识地址在前面③循环执行的程序段在标号和lpp指令之间</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>loop指令框架：</p>\n<pre><code class=\"asm\">     mov cx，循环次数\ns：\n     循环执行的程序段\n     loop s</code></pre>\n</li>\n<li><p>在汇编源程序中，数据不能以字母开头。所以大于9FFFH的数要在前面加0。</p>\n</li>\n<li><p>loop指令的每一次都先判断cx的值，不为0则CS：IP指向下一步循环指令的地址，CPU执行。</p>\n</li>\n<li><p>在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须使用 “[…]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显示的给出段地址所在的段寄存器。</p>\n<pre><code class=\"asm\">mov al,ds:[0]\n//正确的表示\n\nmov al,[0]\n//masm就将[idata] 解释为 idata ，而不是一个内存单元地址</code></pre>\n</li>\n<li><p>用于显示的指明内存单元的段地址的 “ds:” 、”cs:”、”ss:”、”es:”，在汇编语言中成为<strong>段前缀</strong>。</p>\n</li>\n<li><p>在pc机中，一般 0:200~0:2ff 的256个字节的空间是安全的，即没有其它应用使用这段内存单元。</p>\n</li>\n</ol>\n<h3 id=\"第六章：包含多个段的程序\"><a href=\"#第六章：包含多个段的程序\" class=\"headerlink\" title=\"第六章：包含多个段的程序\"></a>第六章：包含多个段的程序</h3><ol>\n<li><p>在操作系统环境中，合法的通过操作系统取得的空间都是安全的，需要在汇编源程序中做出说明</p>\n</li>\n<li><p>dw(define word) 关键字的意思是定义字型数据，数据之间使用逗号分隔。</p>\n</li>\n<li><p>将 start 放在第一条指令前面，然后在伪指令 end 后面加上 start，表示程序第一条指令从前面的 start 开始。</p>\n</li>\n<li><p>内存空间的开辟：使用 dw 关键字定义一些字型数据，通常为 0，然后将这一段空间当作栈段来使用。</p>\n</li>\n<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据:</p>\n<pre><code class=\"asm\">assume cs:codesg\ncodesg segment\n        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n\nstart:  mov ax,0\n        mov ds,ax\n        mov bx,0           ;ds = 0,bx = 0\n        mov cx,8           ;循环8次\n\n    s:  mov ax,[bx]        ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax\n        mov cs:[bx],ax     ;将ax中的数据放入内存地址 ((cs)*16 + (bx)) 处，[bx]为偏移地址，段地址在cs中\n        add bx,2           ;bx + 2\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n</li>\n</ol>\n<ol start=\"6\">\n<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据（数据的传送用栈来进行。栈空间设置在程序内）：</p>\n<pre><code class=\"asm\">assume cs:codesg\ncodesg segment\n        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n        dw 0,0,0,0,0,0,0,0,0,0\n\nstart:  mov ax,cs \n        mov ss,ax\n        mov sp,24h          ;或mov sp, 36  ，ss:sp = cs:24h\n        mov ax,0\n        mov ds,ax           ;ds = 0\n        mov bx,0            ;bx = 0\n        mov cx,8            ;循环8次\n\n    s:  push [bx]           ;将[bx]中的数据压入栈中\n        pop cs:[bx]         ;或 pop ss:[bx],\n        add bx,2            ;bx + 2\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n</li>\n<li><p>在汇编程序中，一个段的段名就代表了这个段的段地址，而偏移地址需要根据段中的数据来确定。</p>\n</li>\n<li><p>8086CPU不允许直接将一个数值送入段寄存器，应该由一个寄存器比如 ax 来中转。</p>\n</li>\n<li><p><strong>汇编语言实验五：</strong></p>\n<p><strong>（1）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题</strong></p>\n<pre><code class=\"asm\">assume cs:code,ds:data,ss:stack \n\ndata segment \n        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h \ndata ends \n\nstack segment \n        dw 0,0,0,0,0,0,0,0 \nstack ends \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n\n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \nend start </code></pre>\n<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>\n<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>\n<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>\n</li>\n</ol>\n<p><strong>（2）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>\n<pre><code class=\"asm\">assume cs:code,ds:data,ss:stack \n\ndata segment \n        dw 0123h,0456h\ndata ends \n\nstack segment \n        dw 0,0\nstack ends \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n\n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \nend start </code></pre>\n<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>\n<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>\n<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>\n<p>④对于如下定义的段：</p>\n<pre><code class=\"asm\">name segment\n\n……\n\nname ends</code></pre>\n<p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 ((N+15)/16)*16 。</p>\n<p>④解析：</p>\n<p>N分为被16整除和不被16整除。</p>\n<p>当N被16整除时： 占有的空间为(N/16)*16</p>\n<p>当N不被16整除时： 占有的空间为(N/16+1)*16，N/16得出的是可以整除的部分，还有一个余数，余数肯定小于16，加上一个16。</p>\n<p>程序加载后分配空间是以16个字节为单位的，也就是说如果不足16个字节的也分配16个字节。</p>\n<p>两种情况总结成一个通用的公式：((N+15)/16)*16</p>\n<p><strong>（3）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>\n<pre><code class=\"asm\">assume cs:code,ds:data,ss:stack \n\ncode segment \n\nstart:  mov ax,stack \n        mov ss,ax \n        mov sp,16 \n        mov ax,data \n        mov ds,ax \n\n        push ds:[0] \n        push ds:[2] \n        pop ds:[2] \n        pop ds:[0] \n\n        mov ax,4c00h \n        int 21h \n\ncode ends \n\ndata segment \n        dw 0123h,0456h\ndata ends \n\nstack segment \n        dw 0,0\nstack ends \n\nend start </code></pre>\n<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>\n<p>②CPU执行程序，程序返回前，CS= 0C86H ，SS= 0C8AH ，DS= 0C89H 。</p>\n<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X+3 ，STACK段的段地址为 X+4 。</p>\n<p><strong>（4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。</strong></p>\n<p>答：start 作为汇编程序的一个标号，定义了程序的入口，如果不指名入口，程序会从加载进内存的第一个单元起开始执行，前二个题中，前面定义的是数据段、栈段，CPU 能够执行，但在整个程序上来讲，逻辑顺序错误，这样会导致空间二次分配等等情况。</p>\n<p>​     如果指明了程序的入口，CPU会直接从入口处开始执行真正的机器码，直到遇到中断指令返回，比如指令进行到需要栈段空间的时候，CPU 会跳到前面定义的栈段得到分配空间的地址。此种方式能够确保程序逻辑上的正确。因此有必要为程序来指明入口。</p>\n<p>​    综上，只有（3）可以在没有指明程序入口的情况下正确执行。</p>\n<p><strong>（5）程序如下，编写code段中代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</strong></p>\n<pre><code class=\"asm\">assume cd:code\n\na segment\n    db 1,2,3,4,5,6,7,8\na ends\n\nb segment \n    db 1,2,3,4,5,6,7,8\nb ends\n\nc segment \n   db 0,0,0,0,0,0,0,0\nc ends\n\ncode segment\n\nstart: mov ax,a\n       mov ds,ax           ;ds段寄存器地址指向a\n\n       mov ax,b\n       mov es,ax           ;es段寄存器地址指向b\n\n       mov ax,c\n       mov ss,ax           ;ss段寄存器地址指向c\n\n       mov bx,0            ;偏移地址为0\n       mov cx,8            ;循环8次\n\n    s: mov ax,[bx]         ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax\n       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中\n       mov ax,es:[bx]      ;(ax) = ((es)*16 + (bx)),将对应的数据送入ax\n       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中\n       inc bx              ;bx + 1\n       loop s\n\n\n       mov ax,4c00h\n       int 21h\n\ncode ends\nend start</code></pre>\n<p><strong>（6）程序如下，编写 code 段中代码，用 push 指令将 a 段中的前8个字型数据，逆序存储到 b 段中。</strong></p>\n<pre><code class=\"asm\">assume cs:code\n\na segment\n    dw 1,2,3,4,5,6,7,8\na ends\n\nb segment\n    dw 0,0,0,0,0,0,0,0\nb ends\n\ncode segment\n\nstart: mov ax,a\n       mov ds,ax   ;ds指向a段\n\n       mov ax,b\n       mov bx,0    ;ds:bx 指向a段的第1个单元\n       mov ss,ax\n\n       mov sp,16   ;设置栈顶指向 b:16\n       mov cx,8    ;循环8次\n\n    s: push [bx]\n       add bx,2    ;bx + 2\n       loop s      ;将a段中0～16个单元逆次入栈\n\ncode ends\nend start</code></pre>\n","path":"hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu.html","permalink":"https://www.yshawlon.cn/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu.html","tags":[{"name":"学习笔记","_id":"clq6dy48u0013ikw0galx0575","slug":"学习笔记","path":"tags/学习笔记/","permalink":"https://www.yshawlon.cn/tags/学习笔记/","length":9}],"categories":[{"name":"汇编","_id":"clq6dy4ak0037ikw0ze8i7hy0","slug":"汇编","path":"categories/汇编/","permalink":"https://www.yshawlon.cn/categories/汇编/","length":3}],"prev":{"title":"汇编语言学习 DOSBox+MASM 安装及使用教程","date":"2021-05-08T06:19:14.000Z","summary":"安装DOSBox和MASM 以及编写汇编程序实现输出 Hello Word，记录学习过程。","slug":"汇编语言学习-DOSBox-MASM-安装及使用教程","published":true,"updated":"2021-12-14T04:46:20.344Z","_id":"clq6dy4ao003iikw0s85badpy","layout":"post","photos":[],"link":"","excerpt":"","path":"hui-bian-yu-yan-xue-xi-dosbox-masm-an-zhuang-ji-shi-yong-jiao-cheng.html","permalink":"https://www.yshawlon.cn/hui-bian-yu-yan-xue-xi-dosbox-masm-an-zhuang-ji-shi-yong-jiao-cheng.html","__post":true},"next":{"title":"Windows+Ubuntu20.04双系统安装教程","date":"2021-05-08T06:07:52.000Z","summary":"由于需要在Linux下写代码，虚拟机运行速度不理想，使用颇为受限，故安装双系统","slug":"Windows-Ubuntu20-04双系统安装教程","published":true,"updated":"2021-05-08T06:09:11.064Z","_id":"clq6dy49h001oikw0ip98jd8c","layout":"post","photos":[],"link":"","excerpt":"","path":"windows-ubuntu20-04-shuang-xi-tong-an-zhuang-jiao-cheng.html","permalink":"https://www.yshawlon.cn/windows-ubuntu20-04-shuang-xi-tong-an-zhuang-jiao-cheng.html","__post":true},"__post":true}