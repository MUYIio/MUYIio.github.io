{"title":"C++学习笔记整理-类与对象","date":"2020-04-26T10:53:44.000Z","toc":true,"summary":"抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程.","source":"_posts/C-学习笔记整理-第四章《类与对象》.md","raw":"---\ntitle: C++学习笔记整理-类与对象\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-04-26 18:53:44\npassword:\nsummary: 抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程.\ntags:\n- 学习笔记\ncategories:\n- C++\n---\n\n\n\n\n\n# 第四章 类和对象\n\n\n\n## 1.面向对象程序设计的基本特点\n\n\n\n### ①抽象\n\n\n\n**抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。**\n\n- 先注意问题的本质及描述，其次是实现过程或细节。\n\n- 数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。\n\n- 代码抽象：描述某类对象的共有的行为特征或具有的功能。\n\n- 抽象的实现：通过类的声明。\n\n\n\n\n\n```c++\n//数据抽象：\nint hour,int minute,int second\n//代码抽象：\nsetTime(),showTime()\n\nclass  Clock {\n  public: \n   void setTime(int newH, int newM, int newS);\u000b   void showTime();\n  private: \n   int hour, minute, second;\n};\n\n```\n\n\n\n### ②封装\n\n\n\n**将抽象出的数据成员、代码成员相结合，将它们视为一个整体。**\n\n- 目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。\n\n- 实现封装：类声明中的{}\n\n\n\n```c++\n//实例：\n\nclass  Clock {\n  public://公有的访问权限\n      void setTime(int newH, int newM, int newS);//外部接口\n      void showTime();//外部接口\n  private: //私有的访问权限\n      int hour, minute, second;\n};//边界\n\n```\n\n\n\n### ③继承\n\n**是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。**\n\n- 实现：声明派生类\n\n\n\n### ④多态\n\n**多态：同一名称，不同的功能实现方式。**\n\n- 目的：达到行为标识统一，减少程序中标识符的个数。\n\n- 实现：重载函数和虚函数\n\n\n\n------\n\n\n\n## 2.类和对象\n\n\n\n### ①类和对象\n\n\n\n**类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。**\n\n- 利用类可以实现数据的封装、隐藏、继承与派生。\n\n- 利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。\n\n- 定义一个新的class也就定义了一个新的类型\n\n\n\n### ②类的定义\n\n类是一种用户自定义类型，声明形式：\n\n```c++\nclass 类名称\n{\n   public:\n             公有成员（外部接口）\n   private:\n             私有成员\n   protected:\n             保护型成员\n};\n```\n\n\n\n- **在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。**\n\n- **在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。**\n  **如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。**\n\n- **protected保护型成员与private类似，其差别表现在继承与派生时对派生类的影响不同**\n\n\n\n------\n\n### ③对象\n\n\n\n**类的对象是该类的某一特定实体，即类类型的变量。**\n声明形式：\n\n```c++c\n类名  对象名；\n例：Clock  myClock;\n```\n\n-  类中成员互访：直接使用成员名\n\n-  类外访问：使用“对象名.成员名”方式访问 public 属性的成员\n\n\n\n### ④类的成员函数\n\n- 在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。\n\n- 允许声明重载函数和带默认形参值的函数\n\n\n\n### ⑤内联成员函数\n\n- **为了提高运行时的效率，对于较简单的函数可以声明为内联形式。**\n\n- 内联函数体中不要有复杂结构（如循环语句和switch语句）。\n\n  \n\n  在类中声明内联成员函数的方式：\n\n  - 将函数体放在类的声明中。\n  - 使用inline关键字。\n\n\n\n```c++\n//example.1类的实现\n#include<iostream>\nusing namespace std;\nclass Clock{\npublic:\t\t\n\tvoid setTime(int newH = 0, int newM = 0, int newS = 0);\n\tvoid showTime();\nprivate:\t\n\tint hour, minute, second;\n};\nint main()\n{\n\tClock myClock;\n\tmyClock.setTime(8, 30, 30);\n\tmyClock.showTime();\n\treturn 0;\n}\n\nvoid Clock::setTime(int newH, int newM,int newS)\n{\n   hour=newH;\n   minute=newM;\n   second=newS;\n}\nvoid Clock::showTime() \n{\n   cout << hour << \":\" << minute << \":\" << second;\n}\n\n\n//运行结果：\n8:30:30\n\n```\n\n\n\n```c++\n//Point类的完整程序\n\nclass Point {   //Point 类的定义\npublic:\n\tPoint(int xx=0, int yy=0) { x = xx; y = yy; }    //构造函数，内联\n\tPoint(const Point& p); //复制构造函数\n    void setX(int xx) {x=xx;}\n    void setY(int yy) {y=yy;}\n\tint getX() const { return x; } //常函数（第5章）\n\tint getY() const { return y; } //常函数（第5章）\nprivate:\n\tint x, y; //私有数据\n};\n//成员函数的实现\nPoint::Point (const Point& p) {\n  x = p.x;\n  y = p.y;\n  cout << \"Calling the copy constructor \" << endl;\n}\n\n//形参为Point类对象的函数\nvoid fun1(Point p) {\n\tcout << p.getX() << endl;\n}\n//返回值为Point类对象的函数\nPoint fun2() {\n\tPoint a(1, 2);\n\treturn a;\n}\n\n//主程序\nint main() {\n\tPoint a(4, 5);\t//第一个对象A\n\tPoint b = a;\t//情况一，用A初始化B。第一次调用复制构造函数\n\tcout << b.getX() << endl;\n\tfun1(b);\t//情况二，对象B作为fun1的实参。第二次调用复制构造函数\n\tb = fun2();\t//情况三，函数的返回值是类对象，函数返回时调用复制构造函数\n\tcout << b.getX() << endl;\n\treturn 0;\n}\n```\n\n\n\n## 3.构造函数和析构函数\n\n\n\n### ①构造函数\n\n- 类中的特殊函数\n- 用于描述初始化算法\n\n- 构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。\n- 在对象创建时被自动调用\n- 如果程序中未声明，则系统自动产生出一个默认的构造函数，其参数列表为空\n- 构造函数可以是内联函数、重载函数、带默认参数值的函数\n\n\n\n```c++\n//构造函数举例\nclass Clock {\npublic:\n\tClock(int newH,int newM,int newS);//构造函数\n\tvoid setTime(int newH, int newM, int newS);\n\tvoid showTime();\nprivate:\n\tint hour, minute, second;\n};\n\n```\n\n\n\n```c++\n//构造函数的实现：\nClock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) {\n\t}\n建立对象时构造函数的作用：\nint main() {\n  Clock c(0,0,0); //此处将自动调用构造函数\n  c.showTime();\n\treturn 0;\n}\n\n\n```\n\n\n\n### ②复制构造函数\n\n\n\n**复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。**\n\n```c++\nclass 类名 {\npublic :\n    类名（形参）；//构造函数\n    类名（const  类名 &对象名）；//复制构造函数\n           ...\n}；\n类名::类（ const  类名 &对象名）//复制构造函数的实现\n{    函数体    }\n\n```\n\n\n\n**复制构造函数被调用的三种情况**\n\n- 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；\n\n- 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；\n\n- 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。\n\n\n\n**有时不应该进行复制和赋值**\n\n\n\n- 例如，房屋中介系统有一个类描述待售房屋\n\n```c++\nclass HomeForSale{…}\n//通常没有完全一样的房屋，因此不应有复制构造\n```\n\n\n\n```c++\n//解决方法一：将不应该有的默认函数定义为私有\n\nclass HomeForSale{\npublic:\n    …\nprivate:\n    …\n    HomeForSale(const HomeForSale&);\n    HomeForSale& operator=(const HomeForSale&)\n        \n//解决方法二：定义一个Uncopyable类作为基类\n\nclass Uncopyable{\nprotected:\n    Uncopyable(){}\n    ~ Uncopyable(){}\nprivate:\n     Uncopyable(const Uncopyable&);\n     Uncopyable operator=(const Uncopyable&);\n};\n\n```\n\n\n\n\n\n### ③默认构造函数\n\n**调用时可以不需要参数的构造函数都是默认构造函数。**\n\n- 当不定义构造函数时，编译器自动产生默认构造函数\n\n- 在类中可以自定义无参数的构造函数，也是默认构造函数\n\n- 全部参数都有默认形参值的构造函数也是默认构造函数\n\n**下面两个都是默认构造函数，如果在类中同时出现，将产生编译错误：**\n\n```c++\nClock();\nClock(int newH=0,int newM=0,int newS=0);\n```\n\n\n\n```c++\n//example.1\nclass Clock {\npublic:\n\tClock(int newH,int newM,int newS);//构造函数\n\tClock();//默认构造函数\n    void setTime(int newH, int newM, int newS);\n\tvoid showTime();\nprivate:\n\tint hour, minute, second;\n};\n//构造函数的实现：\nClock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) { }\n//默认构造函数的实现：\nClock::Clock(): hour(0), minute(0), second(0) { }\n\n//建立对象时构造函数的作用：\nint main() {\n  Clock c(8,10,0); //调用有参构造函数\n  Clock c2();//调用无参构造函数\n  c.showTime();\n  c2.showTime();\n\treturn 0;\n}\n\nvoid Clock::setTime(int newH, int newM,int newS)\n{\n   hour = newH;\n   minute = newM;\n   second = newS;\n}\nvoid Clock::showTime() \n{\n   cout << hour << \":\" << minute << \":\" << second;\n}\n```\n\n\n\n**有时不应该有默认的构造函数**\n\n- 有些类，不应该有默认初始化。 \n  例如，没有姓名的学生对象是没有意义的\n  解决：\n  至少定义一个有参数的构造函数\n  不定义默认构造函数\n\n- 需要深层复制时，默认的复制构造会引起错误。\n  解决：\n  自定义实现深层复制的复制构造函数\n\n\n\n\n\n\n\n### ④隐含的复制构造函数\n\n如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。\n\n\n\n这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。\n\n\n\n### ⑤函数参数尽量传递常引用而不是值\n\n- 传递对象值会引起复制构造和析构，增加时间空间开销。\n- 传常引用可避免这一问题。以引用做参数时，尽量使用常引用。\n\n```c++\n//例如：\nvoid fun1(const Point &p) {\n\tcout << p.getX() << endl;\n   p.setX(1); //语法错误：p是常引用而setX不是常函数\n}\n```\n\n基本类型、STL的迭代器和函数对象传值较好。\n\n\n\n### ⑥返回值优化\n\n- 当函数返回一个对象时，会构造临时对象用以返回，这会增加开销。\n\n- 用返回引用或者指针替代不是好办法。返回指向局部对象的指针或者引用，会引发错误。返回指向动态内存的指针或引用容易忘记动态空间释放，引起内存泄露。\n\n- 解决显式构造临时对象返回。此举表面上还是构造了一个临时对象，但是编译器通常都会进行优化，使之不产生临时对象。\n\n```c++\n//例如：\nPoint fun2() {\n\treturn Point(1, 2);\n}\n```\n\n\n\n\n\n### ⑦析构函数\n\n- 完成对象被删除前的一些清理工作。\n\n- 在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。\n\n- 如果程序中未声明析构函数，编译器将自动产生一个隐含的析构函数。\n\n\n\n```c++\n//构造函数和析构函数举例\n\n#include <iostream>\nusing namespace std;\nclass Point {     \npublic:\n  Point(int xx,int yy);\n  ~Point();\n  //...其他函数原型\nprivate:\n  int x, y;\n};\n\nPoint::Point(int xx,int yy) {\n  x = xx;\n  y = yy;\n}\nPoint::~Point() {\n}\n//...其他函数的实现略\n```\n\n\n\n\n\n------\n\n\n\n## 3.类的组合\n\n### ①组合\n\n- 类中的成员数据是另一个类的对象。\n\n- 可以在已有抽象的基础上实现更复杂的抽象。\n\n\n\n**类组合的构造函数设计**\n\n\n\n- 原则：不仅要负责对本类中的基本类型成员数据赋初值，也要对对象成员初始化。\n\n```c++\n//声明形式：\n类名::类名(对象成员所需的形参，本类成员形参)\n       :对象1(参数)，对象2(参数)，......\n{  \n//函数体其他语句\n}\n\n```\n\n\n\n**构造组合类对象时的初始化次序**\n\n- 首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。\n\n- 成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。\n\n- 初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化\n\n- 处理完初始化列表之后，再执行构造函数的函数体\n\n\n\n```c++\n//类的组合，线段（Line）类\n\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Point {\t//Point类定义\npublic:\n\tPoint(int xx = 0, int yy = 0) {\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tPoint(Point &p);\n\tint getX() { return x; }\n\tint getY() { return y; }\nprivate:\n\tint x, y;\n};\nPoint::Point(Point &p) {\t//复制构造函数的实现\n\tx = p.x;\n\ty = p.y;\n\tcout << \"Calling the copy constructor of Point\" << endl;\n}\n\npublic:\t//外部接口\n\tLine(Point xp1, Point xp2);\n\tLine(Line &l);\n\tdouble getLen() { return len; }\nprivate:\t//私有数据成员\n\tPoint p1, p2;\t//Point类的对象p1,p2\n\tdouble len;\n};\n//组合类的构造函数\nLine::Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) {\n\tcout << \"Calling constructor of Line\" << endl;\n\tdouble x = static_cast<double>(p1.getX() - p2.getX());\n\tdouble y = static_cast<double>(p1.getY() - p2.getY());\n\tlen = sqrt(x * x + y * y);\n}\nLine::Line (Line &l): p1(l.p1), p2(l.p2) {//组合类的复制构造函数\n\tcout << \"Calling the copy constructor of Line\" << endl;\n\tlen = l.len;\n}\n\n//主函数\nint main() {\n\tPoint myp1(1, 1), myp2(4, 5);\t//建立Point类的对象\n\tLine line(myp1, myp2);\t//建立Line类的对象\n\tLine line2(line);\t//利用复制构造函数建立一个新对象\n\tcout << \"The length of the line is: \";\n\tcout << line.getLen() << endl;\n\tcout << \"The length of the line2 is: \";\n\tcout << line2.getLen() << endl;\n\treturn 0;\n}\n\n\n//运行结果如下：\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling constructor of Line\nCalling the copy constructor of Point\nCalling the copy constructor of Point\n\n```\n\n\n\n**前向引用声明**\n\n- 类应该先声明，后使用\n\n- 如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。\n\n- 前向引用声明只为程序引入一个标识符，但具体声明在其他地方。\n\n\n\n```c++\n//example\n\nclass B;  //前向引用声明\nclass A {\npublic:\n  void f(B b);\n};\nclass B {\npublic:\n  void g(A a);\n};\n```\n\n\n\n\n\n**前向引用声明注意事项**\n\n\n\n使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象\n\n\n\n```c++\nclass Fred; //前向引用声明\nclass Barney {\n   Fred x; //错误：类Fred的声明尚不完善\n};\nclass Fred {\n   Barney y;\n};\n\n//更正\nclass Fred;\t//前向引用声明\nclass Barney {\npublic:\n  ……\n  void method() {\n    x.yabbaDabbaDo();\t//错误：Fred类的对象在定义之前被使用\n  }\n private:\n  Fred &x;//正确，经过前向引用声明，可以声明Fred类的对象引用\n};\n \nclass Fred {\npublic:\n  void yabbaDabbaDo();\nprivate:\n  Barney &y;\n}; \n\n```\n\n\n\n**前向引用声明注意事项**\n\n\n\n- 应该记住：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。\n\n------\n\n\n\n## 4.UML图形标识\n\n### ①UML简介\n\n**UML（Unified Modeling Language）语言是一种可视化的的面向对象建模语言。**\n\n**UML有三个基本的部分**\n\n- 事物（Things）\u000bUML中重要的组成部分，在模型中属于最静态的部分，代表概念上的或物理上的元素\n\n- 关系（Relationships）\u000b关系把事物紧密联系在一起\n\n- 图（Diagrams）\u000b图是很多有相互相关的事物的组\n\n\n\n### ②UML类图\n\n\n\n**举例：Clock类的完整表示:**\n\n\n\n| Clock                                       |\n| ------------------------------------------- |\n| - hour:  int                                |\n| - minute:  int                              |\n| - second:  int                              |\n| + showTime(): void                          |\n| + setTime(newH:int=0,newM:int=0,newS:int=0) |\n\n\n\n**Clock类的简洁表示**\n\n\n\n| Clock |\n| ----- |\n|       |\n\n\n\n### ③对象图\n\n| myClock:Clock |\n| :-----------: |\n|  - hour: int  |\n| - minute: int |\n| - second: int |\n\n\n\n### ④几种关系的图形标识\n\n\n\n**依赖关系**\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片5.png)\n\n图中的“类A”是源，“类B”是目标，表示“类A”使用了“类B”，或称“类A”依赖“类B”\n\n\n\n**作用关系—关联**\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片4.png)\n\n图中的“重数A”决定了类B的每个对象与类A的多少个对象发生作用，同样“重数B”决定了类A的每个对象与类B的多少个对象发生作用。\n\n**包含关系—聚集和组合**\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片6.png)\n\n聚集表示类之间的关系是整体与部分的关系，“包含”、“组成”、“分为……部分”等都是聚集关系。共享聚集：部分可以参加多个整体；组成聚集：整体拥有各个部分，整体与部分共存，如果整体不存在了，那么部分也就不存在了。\n\n\n\n***采用UML方法来描述例4-4中Line类和Point类的关系***\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片8.png)\n\n**继承关系—泛化**\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片7.png)\n\n\n\n***带有注释的Line类和Point类关系的描述***\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片3.png)\n\n\n\n\n\n**注释**\n\n在UML图形上，注释表示为带有褶角的矩形，然后用虚线连接到UML的其他元素上，它是一种用于在图中附加文字注释的机制。\n\n## 5.结构体和联合体\n\n### ①结构体\n\n**结构体是一种特殊形态的类**\n\n- 与类的唯一区别：类的缺省访问权限是private，结构体的缺省访问权限是public\n\n- 结构体存在的主要原因：与C语言保持兼容\n\n**什么时候用结构体而不用类**\n\n- 定义主要用来保存数据、而没有什么操作的类型\n\n- 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便\n\n\n\n**结构体的定义和初始化**\n\n```c++\n//结构体定义\nstruct 结构体名称 {\n\t 公有成员\nprotected:\n    保护型成员\nprivate:\n     私有成员\n};\n\n\n//一些结构体变量的初始化可以用以下形式\n类型名 变量名 = { 成员数据1初值, 成员数据2初值, …… };\n\n```\n\n\n\n```c++\n//1.用结构体表示学生的基本信息\n\n#include <iostream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nstruct Student {\t//学生信息结构体\n\tint num;\t\t//学号\n\tstring name;\t//姓名，字符串对象，将在第6章详细介绍\n\tchar sex;\t\t//性别\n\tint age;\t\t//年龄\n};\n\nint main() {\n\tStudent stu = { 97001, \"Lin Lin\", 'F', 19 };\n\tcout << \"Num:  \" << stu.num << endl;\n\tcout << \"Name: \" << stu.name << endl;\n\tcout << \"Sex:  \" << stu.sex << endl;\n\tcout << \"Age:  \" << stu.age << endl;\n\treturn 0;\n}\n\n//运行结果：\nNum:  97001\nName: Lin Lin\nSex:  F\nAge:  19\n\n```\n\n\n\n\n\n### ②联合体\n\n\n\n```c++\n//声明形式\nunion 联合体名称 {\n    公有成员\nprotected:\n    保护型成员\nprivate:\n    私有成员\n};\n```\n\n\n\n**特点：**\n\n- 成员共用相同的内存单元\n\n- 任何两个成员不会同时有效\n\n\n\n**联合体的内存分配**\n\n\n\n```c++\nunion Mark {\t//表示成绩的联合体\n\tchar grade;\t//等级制的成绩\n\tbool pass;\t//只记是否通过课程的成绩\n\tint percent;\t//百分制的成绩\n};\n\n```\n\n\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片2.png)\n\n\n\n\n\n**无名联合**\n\n无名联合没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问。\n\n```c++\n例：\nunion {\n  int i;\n  float f;\n}\n//在程序中可以这样使用：\ni = 10;\nf = 2.2;\n```\n\n\n\n```c++\n//example.使用联合体保存成绩信息，并且输出。\n\n#include <string>\n#include <iostream>\nusing namespace std;\nclass ExamInfo {\nprivate:\n\tstring name;\t//课程名称\n\tenum { GRADE, PASS, PERCENTAGE } mode;//采用何种计分方式\n\tunion {\n\t\tchar grade;\t//等级制的成绩\n\t\tbool pass;\t//只记是否通过课程的成绩\n\t\tint percent;\t//百分制的成绩\n\t};\n\npublic:\n\t//三种构造函数，分别用等级、是否通过和百分初始化\n\tExamInfo(string name, char grade)\n\t\t: name(name), mode(GRADE), grade(grade) { }\n\tExamInfo(string name, bool pass)\n\t\t: name(name), mode(PASS), pass(pass) { }\n\tExamInfo(string name, int percent)\n\t\t: name(name), mode(PERCENTAGE), percent(percent) { }\n\tvoid show();\n}\n\nvoid ExamInfo::show() {\n\tcout << name << \": \";\n\tswitch (mode) {\n\t  case GRADE: cout << grade;  break;\n\t  case PASS: cout << (pass ? \"PASS\" : \"FAIL\"); break;\n\t  case PERCENTAGE: cout << percent; break;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tExamInfo course1(\"English\", 'B');\n\tExamInfo course2(\"Calculus\", true);\n\tExamInfo course3(\"C++ Programming\", 85);\n\tcourse1.show();\n\tcourse2.show();\n\tcourse3.show();\n\treturn 0;\n}\n\n//运行结果：\nEnglish: B\nCalculus: PASS\nC++ Programming: 85\n```\n\n\n\n\n\n------\n\n\n\n\n\n","slug":"C-学习笔记整理-第四章《类与对象》","published":true,"updated":"2021-05-18T07:56:39.107Z","_id":"clq6dy48c000fikw0d22mmt5l","comments":true,"layout":"post","photos":[],"link":"","html":"<h1 id=\"第四章-类和对象\"><a href=\"#第四章-类和对象\" class=\"headerlink\" title=\"第四章 类和对象\"></a>第四章 类和对象</h1><h2 id=\"1-面向对象程序设计的基本特点\"><a href=\"#1-面向对象程序设计的基本特点\" class=\"headerlink\" title=\"1.面向对象程序设计的基本特点\"></a>1.面向对象程序设计的基本特点</h2><h3 id=\"①抽象\"><a href=\"#①抽象\" class=\"headerlink\" title=\"①抽象\"></a>①抽象</h3><p><strong>抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。</strong></p>\n<ul>\n<li><p>先注意问题的本质及描述，其次是实现过程或细节。</p>\n</li>\n<li><p>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</p>\n</li>\n<li><p>代码抽象：描述某类对象的共有的行为特征或具有的功能。</p>\n</li>\n<li><p>抽象的实现：通过类的声明。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//数据抽象：\nint hour,int minute,int second\n//代码抽象：\nsetTime(),showTime()\n\nclass  Clock {\n  public: \n   void setTime(int newH, int newM, int newS);\u000b   void showTime();\n  private: \n   int hour, minute, second;\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"②封装\"><a href=\"#②封装\" class=\"headerlink\" title=\"②封装\"></a>②封装</h3><p><strong>将抽象出的数据成员、代码成员相结合，将它们视为一个整体。</strong></p>\n<ul>\n<li><p>目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</p>\n</li>\n<li><p>实现封装：类声明中的{}</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//实例：\n\nclass  Clock {\n  public://公有的访问权限\n      void setTime(int newH, int newM, int newS);//外部接口\n      void showTime();//外部接口\n  private: //私有的访问权限\n      int hour, minute, second;\n};//边界\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"③继承\"><a href=\"#③继承\" class=\"headerlink\" title=\"③继承\"></a>③继承</h3><p><strong>是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。</strong></p>\n<ul>\n<li>实现：声明派生类</li>\n</ul>\n<h3 id=\"④多态\"><a href=\"#④多态\" class=\"headerlink\" title=\"④多态\"></a>④多态</h3><p><strong>多态：同一名称，不同的功能实现方式。</strong></p>\n<ul>\n<li><p>目的：达到行为标识统一，减少程序中标识符的个数。</p>\n</li>\n<li><p>实现：重载函数和虚函数</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-类和对象\"><a href=\"#2-类和对象\" class=\"headerlink\" title=\"2.类和对象\"></a>2.类和对象</h2><h3 id=\"①类和对象\"><a href=\"#①类和对象\" class=\"headerlink\" title=\"①类和对象\"></a>①类和对象</h3><p><strong>类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。</strong></p>\n<ul>\n<li><p>利用类可以实现数据的封装、隐藏、继承与派生。</p>\n</li>\n<li><p>利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。</p>\n</li>\n<li><p>定义一个新的class也就定义了一个新的类型</p>\n</li>\n</ul>\n<h3 id=\"②类的定义\"><a href=\"#②类的定义\" class=\"headerlink\" title=\"②类的定义\"></a>②类的定义</h3><p>类是一种用户自定义类型，声明形式：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class 类名称\n{\n   public:\n             公有成员（外部接口）\n   private:\n             私有成员\n   protected:\n             保护型成员\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p><strong>在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</strong></p>\n</li>\n<li><p><strong>在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。</strong><br><strong>如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。</strong></p>\n</li>\n<li><p><strong>protected保护型成员与private类似，其差别表现在继承与派生时对派生类的影响不同</strong></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"③对象\"><a href=\"#③对象\" class=\"headerlink\" title=\"③对象\"></a>③对象</h3><p><strong>类的对象是该类的某一特定实体，即类类型的变量。</strong><br>声明形式：</p>\n<pre class=\"line-numbers language-c++c\"><code class=\"language-c++c\">类名  对象名；\n例：Clock  myClock;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li><p>类中成员互访：直接使用成员名</p>\n</li>\n<li><p>类外访问：使用“对象名.成员名”方式访问 public 属性的成员</p>\n</li>\n</ul>\n<h3 id=\"④类的成员函数\"><a href=\"#④类的成员函数\" class=\"headerlink\" title=\"④类的成员函数\"></a>④类的成员函数</h3><ul>\n<li><p>在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。</p>\n</li>\n<li><p>允许声明重载函数和带默认形参值的函数</p>\n</li>\n</ul>\n<h3 id=\"⑤内联成员函数\"><a href=\"#⑤内联成员函数\" class=\"headerlink\" title=\"⑤内联成员函数\"></a>⑤内联成员函数</h3><ul>\n<li><p><strong>为了提高运行时的效率，对于较简单的函数可以声明为内联形式。</strong></p>\n</li>\n<li><p>内联函数体中不要有复杂结构（如循环语句和switch语句）。</p>\n</li>\n</ul>\n<p>  在类中声明内联成员函数的方式：</p>\n<ul>\n<li>将函数体放在类的声明中。</li>\n<li>使用inline关键字。</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//example.1类的实现\n#include<iostream>\nusing namespace std;\nclass Clock{\npublic:        \n    void setTime(int newH = 0, int newM = 0, int newS = 0);\n    void showTime();\nprivate:    \n    int hour, minute, second;\n};\nint main()\n{\n    Clock myClock;\n    myClock.setTime(8, 30, 30);\n    myClock.showTime();\n    return 0;\n}\n\nvoid Clock::setTime(int newH, int newM,int newS)\n{\n   hour=newH;\n   minute=newM;\n   second=newS;\n}\nvoid Clock::showTime() \n{\n   cout << hour << \":\" << minute << \":\" << second;\n}\n\n\n//运行结果：\n8:30:30\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//Point类的完整程序\n\nclass Point {   //Point 类的定义\npublic:\n    Point(int xx=0, int yy=0) { x = xx; y = yy; }    //构造函数，内联\n    Point(const Point& p); //复制构造函数\n    void setX(int xx) {x=xx;}\n    void setY(int yy) {y=yy;}\n    int getX() const { return x; } //常函数（第5章）\n    int getY() const { return y; } //常函数（第5章）\nprivate:\n    int x, y; //私有数据\n};\n//成员函数的实现\nPoint::Point (const Point& p) {\n  x = p.x;\n  y = p.y;\n  cout << \"Calling the copy constructor \" << endl;\n}\n\n//形参为Point类对象的函数\nvoid fun1(Point p) {\n    cout << p.getX() << endl;\n}\n//返回值为Point类对象的函数\nPoint fun2() {\n    Point a(1, 2);\n    return a;\n}\n\n//主程序\nint main() {\n    Point a(4, 5);    //第一个对象A\n    Point b = a;    //情况一，用A初始化B。第一次调用复制构造函数\n    cout << b.getX() << endl;\n    fun1(b);    //情况二，对象B作为fun1的实参。第二次调用复制构造函数\n    b = fun2();    //情况三，函数的返回值是类对象，函数返回时调用复制构造函数\n    cout << b.getX() << endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-构造函数和析构函数\"><a href=\"#3-构造函数和析构函数\" class=\"headerlink\" title=\"3.构造函数和析构函数\"></a>3.构造函数和析构函数</h2><h3 id=\"①构造函数\"><a href=\"#①构造函数\" class=\"headerlink\" title=\"①构造函数\"></a>①构造函数</h3><ul>\n<li><p>类中的特殊函数</p>\n</li>\n<li><p>用于描述初始化算法</p>\n</li>\n<li><p>构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。</p>\n</li>\n<li><p>在对象创建时被自动调用</p>\n</li>\n<li><p>如果程序中未声明，则系统自动产生出一个默认的构造函数，其参数列表为空</p>\n</li>\n<li><p>构造函数可以是内联函数、重载函数、带默认参数值的函数</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//构造函数举例\nclass Clock {\npublic:\n    Clock(int newH,int newM,int newS);//构造函数\n    void setTime(int newH, int newM, int newS);\n    void showTime();\nprivate:\n    int hour, minute, second;\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//构造函数的实现：\nClock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) {\n    }\n建立对象时构造函数的作用：\nint main() {\n  Clock c(0,0,0); //此处将自动调用构造函数\n  c.showTime();\n    return 0;\n}\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"②复制构造函数\"><a href=\"#②复制构造函数\" class=\"headerlink\" title=\"②复制构造函数\"></a>②复制构造函数</h3><p><strong>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class 类名 {\npublic :\n    类名（形参）；//构造函数\n    类名（const  类名 &对象名）；//复制构造函数\n           ...\n}；\n类名::类（ const  类名 &对象名）//复制构造函数的实现\n{    函数体    }\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>复制构造函数被调用的三种情况</strong></p>\n<ul>\n<li><p>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</p>\n</li>\n<li><p>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</p>\n</li>\n<li><p>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。</p>\n</li>\n</ul>\n<p><strong>有时不应该进行复制和赋值</strong></p>\n<ul>\n<li>例如，房屋中介系统有一个类描述待售房屋</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class HomeForSale{…}\n//通常没有完全一样的房屋，因此不应有复制构造<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//解决方法一：将不应该有的默认函数定义为私有\n\nclass HomeForSale{\npublic:\n    …\nprivate:\n    …\n    HomeForSale(const HomeForSale&);\n    HomeForSale& operator=(const HomeForSale&)\n\n//解决方法二：定义一个Uncopyable类作为基类\n\nclass Uncopyable{\nprotected:\n    Uncopyable(){}\n    ~ Uncopyable(){}\nprivate:\n     Uncopyable(const Uncopyable&);\n     Uncopyable operator=(const Uncopyable&);\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"③默认构造函数\"><a href=\"#③默认构造函数\" class=\"headerlink\" title=\"③默认构造函数\"></a>③默认构造函数</h3><p><strong>调用时可以不需要参数的构造函数都是默认构造函数。</strong></p>\n<ul>\n<li><p>当不定义构造函数时，编译器自动产生默认构造函数</p>\n</li>\n<li><p>在类中可以自定义无参数的构造函数，也是默认构造函数</p>\n</li>\n<li><p>全部参数都有默认形参值的构造函数也是默认构造函数</p>\n</li>\n</ul>\n<p><strong>下面两个都是默认构造函数，如果在类中同时出现，将产生编译错误：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Clock();\nClock(int newH=0,int newM=0,int newS=0);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//example.1\nclass Clock {\npublic:\n    Clock(int newH,int newM,int newS);//构造函数\n    Clock();//默认构造函数\n    void setTime(int newH, int newM, int newS);\n    void showTime();\nprivate:\n    int hour, minute, second;\n};\n//构造函数的实现：\nClock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) { }\n//默认构造函数的实现：\nClock::Clock(): hour(0), minute(0), second(0) { }\n\n//建立对象时构造函数的作用：\nint main() {\n  Clock c(8,10,0); //调用有参构造函数\n  Clock c2();//调用无参构造函数\n  c.showTime();\n  c2.showTime();\n    return 0;\n}\n\nvoid Clock::setTime(int newH, int newM,int newS)\n{\n   hour = newH;\n   minute = newM;\n   second = newS;\n}\nvoid Clock::showTime() \n{\n   cout << hour << \":\" << minute << \":\" << second;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>有时不应该有默认的构造函数</strong></p>\n<ul>\n<li><p>有些类，不应该有默认初始化。<br>例如，没有姓名的学生对象是没有意义的<br>解决：<br>至少定义一个有参数的构造函数<br>不定义默认构造函数</p>\n</li>\n<li><p>需要深层复制时，默认的复制构造会引起错误。<br>解决：<br>自定义实现深层复制的复制构造函数</p>\n</li>\n</ul>\n<h3 id=\"④隐含的复制构造函数\"><a href=\"#④隐含的复制构造函数\" class=\"headerlink\" title=\"④隐含的复制构造函数\"></a>④隐含的复制构造函数</h3><p>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。</p>\n<p>这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</p>\n<h3 id=\"⑤函数参数尽量传递常引用而不是值\"><a href=\"#⑤函数参数尽量传递常引用而不是值\" class=\"headerlink\" title=\"⑤函数参数尽量传递常引用而不是值\"></a>⑤函数参数尽量传递常引用而不是值</h3><ul>\n<li>传递对象值会引起复制构造和析构，增加时间空间开销。</li>\n<li>传常引用可避免这一问题。以引用做参数时，尽量使用常引用。</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//例如：\nvoid fun1(const Point &p) {\n    cout << p.getX() << endl;\n   p.setX(1); //语法错误：p是常引用而setX不是常函数\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>基本类型、STL的迭代器和函数对象传值较好。</p>\n<h3 id=\"⑥返回值优化\"><a href=\"#⑥返回值优化\" class=\"headerlink\" title=\"⑥返回值优化\"></a>⑥返回值优化</h3><ul>\n<li><p>当函数返回一个对象时，会构造临时对象用以返回，这会增加开销。</p>\n</li>\n<li><p>用返回引用或者指针替代不是好办法。返回指向局部对象的指针或者引用，会引发错误。返回指向动态内存的指针或引用容易忘记动态空间释放，引起内存泄露。</p>\n</li>\n<li><p>解决显式构造临时对象返回。此举表面上还是构造了一个临时对象，但是编译器通常都会进行优化，使之不产生临时对象。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//例如：\nPoint fun2() {\n    return Point(1, 2);\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"⑦析构函数\"><a href=\"#⑦析构函数\" class=\"headerlink\" title=\"⑦析构函数\"></a>⑦析构函数</h3><ul>\n<li><p>完成对象被删除前的一些清理工作。</p>\n</li>\n<li><p>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。</p>\n</li>\n<li><p>如果程序中未声明析构函数，编译器将自动产生一个隐含的析构函数。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//构造函数和析构函数举例\n\n#include <iostream>\nusing namespace std;\nclass Point {     \npublic:\n  Point(int xx,int yy);\n  ~Point();\n  //...其他函数原型\nprivate:\n  int x, y;\n};\n\nPoint::Point(int xx,int yy) {\n  x = xx;\n  y = yy;\n}\nPoint::~Point() {\n}\n//...其他函数的实现略<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"3-类的组合\"><a href=\"#3-类的组合\" class=\"headerlink\" title=\"3.类的组合\"></a>3.类的组合</h2><h3 id=\"①组合\"><a href=\"#①组合\" class=\"headerlink\" title=\"①组合\"></a>①组合</h3><ul>\n<li><p>类中的成员数据是另一个类的对象。</p>\n</li>\n<li><p>可以在已有抽象的基础上实现更复杂的抽象。</p>\n</li>\n</ul>\n<p><strong>类组合的构造函数设计</strong></p>\n<ul>\n<li>原则：不仅要负责对本类中的基本类型成员数据赋初值，也要对对象成员初始化。</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//声明形式：\n类名::类名(对象成员所需的形参，本类成员形参)\n       :对象1(参数)，对象2(参数)，......\n{  \n//函数体其他语句\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>构造组合类对象时的初始化次序</strong></p>\n<ul>\n<li><p>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。</p>\n</li>\n<li><p>成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。</p>\n</li>\n<li><p>初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化</p>\n</li>\n<li><p>处理完初始化列表之后，再执行构造函数的函数体</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//类的组合，线段（Line）类\n\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Point {    //Point类定义\npublic:\n    Point(int xx = 0, int yy = 0) {\n        x = xx;\n        y = yy;\n    }\n    Point(Point &p);\n    int getX() { return x; }\n    int getY() { return y; }\nprivate:\n    int x, y;\n};\nPoint::Point(Point &p) {    //复制构造函数的实现\n    x = p.x;\n    y = p.y;\n    cout << \"Calling the copy constructor of Point\" << endl;\n}\n\npublic:    //外部接口\n    Line(Point xp1, Point xp2);\n    Line(Line &l);\n    double getLen() { return len; }\nprivate:    //私有数据成员\n    Point p1, p2;    //Point类的对象p1,p2\n    double len;\n};\n//组合类的构造函数\nLine::Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) {\n    cout << \"Calling constructor of Line\" << endl;\n    double x = static_cast<double>(p1.getX() - p2.getX());\n    double y = static_cast<double>(p1.getY() - p2.getY());\n    len = sqrt(x * x + y * y);\n}\nLine::Line (Line &l): p1(l.p1), p2(l.p2) {//组合类的复制构造函数\n    cout << \"Calling the copy constructor of Line\" << endl;\n    len = l.len;\n}\n\n//主函数\nint main() {\n    Point myp1(1, 1), myp2(4, 5);    //建立Point类的对象\n    Line line(myp1, myp2);    //建立Line类的对象\n    Line line2(line);    //利用复制构造函数建立一个新对象\n    cout << \"The length of the line is: \";\n    cout << line.getLen() << endl;\n    cout << \"The length of the line2 is: \";\n    cout << line2.getLen() << endl;\n    return 0;\n}\n\n\n//运行结果如下：\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling constructor of Line\nCalling the copy constructor of Point\nCalling the copy constructor of Point\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>前向引用声明</strong></p>\n<ul>\n<li><p>类应该先声明，后使用</p>\n</li>\n<li><p>如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。</p>\n</li>\n<li><p>前向引用声明只为程序引入一个标识符，但具体声明在其他地方。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//example\n\nclass B;  //前向引用声明\nclass A {\npublic:\n  void f(B b);\n};\nclass B {\npublic:\n  void g(A a);\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>前向引用声明注意事项</strong></p>\n<p>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Fred; //前向引用声明\nclass Barney {\n   Fred x; //错误：类Fred的声明尚不完善\n};\nclass Fred {\n   Barney y;\n};\n\n//更正\nclass Fred;    //前向引用声明\nclass Barney {\npublic:\n  ……\n  void method() {\n    x.yabbaDabbaDo();    //错误：Fred类的对象在定义之前被使用\n  }\n private:\n  Fred &x;//正确，经过前向引用声明，可以声明Fred类的对象引用\n};\n\nclass Fred {\npublic:\n  void yabbaDabbaDo();\nprivate:\n  Barney &y;\n}; \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>前向引用声明注意事项</strong></p>\n<ul>\n<li>应该记住：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</li>\n</ul>\n<hr>\n<h2 id=\"4-UML图形标识\"><a href=\"#4-UML图形标识\" class=\"headerlink\" title=\"4.UML图形标识\"></a>4.UML图形标识</h2><h3 id=\"①UML简介\"><a href=\"#①UML简介\" class=\"headerlink\" title=\"①UML简介\"></a>①UML简介</h3><p><strong>UML（Unified Modeling Language）语言是一种可视化的的面向对象建模语言。</strong></p>\n<p><strong>UML有三个基本的部分</strong></p>\n<ul>\n<li><p>事物（Things）\u000bUML中重要的组成部分，在模型中属于最静态的部分，代表概念上的或物理上的元素</p>\n</li>\n<li><p>关系（Relationships）\u000b关系把事物紧密联系在一起</p>\n</li>\n<li><p>图（Diagrams）\u000b图是很多有相互相关的事物的组</p>\n</li>\n</ul>\n<h3 id=\"②UML类图\"><a href=\"#②UML类图\" class=\"headerlink\" title=\"②UML类图\"></a>②UML类图</h3><p><strong>举例：Clock类的完整表示:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Clock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>- hour:  int</td>\n</tr>\n<tr>\n<td>- minute:  int</td>\n</tr>\n<tr>\n<td>- second:  int</td>\n</tr>\n<tr>\n<td>+ showTime(): void</td>\n</tr>\n<tr>\n<td>+ setTime(newH:int=0,newM:int=0,newS:int=0)</td>\n</tr>\n</tbody></table>\n<p><strong>Clock类的简洁表示</strong></p>\n<table>\n<thead>\n<tr>\n<th>Clock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"③对象图\"><a href=\"#③对象图\" class=\"headerlink\" title=\"③对象图\"></a>③对象图</h3><table>\n<thead>\n<tr>\n<th align=\"center\">myClock:Clock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">- hour: int</td>\n</tr>\n<tr>\n<td align=\"center\">- minute: int</td>\n</tr>\n<tr>\n<td align=\"center\">- second: int</td>\n</tr>\n</tbody></table>\n<h3 id=\"④几种关系的图形标识\"><a href=\"#④几种关系的图形标识\" class=\"headerlink\" title=\"④几种关系的图形标识\"></a>④几种关系的图形标识</h3><p><strong>依赖关系</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%875.png\" alt></p>\n<p>图中的“类A”是源，“类B”是目标，表示“类A”使用了“类B”，或称“类A”依赖“类B”</p>\n<p><strong>作用关系—关联</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%874.png\" alt></p>\n<p>图中的“重数A”决定了类B的每个对象与类A的多少个对象发生作用，同样“重数B”决定了类A的每个对象与类B的多少个对象发生作用。</p>\n<p><strong>包含关系—聚集和组合</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%876.png\" alt></p>\n<p>聚集表示类之间的关系是整体与部分的关系，“包含”、“组成”、“分为……部分”等都是聚集关系。共享聚集：部分可以参加多个整体；组成聚集：整体拥有各个部分，整体与部分共存，如果整体不存在了，那么部分也就不存在了。</p>\n<p><strong><em>采用UML方法来描述例4-4中Line类和Point类的关系</em></strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%878.png\" alt></p>\n<p><strong>继承关系—泛化</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%877.png\" alt></p>\n<p><strong><em>带有注释的Line类和Point类关系的描述</em></strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%873.png\" alt></p>\n<p><strong>注释</strong></p>\n<p>在UML图形上，注释表示为带有褶角的矩形，然后用虚线连接到UML的其他元素上，它是一种用于在图中附加文字注释的机制。</p>\n<h2 id=\"5-结构体和联合体\"><a href=\"#5-结构体和联合体\" class=\"headerlink\" title=\"5.结构体和联合体\"></a>5.结构体和联合体</h2><h3 id=\"①结构体\"><a href=\"#①结构体\" class=\"headerlink\" title=\"①结构体\"></a>①结构体</h3><p><strong>结构体是一种特殊形态的类</strong></p>\n<ul>\n<li><p>与类的唯一区别：类的缺省访问权限是private，结构体的缺省访问权限是public</p>\n</li>\n<li><p>结构体存在的主要原因：与C语言保持兼容</p>\n</li>\n</ul>\n<p><strong>什么时候用结构体而不用类</strong></p>\n<ul>\n<li><p>定义主要用来保存数据、而没有什么操作的类型</p>\n</li>\n<li><p>人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便</p>\n</li>\n</ul>\n<p><strong>结构体的定义和初始化</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//结构体定义\nstruct 结构体名称 {\n     公有成员\nprotected:\n    保护型成员\nprivate:\n     私有成员\n};\n\n\n//一些结构体变量的初始化可以用以下形式\n类型名 变量名 = { 成员数据1初值, 成员数据2初值, …… };\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//1.用结构体表示学生的基本信息\n\n#include <iostream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nstruct Student {    //学生信息结构体\n    int num;        //学号\n    string name;    //姓名，字符串对象，将在第6章详细介绍\n    char sex;        //性别\n    int age;        //年龄\n};\n\nint main() {\n    Student stu = { 97001, \"Lin Lin\", 'F', 19 };\n    cout << \"Num:  \" << stu.num << endl;\n    cout << \"Name: \" << stu.name << endl;\n    cout << \"Sex:  \" << stu.sex << endl;\n    cout << \"Age:  \" << stu.age << endl;\n    return 0;\n}\n\n//运行结果：\nNum:  97001\nName: Lin Lin\nSex:  F\nAge:  19\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"②联合体\"><a href=\"#②联合体\" class=\"headerlink\" title=\"②联合体\"></a>②联合体</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//声明形式\nunion 联合体名称 {\n    公有成员\nprotected:\n    保护型成员\nprivate:\n    私有成员\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>特点：</strong></p>\n<ul>\n<li><p>成员共用相同的内存单元</p>\n</li>\n<li><p>任何两个成员不会同时有效</p>\n</li>\n</ul>\n<p><strong>联合体的内存分配</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">union Mark {    //表示成绩的联合体\n    char grade;    //等级制的成绩\n    bool pass;    //只记是否通过课程的成绩\n    int percent;    //百分制的成绩\n};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%872.png\" alt></p>\n<p><strong>无名联合</strong></p>\n<p>无名联合没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">例：\nunion {\n  int i;\n  float f;\n}\n//在程序中可以这样使用：\ni = 10;\nf = 2.2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//example.使用联合体保存成绩信息，并且输出。\n\n#include <string>\n#include <iostream>\nusing namespace std;\nclass ExamInfo {\nprivate:\n    string name;    //课程名称\n    enum { GRADE, PASS, PERCENTAGE } mode;//采用何种计分方式\n    union {\n        char grade;    //等级制的成绩\n        bool pass;    //只记是否通过课程的成绩\n        int percent;    //百分制的成绩\n    };\n\npublic:\n    //三种构造函数，分别用等级、是否通过和百分初始化\n    ExamInfo(string name, char grade)\n        : name(name), mode(GRADE), grade(grade) { }\n    ExamInfo(string name, bool pass)\n        : name(name), mode(PASS), pass(pass) { }\n    ExamInfo(string name, int percent)\n        : name(name), mode(PERCENTAGE), percent(percent) { }\n    void show();\n}\n\nvoid ExamInfo::show() {\n    cout << name << \": \";\n    switch (mode) {\n      case GRADE: cout << grade;  break;\n      case PASS: cout << (pass ? \"PASS\" : \"FAIL\"); break;\n      case PERCENTAGE: cout << percent; break;\n    }\n    cout << endl;\n}\n\nint main() {\n    ExamInfo course1(\"English\", 'B');\n    ExamInfo course2(\"Calculus\", true);\n    ExamInfo course3(\"C++ Programming\", 85);\n    course1.show();\n    course2.show();\n    course3.show();\n    return 0;\n}\n\n//运行结果：\nEnglish: B\nCalculus: PASS\nC++ Programming: 85<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n","excerpt":"","more":"<h1 id=\"第四章-类和对象\"><a href=\"#第四章-类和对象\" class=\"headerlink\" title=\"第四章 类和对象\"></a>第四章 类和对象</h1><h2 id=\"1-面向对象程序设计的基本特点\"><a href=\"#1-面向对象程序设计的基本特点\" class=\"headerlink\" title=\"1.面向对象程序设计的基本特点\"></a>1.面向对象程序设计的基本特点</h2><h3 id=\"①抽象\"><a href=\"#①抽象\" class=\"headerlink\" title=\"①抽象\"></a>①抽象</h3><p><strong>抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。</strong></p>\n<ul>\n<li><p>先注意问题的本质及描述，其次是实现过程或细节。</p>\n</li>\n<li><p>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</p>\n</li>\n<li><p>代码抽象：描述某类对象的共有的行为特征或具有的功能。</p>\n</li>\n<li><p>抽象的实现：通过类的声明。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//数据抽象：\nint hour,int minute,int second\n//代码抽象：\nsetTime(),showTime()\n\nclass  Clock {\n  public: \n   void setTime(int newH, int newM, int newS);\u000b   void showTime();\n  private: \n   int hour, minute, second;\n};\n</code></pre>\n<h3 id=\"②封装\"><a href=\"#②封装\" class=\"headerlink\" title=\"②封装\"></a>②封装</h3><p><strong>将抽象出的数据成员、代码成员相结合，将它们视为一个整体。</strong></p>\n<ul>\n<li><p>目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</p>\n</li>\n<li><p>实现封装：类声明中的{}</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//实例：\n\nclass  Clock {\n  public://公有的访问权限\n      void setTime(int newH, int newM, int newS);//外部接口\n      void showTime();//外部接口\n  private: //私有的访问权限\n      int hour, minute, second;\n};//边界\n</code></pre>\n<h3 id=\"③继承\"><a href=\"#③继承\" class=\"headerlink\" title=\"③继承\"></a>③继承</h3><p><strong>是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。</strong></p>\n<ul>\n<li>实现：声明派生类</li>\n</ul>\n<h3 id=\"④多态\"><a href=\"#④多态\" class=\"headerlink\" title=\"④多态\"></a>④多态</h3><p><strong>多态：同一名称，不同的功能实现方式。</strong></p>\n<ul>\n<li><p>目的：达到行为标识统一，减少程序中标识符的个数。</p>\n</li>\n<li><p>实现：重载函数和虚函数</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-类和对象\"><a href=\"#2-类和对象\" class=\"headerlink\" title=\"2.类和对象\"></a>2.类和对象</h2><h3 id=\"①类和对象\"><a href=\"#①类和对象\" class=\"headerlink\" title=\"①类和对象\"></a>①类和对象</h3><p><strong>类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。</strong></p>\n<ul>\n<li><p>利用类可以实现数据的封装、隐藏、继承与派生。</p>\n</li>\n<li><p>利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。</p>\n</li>\n<li><p>定义一个新的class也就定义了一个新的类型</p>\n</li>\n</ul>\n<h3 id=\"②类的定义\"><a href=\"#②类的定义\" class=\"headerlink\" title=\"②类的定义\"></a>②类的定义</h3><p>类是一种用户自定义类型，声明形式：</p>\n<pre><code class=\"c++\">class 类名称\n{\n   public:\n             公有成员（外部接口）\n   private:\n             私有成员\n   protected:\n             保护型成员\n};</code></pre>\n<ul>\n<li><p><strong>在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</strong></p>\n</li>\n<li><p><strong>在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。</strong><br><strong>如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。</strong></p>\n</li>\n<li><p><strong>protected保护型成员与private类似，其差别表现在继承与派生时对派生类的影响不同</strong></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"③对象\"><a href=\"#③对象\" class=\"headerlink\" title=\"③对象\"></a>③对象</h3><p><strong>类的对象是该类的某一特定实体，即类类型的变量。</strong><br>声明形式：</p>\n<pre><code class=\"c++c\">类名  对象名；\n例：Clock  myClock;</code></pre>\n<ul>\n<li><p>类中成员互访：直接使用成员名</p>\n</li>\n<li><p>类外访问：使用“对象名.成员名”方式访问 public 属性的成员</p>\n</li>\n</ul>\n<h3 id=\"④类的成员函数\"><a href=\"#④类的成员函数\" class=\"headerlink\" title=\"④类的成员函数\"></a>④类的成员函数</h3><ul>\n<li><p>在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。</p>\n</li>\n<li><p>允许声明重载函数和带默认形参值的函数</p>\n</li>\n</ul>\n<h3 id=\"⑤内联成员函数\"><a href=\"#⑤内联成员函数\" class=\"headerlink\" title=\"⑤内联成员函数\"></a>⑤内联成员函数</h3><ul>\n<li><p><strong>为了提高运行时的效率，对于较简单的函数可以声明为内联形式。</strong></p>\n</li>\n<li><p>内联函数体中不要有复杂结构（如循环语句和switch语句）。</p>\n</li>\n</ul>\n<p>  在类中声明内联成员函数的方式：</p>\n<ul>\n<li>将函数体放在类的声明中。</li>\n<li>使用inline关键字。</li>\n</ul>\n<pre><code class=\"c++\">//example.1类的实现\n#include&lt;iostream&gt;\nusing namespace std;\nclass Clock{\npublic:        \n    void setTime(int newH = 0, int newM = 0, int newS = 0);\n    void showTime();\nprivate:    \n    int hour, minute, second;\n};\nint main()\n{\n    Clock myClock;\n    myClock.setTime(8, 30, 30);\n    myClock.showTime();\n    return 0;\n}\n\nvoid Clock::setTime(int newH, int newM,int newS)\n{\n   hour=newH;\n   minute=newM;\n   second=newS;\n}\nvoid Clock::showTime() \n{\n   cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second;\n}\n\n\n//运行结果：\n8:30:30\n</code></pre>\n<pre><code class=\"c++\">//Point类的完整程序\n\nclass Point {   //Point 类的定义\npublic:\n    Point(int xx=0, int yy=0) { x = xx; y = yy; }    //构造函数，内联\n    Point(const Point&amp; p); //复制构造函数\n    void setX(int xx) {x=xx;}\n    void setY(int yy) {y=yy;}\n    int getX() const { return x; } //常函数（第5章）\n    int getY() const { return y; } //常函数（第5章）\nprivate:\n    int x, y; //私有数据\n};\n//成员函数的实现\nPoint::Point (const Point&amp; p) {\n  x = p.x;\n  y = p.y;\n  cout &lt;&lt; &quot;Calling the copy constructor &quot; &lt;&lt; endl;\n}\n\n//形参为Point类对象的函数\nvoid fun1(Point p) {\n    cout &lt;&lt; p.getX() &lt;&lt; endl;\n}\n//返回值为Point类对象的函数\nPoint fun2() {\n    Point a(1, 2);\n    return a;\n}\n\n//主程序\nint main() {\n    Point a(4, 5);    //第一个对象A\n    Point b = a;    //情况一，用A初始化B。第一次调用复制构造函数\n    cout &lt;&lt; b.getX() &lt;&lt; endl;\n    fun1(b);    //情况二，对象B作为fun1的实参。第二次调用复制构造函数\n    b = fun2();    //情况三，函数的返回值是类对象，函数返回时调用复制构造函数\n    cout &lt;&lt; b.getX() &lt;&lt; endl;\n    return 0;\n}</code></pre>\n<h2 id=\"3-构造函数和析构函数\"><a href=\"#3-构造函数和析构函数\" class=\"headerlink\" title=\"3.构造函数和析构函数\"></a>3.构造函数和析构函数</h2><h3 id=\"①构造函数\"><a href=\"#①构造函数\" class=\"headerlink\" title=\"①构造函数\"></a>①构造函数</h3><ul>\n<li><p>类中的特殊函数</p>\n</li>\n<li><p>用于描述初始化算法</p>\n</li>\n<li><p>构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。</p>\n</li>\n<li><p>在对象创建时被自动调用</p>\n</li>\n<li><p>如果程序中未声明，则系统自动产生出一个默认的构造函数，其参数列表为空</p>\n</li>\n<li><p>构造函数可以是内联函数、重载函数、带默认参数值的函数</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//构造函数举例\nclass Clock {\npublic:\n    Clock(int newH,int newM,int newS);//构造函数\n    void setTime(int newH, int newM, int newS);\n    void showTime();\nprivate:\n    int hour, minute, second;\n};\n</code></pre>\n<pre><code class=\"c++\">//构造函数的实现：\nClock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) {\n    }\n建立对象时构造函数的作用：\nint main() {\n  Clock c(0,0,0); //此处将自动调用构造函数\n  c.showTime();\n    return 0;\n}\n\n</code></pre>\n<h3 id=\"②复制构造函数\"><a href=\"#②复制构造函数\" class=\"headerlink\" title=\"②复制构造函数\"></a>②复制构造函数</h3><p><strong>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</strong></p>\n<pre><code class=\"c++\">class 类名 {\npublic :\n    类名（形参）；//构造函数\n    类名（const  类名 &amp;对象名）；//复制构造函数\n           ...\n}；\n类名::类（ const  类名 &amp;对象名）//复制构造函数的实现\n{    函数体    }\n</code></pre>\n<p><strong>复制构造函数被调用的三种情况</strong></p>\n<ul>\n<li><p>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</p>\n</li>\n<li><p>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</p>\n</li>\n<li><p>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。</p>\n</li>\n</ul>\n<p><strong>有时不应该进行复制和赋值</strong></p>\n<ul>\n<li>例如，房屋中介系统有一个类描述待售房屋</li>\n</ul>\n<pre><code class=\"c++\">class HomeForSale{…}\n//通常没有完全一样的房屋，因此不应有复制构造</code></pre>\n<pre><code class=\"c++\">//解决方法一：将不应该有的默认函数定义为私有\n\nclass HomeForSale{\npublic:\n    …\nprivate:\n    …\n    HomeForSale(const HomeForSale&amp;);\n    HomeForSale&amp; operator=(const HomeForSale&amp;)\n\n//解决方法二：定义一个Uncopyable类作为基类\n\nclass Uncopyable{\nprotected:\n    Uncopyable(){}\n    ~ Uncopyable(){}\nprivate:\n     Uncopyable(const Uncopyable&amp;);\n     Uncopyable operator=(const Uncopyable&amp;);\n};\n</code></pre>\n<h3 id=\"③默认构造函数\"><a href=\"#③默认构造函数\" class=\"headerlink\" title=\"③默认构造函数\"></a>③默认构造函数</h3><p><strong>调用时可以不需要参数的构造函数都是默认构造函数。</strong></p>\n<ul>\n<li><p>当不定义构造函数时，编译器自动产生默认构造函数</p>\n</li>\n<li><p>在类中可以自定义无参数的构造函数，也是默认构造函数</p>\n</li>\n<li><p>全部参数都有默认形参值的构造函数也是默认构造函数</p>\n</li>\n</ul>\n<p><strong>下面两个都是默认构造函数，如果在类中同时出现，将产生编译错误：</strong></p>\n<pre><code class=\"c++\">Clock();\nClock(int newH=0,int newM=0,int newS=0);</code></pre>\n<pre><code class=\"c++\">//example.1\nclass Clock {\npublic:\n    Clock(int newH,int newM,int newS);//构造函数\n    Clock();//默认构造函数\n    void setTime(int newH, int newM, int newS);\n    void showTime();\nprivate:\n    int hour, minute, second;\n};\n//构造函数的实现：\nClock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) { }\n//默认构造函数的实现：\nClock::Clock(): hour(0), minute(0), second(0) { }\n\n//建立对象时构造函数的作用：\nint main() {\n  Clock c(8,10,0); //调用有参构造函数\n  Clock c2();//调用无参构造函数\n  c.showTime();\n  c2.showTime();\n    return 0;\n}\n\nvoid Clock::setTime(int newH, int newM,int newS)\n{\n   hour = newH;\n   minute = newM;\n   second = newS;\n}\nvoid Clock::showTime() \n{\n   cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second;\n}</code></pre>\n<p><strong>有时不应该有默认的构造函数</strong></p>\n<ul>\n<li><p>有些类，不应该有默认初始化。<br>例如，没有姓名的学生对象是没有意义的<br>解决：<br>至少定义一个有参数的构造函数<br>不定义默认构造函数</p>\n</li>\n<li><p>需要深层复制时，默认的复制构造会引起错误。<br>解决：<br>自定义实现深层复制的复制构造函数</p>\n</li>\n</ul>\n<h3 id=\"④隐含的复制构造函数\"><a href=\"#④隐含的复制构造函数\" class=\"headerlink\" title=\"④隐含的复制构造函数\"></a>④隐含的复制构造函数</h3><p>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。</p>\n<p>这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</p>\n<h3 id=\"⑤函数参数尽量传递常引用而不是值\"><a href=\"#⑤函数参数尽量传递常引用而不是值\" class=\"headerlink\" title=\"⑤函数参数尽量传递常引用而不是值\"></a>⑤函数参数尽量传递常引用而不是值</h3><ul>\n<li>传递对象值会引起复制构造和析构，增加时间空间开销。</li>\n<li>传常引用可避免这一问题。以引用做参数时，尽量使用常引用。</li>\n</ul>\n<pre><code class=\"c++\">//例如：\nvoid fun1(const Point &amp;p) {\n    cout &lt;&lt; p.getX() &lt;&lt; endl;\n   p.setX(1); //语法错误：p是常引用而setX不是常函数\n}</code></pre>\n<p>基本类型、STL的迭代器和函数对象传值较好。</p>\n<h3 id=\"⑥返回值优化\"><a href=\"#⑥返回值优化\" class=\"headerlink\" title=\"⑥返回值优化\"></a>⑥返回值优化</h3><ul>\n<li><p>当函数返回一个对象时，会构造临时对象用以返回，这会增加开销。</p>\n</li>\n<li><p>用返回引用或者指针替代不是好办法。返回指向局部对象的指针或者引用，会引发错误。返回指向动态内存的指针或引用容易忘记动态空间释放，引起内存泄露。</p>\n</li>\n<li><p>解决显式构造临时对象返回。此举表面上还是构造了一个临时对象，但是编译器通常都会进行优化，使之不产生临时对象。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//例如：\nPoint fun2() {\n    return Point(1, 2);\n}</code></pre>\n<h3 id=\"⑦析构函数\"><a href=\"#⑦析构函数\" class=\"headerlink\" title=\"⑦析构函数\"></a>⑦析构函数</h3><ul>\n<li><p>完成对象被删除前的一些清理工作。</p>\n</li>\n<li><p>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。</p>\n</li>\n<li><p>如果程序中未声明析构函数，编译器将自动产生一个隐含的析构函数。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//构造函数和析构函数举例\n\n#include &lt;iostream&gt;\nusing namespace std;\nclass Point {     \npublic:\n  Point(int xx,int yy);\n  ~Point();\n  //...其他函数原型\nprivate:\n  int x, y;\n};\n\nPoint::Point(int xx,int yy) {\n  x = xx;\n  y = yy;\n}\nPoint::~Point() {\n}\n//...其他函数的实现略</code></pre>\n<hr>\n<h2 id=\"3-类的组合\"><a href=\"#3-类的组合\" class=\"headerlink\" title=\"3.类的组合\"></a>3.类的组合</h2><h3 id=\"①组合\"><a href=\"#①组合\" class=\"headerlink\" title=\"①组合\"></a>①组合</h3><ul>\n<li><p>类中的成员数据是另一个类的对象。</p>\n</li>\n<li><p>可以在已有抽象的基础上实现更复杂的抽象。</p>\n</li>\n</ul>\n<p><strong>类组合的构造函数设计</strong></p>\n<ul>\n<li>原则：不仅要负责对本类中的基本类型成员数据赋初值，也要对对象成员初始化。</li>\n</ul>\n<pre><code class=\"c++\">//声明形式：\n类名::类名(对象成员所需的形参，本类成员形参)\n       :对象1(参数)，对象2(参数)，......\n{  \n//函数体其他语句\n}\n</code></pre>\n<p><strong>构造组合类对象时的初始化次序</strong></p>\n<ul>\n<li><p>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。</p>\n</li>\n<li><p>成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。</p>\n</li>\n<li><p>初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化</p>\n</li>\n<li><p>处理完初始化列表之后，再执行构造函数的函数体</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//类的组合，线段（Line）类\n\n\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nclass Point {    //Point类定义\npublic:\n    Point(int xx = 0, int yy = 0) {\n        x = xx;\n        y = yy;\n    }\n    Point(Point &amp;p);\n    int getX() { return x; }\n    int getY() { return y; }\nprivate:\n    int x, y;\n};\nPoint::Point(Point &amp;p) {    //复制构造函数的实现\n    x = p.x;\n    y = p.y;\n    cout &lt;&lt; &quot;Calling the copy constructor of Point&quot; &lt;&lt; endl;\n}\n\npublic:    //外部接口\n    Line(Point xp1, Point xp2);\n    Line(Line &amp;l);\n    double getLen() { return len; }\nprivate:    //私有数据成员\n    Point p1, p2;    //Point类的对象p1,p2\n    double len;\n};\n//组合类的构造函数\nLine::Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) {\n    cout &lt;&lt; &quot;Calling constructor of Line&quot; &lt;&lt; endl;\n    double x = static_cast&lt;double&gt;(p1.getX() - p2.getX());\n    double y = static_cast&lt;double&gt;(p1.getY() - p2.getY());\n    len = sqrt(x * x + y * y);\n}\nLine::Line (Line &amp;l): p1(l.p1), p2(l.p2) {//组合类的复制构造函数\n    cout &lt;&lt; &quot;Calling the copy constructor of Line&quot; &lt;&lt; endl;\n    len = l.len;\n}\n\n//主函数\nint main() {\n    Point myp1(1, 1), myp2(4, 5);    //建立Point类的对象\n    Line line(myp1, myp2);    //建立Line类的对象\n    Line line2(line);    //利用复制构造函数建立一个新对象\n    cout &lt;&lt; &quot;The length of the line is: &quot;;\n    cout &lt;&lt; line.getLen() &lt;&lt; endl;\n    cout &lt;&lt; &quot;The length of the line2 is: &quot;;\n    cout &lt;&lt; line2.getLen() &lt;&lt; endl;\n    return 0;\n}\n\n\n//运行结果如下：\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling the copy constructor of Point\nCalling constructor of Line\nCalling the copy constructor of Point\nCalling the copy constructor of Point\n</code></pre>\n<p><strong>前向引用声明</strong></p>\n<ul>\n<li><p>类应该先声明，后使用</p>\n</li>\n<li><p>如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。</p>\n</li>\n<li><p>前向引用声明只为程序引入一个标识符，但具体声明在其他地方。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//example\n\nclass B;  //前向引用声明\nclass A {\npublic:\n  void f(B b);\n};\nclass B {\npublic:\n  void g(A a);\n};</code></pre>\n<p><strong>前向引用声明注意事项</strong></p>\n<p>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象</p>\n<pre><code class=\"c++\">class Fred; //前向引用声明\nclass Barney {\n   Fred x; //错误：类Fred的声明尚不完善\n};\nclass Fred {\n   Barney y;\n};\n\n//更正\nclass Fred;    //前向引用声明\nclass Barney {\npublic:\n  ……\n  void method() {\n    x.yabbaDabbaDo();    //错误：Fred类的对象在定义之前被使用\n  }\n private:\n  Fred &amp;x;//正确，经过前向引用声明，可以声明Fred类的对象引用\n};\n\nclass Fred {\npublic:\n  void yabbaDabbaDo();\nprivate:\n  Barney &amp;y;\n}; \n</code></pre>\n<p><strong>前向引用声明注意事项</strong></p>\n<ul>\n<li>应该记住：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</li>\n</ul>\n<hr>\n<h2 id=\"4-UML图形标识\"><a href=\"#4-UML图形标识\" class=\"headerlink\" title=\"4.UML图形标识\"></a>4.UML图形标识</h2><h3 id=\"①UML简介\"><a href=\"#①UML简介\" class=\"headerlink\" title=\"①UML简介\"></a>①UML简介</h3><p><strong>UML（Unified Modeling Language）语言是一种可视化的的面向对象建模语言。</strong></p>\n<p><strong>UML有三个基本的部分</strong></p>\n<ul>\n<li><p>事物（Things）\u000bUML中重要的组成部分，在模型中属于最静态的部分，代表概念上的或物理上的元素</p>\n</li>\n<li><p>关系（Relationships）\u000b关系把事物紧密联系在一起</p>\n</li>\n<li><p>图（Diagrams）\u000b图是很多有相互相关的事物的组</p>\n</li>\n</ul>\n<h3 id=\"②UML类图\"><a href=\"#②UML类图\" class=\"headerlink\" title=\"②UML类图\"></a>②UML类图</h3><p><strong>举例：Clock类的完整表示:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Clock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>- hour:  int</td>\n</tr>\n<tr>\n<td>- minute:  int</td>\n</tr>\n<tr>\n<td>- second:  int</td>\n</tr>\n<tr>\n<td>+ showTime(): void</td>\n</tr>\n<tr>\n<td>+ setTime(newH:int=0,newM:int=0,newS:int=0)</td>\n</tr>\n</tbody></table>\n<p><strong>Clock类的简洁表示</strong></p>\n<table>\n<thead>\n<tr>\n<th>Clock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"③对象图\"><a href=\"#③对象图\" class=\"headerlink\" title=\"③对象图\"></a>③对象图</h3><table>\n<thead>\n<tr>\n<th align=\"center\">myClock:Clock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">- hour: int</td>\n</tr>\n<tr>\n<td align=\"center\">- minute: int</td>\n</tr>\n<tr>\n<td align=\"center\">- second: int</td>\n</tr>\n</tbody></table>\n<h3 id=\"④几种关系的图形标识\"><a href=\"#④几种关系的图形标识\" class=\"headerlink\" title=\"④几种关系的图形标识\"></a>④几种关系的图形标识</h3><p><strong>依赖关系</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%875.png\" alt></p>\n<p>图中的“类A”是源，“类B”是目标，表示“类A”使用了“类B”，或称“类A”依赖“类B”</p>\n<p><strong>作用关系—关联</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%874.png\" alt></p>\n<p>图中的“重数A”决定了类B的每个对象与类A的多少个对象发生作用，同样“重数B”决定了类A的每个对象与类B的多少个对象发生作用。</p>\n<p><strong>包含关系—聚集和组合</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%876.png\" alt></p>\n<p>聚集表示类之间的关系是整体与部分的关系，“包含”、“组成”、“分为……部分”等都是聚集关系。共享聚集：部分可以参加多个整体；组成聚集：整体拥有各个部分，整体与部分共存，如果整体不存在了，那么部分也就不存在了。</p>\n<p><strong><em>采用UML方法来描述例4-4中Line类和Point类的关系</em></strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%878.png\" alt></p>\n<p><strong>继承关系—泛化</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%877.png\" alt></p>\n<p><strong><em>带有注释的Line类和Point类关系的描述</em></strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%873.png\" alt></p>\n<p><strong>注释</strong></p>\n<p>在UML图形上，注释表示为带有褶角的矩形，然后用虚线连接到UML的其他元素上，它是一种用于在图中附加文字注释的机制。</p>\n<h2 id=\"5-结构体和联合体\"><a href=\"#5-结构体和联合体\" class=\"headerlink\" title=\"5.结构体和联合体\"></a>5.结构体和联合体</h2><h3 id=\"①结构体\"><a href=\"#①结构体\" class=\"headerlink\" title=\"①结构体\"></a>①结构体</h3><p><strong>结构体是一种特殊形态的类</strong></p>\n<ul>\n<li><p>与类的唯一区别：类的缺省访问权限是private，结构体的缺省访问权限是public</p>\n</li>\n<li><p>结构体存在的主要原因：与C语言保持兼容</p>\n</li>\n</ul>\n<p><strong>什么时候用结构体而不用类</strong></p>\n<ul>\n<li><p>定义主要用来保存数据、而没有什么操作的类型</p>\n</li>\n<li><p>人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便</p>\n</li>\n</ul>\n<p><strong>结构体的定义和初始化</strong></p>\n<pre><code class=\"c++\">//结构体定义\nstruct 结构体名称 {\n     公有成员\nprotected:\n    保护型成员\nprivate:\n     私有成员\n};\n\n\n//一些结构体变量的初始化可以用以下形式\n类型名 变量名 = { 成员数据1初值, 成员数据2初值, …… };\n</code></pre>\n<pre><code class=\"c++\">//1.用结构体表示学生的基本信息\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct Student {    //学生信息结构体\n    int num;        //学号\n    string name;    //姓名，字符串对象，将在第6章详细介绍\n    char sex;        //性别\n    int age;        //年龄\n};\n\nint main() {\n    Student stu = { 97001, &quot;Lin Lin&quot;, &#39;F&#39;, 19 };\n    cout &lt;&lt; &quot;Num:  &quot; &lt;&lt; stu.num &lt;&lt; endl;\n    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; stu.name &lt;&lt; endl;\n    cout &lt;&lt; &quot;Sex:  &quot; &lt;&lt; stu.sex &lt;&lt; endl;\n    cout &lt;&lt; &quot;Age:  &quot; &lt;&lt; stu.age &lt;&lt; endl;\n    return 0;\n}\n\n//运行结果：\nNum:  97001\nName: Lin Lin\nSex:  F\nAge:  19\n</code></pre>\n<h3 id=\"②联合体\"><a href=\"#②联合体\" class=\"headerlink\" title=\"②联合体\"></a>②联合体</h3><pre><code class=\"c++\">//声明形式\nunion 联合体名称 {\n    公有成员\nprotected:\n    保护型成员\nprivate:\n    私有成员\n};</code></pre>\n<p><strong>特点：</strong></p>\n<ul>\n<li><p>成员共用相同的内存单元</p>\n</li>\n<li><p>任何两个成员不会同时有效</p>\n</li>\n</ul>\n<p><strong>联合体的内存分配</strong></p>\n<pre><code class=\"c++\">union Mark {    //表示成绩的联合体\n    char grade;    //等级制的成绩\n    bool pass;    //只记是否通过课程的成绩\n    int percent;    //百分制的成绩\n};\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%872.png\" alt></p>\n<p><strong>无名联合</strong></p>\n<p>无名联合没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问。</p>\n<pre><code class=\"c++\">例：\nunion {\n  int i;\n  float f;\n}\n//在程序中可以这样使用：\ni = 10;\nf = 2.2;</code></pre>\n<pre><code class=\"c++\">//example.使用联合体保存成绩信息，并且输出。\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nclass ExamInfo {\nprivate:\n    string name;    //课程名称\n    enum { GRADE, PASS, PERCENTAGE } mode;//采用何种计分方式\n    union {\n        char grade;    //等级制的成绩\n        bool pass;    //只记是否通过课程的成绩\n        int percent;    //百分制的成绩\n    };\n\npublic:\n    //三种构造函数，分别用等级、是否通过和百分初始化\n    ExamInfo(string name, char grade)\n        : name(name), mode(GRADE), grade(grade) { }\n    ExamInfo(string name, bool pass)\n        : name(name), mode(PASS), pass(pass) { }\n    ExamInfo(string name, int percent)\n        : name(name), mode(PERCENTAGE), percent(percent) { }\n    void show();\n}\n\nvoid ExamInfo::show() {\n    cout &lt;&lt; name &lt;&lt; &quot;: &quot;;\n    switch (mode) {\n      case GRADE: cout &lt;&lt; grade;  break;\n      case PASS: cout &lt;&lt; (pass ? &quot;PASS&quot; : &quot;FAIL&quot;); break;\n      case PERCENTAGE: cout &lt;&lt; percent; break;\n    }\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    ExamInfo course1(&quot;English&quot;, &#39;B&#39;);\n    ExamInfo course2(&quot;Calculus&quot;, true);\n    ExamInfo course3(&quot;C++ Programming&quot;, 85);\n    course1.show();\n    course2.show();\n    course3.show();\n    return 0;\n}\n\n//运行结果：\nEnglish: B\nCalculus: PASS\nC++ Programming: 85</code></pre>\n<hr>\n","path":"c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html","permalink":"https://www.yshawlon.cn/c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html","tags":[{"name":"学习笔记","_id":"clq6dy48u0013ikw0galx0575","slug":"学习笔记","path":"tags/学习笔记/","permalink":"https://www.yshawlon.cn/tags/学习笔记/","length":9}],"categories":[{"name":"C++","_id":"clq6dy48e000hikw0uy63x2a1","slug":"C","path":"categories/C/","permalink":"https://www.yshawlon.cn/categories/C/","length":5}],"prev":{"title":"C++学习笔记整理-函数","date":"2020-05-08T11:54:09.000Z","summary":"前面两章和C差不多，就从第三章《函数》开始吧，错误之处欢迎指正。","slug":"C-学习笔记整理-第三章《函数》","published":true,"updated":"2021-05-18T07:52:44.799Z","_id":"clq6dy488000bikw0x8vv0062","layout":"post","photos":[],"link":"","excerpt":"","path":"c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html","permalink":"https://www.yshawlon.cn/c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html","__post":true},"next":{"title":"C++编程题目整合","date":"2020-04-26T10:51:17.000Z","summary":"就从第四章类与对象开始吧，前面的章节和c差不多在另一篇文章。","slug":"C-编程题目整合","published":true,"updated":"2020-04-26T16:18:14.999Z","_id":"clq6dy48a000eikw0vvn61mq2","layout":"post","photos":[],"link":"","excerpt":"","path":"c-bian-cheng-ti-mu-zheng-he.html","permalink":"https://www.yshawlon.cn/c-bian-cheng-ti-mu-zheng-he.html","__post":true},"__post":true}