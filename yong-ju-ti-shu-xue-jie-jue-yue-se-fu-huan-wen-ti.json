{"title":"用具体数学解决约瑟夫环问题","date":"2021-01-10T05:03:34.000Z","toc":true,"summary":"有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？","source":"_posts/用具体数学解决约瑟夫环问题.md","raw":"---\ntitle: 用具体数学解决约瑟夫环问题\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-01-10 13:03:34\npassword:\nsummary: 有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？\ntags:\n- 约瑟夫环\ncategories:\n- 算法\n---\n\n\n\n### 问题描述：\n\n**有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？**\n\n使用链表暴力求解时间复杂度是 O(qn)，递归的话是 O(n) ,使用这个方法可以加速到 O(logn).\n\n------\n\n\n\n\n### 解法思路：\n\n假设初始编号为<font color=red size=4> 1，2，3 ... n </font>，现在考虑一种新的编号方式。\n\n第一个人不会被踢掉，那么他的编号从<font color=red size=4> n </font>开始往后加<font color=red size=4> 1 </font>，变成<font color=red size=4> n+1 </font>，然后第二个人编号变为<font color=red size=4> n+2 </font>，直到第<font color=red size=4> q </font>个人，他被踢掉了。\n\n然后第<font color=red size=4> q+1 </font>个人编号继续加<font color=red size=4> 1 </font>，变成了<font color=red size=4> n+q </font>，依次下去。\n\n考虑当前踢到的人编号为<font color=red size=4> kq</font>，那么此时已经踢掉了<font color=red size=4> k </font>个人，所以接下去的人新的编号为<font color=red size=4> n+k(q-1)+1...</font>。\n\n所以编号为<font color=red size=4> kq+d </font>的人编号变成了<font color=red size=4> n+k(q-1)+d </font> ，其中<font color=red size=4> 1<=d<q</font>;\n\n\n\n**直到最后，可以发现活下来的人编号为<font color=red size=4> qn </font>，问题是怎么根据这个编号推出他原来的编号？**\n\n以 n=10 , q=3 为例，下图就是每个人新的编号：\n\n\n\n|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  11  |  12  |  T   |  13  |  14  |  T   |  15  |  16  |  T   |  17  |\n|  18  |  T   |      |  19  |  20  |      |  T   |  21  |      |  22  |\n|  T   |      |      |  23  |  24  |      |      |  T   |      |  25  |\n|      |      |      |  26  |  T   |      |      |      |      |  27  |\n|      |      |      |  28  |      |      |      |      |      |  T   |\n|      |      |      |  29  |      |      |      |      |      |      |\n|      |      |      |  30  |      |      |      |      |      |      |\n|      |      |      |      |      |      |      |      |      |      |\n\n\n\n**令：**\n$$\n\\quad N=n+k(q-1)+d\n$$\n则他上一次的编号为：\n$$\n\\quad kq+d=kq+N-n-k(q-1)=k+N-n\n$$\n\n$$\n又 \\because k=\\frac{N-n-d}{q-1}=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor\n$$\n\n所以他上一次的编号可以写为：\n$$\n\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor+N-n\n$$\n\n\n因此最后存活的人可以这样计算：\n\n```c++\nN = qn\nwhile N > n:\n    N = k + N - n\nans = N\n```\n\n其中<font color=red size=4> k </font>等于：\n$$\nk=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor\n$$\n**如果用<font color=red size=4> D=qn+1-N </font>代替<font color=red size=4> N </font>,那么算法可以简化为：**\n$$\n\\begin{array}{l}\nD=q n+1-N \\\\\n=q n+1-\\left(\\left\\lfloor\\frac{(q n+1-D)-n-1}{q-1}\\right\\rfloor+q n+1-D-n\\right) \\\\\n=n+D-\\left[\\frac{(q-1) n-D}{q-1}\\right] \\\\\n=D-\\left\\lfloor\\frac{D}{q 1}\\right\\rfloor \\\\\n=D+\\left\\lceil\\frac{D}{q-1}\\right\\rceil \\\\\n=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil\n\\end{array}\n$$\n算法伪代码：\n\n```c++\nD = 1\nwhile D <= (q-1)n:\n    D = k\nans = qn + 1 - D\n```\n\n其中<font color=red size=4> k</font> 等于：\n$$\nk=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil\n$$\n\n------\n\n\n\n### 代码展示：\n\n\n\n```c++\n//c++代码\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL Ceil(LL x, LL y) {\n  return x / y + (x % y != 0);\n}\n\nLL J(LL n, LL q) {\n  LL D = 1, end = (q - 1) * n;\n  while (D <= end) {\n​    D = Ceil(q * D, q - 1);\n  }\n  return q * n + 1 - D;\n}\n\nint main() {\n  LL n, q;\n  while (~scanf(\"%lld%lld\", &n, &q)) {\n​    printf(\"%lld\\n\", J(n, q));\n  }\n  return 0;\n}\n```\n\n","slug":"用具体数学解决约瑟夫环问题","published":true,"updated":"2021-01-13T08:18:22.955Z","_id":"clq6dy4aq003likw0gs1n6h0p","comments":true,"layout":"post","photos":[],"link":"","html":"<h3 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h3><p><strong>有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？</strong></p>\n<p>使用链表暴力求解时间复杂度是 O(qn)，递归的话是 O(n) ,使用这个方法可以加速到 O(logn).</p>\n<hr>\n<h3 id=\"解法思路：\"><a href=\"#解法思路：\" class=\"headerlink\" title=\"解法思路：\"></a>解法思路：</h3><p>假设初始编号为<font color=\"red\" size=\"4\"> 1，2，3 … n </font>，现在考虑一种新的编号方式。</p>\n<p>第一个人不会被踢掉，那么他的编号从<font color=\"red\" size=\"4\"> n </font>开始往后加<font color=\"red\" size=\"4\"> 1 </font>，变成<font color=\"red\" size=\"4\"> n+1 </font>，然后第二个人编号变为<font color=\"red\" size=\"4\"> n+2 </font>，直到第<font color=\"red\" size=\"4\"> q </font>个人，他被踢掉了。</p>\n<p>然后第<font color=\"red\" size=\"4\"> q+1 </font>个人编号继续加<font color=\"red\" size=\"4\"> 1 </font>，变成了<font color=\"red\" size=\"4\"> n+q </font>，依次下去。</p>\n<p>考虑当前踢到的人编号为<font color=\"red\" size=\"4\"> kq</font>，那么此时已经踢掉了<font color=\"red\" size=\"4\"> k </font>个人，所以接下去的人新的编号为<font color=\"red\" size=\"4\"> n+k(q-1)+1…</font>。</p>\n<p>所以编号为<font color=\"red\" size=\"4\"> kq+d </font>的人编号变成了<font color=\"red\" size=\"4\"> n+k(q-1)+d </font> ，其中<font color=\"red\" size=\"4\"> 1&lt;=d&lt;q</font>;</p>\n<p><strong>直到最后，可以发现活下来的人编号为<font color=\"red\" size=\"4\"> qn </font>，问题是怎么根据这个编号推出他原来的编号？</strong></p>\n<p>以 n=10 , q=3 为例，下图就是每个人新的编号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n<th align=\"center\">10</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">11</td>\n<td align=\"center\">12</td>\n<td align=\"center\">T</td>\n<td align=\"center\">13</td>\n<td align=\"center\">14</td>\n<td align=\"center\">T</td>\n<td align=\"center\">15</td>\n<td align=\"center\">16</td>\n<td align=\"center\">T</td>\n<td align=\"center\">17</td>\n</tr>\n<tr>\n<td align=\"center\">18</td>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\">19</td>\n<td align=\"center\">20</td>\n<td align=\"center\"></td>\n<td align=\"center\">T</td>\n<td align=\"center\">21</td>\n<td align=\"center\"></td>\n<td align=\"center\">22</td>\n</tr>\n<tr>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">23</td>\n<td align=\"center\">24</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\">25</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">26</td>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">27</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">28</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">T</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">29</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">30</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>令：</strong><br>$$<br>\\quad N=n+k(q-1)+d<br>$$<br>则他上一次的编号为：<br>$$<br>\\quad kq+d=kq+N-n-k(q-1)=k+N-n<br>$$</p>\n<p>$$<br>又 \\because k=\\frac{N-n-d}{q-1}=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor<br>$$</p>\n<p>所以他上一次的编号可以写为：<br>$$<br>\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor+N-n<br>$$</p>\n<p>因此最后存活的人可以这样计算：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">N = qn\nwhile N > n:\n    N = k + N - n\nans = N<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中<font color=\"red\" size=\"4\"> k </font>等于：<br>$$<br>k=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor<br>$$<br><strong>如果用<font color=\"red\" size=\"4\"> D=qn+1-N </font>代替<font color=\"red\" size=\"4\"> N </font>,那么算法可以简化为：</strong><br>$$<br>\\begin{array}{l}<br>D=q n+1-N \\<br>=q n+1-\\left(\\left\\lfloor\\frac{(q n+1-D)-n-1}{q-1}\\right\\rfloor+q n+1-D-n\\right) \\<br>=n+D-\\left[\\frac{(q-1) n-D}{q-1}\\right] \\<br>=D-\\left\\lfloor\\frac{D}{q 1}\\right\\rfloor \\<br>=D+\\left\\lceil\\frac{D}{q-1}\\right\\rceil \\<br>=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil<br>\\end{array}<br>$$<br>算法伪代码：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">D = 1\nwhile D <= (q-1)n:\n    D = k\nans = qn + 1 - D<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中<font color=\"red\" size=\"4\"> k</font> 等于：<br>$$<br>k=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil<br>$$</p>\n<hr>\n<h3 id=\"代码展示：\"><a href=\"#代码展示：\" class=\"headerlink\" title=\"代码展示：\"></a>代码展示：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//c++代码\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL Ceil(LL x, LL y) {\n  return x / y + (x % y != 0);\n}\n\nLL J(LL n, LL q) {\n  LL D = 1, end = (q - 1) * n;\n  while (D <= end) {\n​    D = Ceil(q * D, q - 1);\n  }\n  return q * n + 1 - D;\n}\n\nint main() {\n  LL n, q;\n  while (~scanf(\"%lld%lld\", &n, &q)) {\n​    printf(\"%lld\\n\", J(n, q));\n  }\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","excerpt":"","more":"<h3 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h3><p><strong>有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？</strong></p>\n<p>使用链表暴力求解时间复杂度是 O(qn)，递归的话是 O(n) ,使用这个方法可以加速到 O(logn).</p>\n<hr>\n<h3 id=\"解法思路：\"><a href=\"#解法思路：\" class=\"headerlink\" title=\"解法思路：\"></a>解法思路：</h3><p>假设初始编号为<font color=\"red\" size=\"4\"> 1，2，3 … n </font>，现在考虑一种新的编号方式。</p>\n<p>第一个人不会被踢掉，那么他的编号从<font color=\"red\" size=\"4\"> n </font>开始往后加<font color=\"red\" size=\"4\"> 1 </font>，变成<font color=\"red\" size=\"4\"> n+1 </font>，然后第二个人编号变为<font color=\"red\" size=\"4\"> n+2 </font>，直到第<font color=\"red\" size=\"4\"> q </font>个人，他被踢掉了。</p>\n<p>然后第<font color=\"red\" size=\"4\"> q+1 </font>个人编号继续加<font color=\"red\" size=\"4\"> 1 </font>，变成了<font color=\"red\" size=\"4\"> n+q </font>，依次下去。</p>\n<p>考虑当前踢到的人编号为<font color=\"red\" size=\"4\"> kq</font>，那么此时已经踢掉了<font color=\"red\" size=\"4\"> k </font>个人，所以接下去的人新的编号为<font color=\"red\" size=\"4\"> n+k(q-1)+1…</font>。</p>\n<p>所以编号为<font color=\"red\" size=\"4\"> kq+d </font>的人编号变成了<font color=\"red\" size=\"4\"> n+k(q-1)+d </font> ，其中<font color=\"red\" size=\"4\"> 1&lt;=d&lt;q</font>;</p>\n<p><strong>直到最后，可以发现活下来的人编号为<font color=\"red\" size=\"4\"> qn </font>，问题是怎么根据这个编号推出他原来的编号？</strong></p>\n<p>以 n=10 , q=3 为例，下图就是每个人新的编号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n<th align=\"center\">10</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">11</td>\n<td align=\"center\">12</td>\n<td align=\"center\">T</td>\n<td align=\"center\">13</td>\n<td align=\"center\">14</td>\n<td align=\"center\">T</td>\n<td align=\"center\">15</td>\n<td align=\"center\">16</td>\n<td align=\"center\">T</td>\n<td align=\"center\">17</td>\n</tr>\n<tr>\n<td align=\"center\">18</td>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\">19</td>\n<td align=\"center\">20</td>\n<td align=\"center\"></td>\n<td align=\"center\">T</td>\n<td align=\"center\">21</td>\n<td align=\"center\"></td>\n<td align=\"center\">22</td>\n</tr>\n<tr>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">23</td>\n<td align=\"center\">24</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\">25</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">26</td>\n<td align=\"center\">T</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">27</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">28</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">T</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">29</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">30</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>令：</strong><br>$$<br>\\quad N=n+k(q-1)+d<br>$$<br>则他上一次的编号为：<br>$$<br>\\quad kq+d=kq+N-n-k(q-1)=k+N-n<br>$$</p>\n<p>$$<br>又 \\because k=\\frac{N-n-d}{q-1}=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor<br>$$</p>\n<p>所以他上一次的编号可以写为：<br>$$<br>\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor+N-n<br>$$</p>\n<p>因此最后存活的人可以这样计算：</p>\n<pre><code class=\"c++\">N = qn\nwhile N &gt; n:\n    N = k + N - n\nans = N</code></pre>\n<p>其中<font color=\"red\" size=\"4\"> k </font>等于：<br>$$<br>k=\\left\\lfloor\\frac{N-n-1}{q-1}\\right\\rfloor<br>$$<br><strong>如果用<font color=\"red\" size=\"4\"> D=qn+1-N </font>代替<font color=\"red\" size=\"4\"> N </font>,那么算法可以简化为：</strong><br>$$<br>\\begin{array}{l}<br>D=q n+1-N \\<br>=q n+1-\\left(\\left\\lfloor\\frac{(q n+1-D)-n-1}{q-1}\\right\\rfloor+q n+1-D-n\\right) \\<br>=n+D-\\left[\\frac{(q-1) n-D}{q-1}\\right] \\<br>=D-\\left\\lfloor\\frac{D}{q 1}\\right\\rfloor \\<br>=D+\\left\\lceil\\frac{D}{q-1}\\right\\rceil \\<br>=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil<br>\\end{array}<br>$$<br>算法伪代码：</p>\n<pre><code class=\"c++\">D = 1\nwhile D &lt;= (q-1)n:\n    D = k\nans = qn + 1 - D</code></pre>\n<p>其中<font color=\"red\" size=\"4\"> k</font> 等于：<br>$$<br>k=\\left\\lceil\\frac{q}{q-1} D\\right\\rceil<br>$$</p>\n<hr>\n<h3 id=\"代码展示：\"><a href=\"#代码展示：\" class=\"headerlink\" title=\"代码展示：\"></a>代码展示：</h3><pre><code class=\"c++\">//c++代码\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long LL;\n\nLL Ceil(LL x, LL y) {\n  return x / y + (x % y != 0);\n}\n\nLL J(LL n, LL q) {\n  LL D = 1, end = (q - 1) * n;\n  while (D &lt;= end) {\n​    D = Ceil(q * D, q - 1);\n  }\n  return q * n + 1 - D;\n}\n\nint main() {\n  LL n, q;\n  while (~scanf(&quot;%lld%lld&quot;, &amp;n, &amp;q)) {\n​    printf(&quot;%lld\\n&quot;, J(n, q));\n  }\n  return 0;\n}</code></pre>\n","path":"yong-ju-ti-shu-xue-jie-jue-yue-se-fu-huan-wen-ti.html","permalink":"https://www.yshawlon.cn/yong-ju-ti-shu-xue-jie-jue-yue-se-fu-huan-wen-ti.html","tags":[{"name":"约瑟夫环","_id":"clq6dy4bj005yikw0pqyzk9h1","slug":"约瑟夫环","path":"tags/约瑟夫环/","permalink":"https://www.yshawlon.cn/tags/约瑟夫环/","length":1}],"categories":[{"name":"算法","_id":"clq6dy491001eikw044hl9f0q","slug":"算法","path":"categories/算法/","permalink":"https://www.yshawlon.cn/categories/算法/","length":5}],"prev":{"title":"Hexo网站部署node版本过高配置问题","date":"2021-02-19T11:16:24.000Z","summary":"node版本过高导致无法部署hexo，通过替换版本解决。","slug":"Hexo网站部署node版本过高配置问题","published":true,"updated":"2021-04-26T07:12:32.836Z","_id":"clq6dy48v0015ikw0gwh0qgm7","layout":"post","photos":[],"link":"","excerpt":"","path":"hexo-wang-zhan-bu-shu-node-ban-ben-guo-gao-pei-zhi-wen-ti.html","permalink":"https://www.yshawlon.cn/hexo-wang-zhan-bu-shu-node-ban-ben-guo-gao-pei-zhi-wen-ti.html","__post":true},"next":{"title":"如何实现一个公平的洗牌算法","date":"2021-01-10T05:02:38.000Z","summary":"每一个元素都能独立等概率的出现在每一个位置，每一个位置都能独立等概率的放置每个元素","slug":"如何实现一个公平的洗牌算法","published":true,"updated":"2021-02-19T15:33:42.494Z","_id":"clq6dy4ag002zikw0t95tsm48","layout":"post","photos":[],"link":"","excerpt":"","path":"ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html","permalink":"https://www.yshawlon.cn/ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html","__post":true},"__post":true}