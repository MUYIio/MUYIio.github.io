<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Shawlon`s Blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script></head>


 <div id="loading-container">
     <p class="loading-text"></p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url()">
        </div>
    </section>
    <section class='menu'>
        <div>Shawlon`s Blog</div>
        
            <div>Yshawlon</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ 学习笔记 }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/cao-zuo-xi-tong-shi-xian-di-yi-pian.html">操作系统实现第一篇</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-03-20T10:58:07.000Z" itemprop="datePublished">
    2022-03-20
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/操作系统/">操作系统</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><p>很早之前就想自己实现一个操作系统，现在才正式开始，我也不知道什么时候能啃下这个庞然大物；这篇博客将尽可能详细，记录学习过程，有感兴趣的小伙伴也可以加入我~</p>
<h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/x86-hui-bian-yu-yan-cong-shi-mo-shi-dao-bao-hu-mo-shi-yue-du-bi-ji.html">《X86汇编语言从实模式到保护模式》阅读笔记</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-16T14:57:10.000Z" itemprop="datePublished">
    2021-05-16
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/操作系统/">操作系统</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/操作系统/汇编/">汇编</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>处理器基本工作：取指令，执行指令，数据访问，万变不离其宗。而处理器访问内存地址通过内存的分段机制来实现。分段机制为： 逻辑地址（20位）=段寄存器地址左移4位（16位）+偏移地址（16位）。<br> 使用上述方式是有历史原因，由于早期只有16位的寄存器，16位的只能达到64KB内存，为了能够表示更大的内存，8086提供20位的地址线可以达到1MB。将16位的段地址+16位的偏移地址不足以得到20位的物理地址，于是将16位的端寄存器左移4位+偏移地址，形成20位的物理地址。</p>
<p>分段机制最重要两个寄存器。CS：代码段寄存器，用于表示cpu从代码段哪个位置执行；DS：数据段寄存器，指向数据段。</p>
<p><img src="06.jpg" alt></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu-hou-ban-bu-fen.html">《汇编语言》王爽著学习笔记记录(后半部分)</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-08T15:08:22.000Z" itemprop="datePublished">
    2021-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/汇编/">汇编</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="第七章：更灵活的定位内存地址的方法"><a href="#第七章：更灵活的定位内存地址的方法" class="headerlink" title="第七章：更灵活的定位内存地址的方法"></a>第七章：更灵活的定位内存地址的方法</h3><ol>
<li><p>and 和 or 指令：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
<th align="center">例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">将操作对象的相应位设为0，其它位不变</td>
<td align="center">将al的第0位设为0：and al,11111110B</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">逻辑或指令，按位进行或运算</td>
<td align="center">将al的第6位设为1：or al,01000000B</td>
</tr>
</tbody></table>
<p>使用这两个命令可以帮助我们对内存中的数据按位置 0 或 1.</p>
</li>
<li><p>指明内存单元的另一个方法：<strong>[bx + idata]来访问一个内存单元(一个变量一个常量)，其代表的是一个偏移地址；</strong>这种内存访问方式为高级语言实现数组提供了便利机制。</p>
<p><strong>命令 mov ax,[200 + bx] 的含义为： (ax) = ((ds) * 16 + (bx) + 200)</strong></p>
<p>通用写法：</p>
<ol>
<li>mov ax,[bx + 200] </li>
<li>mov ax,200[bx] </li>
<li>mov ax,[bx].200 </li>
</ol>
</li>
<li><p>si 和 di 是8086CPU中两个和 bx 功能相近的寄存器， 但不能分为两个 8 为寄存器来使用。</p>
<ol>
<li><pre class="line-numbers language-asm"><code class="language-asm">mov bx，0
mov ax，[bx]
mov si，0
mov ax，[si]
mov di，0
mov ax，[di]
mov bx,0

mov ax,[bx + 123]
mov si,0
mov ax,[si + 123]
mov di,0
mov ax,[di + 123]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
<p>   上面的代码说明了si 与 di 同 bx 使用上的相同之处。</p>
<ol start="4">
<li><p>我们可以使用 [bx (si 或 di)]（一个变量） 、[bx (si 或 di) + idata] （一个变量和一个常量）来指明一个内存单元，还有 [bx + si] 、[bx + di] （两个变量）</p>
<blockquote>
<p>mov ax,[bx + si]         ;(ax) = ((ds) * 16 + (bx) + (si))</p>
<p>常用形式: mov ax,[bx] [si]</p>
</blockquote>
</li>
<li><p>更多的内存访问方式：[bx + si + idata] 、[bx + di + idata]（两个变量，一个常量）</p>
<blockquote>
<p>mov ax,[bx + si + idata]  ;(ax) = ((ds) * 16 + (bx) + (si) + idata) </p>
</blockquote>
<p>常用形式：</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,[bx + 200 + si]
mov ax,[200 + bx + si]
mov ax,200[bx][si]
mov ax,[bx].200[si]
mov ax,[bx] [si].200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将datasg中的每个单词改为大写字母：</p>
<pre class="line-numbers language-asm"><code class="language-asm"> ;版本1
 ;使用 dx 寄存器临时保存 cx 中的值
assume cs:codesg,ds:datasg

datasg segment
     db 'ibm             '
    db 'dec             '
    db 'dos             '
    db 'vax             '
datasg ends

codesg segment
start: mov ax,datasg
       mov ds,ax
       mov bx,0                  ;此时指向第一行第一个字节的字母

       mov cx,4

   s0: mov dx,cx                 ;将 cx 的值暂存到 dx 中
          mov si,0
          mov cx,3

    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))
       and al,11011111b          ;将小写字母改为大写字母
       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)
       inc si                    ;si + 1

       loop s

       add bx,16                 ;00 → 10 → 20 → 30 ...
       mov cx,dx                 ;将暂存的 cx 返回
       loop s0                   ;cx - 1

codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm"> ;版本2
 ;使用栈空间来暂存数据，前面我们使用的是寄存器，但有些时候寄存器是不足的，不是可取的办法
assume cs:codesg,ds:datasg,ss:stacksg

datasg segment
     db 'ibm             '
    db 'dec             '
    db 'dos             '
    db 'vax             '
datasg ends

stacksg segnebt
        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节
stacksg ends

codesg segment
start: mov ax,stacksg
       mov ss,ax
       mov sp,16
       mov ax,datasg
       mov ds,ax
       mov bx,0                  ;此时指向第一行第一个字节的字母

       mov cx,4

   s0: push cx                   ;将外循环 cx 的值压栈
          mov si,0
          mov cx,3                  ;内循环 cx 的值

    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))
       and al,11011111b          ;将小写字母改为大写字母
       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)
       inc si                    ;si + 1

       loop s

       add bx,16                 ;00 → 10 → 20 → 30 ...
       pop cx                    ;将暂存的 cx 返回
       loop s0                   ;cx - 1

       mov ax,4c00H
       int 21H

codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在需要暂存数据的时候，一般使用栈来操作</strong></p>
</li>
<li><p>将 datasg 段中每个单词前4个字母改为大写：</p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:codesg,ds:datasg,ss:stacksg

datasg segment
     db '1. display      '
    db '2. brows        '
    db '3. replace      '
    db '4. modify       '
datasg ends

stacksg segnebt
        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节
stacksg ends

codesg segment
start: mov ax,stacksg
       mov ss,ax
       mov sp,16
       mov ax,datasg
       mov ds,ax
       mov bx,0                  ;此时指向第一行第一个字节的字母

       mov cx,4

   s0: push cx                   ;将外循环 cx 的值压栈
          mov si,0
          mov cx,4                  ;内循环 cx 的值

    s: mov al,[bx + 3 + si]      ;(al) = ((ds) * 16 + (bx) + (si) + 3)
       and al,11011111b          ;将小写字母改为大写字母
       mov [bx + 3 + si],al      ;((ds) * 16 +(bx) + (si) + 3) = (al)
       inc si                    ;si + 1

       loop s

       add bx,16                 ;00 → 10 → 20 → 30 ...
       pop cx                    ;将暂存的 cx 返回
       loop s0                   ;cx - 1

       mov ax,4c00H
       int 21H

codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="第八章：数据处理的两个基本问题"><a href="#第八章：数据处理的两个基本问题" class="headerlink" title="第八章：数据处理的两个基本问题"></a>第八章：数据处理的两个基本问题</h3><ol>
<li><p>描述性符号：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">功能</th>
<th align="center">集合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reg</td>
<td align="center">代表一个寄存器</td>
<td align="center">ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</td>
</tr>
<tr>
<td align="center">sreg</td>
<td align="center">代表一个段寄存器</td>
<td align="center">ds、ss、cs、es</td>
</tr>
</tbody></table>
</li>
<li><p>在8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 […] 中来进行内存单元的寻址。</p>
<p>在 […] 中，这四个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,[bx]
mov ax,[si]
mov ax,[di]
mov ax,[bp]
mov ax,[bx + si]
mov ax,[bx + di]
mov ax,[bp + si]
mov ax,[bp + di]
mov ax,[bx + si + idata]
mov ax,[bx + di + idata]
mov ax,[bp + si + idata]
mov ax,[bp + di + idata]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用寄存器 bp 进行寻址，如果没有显性的给出段地址，那么段地址默认在 ss 段寄存器中</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,[bp] ;(ax) = ((ss) * 16 + (bp))
mov ax,[bp + si + idata] ;(ax) = ((ss) * 16 + (bp) + (si) + idata)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>处理指令大致分为3类：读取、写入、运算；指令执行前，数据一般在3个地方：CPU内部、内存、端口</p>
</li>
<li><p>数据的位置：</p>
<ol>
<li><p>立即数（idata）：在汇编指令中字节给出</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov ax,1
add bx,2000H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>寄存器：要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名就可以。</p>
</li>
<li><p>段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，使用段地址+偏移地址定位内存单元。</p>
</li>
</ol>
</li>
<li><p><strong>寻址方式总结：</strong></p>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">含义</th>
<th align="center">名称</th>
<th align="center">常用格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[idata]</td>
<td align="center">EA = idata;SA = (ds)</td>
<td align="center">直接寻址</td>
<td align="center">[idata]</td>
</tr>
<tr>
<td align="center">[bx]</td>
<td align="center">EA = (bx);SA = (ds)</td>
<td align="center">寄存器间接寻址</td>
<td align="center">[bx]</td>
</tr>
<tr>
<td align="center">[si]</td>
<td align="center">EA = (si) ;SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[di]</td>
<td align="center">EA = (di);SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp]</td>
<td align="center">EA = (bp);SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bx + idata]</td>
<td align="center">EA = (bx) + idata;SA = (ds)</td>
<td align="center">寄存器相对寻址</td>
<td align="center">用于结构体:[bx].idata</td>
</tr>
<tr>
<td align="center">[si + idata]</td>
<td align="center">EA = (si) + idata;SA = (ds)</td>
<td align="center"></td>
<td align="center">用于数组:idata[si],idata[di]</td>
</tr>
<tr>
<td align="center">[di + idata]</td>
<td align="center">EA = (di) + idata;SA = (ds)</td>
<td align="center"></td>
<td align="center">用于二维数组:[bx] [idata]</td>
</tr>
<tr>
<td align="center">[bp + idata]</td>
<td align="center">EA = (bp) + idata;SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bx + si]</td>
<td align="center">EA = (bx) + (si);SA = (ds)</td>
<td align="center">基址变址寻址</td>
<td align="center">用于二维数组:[bx] [si]</td>
</tr>
<tr>
<td align="center">[bx + di]</td>
<td align="center">EA = (bx) + (di);SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp + si]</td>
<td align="center">EA = (bp) + (si);SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp + di]</td>
<td align="center">EA = (bp) + (di);SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bx + si + idata]</td>
<td align="center">EA = (bx) + (si) + idata;SA = (ds)</td>
<td align="center">相对基址变址寻址</td>
<td align="center">用于表格中的数组:[bx].idata[si]</td>
</tr>
<tr>
<td align="center">[bx + di + idata]</td>
<td align="center">EA = (bx) + (di) + idata;SA = (ds)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[bp + si + idata]</td>
<td align="center">EA = (bp) + (si) + idata;SA = (ss)</td>
<td align="center"></td>
<td align="center">用于二维数组:idata[bx] [si]</td>
</tr>
<tr>
<td align="center">[bp + di + idata]</td>
<td align="center">EA = (bp) + (di) + idata;SA = (ss)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>8086CPU 可以处理 byte 和 word 两种尺寸的数据。</p>
<ol>
<li><p>通过寄存器名指明要处理的数据的尺寸：</p>
<pre class="line-numbers language-asm"><code class="language-asm">;字操作
mov ax,1
add ax,1000
inc ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm">;字节操作
mov al
add al000
inc al<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>没有寄存器名存在得情况下，用操作符 X ptr 指明内存单元的长度，X 可以为 byte 或 word：</p>
<pre class="line-numbers language-asm"><code class="language-asm">;word ptr 表示访问一个字单元
mov word ptr ds:[0],1
inc word ptr [bx]
inc word ptr ds:[0]
add word ptr [bx],2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm">;byte ptr 表示访问一个字节单元
mov byte ptr ds:[0],1
inc byte ptr [bx]
inc byte ptr ds:[0]
add byte ptr [bx],2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>   <strong>在机器指令中指明要访问的是字单元还是字节单元是非常重要的，8086CPU中，一个byte为8bit，而一个字为2byte，如果不指明，那么在访问的时候是有区别的。</strong></p>
<ol start="8">
<li><p>使用 push 和 pop 指令就代表了是进行字操作，无需指明</p>
</li>
<li><p>div 除法指令：</p>
<p>(1)除数：8位和16位两种，在一个reg或内存单元中</p>
<p>(2)被除数：默认在AX或AX和DX中，除数位8位，被除数位16位，默认在AX中存放；除数位16位，则被除数位32位，DX存放高16位，AX存放低16位。</p>
<p>(3)结果：如果除数位8位，则AL存储除法操作的商，AH存放余数；如果除数位16位，AX存储除法操作的商，DX存放余数</p>
<pre class="line-numbers language-asm"><code class="language-asm">;格式
div reg
div 内存单元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-asm"><code class="language-asm">;示例
div byte ptr ds:[0]      ;(al) = (ax) / ((ds) * 16 + 0 )的商
                       ;(ah) = (ax) / ((ds) * 16 + 0)的余数

div word ptr es:[0]      ;(ax) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的商
                       ;(dx) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的余数

div byte ptr [bx + si + 8]     ;(al) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的商
                             ;(ah) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的余数

div word ptr [bx + si + 8]     ;(ax) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的商
                             ;(dx) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的余数js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>计算：100001 / 100</p>
<pre class="line-numbers language-asm"><code class="language-asm">;100001 > 65535,所以除数得是32位，转为16进制为 186A1H，所以高16位在DX中，低16位在AX中
mov dx,1
mov ax,86A1H
mov bx,100
div bx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol start="11">
<li><p>伪指令 dd 、dup</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">db</td>
<td align="center">定义字节型数据</td>
<td align="center">db 1</td>
</tr>
<tr>
<td align="center">dw</td>
<td align="center">定义字型数据</td>
<td align="center">dw 100</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">定义dword双字型数据</td>
<td align="center">dd 100001</td>
</tr>
<tr>
<td align="center">dup</td>
<td align="center">与上面3个指令配合使用，用来进行数据的重复</td>
<td align="center">db(dw、dd) 重复次数 dup (重复的数据)</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="12">
<li><p>汇编语言实验七：</p>
<pre class="line-numbers language-asm"><code class="language-asm">;题目太长，只贴代码，先思考写代码，而后体会别人的代码
assume cs:code

data segment
 db '1975','1976','1977','1978','1979','1980','1981','1982','1983','1984','1985'
 db '1986','1987','1988','1989','1990','1991','1992','1993','1994','1995'

 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514,345980
 dd 590827,803530,1183000,1843000,2758000,3753000,4649000,5937000

 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
 dw 11542,14430,15257,17800
data ends

stack segment
 dw 0,0,0,0,0,0,0
stack ends

table segment
 db 21 dup ('year summ ne ?? ')
table ends

code segment

start:
    mov ax,data
    mov es,ax
    mov si,0

    mov ax,table
    mov ds,ax
    mov di,0

    mov ax,stack
    mov ss,ax
    mov sp,16

    mov bx,0
    mov cx,21
s0:
    mov ax,es:[si]    
    mov ds:[di+bx],ax
    add si,2
    add di,2
    mov ax,es:[si]
    mov ds:[di+bx],ax

    mov ax,es:[si+82]
    mov ds:[bx+di+3],ax
    mov ax,es:[si+84]
    mov ds:[bx+di+5],ax

    add si,2
    mov di,0
    add bx,16
    loop s0

    mov bx,0
    mov si,168
    mov di,5
    mov cx,21
s1:    
    mov ax,es:[si]
    mov ds:[bx+di+5],ax

    mov ax,ds:[bx+di]
    mov dx,ds:[bx+di+2]
    div word ptr ds:[bx+di+5]
    mov ds:[bx+di+8],ax

    add si,2
    add bx,16
    loop s1

    mov ax,4c00h
    int 21h

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="第九章：转移指令的原理"><a href="#第九章：转移指令的原理" class="headerlink" title="第九章：转移指令的原理"></a>第九章：转移指令的原理</h3><ol>
<li><p><strong>可以修改 IP ，或者同时修改 CS 和 IP 得指令统称为转移指令。</strong></p>
<ol>
<li>段内转移：jmp ax<ol>
<li>短转移IP修改范围：-128~127</li>
<li>近转移IP修改范围：-32768~32767</li>
</ol>
</li>
<li>段间转移：jmp 1000:0</li>
</ol>
</li>
<li><p>转移指令分为无条件转移指令（jmp）和条件转移指令、循环指令、过程、中断等等</p>
</li>
<li><p>操作符 offset ，能够取得标号的偏移地址：</p>
<pre class="line-numbers language-asm"><code class="language-asm">start: mov ax,offset start  ;取得start的偏移地址，相当于 mov ax，0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li></li>
</ol>
<h3 id="第十章：CALL和RET指令"><a href="#第十章：CALL和RET指令" class="headerlink" title="第十章：CALL和RET指令"></a>第十章：CALL和RET指令</h3><ol>
<li><h3 id="第十一章：标志寄存器"><a href="#第十一章：标志寄存器" class="headerlink" title="第十一章：标志寄存器"></a>第十一章：标志寄存器</h3></li>
<li></li>
</ol>
<h3 id="第十二章：内中断"><a href="#第十二章：内中断" class="headerlink" title="第十二章：内中断"></a>第十二章：内中断</h3><ol>
<li><h3 id="第十三章：int-指令"><a href="#第十三章：int-指令" class="headerlink" title="第十三章：int 指令"></a>第十三章：int 指令</h3></li>
<li></li>
</ol>
<h3 id="第十四章：端口"><a href="#第十四章：端口" class="headerlink" title="第十四章：端口"></a>第十四章：端口</h3><ol>
<li><h3 id="第十五章：外中断"><a href="#第十五章：外中断" class="headerlink" title="第十五章：外中断"></a>第十五章：外中断</h3></li>
<li></li>
</ol>
<h3 id="第十六章：直接定址表"><a href="#第十六章：直接定址表" class="headerlink" title="第十六章：直接定址表"></a>第十六章：直接定址表</h3><ol>
<li><h3 id="第十七章：使用BIOS进行键盘输入"><a href="#第十七章：使用BIOS进行键盘输入" class="headerlink" title="第十七章：使用BIOS进行键盘输入"></a>第十七章：使用BIOS进行键盘输入</h3></li>
<li></li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu.html">《汇编语言》王爽著学习笔记记录(前半部分)</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-08T06:17:32.000Z" itemprop="datePublished">
    2021-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/汇编/">汇编</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>看了看书发现书上的一些概念容易忘记，就顺手打下来，考虑到篇幅过长，分为前后两个部分。</p>
<h3 id="第一章：基础知识"><a href="#第一章：基础知识" class="headerlink" title="第一章：基础知识"></a>第一章：基础知识</h3><ol>
<li><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p>
</li>
<li><p>每一种CPU都有自己的汇编指令集</p>
</li>
<li><p>在存储器中指令和数据没有任何区别，都是二进制信息。</p>
</li>
<li><p>CPU可以直接使用的信息在存储器中存放。</p>
</li>
<li><p>存储器单元从零开始顺序编号。</p>
</li>
<li><p>一个存储单元可以存储8 bit，即8个二进制位。</p>
</li>
<li><p>1Byte = 8bit….</p>
</li>
<li><p>每一个CPU芯片都有许多管脚，它们与总线相连。其分为三类：</p>
<ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其它器件进行数据传送时一次数据传送量</li>
<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>
</ul>
</li>
<li><p><strong>内存地址空间：</strong>最终运行程序的是CPU，对CPU来讲，系统中所有的存储器的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力（读取内存地址的范围）的限制。这个逻辑存储器即内存地址空间。</p>
</li>
</ol>
<h3 id="第二章：寄存器"><a href="#第二章：寄存器" class="headerlink" title="第二章：寄存器"></a>第二章：寄存器</h3><ol>
<li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p>
</li>
<li><p>AX、BX、CX、DX这四个寄存器用来存放一般性数据，称为通用寄存器。为了兼容，通常把它们掰为两半来使用,它们可以独立使用：</p>
<ul>
<li>AX → AH + AL</li>
<li>BX → BH + BL</li>
<li>CX → CH + CL</li>
<li>DX → DH + DL</li>
</ul>
</li>
<li><p>在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的。</p>
</li>
<li><p>8086cpu一次性能处理16位地址，但有20位地址总线，于是采用两个16位地址合成来形成一个20位的物理地址。</p>
</li>
<li><p><strong>物理地址 = 段地址 * 16 + 偏移地址</strong>，其含义是用一个基础地址（段地址 * 16）和一个相对于基础地址的偏移地址相加得到物理地址。</p>
</li>
<li><p>将若干地址连续的内存单元看作是一个段，段地址就是该段的起始地址，用偏移地址定位段中的具体位置。其中段地址必然是16的倍数，偏移地址为16位，所以寻址能力为64K，故一个段的长度最大为64K</p>
</li>
<li><p><strong>段寄存器：CS、DS、SS、ES、</strong></p>
</li>
<li><p>8086pc机中，设CS中的内容为M(段地址)，IP中的内容为N(偏移地址)，任意时刻，CPU将从M * 16 + N内存单元读取指令执行。</p>
</li>
<li><p>“ jmp   某一合法寄存器”  ：用寄存器中的值修改 IP。</p>
</li>
<li><p><strong>Debug基本命令：</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R(Register)</td>
<td align="center">查看、改变CPU寄存器中的内容</td>
<td align="center">①查看：直接输入r，②修改寄存器值：r ax，按enter然后输入数据</td>
</tr>
<tr>
<td align="center">D(Dump)</td>
<td align="center">查看内存中的内容</td>
<td align="center">d 段地址：偏移地址 或者 d 段地址：偏移地址段 或d 起始位置  L长度</td>
</tr>
<tr>
<td align="center">E(Enter)</td>
<td align="center">改写内存中的内容</td>
<td align="center">e 起始地址 数据 数据 …  空格键表示处理完成</td>
</tr>
<tr>
<td align="center">U(Unassemble)</td>
<td align="center">将内存中的机器指令翻译为汇编指令</td>
<td align="center">u 段地址：偏移地址</td>
</tr>
<tr>
<td align="center">T(Trace)</td>
<td align="center">执行一条机器指令</td>
<td align="center">输入t ，CPU执行CS:IP指向的指令</td>
</tr>
<tr>
<td align="center">A(Assemble)</td>
<td align="center">以汇编指令的格式在内存中写入一条机器指令</td>
<td align="center">a 段地址：偏移地址，接着输入汇编指令</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="第三章：寄存器-内存访问"><a href="#第三章：寄存器-内存访问" class="headerlink" title="第三章：寄存器(内存访问)"></a>第三章：寄存器(内存访问)</h3><ol>
<li><p>8086CPU用16位来存储一个字，高8位存放在高位字节，低8位存放在低位字节。一个字用两个地址连续的内存单元存放，低位字节在低位地址，高位字节在高位地址。</p>
</li>
<li><p>DS寄存器通常用来存放要要访问的数据的段地址。不支持直接将数据送入段寄存器。</p>
</li>
<li><p>mov、add、sub指令</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">格式</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov</td>
<td align="center">寄存器，数据</td>
<td align="center">mov ax，6</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">寄存器，寄存器</td>
<td align="center">mov ax，bx</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">寄存器，内存单元</td>
<td align="center">mov ax，[8]</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">内存单元，寄存器</td>
<td align="center">mov [9]，ax</td>
</tr>
<tr>
<td align="center">mov</td>
<td align="center">段寄存器，寄存器</td>
<td align="center">mov ds，ax</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">寄存器，数据</td>
<td align="center">add ax，0</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">寄存器，寄存器</td>
<td align="center">add  ax，bx</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">寄存器，内存单元</td>
<td align="center">add ax，[0]</td>
</tr>
<tr>
<td align="center">add</td>
<td align="center">内存单元，寄存器</td>
<td align="center">add [0]，ax</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">寄存器，数据</td>
<td align="center">sub ax，0</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">寄存器，寄存器</td>
<td align="center">aub ax，bx</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">寄存器，内存单元</td>
<td align="center">sub ax，[9]</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">内存单元，寄存器</td>
<td align="center">sub [9]，ax</td>
</tr>
</tbody></table>
</li>
<li><p>入栈：将新元素放到栈顶，出栈：从栈顶取出一个元素。遵循先入后出原则（LIFO）</p>
</li>
<li><p>PUSH（入栈），POP（出栈），以字为单位进行，</p>
</li>
<li><p><strong>任意时刻，SS:SP指向栈顶元素</strong>，push和pop执行时，cpu从ss：sp中得到栈顶地址。</p>
</li>
<li><p>执行PUSH指令时，SP=SP-2，表示栈顶向上移动；执行pop指令时，SP=SP+2，表示栈顶向下移动；当栈为空时，SS:SP指向栈顶内存地址+2的内存单元。</p>
</li>
<li><p>在使用栈的时候，应当注意不要出现越界。</p>
</li>
<li><p>出栈的顺序应该和入栈的顺序相反，这与栈后入先出的特性相关。</p>
</li>
<li><p>PUSH过程：①CPU先改变SP=SP+2，②向SS：SP处传送；</p>
<p>POP过程：①CPU先向SS：SP读取数据，②改变SP的值SP=SP-2。</p>
<p>push和pop指令操作栈的时候，修改的只是SP。</p>
</li>
<li><p>栈的栈顶变化范围：0~FFFFH，所以一个栈段最大容量为64K.</p>
</li>
</ol>
<h3 id="第四章：第一个程序"><a href="#第四章：第一个程序" class="headerlink" title="第四章：第一个程序"></a>第四章：第一个程序</h3><ol>
<li><p>伪指令：由编译器执行的指令，CPU是不知道它们的，由编译器执行它们</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">段名 segment … 段名 ends</td>
<td align="center">定义一个段，segment说明一个段开始，ends说明一个段结束</td>
</tr>
<tr>
<td align="center">ebd</td>
<td align="center">汇编程序结束的标志</td>
</tr>
<tr>
<td align="center">assume</td>
<td align="center">assume cs：code，将段code与寄存器cs关联起来</td>
</tr>
<tr>
<td align="center">mov ax，4c00H    int 21H</td>
<td align="center">两行汇编指令，实现程序返回</td>
</tr>
</tbody></table>
</li>
<li><p>连接（LINK）作用：</p>
<ol>
<li>当源程序很大时，可以将它分为几个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们连接到一起，生成一个可执行文件；</li>
<li>程序中调用来某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>
<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>
</ol>
</li>
<li><p>EXE文件加载过程：找到一段起始地址为0的空闲区，创建一个程序段前缀（PSP），在PSP后256字节开始，即SA+10H:0为段地址载入ds寄存器中，并初始化CS:IP指向这个地址。</p>
</li>
</ol>
<h3 id="第五章：-BX-和loop指令"><a href="#第五章：-BX-和loop指令" class="headerlink" title="第五章：[BX]和loop指令"></a>第五章：[BX]和loop指令</h3><ol>
<li><p>[BX]:</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov ax，[bx]</td>
<td align="center">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即(ax) = ((ds)*16 + (bx))</td>
</tr>
<tr>
<td align="center">mov [bx]，ax</td>
<td align="center">bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA:EA处，即((ds)*16 + (bx)) = (ax)</td>
</tr>
</tbody></table>
</li>
<li><p>loop指令：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">格式</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">loop</td>
<td align="center">loop  标号</td>
<td align="center">实现循环功能，cx中存放着循环次数，就相当于for，cx为0向下执行，不为0循环</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">使用方法：</td>
<td align="center">①在cx中存放循环次数②loop指令中的标号所标识地址在前面③循环执行的程序段在标号和lpp指令之间</td>
</tr>
</tbody></table>
</li>
<li><p>loop指令框架：</p>
<pre class="line-numbers language-asm"><code class="language-asm">     mov cx，循环次数
s：
     循环执行的程序段
     loop s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在汇编源程序中，数据不能以字母开头。所以大于9FFFH的数要在前面加0。</p>
</li>
<li><p>loop指令的每一次都先判断cx的值，不为0则CS：IP指向下一步循环指令的地址，CPU执行。</p>
</li>
<li><p>在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须使用 “[…]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显示的给出段地址所在的段寄存器。</p>
<pre class="line-numbers language-asm"><code class="language-asm">mov al,ds:[0]
//正确的表示

mov al,[0]
//masm就将[idata] 解释为 idata ，而不是一个内存单元地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>用于显示的指明内存单元的段地址的 “ds:” 、”cs:”、”ss:”、”es:”，在汇编语言中成为<strong>段前缀</strong>。</p>
</li>
<li><p>在pc机中，一般 0:200~0:2ff 的256个字节的空间是安全的，即没有其它应用使用这段内存单元。</p>
</li>
</ol>
<h3 id="第六章：包含多个段的程序"><a href="#第六章：包含多个段的程序" class="headerlink" title="第六章：包含多个段的程序"></a>第六章：包含多个段的程序</h3><ol>
<li><p>在操作系统环境中，合法的通过操作系统取得的空间都是安全的，需要在汇编源程序中做出说明</p>
</li>
<li><p>dw(define word) 关键字的意思是定义字型数据，数据之间使用逗号分隔。</p>
</li>
<li><p>将 start 放在第一条指令前面，然后在伪指令 end 后面加上 start，表示程序第一条指令从前面的 start 开始。</p>
</li>
<li><p>内存空间的开辟：使用 dw 关键字定义一些字型数据，通常为 0，然后将这一段空间当作栈段来使用。</p>
</li>
<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据:</p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:codesg
codesg segment
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

start:  mov ax,0
        mov ds,ax
        mov bx,0           ;ds = 0,bx = 0
        mov cx,8           ;循环8次

    s:  mov ax,[bx]        ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax
        mov cs:[bx],ax     ;将ax中的数据放入内存地址 ((cs)*16 + (bx)) 处，[bx]为偏移地址，段地址在cs中
        add bx,2           ;bx + 2
        loop s

        mov ax,4c00h
        int 21h
codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol start="6">
<li><p>使用内存 0:0~0:15 单元中的内容改写为程序中的数据（数据的传送用栈来进行。栈空间设置在程序内）：</p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:codesg
codesg segment
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
        dw 0,0,0,0,0,0,0,0,0,0

start:  mov ax,cs 
        mov ss,ax
        mov sp,24h          ;或mov sp, 36  ，ss:sp = cs:24h
        mov ax,0
        mov ds,ax           ;ds = 0
        mov bx,0            ;bx = 0
        mov cx,8            ;循环8次

    s:  push [bx]           ;将[bx]中的数据压入栈中
        pop cs:[bx]         ;或 pop ss:[bx],
        add bx,2            ;bx + 2
        loop s

        mov ax,4c00h
        int 21h
codesg ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在汇编程序中，一个段的段名就代表了这个段的段地址，而偏移地址需要根据段中的数据来确定。</p>
</li>
<li><p>8086CPU不允许直接将一个数值送入段寄存器，应该由一个寄存器比如 ax 来中转。</p>
</li>
<li><p><strong>汇编语言实验五：</strong></p>
<p><strong>（1）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code,ds:data,ss:stack 

data segment 
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h 
data ends 

stack segment 
        dw 0,0,0,0,0,0,0,0 
stack ends 

code segment 

start:  mov ax,stack 
        mov ss,ax 
        mov sp,16 
        mov ax,data 
        mov ds,ax 

        push ds:[0] 
        push ds:[2] 
        pop ds:[2] 
        pop ds:[0] 

        mov ax,4c00h 
        int 21h 

code ends 
end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>
<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>
<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>
</li>
</ol>
<p><strong>（2）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code,ds:data,ss:stack 

data segment 
        dw 0123h,0456h
data ends 

stack segment 
        dw 0,0
stack ends 

code segment 

start:  mov ax,stack 
        mov ss,ax 
        mov sp,16 
        mov ax,data 
        mov ds,ax 

        push ds:[0] 
        push ds:[2] 
        pop ds:[2] 
        pop ds:[0] 

        mov ax,4c00h 
        int 21h 

code ends 
end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>
<p>②CPU执行程序，程序返回前，CS= 0C88H ，SS= 0C87H ，DS= 0C86H 。</p>
<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X-2 ，STACK段的段地址为 X-1 。</p>
<p>④对于如下定义的段：</p>
<pre class="line-numbers language-asm"><code class="language-asm">name segment

……

name ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为 ((N+15)/16)*16 。</p>
<p>④解析：</p>
<p>N分为被16整除和不被16整除。</p>
<p>当N被16整除时： 占有的空间为(N/16)*16</p>
<p>当N不被16整除时： 占有的空间为(N/16+1)*16，N/16得出的是可以整除的部分，还有一个余数，余数肯定小于16，加上一个16。</p>
<p>程序加载后分配空间是以16个字节为单位的，也就是说如果不足16个字节的也分配16个字节。</p>
<p>两种情况总结成一个通用的公式：((N+15)/16)*16</p>
<p><strong>（3）将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code,ds:data,ss:stack 

code segment 

start:  mov ax,stack 
        mov ss,ax 
        mov sp,16 
        mov ax,data 
        mov ds,ax 

        push ds:[0] 
        push ds:[2] 
        pop ds:[2] 
        pop ds:[0] 

        mov ax,4c00h 
        int 21h 

code ends 

data segment 
        dw 0123h,0456h
data ends 

stack segment 
        dw 0,0
stack ends 

end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①CPU执行程序，程序返回前，data段中的数据 不变 。</p>
<p>②CPU执行程序，程序返回前，CS= 0C86H ，SS= 0C8AH ，DS= 0C89H 。</p>
<p>③设程序加载后，CODE段的段地址为X，则DATA段的段地址为 X+3 ，STACK段的段地址为 X+4 。</p>
<p><strong>（4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。</strong></p>
<p>答：start 作为汇编程序的一个标号，定义了程序的入口，如果不指名入口，程序会从加载进内存的第一个单元起开始执行，前二个题中，前面定义的是数据段、栈段，CPU 能够执行，但在整个程序上来讲，逻辑顺序错误，这样会导致空间二次分配等等情况。</p>
<p>​     如果指明了程序的入口，CPU会直接从入口处开始执行真正的机器码，直到遇到中断指令返回，比如指令进行到需要栈段空间的时候，CPU 会跳到前面定义的栈段得到分配空间的地址。此种方式能够确保程序逻辑上的正确。因此有必要为程序来指明入口。</p>
<p>​    综上，只有（3）可以在没有指明程序入口的情况下正确执行。</p>
<p><strong>（5）程序如下，编写code段中代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cd:code

a segment
    db 1,2,3,4,5,6,7,8
a ends

b segment 
    db 1,2,3,4,5,6,7,8
b ends

c segment 
   db 0,0,0,0,0,0,0,0
c ends

code segment

start: mov ax,a
       mov ds,ax           ;ds段寄存器地址指向a

       mov ax,b
       mov es,ax           ;es段寄存器地址指向b

       mov ax,c
       mov ss,ax           ;ss段寄存器地址指向c

       mov bx,0            ;偏移地址为0
       mov cx,8            ;循环8次

    s: mov ax,[bx]         ;(ax) = ((ds)*16 + (bx)),将对应的数据送入ax
       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中
       mov ax,es:[bx]      ;(ax) = ((es)*16 + (bx)),将对应的数据送入ax
       mov ss:[bx],ax      ;将ax中的数据放入内存地址 ((ss)*16 + (bx)) 处，[bx]为偏移地址，段地址在ss中
       inc bx              ;bx + 1
       loop s


       mov ax,4c00h
       int 21h

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（6）程序如下，编写 code 段中代码，用 push 指令将 a 段中的前8个字型数据，逆序存储到 b 段中。</strong></p>
<pre class="line-numbers language-asm"><code class="language-asm">assume cs:code

a segment
    dw 1,2,3,4,5,6,7,8
a ends

b segment
    dw 0,0,0,0,0,0,0,0
b ends

code segment

start: mov ax,a
       mov ds,ax   ;ds指向a段

       mov ax,b
       mov bx,0    ;ds:bx 指向a段的第1个单元
       mov ss,ax

       mov sp,16   ;设置栈顶指向 b:16
       mov cx,8    ;循环8次

    s: push [bx]
       add bx,2    ;bx + 2
       loop s      ;将a段中0～16个单元逆次入栈

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html">C++学习笔记整理-函数</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-05-08T11:54:09.000Z" itemprop="datePublished">
    2020-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C/">C++</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>前面几章大体上和C差不多，就从函数开始吧。</strong></p>
<h2 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h2><h2 id="1-函数的定义与使用"><a href="#1-函数的定义与使用" class="headerlink" title="1 .函数的定义与使用"></a>1 .函数的定义与使用</h2><h3 id="函数定义的语法形式："><a href="#函数定义的语法形式：" class="headerlink" title="函数定义的语法形式："></a>函数定义的语法形式：</h3><pre class="line-numbers language-c++"><code class="language-c++">类型标识符  函数名（形式参数表）
{  
   语句序列
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>若无返回值，类型标识符写void </li>
<li>形式参数表：是被初始化的内部变量，寿命和可见性仅限于函数内部 </li>
</ul>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p><strong>调用前先声明函数：</strong></p>
<ul>
<li>若函数定义在调用点之前，则无需另外声明； </li>
<li>若函数定义在调用点之后，则需要在调用函数前按如下形式声明函数原型： </li>
</ul>
<p>类型标识符 被调用函数名（含类型说明的形参表）;</p>
<p><strong>调用形式：</strong> </p>
<p>函数名（实参列表）</p>
<ul>
<li>嵌套调用：     在一个函数的函数体中，可以调用另一函数，称为嵌套调用。 </li>
<li>递归调用：     函数直接或间接调用自身。 </li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//1.编写一个求x的n次方的函数

#include <iostream>
using namespace std;

//计算x的n次方
double power(double x,int n)
{
    double val=1.0;
    while(n--)
        val*=x;
    return val;
}

int main()
{
    cout << "5 to the power 2 is :"<< power(5, 2) << endl;
    return 0;
}




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//2.数制转换
//输入一个8位二进制数，将其转换为十进制数输出。
//例如：11012=1(23)+1(22)+0(21)+1(20)=1310 
//所以，如果输入1101，则应输出13

#include <iostream>
using namespace std;

double power (double x,int n); //计算x的n次方

int main()
{
    int  value=0;
    cout <<"Enter an 8 bit binary number ";
    for (int i=7;i>=0;i--) 
    {
      char ch;
      cin>>ch;
      if (ch =='1')
            value+=static_cast<int>(power(2, i));
    }
    cout<<"Decimal value is "<<value<<endl;
    return 0;
}

double power(double x,int n)
{
    double val=1.0;
    while(n--) 
      val*=x;
    return val;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">
/*3.编写程序求π的值
π=16arctan(1/5)-4arctan(1/239)
其中arctan用如下形式的级数计算：
arctanx=x-x^3/3+x^/5-x^7/7+...
直到级数某项绝对值不大于10-15为止；π和x均为double型。*/

#include <iostream>
using namespace std;

double arctan(double x)
{
    double sqr = x * x;
    double e = x;
    double r = 0;
    int i = 1;
    while (e / i > 1e-15) {
        double f = e / i;
        r = (i % 4 == 1) ? r + f : r - f;
        e = e * sqr;
        i += 2;
    }
    return r;
}

int main() 
{
    double a = 16.0 * arctan(1 / 5.0); 
    double b = 4.0 * arctan(1 / 239.0); 
    /* 注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0 */

    cout << "PI = " << a - b << endl;
    return 0;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*4.寻找并输出11~999之间的数m，它满足m、m2和m3均为回文数。
回文：各位数字左右对称的整数。
例如：11满足上述条件 
112=121，113=1331。
分析：
10取余的方法，从最低位开始，依次取出该数的各位数字。按反序重新构成新的数，比较与原数是否相等，若相等，则原数为回文。*/

#include <iostream>
using namespace std;
//判断n是否为回文数
bool symm(unsigned n)
{
  unsigned i = n;
    unsigned m = 0;
    while (i > 0) {
      m = m*10+i%10;
      i/=10;
  }
  return m==n;
}

int main()
{
    for(unsigned m = 11; m < 1000; m++)
      if (symm(m) && symm(m * m) &&
          symm(m * m * m)) {
        cout << "m = " << m;
        cout << "  m * m = " << m * m;
        cout << "  m * m * m = "
             << m * m * m << endl;
      }
    return 0;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>/<em>5.计算如下公式，并输出结果：</em><br>$$<br>k =  \begin{cases}     \sqrt{sin^2r+sin^2s} &amp; \text{}\  当r^2\leqslant s^2\     \frac{1}{2}sin(rs) &amp; \text{}\ 当r^2&gt; s^2&amp;  \end{cases}<br>$$<br>其中r、s的值由键盘输入</p>
<p>sin x的近似值按如下公式计算，计算精度为10-10：</p>
<p>$$ sinx=\frac{x}{1!}+\frac{x^3}{3!}+\frac{x^5}{5!}+\frac{x^7}{7!}+…=\displaystyle \sum_{n=1}^∞(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!} $$</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <cmath>  /*对C++标准库中数学函数的说明*/
using namespace std;

const double TINY_VALUE = 1e-10;

double tsin(double x) 
{
    double g = 0;
    double t = x;
    int n = 1;
    do {
        g += t;
        n++;
        t = -t * x * x / (2 * n - 1) / (2 * n - 2);
    } while (fabs(t) >= TINY_VALUE); 
    return g;
} 

int main() 
{
    double k, r, s;
    cout << "r = ";
    cin >> r;
    cout << "s = ";
    cin >> s;
    if (r * r <= s * s)
      k=sqrt(tsin(r)*tsin(r)+tsin(s)*tsin(s));
    else
      k = tsin(r * s) / 2;
    cout << k << endl;
    return 0;
}



//运行结果：
r=5
s=8
1.37781
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*6.投骰子的随机游戏

每个骰子有六面，点数分别为1、2、3、4、5、6。游戏者在程序开始时输入一个无符号整数，作为产生随机数的种子。
每轮投两次骰子，第一轮如果和数为7或11则为胜，游戏结束；和数为2、3或12则为负，游戏结束；和数为其它值则将此值作为自己的点数，继续第二轮、第三轮...直到某轮的和数等于点数则取胜，若在此前出现和数为7则为负。
由rolldice函数负责模拟投骰子、计算和数并输出和数。

rand
函数原型：int rand(void);
所需头文件：<cstdlib>
功能和返回值：求出并返回一个伪随机数

srand
函数原型：void srand(unsigned int seed);
参数：seed产生随机数的种子。
所需头文件：<cstdlib>
功能：为使rand()产生一序列伪随机整数而设置起始点。使用1作为seed参数，可以重新初化rand()。*/

#include <iostream>
#include <cstdlib>
using namespace std;

//投骰子、计算和数、输出和数
int rollDice() {
    int die1 = 1 + rand() % 6;
    int die2 = 1 + rand() % 6;
    int sum = die1 + die2;
    cout << "player rolled " << die1 << " + " << die2 << " = " << sum << endl;
    return sum;
}

enum GameStatus { WIN, LOSE, PLAYING };

int main() {
    int sum, myPoint;
    GameStatus status;

    unsigned seed; 
    cout<<"Please enter an unsigned integer: ";
    cin >> seed;//输入随机数种子
    srand(seed);//将种子传递给rand()

    sum = rollDice(); //第一轮投骰子、计算和数

switch (sum) {
    case 7:   //如果和数为7或11则为胜,状态为WIN
    case 11:
      status = WIN;
      break;
    case 2:   //和数为2、3或12则为负,状态为LOSE
    case 3: 
    case 12:
      status = LOSE;
      break;
    default: /*其它情况,游戏尚无结果,状态为
            PLAYING,记下点数,为下一轮做准备 */
      status = PLAYING;
      myPoint = sum;
      cout << "point is " << myPoint << endl;
      break;
    }

while (status == PLAYING) { //只要状态仍为PLAYING,就继续进 行下一轮
      sum = rollDice();
      if (sum == myPoint)    //某轮的和数等于点数则取胜
        status = WIN;
      else if (sum == 7)    //出现和数为7则为负
        status = LOSE;
    }

    //当状态不为PLAYING时上面的循环结束,以下程序段输出游戏结果
    if (status == WIN)
      cout << "player wins" << endl;
    else
      cout << "player loses" << endl;

    return 0;
}
//运行结果：
Please enter an unsigned integer:23
player rolled 6 + 3 = 9
point is 9
player rolled 5 + 4 = 9
player wins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>嵌套调用</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">//1.输入两个整数，求平方和

#include <iostream>
using namespace std;

int fun2(int m) 
{
    return m * m;
}

int fun1(int x,int y) 
{
    return fun2(x) + fun2(y);
}

int main() 
{
    int a, b;
    cout<<"Please enter two integers (a and b): ";
    cin >> a >> b;
    cout << "The sum of square of a and  b: " << fun1(a, b) << endl;
    return 0;
}


//运行结果：
Please enter two integers(a and b): 3 4
The sum of square of a and b: 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>递归调用</strong></p>
<p>//1.求n!<br>$$<br>n!=  \begin{cases}     1 &amp; \text{}\ (n=0)  \     n(n-1)! &amp; \text{}\ (n&gt; 0)  \ \end{cases}<br>$$</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

unsigned fac(int n)
{
    unsigned f;
    if (n == 0)
      f = 1;
  else
      f = fac(n - 1) * n;
  return f;
}

int main() 
{
    unsigned n;
    cout << "Enter a positive integer:";
    cin >> n;
    unsigned y = fac(n);
    cout << n << "! = " << y << endl;
    return 0;
}

//运行结果：
Enter a positive integer:8
8! = 40320
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*2.用递归法计算从n个人中选择k个人组成一个委员会的不同组合数。

分析：
   由n个人里选k个人的组合数 = 由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数
当n = k或k = 0时，组合数为1*/

#include <iostream>
using namespace std;

int comm(int n, int k) {
    if (k > n)
      return 0;
    else if (n == k || k == 0)
      return 1;
    else
      return comm(n - 1, k) + comm(n - 1, k - 1);
}

int main() {
    int n, k;
    cout << "Please enter two integers n and k: ";
    cin >> n >> k;
    cout << "C(n, k) = " << comm(n, k) << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3.汉诺塔问题</strong></p>
<p>有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%871.png" alt="img"></p>
<p>分析：</p>
<ul>
<li><strong>将n 个盘子从A针移到C针可以分解为下面三个步骤：</strong></li>
<li>①将A 上n-1个盘子移到 B针上（借助C针）;</li>
<li>②把A针上剩下的一个盘子移到C针上;</li>
<li>③将n-1个盘子从B针移到C针上（借助A针）; </li>
<li><strong>事实上，上面三个步骤包含两种操作：</strong> </li>
<li>①将多个盘子从一个针移到另一个针上，这是一个递归的过程。 hanoi函数实现。</li>
<li>②将1个盘子从一个针上移到另一针上。 用move函数实现</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//3.汉诺塔问题

#include <iostream>
using namespace std;

//把src针的最上面一个盘子移动到dest针上
void move(char src, char dest) { 
    cout << src << " --> " << dest << endl;
}

//把n个盘子从src针移动到dest针，以medium针作为中介
void hanoi(int n, char src, char medium, char dest) {
    if (n == 1)
      move(src, dest);
    else {
      hanoi(n - 1, src, dest, medium);
      move(src, dest);
      hanoi(n - 1, medium, src, dest);
    }
}

int main() {
    int m;
    cout << "Enter the number of diskes: ";
    cin >> m;
    cout << "the steps to moving " << m << " diskes:" << endl;
    hanoi(m,'A','B','C');
    return 0;
}

//运行结果：
Enter the number of diskes:3
the steps to moving 3 diskes:
A --> C
A --> B
C --> B
A --> C
B --> A
B --> C
A --> C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><ul>
<li>在函数被调用时才分配形参的存储单元。 </li>
<li>实参可以是常量、变量或表达式。 </li>
<li>实参类型必须与形参相符。 </li>
<li>值传递是传递参数值，即单向传递。 </li>
<li>引用传递可以实现双向传递 </li>
<li>常引用作参数可以保障实参数据的安全 </li>
</ul>
<p><strong>引用传递</strong></p>
<p>引用(&amp;)是标识符的别名,例如:</p>
<pre class="line-numbers language-c++"><code class="language-c++">int i,j;
int &ri=i;//建立一个int型的引用ri,并将其初始化为变量i的一个别名
j=10;
ri=j;//相当于 i = j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。 一旦一个引用被初始化后，就不能改为指向其它对象。 引用可以作为形参:</p>
<pre class="line-numbers language-c++"><code class="language-c++">void swap(int &a, int &b) {...}
//1.输入两个整数交换后输出

#include<iostream>
using namespace std;
void swap(int& a, int& b) {
    int t = a;
    a = b;
    b = t;
}
int main() {
    int x = 5, y = 10;
    cout << "x = " << x << "  y = " << y << endl;
    swap(x, y);
    cout << "x = " << x << "  y = " << y << endl;
    return 0;
}

//运行结果:
x = 5   y = 10
x = 10  y = 5
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//2.值传递与引用传递的比较

#include <iostream>
#include <iomanip>
using namespace std;
void fiddle(int in1, int &in2) 
{
    in1 = in1 + 100;
    in2 = in2 + 100;
    cout<<"The values are ";
    cout << setw(5) << in1;
    cout << setw(5) << in2 << endl;
}

int main() { 
  int v1=7,v2=12;
  cout << "The values are ";
  cout << setw(5) << v1;
  cout << setw(5) << v2 << endl;
  fiddle(v1, v2);
  cout << "The values are ";
  cout << setw(5) << v1;
  cout << setw(5) << v2 << endl;
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2.内联函数"></a>2.内联函数</h2><ul>
<li>声明时使用关键字 inline。 </li>
<li>编译时在调用处用函数体进行替换,节省了参数传递、控制转移等开销。 </li>
<li>内联函数体内不能有循环语句和switch语句。 </li>
<li>内联函数的声明必须出现在内联函数第一次被调用之前。 </li>
<li>对内联函数不能进行异常接口声明。 </li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//example:

#include <iostream>
using namespace std;

const double PI = 3.14159265358979;
inline double calArea(double radius) {
    return PI * radius * radius;
}

int main() {
    double r = 3.0;
    double area = calArea(r);
    cout << area << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-带默认参数值的函数"><a href="#3-带默认参数值的函数" class="headerlink" title="3.带默认参数值的函数"></a>3.带默认参数值的函数</h2><p>函数在声明时可以预先给出默认的形参值，调用时如给出实参，则采用实参值，否则采用预先给出的默认参数值。</p>
<p>例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x = 5,int y = 6) {
    return x + y;
}
int main() {
    add(10,20);//10+20
    add(10);  //10+6
    add();  //5+6
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>默认参数值的说明次序</strong></p>
<p>有默认参数的形参必须在形参列表的最后，也就是说默认参数值的右面不能有无默认值的参数。因为调用时实参与形参的结合是从左向右的顺序。</p>
<p>例：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x, int y = 5, int z = 6);//正确
int add(int x = 1, int y = 5, int z);//错误
int add(int x = 1, int y, int z = 6);//错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>默认参数值与函数的调用位置</strong></p>
<p>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值必须在函数原型声明中给出；而如果只有函数的定义，或函数定义在前，则默认参数值需在函数定义中给出。 例：</p>
<pre><code>int add(int x = 5,int y = 6);        int add(int x = 5,int y = 6) {
//原型声明在前                         //只有定义，没有原型声明
int main() {                         return  x + y;
  add();                             }
}                                    int main() {
int add(int x,int y) {               add();
//此处不能再指定默认值                   }
  return x + y;
}
</code></pre><h2 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4.函数重载"></a>4.函数重载</h2><p>C++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。</p>
<p>例：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//形参类型不同
int add(int x, int y);
float add(float x, float y);

//形参个数不同
int add(int x, int y);
int add(int x, int y, int z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*1.计算长方体的体积

子函数getVolume是计算体积的函数，有三个形参：length（长）、width（宽）、height（高），其中width和height带有默认值。
主函数中以不同形式调用getVolume函数，分析程序的运行结果。*/

#include <iostream>
#include <iomanip>
using namespace std;

int getVolume(int length, int width = 2, int height = 3);

int main() {
    const int X = 10, Y = 12, Z = 15;
    cout << "Some box data is " ;
    cout << getVolume(X, Y, Z) << endl;
    cout << "Some box data is " ;
    cout << getVolume(X, Y) << endl;
    cout << "Some box data is " ;
    cout << getVolume(X) << endl;
    return 0;
}

int getVolume(int length, int width/* = 2 */, int height/* = 3 */) {
    cout << setw(5) << length << setw(5) << width << setw(5) << height << '\t';
    return length * width * height;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>重载函数的形参必须不同:个数不同或类型不同。 </li>
<li>编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。 </li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x,int y);                     int add(int x,int y);
int add(int a,int b);                     void add(int x,int y);
//编译器不以形参名来区分                        //编译器不以返回值来区分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好：</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x, int y)               float add(float x,float y)
{  return x + y;  }                 {  return x - y;  }
//编写两个名为sumOfSquare的重载函数，分别求两整数的平方和及两实数的平方和。



#include <iostream>
using namespace std;

int sumOfSquare(int a, int b) {
    return a * a + b * b;
}
double sumOfSquare(double a, double b) {
    return a * a + b * b;
}
int main() {
    int m, n;
    cout << "Enter two integer: ";
    cin >> m >> n;
    cout << "Their sum of square: " << sumOfSquare(m, n) << endl;

    double x, y;
    cout << "Enter two real number: ";
    cin >> x >> y;
    cout << "Their sum of square: " << sumOfSquare(x, y) << endl;

    return 0;
}


//运行结果：
Enter two integer: 3 5
Their sum of square: 34
Enter two real number: 2.3 5.8
Their sum of square: 38.93<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="5-使用C-系统函数"><a href="#5-使用C-系统函数" class="headerlink" title="5.使用C++系统函数"></a>5.使用C++系统函数</h2><p>C++的系统库中提供了几百个函数可供程序员使用。 例如：求平方根函数（sprt）、求绝对值函数（abs）等。</p>
<p>使用系统函数时要包含相应的头文件。 例如：cmath 或 math.h</p>
<pre class="line-numbers language-c++"><code class="language-c++">/*1.从键盘输入一个角度值，求出该角度的正弦值、余弦值和正切值。

分析：
系统函数中提供了求正弦值、余弦值和正切值的函数：sin()、cos()、tan()，函数的说明在头文件cmath中。*/


#include <iostream>
#include <cmath>
using namespace std;

const double PI = 3.14159265358979;

int main() {
    double angle;
    cout << "Please enter an angle: ";
    cin >> angle;   //输入角度值

    double radian = angle * PI / 180;   //转化为弧度值
    cout << "sin(" << angle << ") = " << sin(radian) <<endl;
    cout << "cos(" << angle << ") = " << cos(radian) <<endl;
    cout << "tan(" << angle << ") = " << tan(radian) <<endl;
    return 0;
}

//运行结果：
30
sin(30)=0.5
cos(30)=0.866025
tan(30)=0.57735<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html">C++学习笔记整理-类与对象</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-04-26T10:53:44.000Z" itemprop="datePublished">
    2020-04-26
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C/">C++</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h1 id="第四章-类和对象"><a href="#第四章-类和对象" class="headerlink" title="第四章 类和对象"></a>第四章 类和对象</h1><h2 id="1-面向对象程序设计的基本特点"><a href="#1-面向对象程序设计的基本特点" class="headerlink" title="1.面向对象程序设计的基本特点"></a>1.面向对象程序设计的基本特点</h2><h3 id="①抽象"><a href="#①抽象" class="headerlink" title="①抽象"></a>①抽象</h3><p><strong>抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。</strong></p>
<ul>
<li><p>先注意问题的本质及描述，其次是实现过程或细节。</p>
</li>
<li><p>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</p>
</li>
<li><p>代码抽象：描述某类对象的共有的行为特征或具有的功能。</p>
</li>
<li><p>抽象的实现：通过类的声明。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//数据抽象：
int hour,int minute,int second
//代码抽象：
setTime(),showTime()

class  Clock {
  public: 
   void setTime(int newH, int newM, int newS);   void showTime();
  private: 
   int hour, minute, second;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②封装"><a href="#②封装" class="headerlink" title="②封装"></a>②封装</h3><p><strong>将抽象出的数据成员、代码成员相结合，将它们视为一个整体。</strong></p>
<ul>
<li><p>目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</p>
</li>
<li><p>实现封装：类声明中的{}</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//实例：

class  Clock {
  public://公有的访问权限
      void setTime(int newH, int newM, int newS);//外部接口
      void showTime();//外部接口
  private: //私有的访问权限
      int hour, minute, second;
};//边界
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="③继承"><a href="#③继承" class="headerlink" title="③继承"></a>③继承</h3><p><strong>是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。</strong></p>
<ul>
<li>实现：声明派生类</li>
</ul>
<h3 id="④多态"><a href="#④多态" class="headerlink" title="④多态"></a>④多态</h3><p><strong>多态：同一名称，不同的功能实现方式。</strong></p>
<ul>
<li><p>目的：达到行为标识统一，减少程序中标识符的个数。</p>
</li>
<li><p>实现：重载函数和虚函数</p>
</li>
</ul>
<hr>
<h2 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2.类和对象"></a>2.类和对象</h2><h3 id="①类和对象"><a href="#①类和对象" class="headerlink" title="①类和对象"></a>①类和对象</h3><p><strong>类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。</strong></p>
<ul>
<li><p>利用类可以实现数据的封装、隐藏、继承与派生。</p>
</li>
<li><p>利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。</p>
</li>
<li><p>定义一个新的class也就定义了一个新的类型</p>
</li>
</ul>
<h3 id="②类的定义"><a href="#②类的定义" class="headerlink" title="②类的定义"></a>②类的定义</h3><p>类是一种用户自定义类型，声明形式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class 类名称
{
   public:
             公有成员（外部接口）
   private:
             私有成员
   protected:
             保护型成员
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</strong></p>
</li>
<li><p><strong>在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。</strong><br><strong>如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。</strong></p>
</li>
<li><p><strong>protected保护型成员与private类似，其差别表现在继承与派生时对派生类的影响不同</strong></p>
</li>
</ul>
<hr>
<h3 id="③对象"><a href="#③对象" class="headerlink" title="③对象"></a>③对象</h3><p><strong>类的对象是该类的某一特定实体，即类类型的变量。</strong><br>声明形式：</p>
<pre class="line-numbers language-c++c"><code class="language-c++c">类名  对象名；
例：Clock  myClock;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>类中成员互访：直接使用成员名</p>
</li>
<li><p>类外访问：使用“对象名.成员名”方式访问 public 属性的成员</p>
</li>
</ul>
<h3 id="④类的成员函数"><a href="#④类的成员函数" class="headerlink" title="④类的成员函数"></a>④类的成员函数</h3><ul>
<li><p>在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。</p>
</li>
<li><p>允许声明重载函数和带默认形参值的函数</p>
</li>
</ul>
<h3 id="⑤内联成员函数"><a href="#⑤内联成员函数" class="headerlink" title="⑤内联成员函数"></a>⑤内联成员函数</h3><ul>
<li><p><strong>为了提高运行时的效率，对于较简单的函数可以声明为内联形式。</strong></p>
</li>
<li><p>内联函数体中不要有复杂结构（如循环语句和switch语句）。</p>
</li>
</ul>
<p>  在类中声明内联成员函数的方式：</p>
<ul>
<li>将函数体放在类的声明中。</li>
<li>使用inline关键字。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//example.1类的实现
#include<iostream>
using namespace std;
class Clock{
public:        
    void setTime(int newH = 0, int newM = 0, int newS = 0);
    void showTime();
private:    
    int hour, minute, second;
};
int main()
{
    Clock myClock;
    myClock.setTime(8, 30, 30);
    myClock.showTime();
    return 0;
}

void Clock::setTime(int newH, int newM,int newS)
{
   hour=newH;
   minute=newM;
   second=newS;
}
void Clock::showTime() 
{
   cout << hour << ":" << minute << ":" << second;
}


//运行结果：
8:30:30
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//Point类的完整程序

class Point {   //Point 类的定义
public:
    Point(int xx=0, int yy=0) { x = xx; y = yy; }    //构造函数，内联
    Point(const Point& p); //复制构造函数
    void setX(int xx) {x=xx;}
    void setY(int yy) {y=yy;}
    int getX() const { return x; } //常函数（第5章）
    int getY() const { return y; } //常函数（第5章）
private:
    int x, y; //私有数据
};
//成员函数的实现
Point::Point (const Point& p) {
  x = p.x;
  y = p.y;
  cout << "Calling the copy constructor " << endl;
}

//形参为Point类对象的函数
void fun1(Point p) {
    cout << p.getX() << endl;
}
//返回值为Point类对象的函数
Point fun2() {
    Point a(1, 2);
    return a;
}

//主程序
int main() {
    Point a(4, 5);    //第一个对象A
    Point b = a;    //情况一，用A初始化B。第一次调用复制构造函数
    cout << b.getX() << endl;
    fun1(b);    //情况二，对象B作为fun1的实参。第二次调用复制构造函数
    b = fun2();    //情况三，函数的返回值是类对象，函数返回时调用复制构造函数
    cout << b.getX() << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-构造函数和析构函数"><a href="#3-构造函数和析构函数" class="headerlink" title="3.构造函数和析构函数"></a>3.构造函数和析构函数</h2><h3 id="①构造函数"><a href="#①构造函数" class="headerlink" title="①构造函数"></a>①构造函数</h3><ul>
<li><p>类中的特殊函数</p>
</li>
<li><p>用于描述初始化算法</p>
</li>
<li><p>构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。</p>
</li>
<li><p>在对象创建时被自动调用</p>
</li>
<li><p>如果程序中未声明，则系统自动产生出一个默认的构造函数，其参数列表为空</p>
</li>
<li><p>构造函数可以是内联函数、重载函数、带默认参数值的函数</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//构造函数举例
class Clock {
public:
    Clock(int newH,int newM,int newS);//构造函数
    void setTime(int newH, int newM, int newS);
    void showTime();
private:
    int hour, minute, second;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//构造函数的实现：
Clock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) {
    }
建立对象时构造函数的作用：
int main() {
  Clock c(0,0,0); //此处将自动调用构造函数
  c.showTime();
    return 0;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②复制构造函数"><a href="#②复制构造函数" class="headerlink" title="②复制构造函数"></a>②复制构造函数</h3><p><strong>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class 类名 {
public :
    类名（形参）；//构造函数
    类名（const  类名 &对象名）；//复制构造函数
           ...
}；
类名::类（ const  类名 &对象名）//复制构造函数的实现
{    函数体    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>复制构造函数被调用的三种情况</strong></p>
<ul>
<li><p>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</p>
</li>
<li><p>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</p>
</li>
<li><p>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。</p>
</li>
</ul>
<p><strong>有时不应该进行复制和赋值</strong></p>
<ul>
<li>例如，房屋中介系统有一个类描述待售房屋</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">class HomeForSale{…}
//通常没有完全一样的房屋，因此不应有复制构造<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//解决方法一：将不应该有的默认函数定义为私有

class HomeForSale{
public:
    …
private:
    …
    HomeForSale(const HomeForSale&);
    HomeForSale& operator=(const HomeForSale&)

//解决方法二：定义一个Uncopyable类作为基类

class Uncopyable{
protected:
    Uncopyable(){}
    ~ Uncopyable(){}
private:
     Uncopyable(const Uncopyable&);
     Uncopyable operator=(const Uncopyable&);
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="③默认构造函数"><a href="#③默认构造函数" class="headerlink" title="③默认构造函数"></a>③默认构造函数</h3><p><strong>调用时可以不需要参数的构造函数都是默认构造函数。</strong></p>
<ul>
<li><p>当不定义构造函数时，编译器自动产生默认构造函数</p>
</li>
<li><p>在类中可以自定义无参数的构造函数，也是默认构造函数</p>
</li>
<li><p>全部参数都有默认形参值的构造函数也是默认构造函数</p>
</li>
</ul>
<p><strong>下面两个都是默认构造函数，如果在类中同时出现，将产生编译错误：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">Clock();
Clock(int newH=0,int newM=0,int newS=0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//example.1
class Clock {
public:
    Clock(int newH,int newM,int newS);//构造函数
    Clock();//默认构造函数
    void setTime(int newH, int newM, int newS);
    void showTime();
private:
    int hour, minute, second;
};
//构造函数的实现：
Clock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) { }
//默认构造函数的实现：
Clock::Clock(): hour(0), minute(0), second(0) { }

//建立对象时构造函数的作用：
int main() {
  Clock c(8,10,0); //调用有参构造函数
  Clock c2();//调用无参构造函数
  c.showTime();
  c2.showTime();
    return 0;
}

void Clock::setTime(int newH, int newM,int newS)
{
   hour = newH;
   minute = newM;
   second = newS;
}
void Clock::showTime() 
{
   cout << hour << ":" << minute << ":" << second;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>有时不应该有默认的构造函数</strong></p>
<ul>
<li><p>有些类，不应该有默认初始化。<br>例如，没有姓名的学生对象是没有意义的<br>解决：<br>至少定义一个有参数的构造函数<br>不定义默认构造函数</p>
</li>
<li><p>需要深层复制时，默认的复制构造会引起错误。<br>解决：<br>自定义实现深层复制的复制构造函数</p>
</li>
</ul>
<h3 id="④隐含的复制构造函数"><a href="#④隐含的复制构造函数" class="headerlink" title="④隐含的复制构造函数"></a>④隐含的复制构造函数</h3><p>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。</p>
<p>这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</p>
<h3 id="⑤函数参数尽量传递常引用而不是值"><a href="#⑤函数参数尽量传递常引用而不是值" class="headerlink" title="⑤函数参数尽量传递常引用而不是值"></a>⑤函数参数尽量传递常引用而不是值</h3><ul>
<li>传递对象值会引起复制构造和析构，增加时间空间开销。</li>
<li>传常引用可避免这一问题。以引用做参数时，尽量使用常引用。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//例如：
void fun1(const Point &p) {
    cout << p.getX() << endl;
   p.setX(1); //语法错误：p是常引用而setX不是常函数
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基本类型、STL的迭代器和函数对象传值较好。</p>
<h3 id="⑥返回值优化"><a href="#⑥返回值优化" class="headerlink" title="⑥返回值优化"></a>⑥返回值优化</h3><ul>
<li><p>当函数返回一个对象时，会构造临时对象用以返回，这会增加开销。</p>
</li>
<li><p>用返回引用或者指针替代不是好办法。返回指向局部对象的指针或者引用，会引发错误。返回指向动态内存的指针或引用容易忘记动态空间释放，引起内存泄露。</p>
</li>
<li><p>解决显式构造临时对象返回。此举表面上还是构造了一个临时对象，但是编译器通常都会进行优化，使之不产生临时对象。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//例如：
Point fun2() {
    return Point(1, 2);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="⑦析构函数"><a href="#⑦析构函数" class="headerlink" title="⑦析构函数"></a>⑦析构函数</h3><ul>
<li><p>完成对象被删除前的一些清理工作。</p>
</li>
<li><p>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。</p>
</li>
<li><p>如果程序中未声明析构函数，编译器将自动产生一个隐含的析构函数。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//构造函数和析构函数举例

#include <iostream>
using namespace std;
class Point {     
public:
  Point(int xx,int yy);
  ~Point();
  //...其他函数原型
private:
  int x, y;
};

Point::Point(int xx,int yy) {
  x = xx;
  y = yy;
}
Point::~Point() {
}
//...其他函数的实现略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="3-类的组合"><a href="#3-类的组合" class="headerlink" title="3.类的组合"></a>3.类的组合</h2><h3 id="①组合"><a href="#①组合" class="headerlink" title="①组合"></a>①组合</h3><ul>
<li><p>类中的成员数据是另一个类的对象。</p>
</li>
<li><p>可以在已有抽象的基础上实现更复杂的抽象。</p>
</li>
</ul>
<p><strong>类组合的构造函数设计</strong></p>
<ul>
<li>原则：不仅要负责对本类中的基本类型成员数据赋初值，也要对对象成员初始化。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//声明形式：
类名::类名(对象成员所需的形参，本类成员形参)
       :对象1(参数)，对象2(参数)，......
{  
//函数体其他语句
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>构造组合类对象时的初始化次序</strong></p>
<ul>
<li><p>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。</p>
</li>
<li><p>成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。</p>
</li>
<li><p>初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化</p>
</li>
<li><p>处理完初始化列表之后，再执行构造函数的函数体</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//类的组合，线段（Line）类


#include <iostream>
#include <cmath>
using namespace std;
class Point {    //Point类定义
public:
    Point(int xx = 0, int yy = 0) {
        x = xx;
        y = yy;
    }
    Point(Point &p);
    int getX() { return x; }
    int getY() { return y; }
private:
    int x, y;
};
Point::Point(Point &p) {    //复制构造函数的实现
    x = p.x;
    y = p.y;
    cout << "Calling the copy constructor of Point" << endl;
}

public:    //外部接口
    Line(Point xp1, Point xp2);
    Line(Line &l);
    double getLen() { return len; }
private:    //私有数据成员
    Point p1, p2;    //Point类的对象p1,p2
    double len;
};
//组合类的构造函数
Line::Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) {
    cout << "Calling constructor of Line" << endl;
    double x = static_cast<double>(p1.getX() - p2.getX());
    double y = static_cast<double>(p1.getY() - p2.getY());
    len = sqrt(x * x + y * y);
}
Line::Line (Line &l): p1(l.p1), p2(l.p2) {//组合类的复制构造函数
    cout << "Calling the copy constructor of Line" << endl;
    len = l.len;
}

//主函数
int main() {
    Point myp1(1, 1), myp2(4, 5);    //建立Point类的对象
    Line line(myp1, myp2);    //建立Line类的对象
    Line line2(line);    //利用复制构造函数建立一个新对象
    cout << "The length of the line is: ";
    cout << line.getLen() << endl;
    cout << "The length of the line2 is: ";
    cout << line2.getLen() << endl;
    return 0;
}


//运行结果如下：
Calling the copy constructor of Point
Calling the copy constructor of Point
Calling the copy constructor of Point
Calling the copy constructor of Point
Calling constructor of Line
Calling the copy constructor of Point
Calling the copy constructor of Point
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>前向引用声明</strong></p>
<ul>
<li><p>类应该先声明，后使用</p>
</li>
<li><p>如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。</p>
</li>
<li><p>前向引用声明只为程序引入一个标识符，但具体声明在其他地方。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//example

class B;  //前向引用声明
class A {
public:
  void f(B b);
};
class B {
public:
  void g(A a);
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>前向引用声明注意事项</strong></p>
<p>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Fred; //前向引用声明
class Barney {
   Fred x; //错误：类Fred的声明尚不完善
};
class Fred {
   Barney y;
};

//更正
class Fred;    //前向引用声明
class Barney {
public:
  ……
  void method() {
    x.yabbaDabbaDo();    //错误：Fred类的对象在定义之前被使用
  }
 private:
  Fred &x;//正确，经过前向引用声明，可以声明Fred类的对象引用
};

class Fred {
public:
  void yabbaDabbaDo();
private:
  Barney &y;
}; 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>前向引用声明注意事项</strong></p>
<ul>
<li>应该记住：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</li>
</ul>
<hr>
<h2 id="4-UML图形标识"><a href="#4-UML图形标识" class="headerlink" title="4.UML图形标识"></a>4.UML图形标识</h2><h3 id="①UML简介"><a href="#①UML简介" class="headerlink" title="①UML简介"></a>①UML简介</h3><p><strong>UML（Unified Modeling Language）语言是一种可视化的的面向对象建模语言。</strong></p>
<p><strong>UML有三个基本的部分</strong></p>
<ul>
<li><p>事物（Things）UML中重要的组成部分，在模型中属于最静态的部分，代表概念上的或物理上的元素</p>
</li>
<li><p>关系（Relationships）关系把事物紧密联系在一起</p>
</li>
<li><p>图（Diagrams）图是很多有相互相关的事物的组</p>
</li>
</ul>
<h3 id="②UML类图"><a href="#②UML类图" class="headerlink" title="②UML类图"></a>②UML类图</h3><p><strong>举例：Clock类的完整表示:</strong></p>
<table>
<thead>
<tr>
<th>Clock</th>
</tr>
</thead>
<tbody><tr>
<td>- hour:  int</td>
</tr>
<tr>
<td>- minute:  int</td>
</tr>
<tr>
<td>- second:  int</td>
</tr>
<tr>
<td>+ showTime(): void</td>
</tr>
<tr>
<td>+ setTime(newH:int=0,newM:int=0,newS:int=0)</td>
</tr>
</tbody></table>
<p><strong>Clock类的简洁表示</strong></p>
<table>
<thead>
<tr>
<th>Clock</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<h3 id="③对象图"><a href="#③对象图" class="headerlink" title="③对象图"></a>③对象图</h3><table>
<thead>
<tr>
<th align="center">myClock:Clock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">- hour: int</td>
</tr>
<tr>
<td align="center">- minute: int</td>
</tr>
<tr>
<td align="center">- second: int</td>
</tr>
</tbody></table>
<h3 id="④几种关系的图形标识"><a href="#④几种关系的图形标识" class="headerlink" title="④几种关系的图形标识"></a>④几种关系的图形标识</h3><p><strong>依赖关系</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%875.png" alt></p>
<p>图中的“类A”是源，“类B”是目标，表示“类A”使用了“类B”，或称“类A”依赖“类B”</p>
<p><strong>作用关系—关联</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%874.png" alt></p>
<p>图中的“重数A”决定了类B的每个对象与类A的多少个对象发生作用，同样“重数B”决定了类A的每个对象与类B的多少个对象发生作用。</p>
<p><strong>包含关系—聚集和组合</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%876.png" alt></p>
<p>聚集表示类之间的关系是整体与部分的关系，“包含”、“组成”、“分为……部分”等都是聚集关系。共享聚集：部分可以参加多个整体；组成聚集：整体拥有各个部分，整体与部分共存，如果整体不存在了，那么部分也就不存在了。</p>
<p><strong><em>采用UML方法来描述例4-4中Line类和Point类的关系</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%878.png" alt></p>
<p><strong>继承关系—泛化</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%877.png" alt></p>
<p><strong><em>带有注释的Line类和Point类关系的描述</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%873.png" alt></p>
<p><strong>注释</strong></p>
<p>在UML图形上，注释表示为带有褶角的矩形，然后用虚线连接到UML的其他元素上，它是一种用于在图中附加文字注释的机制。</p>
<h2 id="5-结构体和联合体"><a href="#5-结构体和联合体" class="headerlink" title="5.结构体和联合体"></a>5.结构体和联合体</h2><h3 id="①结构体"><a href="#①结构体" class="headerlink" title="①结构体"></a>①结构体</h3><p><strong>结构体是一种特殊形态的类</strong></p>
<ul>
<li><p>与类的唯一区别：类的缺省访问权限是private，结构体的缺省访问权限是public</p>
</li>
<li><p>结构体存在的主要原因：与C语言保持兼容</p>
</li>
</ul>
<p><strong>什么时候用结构体而不用类</strong></p>
<ul>
<li><p>定义主要用来保存数据、而没有什么操作的类型</p>
</li>
<li><p>人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便</p>
</li>
</ul>
<p><strong>结构体的定义和初始化</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">//结构体定义
struct 结构体名称 {
     公有成员
protected:
    保护型成员
private:
     私有成员
};


//一些结构体变量的初始化可以用以下形式
类型名 变量名 = { 成员数据1初值, 成员数据2初值, …… };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//1.用结构体表示学生的基本信息

#include <iostream>
#include <iomanip>
#include <string>
using namespace std;

struct Student {    //学生信息结构体
    int num;        //学号
    string name;    //姓名，字符串对象，将在第6章详细介绍
    char sex;        //性别
    int age;        //年龄
};

int main() {
    Student stu = { 97001, "Lin Lin", 'F', 19 };
    cout << "Num:  " << stu.num << endl;
    cout << "Name: " << stu.name << endl;
    cout << "Sex:  " << stu.sex << endl;
    cout << "Age:  " << stu.age << endl;
    return 0;
}

//运行结果：
Num:  97001
Name: Lin Lin
Sex:  F
Age:  19
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②联合体"><a href="#②联合体" class="headerlink" title="②联合体"></a>②联合体</h3><pre class="line-numbers language-c++"><code class="language-c++">//声明形式
union 联合体名称 {
    公有成员
protected:
    保护型成员
private:
    私有成员
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>特点：</strong></p>
<ul>
<li><p>成员共用相同的内存单元</p>
</li>
<li><p>任何两个成员不会同时有效</p>
</li>
</ul>
<p><strong>联合体的内存分配</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">union Mark {    //表示成绩的联合体
    char grade;    //等级制的成绩
    bool pass;    //只记是否通过课程的成绩
    int percent;    //百分制的成绩
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%872.png" alt></p>
<p><strong>无名联合</strong></p>
<p>无名联合没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问。</p>
<pre class="line-numbers language-c++"><code class="language-c++">例：
union {
  int i;
  float f;
}
//在程序中可以这样使用：
i = 10;
f = 2.2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//example.使用联合体保存成绩信息，并且输出。

#include <string>
#include <iostream>
using namespace std;
class ExamInfo {
private:
    string name;    //课程名称
    enum { GRADE, PASS, PERCENTAGE } mode;//采用何种计分方式
    union {
        char grade;    //等级制的成绩
        bool pass;    //只记是否通过课程的成绩
        int percent;    //百分制的成绩
    };

public:
    //三种构造函数，分别用等级、是否通过和百分初始化
    ExamInfo(string name, char grade)
        : name(name), mode(GRADE), grade(grade) { }
    ExamInfo(string name, bool pass)
        : name(name), mode(PASS), pass(pass) { }
    ExamInfo(string name, int percent)
        : name(name), mode(PERCENTAGE), percent(percent) { }
    void show();
}

void ExamInfo::show() {
    cout << name << ": ";
    switch (mode) {
      case GRADE: cout << grade;  break;
      case PASS: cout << (pass ? "PASS" : "FAIL"); break;
      case PERCENTAGE: cout << percent; break;
    }
    cout << endl;
}

int main() {
    ExamInfo course1("English", 'B');
    ExamInfo course2("Calculus", true);
    ExamInfo course3("C++ Programming", 85);
    course1.show();
    course2.show();
    course3.show();
    return 0;
}

//运行结果：
English: B
Calculus: PASS
C++ Programming: 85<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-bian-cheng-ti-mu-zheng-he.html">C++编程题目整合</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-04-26T10:51:17.000Z" itemprop="datePublished">
    2020-04-26
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C/">C++</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>就从第四章类与对象开始吧，前面的章节和c差不多。</strong></p>
<h3 id="1-点类定义和使用"><a href="#1-点类定义和使用" class="headerlink" title="1.点类定义和使用"></a>1.点类定义和使用</h3><p><strong>【问题描述】</strong></p>
<p>定义一个点类，该类包含整形坐标x,y以及用于设置坐标值的函数，名为setxy（）参数自行确定，以及用于显示坐标的函数displayxy()参数自行设置。合理编写主函数，能够实现（3，4）以及（5，6）固定两个点对象的参数设置，以及信息输出</p>
<p><strong>【输入形式】</strong></p>
<p>无数据输入，请一定使用类的定义以及对象的创建的相关知识</p>
<p><strong>【输出形式】</strong></p>
<p>输出两个固定点的相关信息</p>
<p><strong>【样例输入】</strong></p>
<p><strong>【样例输出】</strong></p>
<p>The first point is:(3,4)</p>
<p>The second point is:(5,6)</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>
using namespace std;
class Point {
    public:
              Point(int a,int b) 
              {     x=a;
                  y=b;
            } 
          void setxy(int a,int b)
          {
                x=a;
                y=b;
          }
                  void display()
         {
             cout<<"The first point is"<<":"<<"("<<x<<","<<y<<")"<<endl;
             //cout<<"The second point is"<<":"<<"("<<5<<","<<6<<")"<<endl;
         }
    private: 
        int x,y;
};
int main()
{
    //int a,b,c,d;
    Point s1(3,4);
    Point s2(5,6);
    //s.setxy(3,4);
    //s.display();
    //s.setxy(5,6);
    s1.display();
    s2.display();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="2-三角形类"><a href="#2-三角形类" class="headerlink" title="2.三角形类"></a>2.三角形类</h3><p><strong>【问题描述】</strong></p>
<p>定义一个描述三角形的类Tri，其具体要求为：  </p>
<p>（1）私有数据成员为三角形的三边 </p>
<p> （2）公有成员函数      构造函数：用以初始化指定的三角形对象；求三角形的边长的成员函数；求三角形面积的成员函数；输出三角形各种参数的成员函数即用以输出三角形对象的边长、周长和面积。</p>
<p><strong>【输入形式】</strong></p>
<p>输入三角形的三边长 【输出形式】若构成三角形，输出三角形的边长、周长及面积，否则输出“不构成三角形!” </p>
<p><strong>【样例输入1】</strong></p>
<p>  3 4 5 </p>
<p><strong>【样例输出1】</strong>    </p>
<p>三角形的边长:3 4 5  三角形的周长:12  三角形的面积:6</p>
<p><strong>【样例输入1】</strong> </p>
<p> 1 2 3 </p>
<p><strong>【样例输出1】</strong>   </p>
<p> 不构成三角形!</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>
#include<math.h>
using namespace std; 

class Tri
{
        double a,b,c;  //定义三角形的三边
    public:
        Tri(double x, double y, double z) //构造函数，初始化三边
        {        a=x; b=y;c=z;        }

        double Peri()  //返回三角形的周长
        {        return (a+b+c);        }

        double Area()  //返回三角形的面积
        {    double s=Peri()/2;
            double area=sqrt(s*(s-a)*(s-b)*(s-c));
            return area;
        }

        void Show() //输出三角形的参数
        {    cout<<"三角形的边长:"<<a<<' '<<b<<' '<<c<<endl;
            cout<<"三角形的周长:"<<Peri()<<endl;
            cout<<"三角形的面积:"<<Area()<<endl<<endl;
        }

};//三角形类的定义结束，定义了三角形的各种属性和可实施的操作

int main()
{    double x,y,z;
    cin>>x>>y>>z;
    Tri tri(x,y,z);

    if(x+y>z&&y+z>x&&x+z>y)
        tri.Show();  //输出这两个三角形的参数
    else
        cout<<"不构成三角形!"<<endl;

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="3-设计一个Time类"><a href="#3-设计一个Time类" class="headerlink" title="3.设计一个Time类"></a>3.设计一个Time类</h3><p><strong>【问题描述】</strong></p>
<p>定义了一个以hours, minutes和seconds作为数据成员的Time类。设计了成员函数将两个Time对象相加（即时间相加），并进行相应的检查，查看增加的分钟数及秒数是否大于59。如果秒数大于59，则分钟数向前递增1。类似地，如果分钟数大于59，则小时数向前增1。</p>
<p><strong>【输入形式】</strong></p>
<p>输入两个由时、分、秒构成的时间。 </p>
<p><strong>【输出形式】</strong></p>
<p>输出输入的两个时间相加后的时间</p>
<p> <strong>【样例输入】</strong></p>
<p>  2 34 45  1 47 56</p>
<p><strong>【样例输出】</strong></p>
<p>  the result is:4:22:41</p>
<p><strong>【样例输入】</strong></p>
<p>​    2 67 100  1 56 200</p>
<p><strong>【样例输出】</strong></p>
<p>  the result is:5:8:0</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>
using namespace std; 

class Time
{
    private:
          int hours, minutes, seconds;
    public:
        void get_time()
        {
            cin>>hours>>minutes>>seconds;
        }

        void display_time()
        {
            cout<<hours<<':'<<minutes<<':'<<seconds<<endl;
        }

        void add_time(Time & t1, Time & t2)
        {    int tmp; 
            hours=t1.hours+t2.hours;
            minutes=t1.minutes+t2.minutes;
            seconds=t1.seconds+t2.seconds;
            if(seconds>=60)
            {  tmp=seconds/60;
               seconds-=tmp*60;
               minutes=minutes+tmp;
            }
            if(minutes>=60)
            {  tmp=minutes/60;
               minutes-=tmp*60;
               hours=hours+tmp;
            }
        }
};

int main()
{
       Time one, two, three;
       //cout<<"Enter the first time(hours minutes seconds):";
       one.get_time();
       //cout<<"Enter the second time(hours minutes seconds):";
       two.get_time();
       three.add_time(one,two);
       cout<<"the result is:";
       three.display_time();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="4-datatype-数据类型-类"><a href="#4-datatype-数据类型-类" class="headerlink" title="4.datatype(数据类型)类"></a>4.datatype(数据类型)类</h3><p><strong>【问题描述】</strong></p>
<p>声明一个datatype(数据类型)类，该类能够根据用户的输入，确定输入的数据类型，能处理包含字符型、整形、浮点型3种类型的数据，并给出合理的输出。提示：需要进行构造函数的重载</p>
<p><strong>【输入形式】</strong></p>
<p>给用户选择，当输入1时，选择输入整型；输入2时，输入字符型；选择3时，输入浮点型。不考虑其他错误情况</p>
<p><strong>【输出形式】</strong></p>
<p>输入该数据以及该数据的类型</p>
<p><strong>【样例输入1】</strong></p>
<p>2c</p>
<p><strong>【样例输出1】</strong></p>
<p>character:c</p>
<p><strong>【样例输入2】</strong></p>
<p>112</p>
<p><strong>【样例输出2】</strong></p>
<p>int:12</p>
<p><strong>【样例输入3】</strong></p>
<p>31.44F</p>
<p><strong>【样例输出3】</strong></p>
<p>float:1.44</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

class DataType{
    enum
    {
        character,
        integer,
        floating_point
    } vartype;
    union 
    {
        char c;
        int i;
        float f;
    };
    public:
        DataType(char ch) 
        {
            vartype = character;
            c = ch;
        }

        DataType(int ii) 
        {
            vartype = integer;
            i = ii;
        }

        DataType(float ff) 
        {
            vartype = floating_point;
            f = ff;
        }
        void print();
};

void DataType::print() 
{
    switch (vartype) 
    {
        case character:
            cout << "字符型: " << c << endl;
            break;
        case integer:
            cout << "整型: " << i << endl;
            break;
        case floating_point:
            cout << "浮点型: " << f << endl;
            break;
    }
}

int main() 
{    DataType a('c'), b(12), c(1.44F);
    a.print();
    b.print();
    c.print();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="5-复数类Complex"><a href="#5-复数类Complex" class="headerlink" title="5.复数类Complex"></a>5.复数类Complex</h3><p><strong>【问题描述】</strong></p>
<p>定义一个复数类，使得下面的代码能够工作：    </p>
<p>Complex c1(3,5);   </p>
<p> Complex c2=4.5;   </p>
<p> c1.add(c2);    </p>
<p> c1.show(); </p>
<p><strong>【输入形式】</strong></p>
<p>无 </p>
<p><strong>【输出形式】</strong> </p>
<p>c1=3 + 5i </p>
<p>c2=4.5 + 0i  </p>
<p>c1+c2=7.5 + 5i</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

class Complex {
    public:
        Complex(double r, double i) :real(r), image(i) { }
        Complex(double r) :real(r), image(0) {}
        void show();
        void add(Complex c2);

    private:
        double real;
        double image;
};
void Complex::add(Complex c2) {
    real += c2.real;
    image += c2.image;
}

void Complex::show() {
    cout << real << "+";
    cout << image << "i";
    cout << endl;
}

int main() {
    Complex c1(3, 5);
    Complex c2=4.5;
    cout<<"c1=";
    c1.show();
    cout<<"c2=";
    c2.show();
    c1.add(c2);
    cout<<"c1+c2=";
    c1.show();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="6-计算由圆和正方形构成的阴影部分的面积"><a href="#6-计算由圆和正方形构成的阴影部分的面积" class="headerlink" title="6.计算由圆和正方形构成的阴影部分的面积"></a>6.计算由圆和正方形构成的阴影部分的面积</h3><p><strong>【问题描述】</strong></p>
<p>定义一个圆形类，属性有半径和相应的成员函数。然后定义一个正方形类，属性有边长和相应的成员函数。再编写一个如下图所示的组合类，由一个正方型和一个圆形组成，要求该组合类能求出阴影部分面积和周长。</p>
<p><img src="http://jsjjs.ctbu.edu.cn/userfiles/image/2020/1586088754215004939.png" alt="image.png"></p>
<p><strong>【输入形式】</strong></p>
<p>无 </p>
<p><strong>【输出形式】</strong> </p>
<p> 自定义图形的面积49.2656  自定义图形的周长29.1328  自定义图形的面积109.098  自定义图形的周长45.6992</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std; 

const double  PI=3.1416;
/**********Program**********/
class Box  //正方形类 
{
    private:
        int A;
    public:
        Box( ){ }  //默认构造函数 
        Box(int x){    A=x;}  //构造函数 
        void set(double a){ A=a;}  //设置边长 
        double S(){    return A*A;    }  //求面积 
        double BL(){    return 4*A;    }  //求周长 
};

class circle  //圆类 
{
    private:
        int B;
    public:
          circle( ){ }; //默认构造函数 
        circle(int x){B=x;} //构造函数
        void set(double b){ B=b;} //设置半径
        double CL(){    return 2*PI*B;    } //求周长 
        double S(){ return PI*B*B;}   //求面积
};

class NewStyle  //组合类 
{
    private:
        circle A;
        Box B;
    public:
        NewStyle( ) {} //默认构造函数
        NewStyle(circle x,Box y):A(x),B(y){}  //构造函数
        void set(circle x,Box y){ A=x;B=y;}  //设置组合图形 
        double S(){    return A.S()-B.S();}     //求面积
        double L(){    return A.CL()+B.BL();};  //求周长
} ; 
/**********  End  **********/

int main()
{
    circle A(4);  //圆的半径为4
    Box B(1);   //正方形的边长为1
    NewStyle C(A,B);  
    cout<<"自定义图形的面积"<<C.S()<<endl; 
    cout<<"自定义图形的周长"<<C.L()<<endl; 
    A.set(6);   //圆的半径变为6
    B.set(2);   //正方形的边长变为2
    C.set(A,B);
    cout<<"自定义图形的面积"<<C.S()<<endl; 
    cout<<"自定义图形的周长"<<C.L()<<endl; 
    return 0;
}  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="7-CPU类"><a href="#7-CPU类" class="headerlink" title="7.CPU类"></a>7.CPU类</h3><p><strong>【问题描述】</strong></p>
<p>声明一个CPU类。包含等级(rank)、频率(frequency)、电压(voltage)等属性，有两个公有成员函数run、stop，分别提示“CPU开始运行!”和“CPU停止运行!”。其中，rank为枚举类型CPU_Rank，声明为enum CPU_Rank{ P1=1, P2, P3, P4, P5, P6, P7 }; frequency为单位是MHz的整型数，voltage为浮点型的电压值。用2个CPU对象进行测试观察构造函数和析构函数的调用顺序。</p>
<p><strong>【输入形式】</strong></p>
<p>输入CPU的等级，1表示P1，3代表P3</p>
<p><strong>【输出形式】</strong></p>
<p>CPU对象的相关信息：构造函数、析构函数的调用情况，CPU对象的运行状况及CPU的等级</p>
<p><strong>【样例输入1】</strong></p>
<p>  2 5 </p>
<p><strong>【样例输出1】</strong> </p>
<p> 构造了一个CPU! </p>
<p> 构造了一个CPU! </p>
<p> CPU开始运行! </p>
<p> 等级为:2  </p>
<p>CPU停止运行!</p>
<p>  CPU开始运行!  </p>
<p>等级为:5  </p>
<p>CPU停止运行!</p>
<p> 析构了一个CPU!  </p>
<p>析构了一个CPU!</p>
<p><strong>【样例输入2】</strong> </p>
<p> 1 7 </p>
<p><strong>【样例输出2】</strong> </p>
<p> 构造了一个CPU!  </p>
<p>构造了一个CPU!  </p>
<p>CPU开始运行!  </p>
<p>等级为:1 </p>
<p> CPU停止运行!  </p>
<p>CPU开始运行!  </p>
<p>等级为:7  </p>
<p>CPU停止运行!  </p>
<p>析构了一个CPU!  </p>
<p>析构了一个CPU! </p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

enum CPU_Rank {P1=1,P2,P3,P4,P5,P6,P7};
class CPU
{
    private:
        CPU_Rank rank;
        int frequency;
        float voltage;
    public:
        CPU (CPU_Rank r, int f, float v)
        {
            rank = r;
            frequency = f;
            voltage = v;
            cout << "构造了一个CPU!" << endl;
        }

        ~CPU () { cout << "析构了一个CPU!" << endl; }

        CPU_Rank GetRank() const { return rank; }
        int GetFrequency() const { return frequency; }
        float GetVoltage() const { return voltage; }

        void SetRank(CPU_Rank r) { rank = r; }
        void SetFrequency(int f) { frequency = f; }
        void SetVoltage(float v) { voltage = v; }

        void Run() {cout << "CPU开始运行!" << "\n等级为:"<<rank<<endl; }
        void Stop() {cout << "CPU停止运行!" << endl; }
};

int main()
{
    int r1,r2;
    cin>>r1>>r2;
    CPU a((CPU_Rank)r1,300,2.8);
    CPU b((CPU_Rank)r2,800,8.8);
    a.Run();
    a.Stop();
    b.Run();
    b.Stop();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>持续更新中</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-xue-xi-bi-ji-zheng-li-di-wu-zhang-shu-ju-de-gong-xiang-yu-bao-hu.html">C++学习笔记整理-数据的共享与保护</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-04-23T04:59:54.000Z" itemprop="datePublished">
    2020-04-23
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C/">C++</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <hr>
<h1 id="第五章数据的共享与保护"><a href="#第五章数据的共享与保护" class="headerlink" title="第五章数据的共享与保护"></a>第五章数据的共享与保护</h1><h2 id="1-标识符的作用域与可见性"><a href="#1-标识符的作用域与可见性" class="headerlink" title="1.标识符的作用域与可见性"></a>1.标识符的作用域与可见性</h2><h3 id="①作用域"><a href="#①作用域" class="headerlink" title="①作用域"></a>①作用域</h3><p><strong>作用域是一个标识符在程序正文中有效的区域。</strong></p>
<ul>
<li><p>函数原型作用域</p>
</li>
<li><p>局部作用域(块作用域)</p>
</li>
<li><p>类作用域</p>
</li>
<li><p>文件作用域</p>
</li>
<li><p>命名空间作用域</p>
</li>
</ul>
<p><strong>函数原形的作用域</strong></p>
<p>函数原型中的参数，其作用域始于”(“，结束于”)”。</p>
<pre class="line-numbers language-c++"><code class="language-c++">//例如，设有下列原型声明：
double area(double radius);
//radius 的作用域仅在于此area，不能用于程序正文其他地方，因而可有可无。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>局部作用域</strong></p>
<p>函数的形参，在块中声明的标识符，其作用域自声明处起，限于块中，例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">void fun(int a) {
   int b = a;
   cin >> b;
   if (b > 0) {
     int c;

     ......
   }
}

//a的作用域是整个fun函数，b作用域在fun函数内，而c作用域在if语句内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>类作用域</strong></p>
<ul>
<li><p>类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。</p>
</li>
<li><p>如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）。</p>
</li>
</ul>
<p><strong>文件作用域</strong></p>
<p>不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束于文件尾。</p>
<pre class="line-numbers language-c++"><code class="language-c++">//example.1
#include <iostream>
using namespace std;

int i;                //全局变量，文件作用域
int main() { 
     i = 5;            //为全局变量i赋值
     {                //子块1
         int i;        //局部变量，局部作用域
         i = 7;
         cout << "i = " << i << endl;//输出7
      }
      cout << “i = ” << i << endl;//输出5
      return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②可见性"><a href="#②可见性" class="headerlink" title="②可见性"></a>②可见性</h3><ul>
<li><p>可见性是从对标识符的引用的角度来谈的概念</p>
</li>
<li><p>可见性表示从内层作用域向外层作用域“看”时能看见什么。</p>
</li>
<li><p>如果标识在某处可见，则就可以在该处引用此标识符。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%879.png" alt></p>
<ul>
<li>标识符应声明在先，引用在后。</li>
<li>如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见。</li>
<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。</li>
</ul>
<p><strong>同一作用域中的同名标识符</strong></p>
<ul>
<li><p>在同一作用域内的对象名、函数名、枚举常量名会隐藏同名的类名或枚举类型名。</p>
</li>
<li><p>重载的函数可以有相同的函数名。</p>
</li>
</ul>
<hr>
<h2 id="2-对象的生存期"><a href="#2-对象的生存期" class="headerlink" title="2.对象的生存期"></a>2.对象的生存期</h2><p><strong>对象从产生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的值，直到被更新为止。</strong></p>
<p><strong>①静态生存期</strong></p>
<ul>
<li><p>这种生存期与程序的运行期相同。</p>
</li>
<li><p>在文件作用域中声明的对象具有这种生存期。</p>
</li>
<li><p>在函数内部声明静态生存期对象，要冠以关键字static 。</p>
</li>
</ul>
<p><strong>②动态生存期</strong></p>
<ul>
<li><p>块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。</p>
</li>
<li><p>开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//1.变量的生存期与可见性


#include<iostream>
using namespace std;
int i = 1; // i 为全局变量，具有静态生存期。
void other() {
  static int a = 2;
  static int b;
   // a,b为静态局部变量，具有全局寿命，局部可见。
   //只第一次进入函数时被初始化。
  int c = 10; // C为局部变量，具有动态生存期，
            //每次进入函数时都初始化。
  a += 2; i += 32; c += 5;
  cout<<"---OTHER---\n";
  cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
  b = a;
}

int main() {
  static int a;//静态局部变量，有全局寿命，局部可见。
  int b = -10; // b, c为局部变量，具有动态生存期。
  int c = 0;
    cout << "---MAIN---\n";
  cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
  c += 8; other();
  cout<<"---MAIN---\n";
  cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
  i += 10; other();  
    return 0;
}

//运行结果：
---MAIN---
 i: 1 a: 0 b: -10 c: 0
---OTHER---
 i: 33 a: 4 b: 0 c: 15
---MAIN---
 i: 33 a: 0 b: -10 c: 8
---OTHER---
 i: 75 a: 6 b: 4 c: 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-类的静态成员"><a href="#3-类的静态成员" class="headerlink" title="3.类的静态成员"></a>3.类的静态成员</h2><p><strong>静态数据成员</strong></p>
<ul>
<li><p>用关键字static声明</p>
</li>
<li><p>为该类的所有对象共享，静态数据成员具有静态生存期。</p>
</li>
<li><p>必须在类外定义和初始化，用(::)来指明所属的类。</p>
</li>
</ul>
<p><strong>具有静态数据成员的Point类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%8710.png" alt></p>
<pre class="line-numbers language-c++"><code class="language-c++">//1.具有静态数据成员的Point类

#include <iostream>
using namespace std;

class Point {    //Point类定义
public:    //外部接口
    Point(int x = 0, int y = 0) : x(x), y(y) { //构造函数
        //在构造函数中对count累加，所有对象共同维护同一个count
        count++;
    }
    Point(Point &p) {    //复制构造函数
        x = p.x;
        y = p.y;
        count++;
    }
    ~Point() {  count--; }
    int getX() { return x; }
    int getY() { return y; }

 void showCount() {        //输出静态数据成员
        cout << "  Object count = " << count << endl;
    }
private:    //私有数据成员
    int x, y;
    static int count;    //静态数据成员声明，用于记录点的个数
};
int Point::count = 0;//静态数据成员定义和初始化，使用类名限定
int main() {    //主函数
    Point a(4, 5);    //定义对象a，其构造函数回使count增1
    cout << "Point A: " << a.getX() << ", " << a.getY();
    a.showCount();    //输出对象个数

    Point b(a);    //定义对象b，其构造函数回使count增1
    cout << "Point B: " << b.getX() << ", " << b.getY();
    b.showCount();    //输出对象个数
    return 0;
}



//运行结果：
 Point A: 4, 5  Object count=1
 Point B: 4, 5  Object count=2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>静态函数成员</strong></p>
<ul>
<li>类外代码可以使用类名和作用域操作符来调用静态成员函数。</li>
<li>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。</li>
</ul>
<p><strong>具有静态数据、函数成员的 Point类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%8711.png" alt></p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

class Point {    //Point类定义
public:    //外部接口
    Point(int x = 0, int y = 0) : x(x), y(y) { //构造函数
        //在构造函数中对count累加，所有对象共同维护同一个count
        count++;
    }    
    Point(Point &p) {    //复制构造函数
        x = p.x;
        y = p.y;
        count++;
    }
    ~Point() {  count--; }
    int getX() { return x; }
    int getY() { return y; }

    static void showCount() {        //静态函数成员
        cout << "  Object count = " << count << endl;
    }

private:    //私有数据成员
    int x, y;
    static int count;    //静态数据成员声明，用于记录点的个数
};

int Point::count = 0;//静态数据成员定义和初始化，使用类名限定

int main() {    //主函数
    Point a(4, 5);    //定义对象a，其构造函数回使count增1
    cout << "Point A: " << a.getX() << ", " << a.getY();
    Point::showCount();    //输出对象个数

    Point b(a);    //定义对象b，其构造函数回使count增1
    cout << "Point B: " << b.getX() << ", " << b.getY();
    Point::showCount();    //输出对象个数

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="4-类的友元"><a href="#4-类的友元" class="headerlink" title="4.类的友元"></a>4.类的友元</h2><p>友元是C++提供的一种破坏数据封装和数据隐藏的机制。</p>
<p>通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。</p>
<p>可以使用友元函数和友元类。</p>
<p>为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-yu-yan-bian-cheng-ti-mu-zheng-he.html">C语言编程题目整合</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-04-13T06:50:08.000Z" itemprop="datePublished">
    2020-04-13
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/代码整合/">代码整合</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C语言/">C语言</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>做过的题目渐渐变得生疏，索性记录在博客上，看着更直观些，好记性不如烂笔头！</strong></p>
<hr>
<h3 id="1-数值变换"><a href="#1-数值变换" class="headerlink" title="1.数值变换"></a>1.数值变换</h3><p><strong>【问题描述】</strong></p>
<p> 编写一程序，从键盘输入输入一个三位正整数，然后反向输出对应的数，如果输入的数不是三位正整数，则输出－1。 </p>
<p><strong>【输入形式】</strong> </p>
<p>从键盘输入三位的正整数。 </p>
<p><strong>【输出形式】</strong></p>
<p> 输出交换后的正整数值。 </p>
<p><strong>【输入样例】</strong></p>
<p> 356  </p>
<p><strong>【输出样例】</strong></p>
<p> 653 </p>
<p><strong>【样例说明】</strong></p>
<p>从键盘输入的正整数值为356，将该数的个位与百位互换，所得结果为653.如果输入的正整数为300，则输出为3。 </p>
<p><strong>【评分标准】</strong> </p>
<p>结果完全正确得20分，每个测试点4分。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">>=</span><span class="token number">100</span><span class="token operator">&amp;&amp;</span>a<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        b<span class="token operator">=</span>a<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>    
        c<span class="token operator">=</span>a<span class="token operator">%</span><span class="token number">100</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
        d<span class="token operator">=</span>a<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span>c<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="2-sinx计算公式"><a href="#2-sinx计算公式" class="headerlink" title="2.sinx计算公式"></a>2.sinx计算公式</h3><p><strong>【问题描述】</strong></p>
<p>已知sinx的近似计算公式如下： sin x = x - x3/3! + x5/5! - x7/7! + … + (-1)n-1x2n-1/(2n-1)! 其中x为弧度，n为正整数。编写程序根据用户输入的x和n的值，利用上述近似计算公式计算sinx的近似值，要求输出结果小数点后保留8位。</p>
<p><strong>【输入形式】</strong></p>
<p>从控制台输入小数x（0&lt;=x&lt;=20）和整数n（1&lt;=n&lt;=5000），两数中间用空格分隔。</p>
<p><strong>【输出形式】</strong></p>
<p>控制台输出公式结果：小数点后保留8位。</p>
<p><strong>【样例输入1】</strong></p>
<p>0.5236 4</p>
<p><strong>【样例输出1】</strong></p>
<p>0.50000105</p>
<p><strong>【样例输入2】</strong></p>
<p>0.5236 50</p>
<p><strong>【样例输出2】</strong></p>
<p>0.50000106</p>
<p><strong>【样例说明】</strong></p>
<p>输入x为0.5236，n为4，求得sinx近似计算公式的值为0.50000105，小数点后保留8位；同样，输入x为0.5236，n为50，求得sinx近似计算公式的值为0.50000106，小数点后保留8位。注意：为保证数据的准确性和一致性，<strong>请使用double数据类型保存计算结果。</strong></p>
<p><strong>【评分标准】</strong></p>
<p>该题要求输出上述公式的计算结果，共有5个测试点</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"># <span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">double</span> p<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span>f<span class="token punctuation">,</span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p是阶乘中的变量，总量即分母是f </span>
    <span class="token keyword">double</span> s<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>n<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf %lf"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">=</span>x<span class="token punctuation">;</span>
    f<span class="token operator">=</span>x<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>    p<span class="token operator">=</span>p<span class="token operator">*</span>i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

           s<span class="token operator">=</span>s<span class="token operator">+</span>t<span class="token operator">*</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token operator">/</span>p<span class="token punctuation">;</span>
           t<span class="token operator">=</span><span class="token operator">-</span>t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.8lf"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="3-个人所得税"><a href="#3-个人所得税" class="headerlink" title="3.个人所得税"></a>3.个人所得税</h3><p><strong>【问题描述】</strong>2019年1月1月新修订的个税法正式实施，个人所得税由之前的3500元提高到了5000元，还可以减去6项专项附加扣除，主要有子女教育、继续教育、赡养老人、大病医疗、住房贷款利息和住房租金，扣除三险一金和专项附加，工资大于5000元需要缴纳个人所得税，若小于5000元则不需要缴纳。2019年5000起征点个税表如下：</p>
<p><img src="http://jsjjs.ctbu.edu.cn/userfiles/image/2019/15706296140540202339.jpg" alt="1-1P91H2561V43.jpg"></p>
<p>假设6项专项附加扣除为零。</p>
<p>请根据税率表编写代码，输入月收入和扣除的三险一金（单位：元），输出待交的个人所得税。</p>
<p><strong>注：个税的计算方法</strong></p>
<p>比如张先生在武汉工作每个月工资为10000元，公司每个月缴纳社保公积金扣除1300元，没有专项附加扣除费。那么张先生到手的工资为10000-1300-0=8700元，达到了个税起征点5000元，超出的部分按照10%的个人所得税率来计算，(8700-5000)*10%-210=160元，那么张先生一个月需要缴纳的个人所得税为160元。</p>
<p><strong>【输入形式】</strong>用户在第一行输入月收入和三险一金(单位：元），中间用空格分开，第一个数是月收入，第二个数是三险一金<br><strong>【输出形式】</strong>用户待交的个人所得税（单位：元），保留两位小数<br><strong>【样例输入】</strong>10000 1300<br><strong>【样例输出】</strong>160.00<br><strong>【样例说明】</strong>输入的两个数中，第一个表示月收入，第二个数表示扣除的三险一金;输出待交的个人所得税<br><strong>【评分标准】</strong>完全正确20分。提交源文件名为tax.c</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> t<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m<span class="token punctuation">,</span>l<span class="token punctuation">,</span>p<span class="token punctuation">,</span>tax<span class="token punctuation">;</span>
    <span class="token keyword">double</span> rate<span class="token punctuation">,</span>late<span class="token punctuation">;</span> 
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf%lf"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>l<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token operator">=</span>l<span class="token operator">-</span>p<span class="token number">-5000</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        tax<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">3000</span><span class="token punctuation">)</span>    
            t<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">12000</span><span class="token punctuation">)</span>
            t<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">25000</span><span class="token punctuation">)</span>
            t<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">35000</span><span class="token punctuation">)</span>
            t<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">55000</span><span class="token punctuation">)</span>
            t<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&lt;=</span><span class="token number">80000</span><span class="token punctuation">)</span>
            t<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> 
            t<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span>

        <span class="token keyword">switch</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.10</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">210</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.20</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">1410</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.25</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">2660</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">5</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.30</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">4410</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">6</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.35</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">7160</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">7</span><span class="token punctuation">:</span>
                rate<span class="token operator">=</span><span class="token number">0.45</span><span class="token punctuation">,</span>late<span class="token operator">=</span><span class="token number">15160</span><span class="token punctuation">;</span>        
        <span class="token punctuation">}</span>
        tax<span class="token operator">=</span>m<span class="token operator">*</span>rate<span class="token operator">-</span>late<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"需要缴纳的个人所得税为:%.2f 元"</span><span class="token punctuation">,</span>tax<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="4-字符串复制"><a href="#4-字符串复制" class="headerlink" title="4.字符串复制"></a>4.字符串复制</h3><p><strong>【问题描述】</strong></p>
<p>编写一个字符串复制函数strCopy()，将字符串1中奇数位置的字符复制到另一个字符串2中，在主函数中调用函数strCopy()并输出复制后的结果。例如，当字符串1为”This is a C program”，则字符串2为”Ti saCporm”。</p>
<p><strong>【输入形式】</strong></p>
<p>输入字符串 </p>
<p><strong>【输出形式】</strong></p>
<p>输出复制后的字符串 </p>
<p><strong>【样例输入】</strong></p>
<p>This is a C Program </p>
<p><strong>【样例输出】</strong></p>
<p>Ti saCporm </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strCopy</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token function">gets</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token function">strCopy</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="5-还是三角形"><a href="#5-还是三角形" class="headerlink" title="5.还是三角形"></a>5.还是三角形</h3><p><strong>【问题描述】</strong></p>
<p>给定三条边，请判断三角形的类型。</p>
<p><strong>【输入形式】</strong></p>
<p>输入数据包含3个整数，表示三条边的长度，数据保证三条边一定能够组成三角形。</p>
<p><strong>【输出形式】</strong></p>
<p>请判断三条边组成的三角形类型（锐角三角形、钝角三角形、直角三角形、等腰三角形、等边三角形）。如果数据符合多种类型，则只输出优先度最高的类型（上面的五种三角形，优先级从低到高），具体输出格式参见样例。</p>
<p><strong>【样例输入】</strong></p>
<p>3 3 3</p>
<p><strong>【样例输出】</strong></p>
<p> 等边三角形</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span> </span>
<span class="token keyword">int</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>    
    <span class="token keyword">int</span> t<span class="token punctuation">,</span>max<span class="token punctuation">;</span>    
    t<span class="token operator">=</span>a<span class="token operator">></span>b<span class="token operator">?</span>a<span class="token punctuation">:</span>b<span class="token punctuation">;</span>   
    max<span class="token operator">=</span>t<span class="token operator">></span>c<span class="token operator">?</span>t<span class="token punctuation">:</span>c<span class="token punctuation">;</span>   
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">Min</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>    
    <span class="token keyword">int</span> t<span class="token punctuation">,</span>min<span class="token punctuation">;</span> 
    t<span class="token operator">=</span>a<span class="token operator">&lt;</span>b<span class="token operator">?</span>a<span class="token punctuation">:</span>b<span class="token punctuation">;</span> 
    min<span class="token operator">=</span>t<span class="token operator">&lt;</span>c<span class="token operator">?</span>t<span class="token punctuation">:</span>c<span class="token punctuation">;</span> 
    <span class="token keyword">return</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">Mid</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>   
    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    
    mid<span class="token operator">=</span>a<span class="token operator">></span>b<span class="token operator">?</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span>c<span class="token operator">?</span>a<span class="token punctuation">:</span><span class="token punctuation">(</span>b<span class="token operator">></span>c<span class="token operator">?</span>b<span class="token punctuation">:</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">(</span>b<span class="token operator">&lt;</span>c<span class="token operator">?</span>b<span class="token punctuation">:</span><span class="token punctuation">(</span>a<span class="token operator">></span>c<span class="token operator">?</span>a<span class="token punctuation">:</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>    
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>k<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>             
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>       
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">></span>c<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span><span class="token operator">&lt;</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>           
    <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//  满足上面条件的三边可以构成三角形             </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token operator">&amp;&amp;</span>b<span class="token operator">==</span>c<span class="token punctuation">)</span>                
             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"等边三角形\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token operator">&amp;&amp;</span>c<span class="token operator">!=</span>a<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>b<span class="token operator">==</span>c<span class="token operator">&amp;</span>a<span class="token operator">!=</span>b<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token operator">&amp;&amp;</span>b<span class="token operator">!=</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>           
                 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"等腰三角形\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
             <span class="token keyword">else</span>                 
            <span class="token punctuation">{</span>                    
                x<span class="token operator">=</span><span class="token function">Min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>         
                y<span class="token operator">=</span><span class="token function">Mid</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>      
                z<span class="token operator">=</span><span class="token function">Max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>     
                <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>y<span class="token operator">*</span>y<span class="token operator">></span>z<span class="token operator">*</span>z<span class="token punctuation">)</span>                           
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"锐角三角形\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">*</span>a<span class="token operator">+</span>b<span class="token operator">*</span>b<span class="token operator">==</span>c<span class="token operator">*</span>c<span class="token punctuation">)</span>                            
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"直角三角形\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>y<span class="token operator">*</span>y<span class="token operator">&lt;</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span>                            
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"钝角三角形\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   
            <span class="token punctuation">}</span>           
    <span class="token punctuation">}</span>       
    <span class="token keyword">else</span><span class="token comment" spellcheck="true">//不满足构成三角形的条件           </span>
    <span class="token punctuation">{</span>                
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这三边不能构成三角形\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="6-寻找完全数"><a href="#6-寻找完全数" class="headerlink" title="6.寻找完全数"></a>6.寻找完全数</h3><p><strong>【问题描述】</strong></p>
<p>完全数是特殊的自然数。它所有的真约数（即除了自身以外的约数）的和，恰好等于它本身。 第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3=6 第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。 输入一个整数m，输出区间[1,m]内最大的完全数。</p>
<p><strong>【输入形式】</strong></p>
<p>输入一个整数。</p>
<p><strong>【输出形式】</strong></p>
<p>输出不超过m的最大完全数。</p>
<p><strong>【样例输入】</strong></p>
<p>32</p>
<p><strong>【样例输出】</strong></p>
<p>28</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>m<span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 
            s <span class="token operator">=</span> i<span class="token operator">/</span>j<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            n <span class="token operator">=</span> n<span class="token operator">+</span>s<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            c <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="7-回文字符串"><a href="#7-回文字符串" class="headerlink" title="7.回文字符串"></a>7.回文字符串</h3><p><strong>【问题描述】</strong></p>
<p>回文字符串是具有回文特性的字符串：即该字符串从左向右读和从右向左读都一样，单独的字母不作为回文字符串，例如abcddcba即为一个长度为8的回文字符串。 编写一个程序，输入一个全是字母的字符串，找出字符串中最长的回文字符串，输出最长回文字符串的长度和最长的回文字符串（长度相同的输出第一个），若无回文字符串，只输出0。</p>
<p><strong>【输入形式】</strong></p>
<p>输入第一行为只含字母的字符串，长度不超过10000字符。 </p>
<p><strong>【输出形式】</strong></p>
<p> 输出结果第一行为最长回文字符串的长度输出结果第二行为最长的回文字符串</p>
<p><strong>【样例输入1】</strong></p>
<p><code>abcdef</code></p>
<p><strong>【样例输出1】</strong></p>
<p><code>0</code></p>
<p><strong>【样例输入2】</strong></p>
<p><code>abcba</code></p>
<p><strong>【样例输出2】</strong></p>
<p><code>5 abcba</code></p>
<p><strong>【样例输入3】</strong></p>
<p>`aAabccbaABcdcBA</p>
<p><strong>【样例输出3】</strong></p>
<p><code>8 AabccbaA</code></p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> LEN 100</span>
<span class="token comment" spellcheck="true">/*
"最大回文子串是指个字行串中长度最大的回文字符串,其基本算法思想如下：
1、每个回文都有一个"中心"，当回文字符数为奇数时，中间的那个字符就是
回文中心，但是当回文的字数为偶数时,回文的中心是最中间的那两个字符,
且这两个字符相同。
2.对任一个字符或者相同的两个连续字符,我们都可以假设它为回文的"中心"，
向它的左右两边扩展出尽可能长的回文,对于每种假设,我们都能得到一个回文,
而最长回文必定由其中的某个假设中得到!*/</span>


<span class="token keyword">int</span> <span class="token function">Maxhw</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">,</span>maxlen<span class="token punctuation">;</span>
    <span class="token keyword">int</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> slen<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>slen<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    maxlen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>slen<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token operator">&lt;</span>slen<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 如果以i为中心是奇数的回文子串</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">></span>maxlen<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                start<span class="token operator">=</span>i<span class="token operator">-</span>j<span class="token punctuation">;</span>
                maxlen<span class="token operator">=</span>j<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>slen<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果以i为中心是偶数的回文子串</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">></span>maxlen<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                start<span class="token operator">=</span>i<span class="token operator">-</span>j<span class="token punctuation">;</span>
                maxlen<span class="token operator">=</span>j<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k<span class="token operator">=</span>start<span class="token punctuation">;</span>k<span class="token operator">&lt;</span>start<span class="token operator">+</span>maxlen<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//输出最长回文串 </span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> maxlen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回最长回文串的长度 </span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"aAabccbaABcdcBA"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//char ch[LEN];</span>
    <span class="token comment" spellcheck="true">//gets(ch); </span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">Maxhw</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-三种方法求Fabonacci数列"><a href="#8-三种方法求Fabonacci数列" class="headerlink" title="8.三种方法求Fabonacci数列"></a>8.三种方法求Fabonacci数列</h3><p><strong>本题要求实现求Fabonacci数列项的函数。</strong></p>
<p>Fabonacci数列的定义如下：<em>f</em>(<em>n</em>)=<em>f</em>(<em>n</em>−2)+<em>f</em>(<em>n</em>−1) (<em>n</em>≥2)，其中<em>f</em>(0)=0，<em>f</em>(1)=1。</p>
<p><strong>函数接口定义</strong>：<code>int f( int n );</code></p>
<p>函数<code>f</code>应返回第<code>n</code>个Fabonacci数。题目保证输入输出在长整型范围内。建议用递归实现。 </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//递归</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> 
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//递推</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>n<span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//递推求相应项的值 </span>
    <span class="token punctuation">{</span>    
            a<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>
            b<span class="token operator">=</span>b<span class="token operator">+</span>a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//数组方法</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fib<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    fib<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>fib<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        fib<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>fib<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>fib<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>fib<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="9-相亲数"><a href="#9-相亲数" class="headerlink" title="9.相亲数"></a>9.相亲数</h3><p><strong>【问题描述】</strong></p>
<p>2500年前数学大师毕达哥拉斯就发现，220和284两数之间存在着奇妙的联系： 220的因数之和（除了自身之外的因数）为：110+55+44+22+20+11+10+5+4+2+1=284，284的因数之和为：142+71+4+2+1=220。 毕达哥拉斯把这样的数对称为相亲数。输入两个正整数（大于1并且在int的表示范围之内），分别计算它们所有因数之和（除了自身之外的因数），并判断它们是否是一对相亲数。</p>
<p><strong>【输入形式】</strong></p>
<p>从标准输入输入两个正整数，以一个空格分隔这两个正整数。</p>
<p><strong>【输出形式】</strong></p>
<p>以输入的先后顺序分行输出：输入的正整数，后跟英文逗号&ldquo;,&rdquo;，再从除自身之外的最大的因数开始输出其因数相加的公式（最小的因数1之后没有加号），最后输出英文等号&ldquo;=&rdquo;和因数之和。注意：所有输出元素间无空格。 若它们是一对相亲数，则在新的一行上输出1；若不是则在新的一行上输出0。</p>
<p><strong>【样例输入1】</strong></p>
<p>220 284</p>
<p><strong>【样例输出1】</strong></p>
<p>220,110+55+44+22+20+11+10+5+4+2+1=284 284,142+71+4+2+1=220 1</p>
<p><strong>【样例输入2】</strong></p>
<p>2560 3282</p>
<p><strong>【样例输出2】</strong></p>
<p>2560,1280+640+512+320+256+160+128+80+64+40+32+20+16+10+8+5+4+2+1=3578 3282,1641+1094+547+6+3+2+1=3294 0</p>
<p><strong>【样例说明】</strong></p>
<p>样例1中输入的两个正整数为220和284，220的因数之和为284，284的因数之和为220，所以它们是一对相亲数，最后输出1； 例2中输入的两个正整数是2560和3282，2560的因数之和为3578，3282的因数之和为3294，所以它们不是一对相亲数，最后输出0。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>x<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            n<span class="token operator">=</span>n<span class="token operator">+</span>i<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>        
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> n<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>v<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token operator">=</span><span class="token function">p</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">p</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token operator">==</span>b<span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="10-计算天数"><a href="#10-计算天数" class="headerlink" title="10.计算天数"></a>10.计算天数</h3><p><strong>【问题描述】</strong></p>
<p>定义一个结构体变量用以记录一个日期（包括年，月，日）。输入一个日期，计算该日是本年的第几天。 </p>
<p><strong>【输入形式】</strong></p>
<p>输入日期（包括年 月 日），是三个整数，以空格分隔。 </p>
<p><strong>【输出形式】</strong></p>
<p>输出该日是本年的第多少天。</p>
<p> <strong>【样例输入】</strong></p>
<p> 2003 3 25 </p>
<p><strong>【样例输出】</strong></p>
<p> 84 </p>
<p><strong>【样例说明】</strong></p>
<p>输入一个日期，输出该日是本年的第几天。 </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">Y</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">)</span>
<span class="token punctuation">{</span>    
    <span class="token keyword">int</span> g<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>year<span class="token operator">%</span><span class="token number">400</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
        g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>year<span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>year<span class="token operator">%</span><span class="token number">100</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>
            g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            g<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>sum<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Y</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>b<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
                n<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sum<span class="token operator">=</span><span class="token number">31</span><span class="token operator">*</span>k<span class="token operator">+</span><span class="token number">30</span><span class="token operator">*</span>n<span class="token operator">+</span>c<span class="token number">-1</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Y</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">2</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>b<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
                n<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sum<span class="token operator">=</span><span class="token number">31</span><span class="token operator">*</span>k<span class="token operator">+</span><span class="token number">30</span><span class="token operator">*</span>n<span class="token operator">+</span>c<span class="token number">-2</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>b<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
                n<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sum<span class="token operator">=</span><span class="token number">31</span><span class="token operator">*</span>k<span class="token operator">+</span><span class="token number">30</span><span class="token operator">*</span>n<span class="token operator">+</span>c<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="11-求最大公因子"><a href="#11-求最大公因子" class="headerlink" title="11.求最大公因子"></a>11.求最大公因子</h3><p><strong>【问题描述】</strong></p>
<p>用递归方法编写求最大公因子程序。两个正整数x和y的最大公因子定义为：如果y&lt;=x且x mod y＝0时，gcd(x,y)=y;如果y&gt;x时，gcd(x,y)=gcd(y,x);其他情况，gcd(x,y)=gcd(y,x mod y) </p>
<p><strong>【输入形式】</strong></p>
<p>用户在第一行输入两个数字，数字之间用空格分割。</p>
<p> <strong>【输出形式】</strong></p>
<p>程序在下一行输出前面输入的两个数字的最大公因子。 </p>
<p><strong>【样例输入】</strong></p>
<p>36 24 </p>
<p><strong>【样例输出】</strong></p>
<p>12 </p>
<p><strong>【样例说明】</strong></p>
<p>用户输入36，24，程序输出它们的最大公因子12 </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token keyword">return</span> y<span class="token punctuation">;</span>
     <span class="token keyword">else</span> 
         <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>x<span class="token operator">%</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="12-整数合并"><a href="#12-整数合并" class="headerlink" title="12.整数合并"></a>12.整数合并</h3><p><strong>【问题描述】</strong> </p>
<p>编写一函数int comb(int a,int b)，将两个两位数的正整数a、b合并形成一个整数并返回。合并的方式是：将a的十位和个位数依次放在结果的十位和千位上， b的十位和个位数依次放在结果的个位和百位上。例如，当a＝45，b=12。调用该函数后，返回5241。要求在main函数中调用该函数进行验证：从键盘输入两个整数，然后调用该函数进行合并，并输出合并后的结果。 </p>
<p><strong>【输入形式】</strong></p>
<p> 输入两个两位数的正整数，以空格隔开。</p>
<p><strong>【输出形式】</strong></p>
<p>输出合并后的正整数。 </p>
<p><strong>【输入样例】</strong> </p>
<p>45 12 </p>
<p><strong>【输出样例】</strong></p>
<p> 5241</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">=</span><span class="token punctuation">(</span>a<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">;</span>
    a<span class="token operator">=</span>a<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
    d<span class="token operator">=</span><span class="token punctuation">(</span>a<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>

    e<span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">;</span>
    b<span class="token operator">=</span>b<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
    f<span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum<span class="token operator">=</span>c<span class="token operator">+</span>d<span class="token operator">+</span>e<span class="token operator">+</span>f<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>暂时就更新到这里吧</p>

      
    </div>
</article>

    </li>
  
</ul>



            <footer>
    <div>© 2023 - Tyzhao </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>