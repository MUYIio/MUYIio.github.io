<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Shawlon`s Blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script></head>


 <div id="loading-container">
     <p class="loading-text"></p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url()">
        </div>
    </section>
    <section class='menu'>
        <div>Shawlon`s Blog</div>
        
            <div>Yshawlon</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ LeetCode }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/shu-jia-leetcode-shua-ti-ji-he-xia.html">暑假LeetCode刷题集合（下）</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-27T08:48:27.000Z" itemprop="datePublished">
    2021-07-27
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/LeetCode/">LeetCode</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/每日一题/">每日一题</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h2 id="【Day31】461-汉明距离"><a href="#【Day31】461-汉明距离" class="headerlink" title="【Day31】461. 汉明距离"></a>【Day31】461. 汉明距离</h2><h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></h4><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong></p>
<ul>
<li>0 ≤ x, y &lt; 231.</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code>输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。</code></pre><p><strong>题解：</strong></p>
<p>可以考虑为求异或结果值当中1的个数，进一步转换为求二进制中1的个数。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ans<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day32】477-汉明距离总和"><a href="#【Day32】477-汉明距离总和" class="headerlink" title="【Day32】477.汉明距离总和"></a>【Day32】477.汉明距离总和</h2><h4 id="477-汉明距离总和"><a href="#477-汉明距离总和" class="headerlink" title="477. 汉明距离总和"></a><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></h4><p>两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。</p>
<p>计算一个数组中，任意两个数之间汉明距离的总和。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</code></pre><p><strong>注意:</strong></p>
<ul>
<li>数组中元素的范围为从 0到 10^9。</li>
<li>数组的长度不超过 10^4。</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">totalHammingDistance</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> cnt<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                cnt<span class="token punctuation">[</span>num <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
                num <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            ans <span class="token operator">+</span><span class="token operator">=</span> cnt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> cnt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day33】1074-元素和为目标值的子矩阵数量"><a href="#【Day33】1074-元素和为目标值的子矩阵数量" class="headerlink" title="【Day33】1074.元素和为目标值的子矩阵数量"></a>【Day33】1074.元素和为目标值的子矩阵数量</h2><h4 id="1074-元素和为目标值的子矩阵数量"><a href="#1074-元素和为目标值的子矩阵数量" class="headerlink" title="1074. 元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. 元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 x1, y1, x2, y2 是满足 x1 &lt;= x &lt;= x2 且 y1 &lt;= y &lt;= y2 的所有单元 matrix[x][y] 的集合。</p>
<p>如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 != x1’），那么这两个子矩阵也不同。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" alt></p>
<pre><code>输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
输出：4
解释：四个只含 0 的 1x1 子矩阵。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：matrix = [[1,-1],[-1,1]], target = 0
输出：5
解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：matrix = [[904]], target = 0
输出：0</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= matrix.length &lt;= 100</li>
<li>1 &lt;= matrix[0].length &lt;= 100</li>
<li>-1000 &lt;= matrix[i] &lt;= 1000</li>
<li>-10^8 &lt;= target &lt;= 10^8</li>
</ul>
<p><strong>题解：</strong></p>
<p>二维前缀和的题目，使用哈希表来优化</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> HT_LENGTH 256</span>

<span class="token keyword">struct</span> HashTable <span class="token punctuation">{</span>
    <span class="token keyword">int</span> keys<span class="token punctuation">[</span>HT_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> vals<span class="token punctuation">[</span>HT_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> vals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> HT_LENGTH<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">bool</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        uint32_t ikey <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>key <span class="token operator">%</span> HT_LENGTH<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> HT_LENGTH<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ret <span class="token operator">=</span> vals<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            ikey <span class="token operator">++</span><span class="token punctuation">;</span>
            ikey <span class="token operator">=</span> ikey <span class="token operator">==</span> HT_LENGTH <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> ikey<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        uint32_t ikey <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>key <span class="token operator">%</span> HT_LENGTH<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> HT_LENGTH<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                keys<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
                vals<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                vals<span class="token punctuation">[</span>ikey<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            ikey <span class="token operator">++</span><span class="token punctuation">;</span>
            ikey <span class="token operator">=</span> ikey <span class="token operator">==</span> HT_LENGTH <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> ikey<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    HashTable ht<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">numSubmatrixSumTarget</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> rprefix<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            rprefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                rprefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> rprefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ht<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> cprefix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> val<span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>row <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>row<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    cprefix <span class="token operator">+</span><span class="token operator">=</span> rprefix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> rprefix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cprefix <span class="token operator">-</span> target<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span> ret <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">;</span>
                    ht<span class="token punctuation">.</span><span class="token function">inc</span><span class="token punctuation">(</span>cprefix<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day34】231-2-的幂"><a href="#【Day34】231-2-的幂" class="headerlink" title="【Day34】231. 2 的幂"></a>【Day34】231. 2 的幂</h2><h4 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2 的幂</a></h4><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 1
输出：true
解释：20 = 1</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 16
输出：true
解释：24 = 16</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：n = 3
输出：false</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：n = 4
输出：true</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：n = 5
输出：false</code></pre><p><strong>提示：</strong></p>
<ul>
<li>-231 &lt;= n &lt;= 231 - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>位运算</strong></p>
<p>若 n = 2^x 且 x为自然数（即 n 为 2 的幂），则一定满足以下条件：</p>
<p>首先，恒有 n &amp; (n - 1) == 0，因为：</p>
<ul>
<li>n 二进制最高位为 11，其余所有位为 00；</li>
<li>n−1 二进制最高位为 00，其余所有位为 11；</li>
</ul>
<p>其次，我们只需要限定n &gt; 0 即可。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day35】342-4的幂"><a href="#【Day35】342-4的幂" class="headerlink" title="【Day35】342. 4的幂"></a>【Day35】342. 4的幂</h2><h4 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">342. 4的幂</a></h4><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 16
输出：true</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 5
输出：false</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：n = 1
输出：true</code></pre><p><strong>提示：</strong></p>
<ul>
<li>-231 &lt;= n &lt;= 231 - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p>一个数是<code>2</code>的幂，那么二进制从右边数奇数位是<code>1</code>的一定是<code>4</code>的幂。判断是<code>2</code>的幂，我们只需要判断二进制中<code>1</code>的个数，用昨天的解即可。</p>
<pre><code>0x55555555的  二进制是  01010101 01010101 01010101 01010101</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day36】LeetCode-1744"><a href="#【Day36】LeetCode-1744" class="headerlink" title="【Day36】LeetCode 1744"></a>【Day36】LeetCode 1744</h2><h4 id="1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？"><a href="#1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？" class="headerlink" title="1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？"></a><a href="https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/" target="_blank" rel="noopener">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</a></h4><p>给你一个下标从 <strong>0</strong> 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。</p>
<p>你按照如下规则进行一场游戏：</p>
<ul>
<li>你从第 0 天开始吃糖果。</li>
<li>你在吃完 <strong>所有</strong> 第 i - 1 类糖果之前，<strong>不能</strong> 吃任何一颗第 i 类糖果。</li>
<li>在吃完所有糖果之前，你必须每天 <strong>至少</strong> 吃 一颗 糖果。</li>
</ul>
<p>请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 <strong>不超过</strong> dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p>
<p>请你返回得到的数组 answer 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
输出：[true,false,true]
提示：
1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。
2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。
3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。</code></pre><p><strong>示例 2：</strong></p>
<pre class="line-numbers language-text"><code class="language-text">输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
输出：[false,true,true,false,false]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= candiesCount.length &lt;= 105</li>
<li>1 &lt;= candiesCount[i] &lt;= 105</li>
<li>1 &lt;= queries.length &lt;= 105</li>
<li>queries[i].length == 3</li>
<li>0 &lt;= favoriteTypei &lt; candiesCount.length</li>
<li>0 &lt;= favoriteDayi &lt;= 109</li>
<li>1 &lt;= dailyCapi &lt;= 109</li>
</ul>
<p><strong>题解：</strong></p>
<p>使用前缀和解题：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> sum<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candiesCount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> favoriteType <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> favoriteDay <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dailyCap <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 第favoriteType类型的前缀和</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> sum<span class="token punctuation">[</span>favoriteType <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 每天吃一颗糖 </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>favoriteDay <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> sum<span class="token punctuation">[</span>favoriteType <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 吃最多糖</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum<span class="token punctuation">[</span>favoriteType<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">1ll</span><span class="token operator">*</span><span class="token punctuation">(</span>favoriteDay <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> dailyCap<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">canEat</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candiesCount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> candiesCount<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> candiesCount<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> ans<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> q <span class="token operator">:</span> queries<span class="token punctuation">)</span>
            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>candiesCount<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day37】523-连续的子数组和"><a href="#【Day37】523-连续的子数组和" class="headerlink" title="【Day37】523.连续的子数组和"></a>【Day37】523.连续的子数组和</h2><h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. 连续的子数组和</a></h4><p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小 <strong>至少为 2</strong> ，且</li>
<li>子数组元素总和为 k 的倍数。</li>
</ul>
<p>如果存在，返回 true ；否则，返回 false 。</p>
<p>如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [23,2,6,4,7], k = 13
输出：false</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 105</li>
<li>0 &lt;= nums[i] &lt;= 109</li>
<li>0 &lt;= sum(nums[i]) &lt;= 231 - 1</li>
<li>1 &lt;= k &lt;= 231 - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p>经典的前缀和</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">checkSubarraySum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sum <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day38】525-连续数组"><a href="#【Day38】525-连续数组" class="headerlink" title="【Day38】525.连续数组"></a>【Day38】525.连续数组</h2><h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/" target="_blank" rel="noopener">525. 连续数组</a></h4><p>给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 105</li>
<li>nums[i] 不是 0 就是 1</li>
</ul>
<p><strong>题解：</strong></p>
<p>前缀和＋哈希</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            num <span class="token operator">=</span> num <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ans <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>i <span class="token operator">-</span> m<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                m<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day39】160-相交链表"><a href="#【Day39】160-相交链表" class="headerlink" title="【Day39】160.相交链表"></a>【Day39】160.相交链表</h2><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>：函数返回结果后，链表必须 保持其<strong>原始结构</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt></p>
<pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at &#39;8&#39;
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt></p>
<pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at &#39;2&#39;
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt></p>
<pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>listA 中节点数目为 m</li>
<li>listB 中节点数目为 n</li>
<li>0 &lt;= m, n &lt;= 3 * 104</li>
<li>1 &lt;= Node.val &lt;= 105</li>
<li>0 &lt;= skipA &lt;= m</li>
<li>0 &lt;= skipB &lt;= n</li>
<li>如果 listA 和 listB 没有交点，intersectVal 为 0</li>
<li>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<p><strong>题解：</strong></p>
<p>pA走过的路径为A链+B链</p>
<p>pB走过的路径为B链+A链</p>
<p>pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。</p>
<pre><code>pA:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null-&gt;9-&gt;5-&gt;6-&gt;null
pB:9-&gt;5-&gt;6-&gt;null-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode <span class="token operator">*</span>p <span class="token operator">=</span> headA<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> headB<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> p <span class="token operator">?</span> p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> headB<span class="token punctuation">;</span>
            q <span class="token operator">=</span> q <span class="token operator">?</span> q<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> headA<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day40】203-移除链表元素"><a href="#【Day40】203-移除链表元素" class="headerlink" title="【Day40】203.移除链表元素"></a>【Day40】203.移除链表元素</h2><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></h4><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt></p>
<pre><code>输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：head = [], val = 1
输出：[]</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：head = [7,7,7,7], val = 7
输出：[]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>列表中的节点在范围 [0, 104] 内</li>
<li>1 &lt;= Node.val &lt;= 50</li>
<li>0 &lt;= k &lt;= 50</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode <span class="token operator">*</span><span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span>
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">==</span> val <span class="token operator">?</span> head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day41】474-一和零"><a href="#【Day41】474-一和零" class="headerlink" title="【Day41】474.一和零"></a>【Day41】474.一和零</h2><h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h4><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 <strong>最多</strong> 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 <strong>子集</strong> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;} ，因此答案是 4 。
其他满足题意但较小的子集包括 {&quot;0001&quot;,&quot;1&quot;} 和 {&quot;10&quot;,&quot;1&quot;,&quot;0&quot;} 。{&quot;111001&quot;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1
输出：2
解释：最大的子集是 {&quot;0&quot;, &quot;1&quot;} ，所以答案是 2 。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= strs.length &lt;= 600</li>
<li>1 &lt;= strs[i].length &lt;= 100</li>
<li>strs[i] 仅由 ‘0’ 和 ‘1’ 组成</li>
<li>1 &lt;= m, n &lt;= 100</li>
</ul>
<p><strong>题解：</strong></p>
<p>动态规划</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">findMaxForm</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>str<span class="token operator">:</span>strs<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> one <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> zero <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c<span class="token operator">:</span>str<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'1'</span><span class="token punctuation">)</span>
                    <span class="token operator">++</span>one<span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    <span class="token operator">++</span>zero<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// zero = str.size() - one;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span> j<span class="token operator">>=</span>zero<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>n<span class="token punctuation">;</span> k<span class="token operator">>=</span>one<span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>zero<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span>one<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day42】494-目标和"><a href="#【Day42】494-目标和" class="headerlink" title="【Day42】494. 目标和"></a>【Day42】494. 目标和</h2><h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></h4><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<blockquote>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</p>
</blockquote>
<p>返回可以通过上述方法构造的、运算结果等于 target 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [1], target = 1
输出：1</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 20</li>
<li>0 &lt;= nums[i] &lt;= 1000</li>
<li>0 &lt;= sum(nums[i]) &lt;= 1000</li>
<li>-1000 &lt;= target &lt;= 100</li>
</ul>
<p><strong>题解：</strong></p>
<p>还是动态规划</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> t<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t <span class="token operator">=</span> target<span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>u <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token operator">++</span>ans<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> s <span class="token operator">+</span> nums<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> s <span class="token operator">-</span> nums<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day43】1049-最后一块石头的重量-II"><a href="#【Day43】1049-最后一块石头的重量-II" class="headerlink" title="【Day43】1049. 最后一块石头的重量 II"></a>【Day43】1049. 最后一块石头的重量 II</h2><h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II</a></h4><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 x == y，那么两块石头都会被完全粉碎；</li>
<li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>
</ul>
<p>最后，<strong>最多只会剩下一块 石头</strong>。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 0。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：stones = [31,26,33,21,40]
输出：5</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：stones = [1,2]
输出：1</code></pre><p><strong>提示：</strong></p>
<ul>
<li><p>1 &lt;= stones.length &lt;= 30</p>
</li>
<li><p>1 &lt;= stones[i] &lt;= 100</p>
<p><strong>题解：</strong></p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">lastStoneWeightII</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> stones<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>stones<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stones<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> stone <span class="token operator">:</span> stones<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> stone<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> stone<span class="token punctuation">]</span> <span class="token operator">+</span> stone<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum <span class="token operator">-</span> dp<span class="token punctuation">[</span>sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day44】879-盈利计划"><a href="#【Day44】879-盈利计划" class="headerlink" title="【Day44】879. 盈利计划"></a>【Day44】879. 盈利计划</h2><h4 id="879-盈利计划"><a href="#879-盈利计划" class="headerlink" title="879. 盈利计划"></a><a href="https://leetcode-cn.com/problems/profitable-schemes/" target="_blank" rel="noopener">879. 盈利计划</a></h4><p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>工作的任何至少产生 minProfit 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 n 。</p>
<p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> 10^9 + 7 的<strong>值</strong>。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= n &lt;= 100</li>
<li>0 &lt;= minProfit &lt;= 100</li>
<li>1 &lt;= group.length &lt;= 100</li>
<li>1 &lt;= group[i] &lt;= 100</li>
<li>profit.length == group.length</li>
<li>0 &lt;= profit[i] &lt;= 100</li>
</ul>
<p><strong>题解：</strong></p>
<p>这题不会，贴一个题解吧</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">profitableSchemes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> minProfit<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> group<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> profit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> group<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>minProfit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> cur_group <span class="token operator">=</span> group<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cur_profit <span class="token operator">=</span> profit<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span> j <span class="token operator">>=</span> cur_group<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> minProfit<span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> cur_group<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">max</span><span class="token punctuation">(</span>k <span class="token operator">-</span> cur_profit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">%</span><span class="token operator">=</span> mod<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>minProfit<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day45】518-零钱兑换-II"><a href="#【Day45】518-零钱兑换-II" class="headerlink" title="【Day45】518. 零钱兑换 II"></a>【Day45】518. 零钱兑换 II</h2><h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h4><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: amount = 10, coins = [10] 
输出: 1</code></pre><p><strong>注意:</strong></p>
<ul>
<li>0 &lt;= amount (总金额) &lt;= 5000</li>
<li>1 &lt;= coin (硬币面额) &lt;= 5000</li>
<li>硬币种类不超过 500 种</li>
<li>结果符合 32 位符号整数</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> coins<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> val <span class="token operator">=</span> coins<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> val<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day46】279-完全平方数"><a href="#【Day46】279-完全平方数" class="headerlink" title="【Day46】279. 完全平方数"></a>【Day46】279. 完全平方数</h2><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 <strong>最少数量</strong> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 13
输出：2
解释：13 = 4 + 9</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= n &lt;= 104</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//假设最小公式值m = ƒ(n) </span>
<span class="token comment" spellcheck="true">//那么n的值满足下列公式 ∑(A[i] * A[i]) = n </span>
<span class="token comment" spellcheck="true">//令 k 为满足最小值 m 的时候，最大的平方数  。 令  d + k * k; = n ;  d >= 0; </span>
   <span class="token comment" spellcheck="true">// 注意：一定要是满足m最小的时候的k值,一味的取最大平方数,就是贪心算法了</span>
<span class="token comment" spellcheck="true">//得出 f(d) + f(k*k) = f(n);</span>
<span class="token comment" spellcheck="true">//显然 f(k*k) = 1; 则  f(d) + 1 = f(n); 因为 d = n - k*k;</span>
<span class="token comment" spellcheck="true">//则可以推出ƒ(n - k * k) + 1 = ƒ(n) ;  且 k * k &lt;= n;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">-</span> j<span class="token operator">*</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                min <span class="token operator">=</span> min <span class="token operator">></span> tmp <span class="token operator">?</span>  tmp<span class="token operator">:</span>min<span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day47】1449-数位成本和为目标值的最大数字"><a href="#【Day47】1449-数位成本和为目标值的最大数字" class="headerlink" title="【Day47】1449. 数位成本和为目标值的最大数字"></a>【Day47】1449. 数位成本和为目标值的最大数字</h2><h4 id="1449-数位成本和为目标值的最大数字"><a href="#1449-数位成本和为目标值的最大数字" class="headerlink" title="1449. 数位成本和为目标值的最大数字"></a><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">1449. 数位成本和为目标值的最大数字</a></h4><p>给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>
<ul>
<li>给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。</li>
<li>总成本必须恰好等于 target 。</li>
<li>添加的数位中没有数字 0 。</li>
</ul>
<p>由于答案可能会很大，请你以字符串形式返回。</p>
<p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
输出：&quot;7772&quot;
解释：添加数位 &#39;7&#39; 的成本为 2 ，添加数位 &#39;2&#39; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。
 数字     成本
  1  -&gt;   4
  2  -&gt;   3
  3  -&gt;   2
  4  -&gt;   5
  5  -&gt;   6
  6  -&gt;   7
  7  -&gt;   2
  8  -&gt;   5
  9  -&gt;   5</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：cost = [7,6,5,5,5,6,8,7,8], target = 12
输出：&quot;85&quot;
解释：添加数位 &#39;8&#39; 的成本是 7 ，添加数位 &#39;5&#39; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：cost = [2,4,6,2,4,6,4,4,4], target = 5
输出：&quot;0&quot;
解释：总成本是 target 的条件下，无法生成任何整数。</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：cost = [6,10,15,40,40,40,40,40,40], target = 47
输出：&quot;32211&quot;</code></pre><p><strong>提示：</strong></p>
<ul>
<li>cost.length == 9</li>
<li>1 &lt;= cost[i] &lt;= 5000</li>
<li>1 &lt;= target &lt;= 5000</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string <span class="token function">largestNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cost<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> len<span class="token operator">=</span>cost<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//因为i遍历的顺序是从小到大，就保证了整数的高位一定大于等于整数的低位，也就保证了整数最大</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>    
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>cost<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>cost<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">CompareString</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>cost<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"#"</span><span class="token operator">?</span><span class="token string">"0"</span><span class="token operator">:</span>dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    string <span class="token function">CompareString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> m<span class="token operator">=</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">==</span>n<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> m<span class="token operator">></span>n<span class="token operator">?</span>s1<span class="token operator">:</span>s2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day48】278-第一个错误的版本"><a href="#【Day48】278-第一个错误的版本" class="headerlink" title="【Day48】278. 第一个错误的版本"></a>【Day48】278. 第一个错误的版本</h2><h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></h4><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p><strong>示例:</strong></p>
<pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true

所以，4 是第一个错误的版本。 </code></pre><p><strong>题解：</strong></p>
<p>二分</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">firstBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hi <span class="token operator">=</span> n<span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBadVersion</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                hi <span class="token operator">=</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> hi<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day49】374-猜数字大小"><a href="#【Day49】374-猜数字大小" class="headerlink" title="【Day49】374. 猜数字大小"></a>【Day49】374. 猜数字大小</h2><h4 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></h4><p>猜数字游戏的规则如下：</p>
<ul>
<li>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。</li>
<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>
</ul>
<p>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>
<ul>
<li>-1：我选出的数字比你猜的数字小 pick &lt; num</li>
<li>1：我选出的数字比你猜的数字大 pick &gt; num</li>
<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num</li>
</ul>
<p>返回我选出的数字。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 10, pick = 6
输出：6</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 1, pick = 1
输出：1</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：n = 2, pick = 1
输出：1</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：n = 2, pick = 2
输出：2</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= n &lt;= 231 - 1</li>
<li>1 &lt;= pick &lt;= n</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return          -1 if num is lower than the guess number
 *                  1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">guessNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> r<span class="token punctuation">;</span>
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">guess</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">return</span> m<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                r <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day50】852-山脉数组的峰顶索引"><a href="#【Day50】852-山脉数组的峰顶索引" class="headerlink" title="【Day50】852. 山脉数组的峰顶索引"></a>【Day50】852. 山脉数组的峰顶索引</h2><h4 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引</a></h4><p>符合下列属性的数组 arr 称为 <strong>山脉数组</strong> ：</p>
<ul>
<li><p>arr.length &gt;= 3</p>
</li>
<li><p>存在 i（0 &lt; i &lt; arr.length - 1）使得：</p>
<ul>
<li>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]</li>
<li>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]</li>
</ul>
<p>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：arr = [0,1,0]
输出：1</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：arr = [0,2,1,0]
输出：1</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：arr = [0,10,5,2]
输出：1</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：arr = [3,4,5,1]
输出：2</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：arr = [24,69,100,99,79,78,67,36,26,19]
输出：2</code></pre><p><strong>提示：</strong></p>
<ul>
<li>3 &lt;= arr.length &lt;= 104</li>
<li>0 &lt;= arr[i] &lt;= 106</li>
<li>题目数据保证 arr 是一个山脉数组</li>
</ul>
<p><strong>题解：</strong></p>
<p>二分法</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">peakIndexInMountainArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//根据 arr[mid-1]和arr[mid]对比</span>
        <span class="token comment" spellcheck="true">//所以搜索范围是 [1,arr.length -1]</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//如果check 函数调整的是left，则+1. 否则有可能陷入死循环</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
            left <span class="token operator">=</span> mid<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
            right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day51】877-石子游戏"><a href="#【Day51】877-石子游戏" class="headerlink" title="【Day51】877. 石子游戏"></a>【Day51】877. 石子游戏</h2><h4 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/" target="_blank" rel="noopener">877. 石子游戏</a></h4><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子<strong>排成一行</strong>，每堆都有正整数颗石子 piles[i] 。</p>
<p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p>
<p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p>
<p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= piles.length &lt;= 500</li>
<li>piles.length 是偶数。</li>
<li>1 &lt;= piles[i] &lt;= 500</li>
<li>sum(piles) 是奇数。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>博弈论</strong></p>
<p><a href="https://leetcode-cn.com/problems/stone-game/solution/gong-shui-san-xie-jing-dian-qu-jian-dp-j-wn31/" target="_blank" rel="noopener">三叶的题解</a></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">stoneGame</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> piles<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day52】65-有效数字"><a href="#【Day52】65-有效数字" class="headerlink" title="【Day52】65. 有效数字"></a>【Day52】65. 有效数字</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 <strong>整数</strong></li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：<ol>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
<p>部分有效数字列举如下：</p>
<ul>
<li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li>
</ul>
<p>部分无效数字列举如下：</p>
<ul>
<li>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</li>
</ul>
<p>给你一个字符串 s ，如果 s 是一个 <strong>有效数字</strong> ，请返回 true 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;0&quot;
输出：true</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;e&quot;
输出：false</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：s = &quot;.&quot;
输出：false</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：s = &quot;.1&quot;
输出：true</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= s.length &lt;= 20</li>
<li>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，或者点 ‘.’ 。</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//去掉前后空格</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> l <span class="token operator">++</span> <span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> r <span class="token operator">--</span> <span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//去掉正负号</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果只有正负号，false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果只有一个点，或者.e || .E 返回false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'e'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//记录点和e的次数</span>
        <span class="token keyword">int</span> dot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果出现多个点或者e ，fasle</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>dot <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> e <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                dot <span class="token operator">++</span> <span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'e'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果e的前面没东西或者后面没东西，或者多个e ，false</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i <span class="token operator">||</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> e <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//如果e的后面是正负号</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//但是后面没东西了，返回false</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    i <span class="token operator">++</span> <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                e <span class="token operator">++</span> <span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//不合法</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token string">'0'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day53】483-最小好进制"><a href="#【Day53】483-最小好进制" class="headerlink" title="【Day53】483. 最小好进制"></a>【Day53】483. 最小好进制</h2><h4 id="483-最小好进制"><a href="#483-最小好进制" class="headerlink" title="483. 最小好进制"></a><a href="https://leetcode-cn.com/problems/smallest-good-base/" target="_blank" rel="noopener">483. 最小好进制</a></h4><p>对于给定的整数 n, 如果n的k（k&gt;=2）进制数的所有数位全为1，则称 k（k&gt;=2）是 n 的一个<strong>好进制</strong>。</p>
<p>以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：&quot;13&quot;
输出：&quot;3&quot;
解释：13 的 3 进制是 111。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：&quot;4681&quot;
输出：&quot;8&quot;
解释：4681 的 8 进制是 11111。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：&quot;1000000000000000000&quot;
输出：&quot;999999999999999999&quot;
解释：1000000000000000000 的 999999999999999999 进制是 11。</code></pre><p><strong>提示：</strong></p>
<ol>
<li>n的取值范围是 [3, 10^18]。</li>
<li>输入总是有效且没有前导 0。</li>
</ol>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> LL <span class="token operator">=</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">;</span>
    string <span class="token function">smallestGoodBase</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LL x <span class="token operator">=</span> <span class="token function">stoll</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> m <span class="token operator">&lt;=</span> <span class="token number">60</span><span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            LL k <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">/</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                LL cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span>LL i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    base <span class="token operator">*</span><span class="token operator">=</span> k<span class="token punctuation">;</span>
                    cur <span class="token operator">+</span><span class="token operator">=</span> base<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">to_string</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">to_string</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day54】1239-串联字符串的最大长度"><a href="#【Day54】1239-串联字符串的最大长度" class="headerlink" title="【Day54】1239. 串联字符串的最大长度"></a>【Day54】1239. 串联字符串的最大长度</h2><h4 id="1239-串联字符串的最大长度"><a href="#1239-串联字符串的最大长度" class="headerlink" title="1239. 串联字符串的最大长度"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" target="_blank" rel="noopener">1239. 串联字符串的最大长度</a></h4><p>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。</p>
<p>请返回所有可行解 s 中最长长度。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]
输出：4
解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]
输出：6
解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]
输出：26</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= arr.length &lt;= 16</li>
<li>1 &lt;= arr[i].length &lt;= 26</li>
<li>arr[i] 中只含有小写英文字母</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> masks <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ch <span class="token operator">-</span><span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">>></span> ch<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解</span>
                    mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                mask <span class="token operator">|</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> ch<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 ch 加入 mask 中</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> masks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> m <span class="token operator">=</span> masks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// m 和 mask 无公共元素</span>
                    masks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m <span class="token operator">|</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">__builtin_popcount</span><span class="token punctuation">(</span>m <span class="token operator">|</span> mask<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day55】1600-皇位继承顺序"><a href="#【Day55】1600-皇位继承顺序" class="headerlink" title="【Day55】1600.皇位继承顺序"></a>【Day55】1600.皇位继承顺序</h2><h4 id="1600-皇位继承顺序"><a href="#1600-皇位继承顺序" class="headerlink" title="1600. 皇位继承顺序"></a><a href="https://leetcode-cn.com/problems/throne-inheritance/" target="_blank" rel="noopener">1600. 皇位继承顺序</a></h4><p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>
<p>这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。</p>
<blockquote>
<p>Successor(x, curOrder):<br> 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：<br>     如果 x 是国王，那么返回 null<br>     否则，返回 Successor(x 的父亲, curOrder)<br> 否则，返回 x 不在 curOrder 中最年长的孩子</p>
</blockquote>
<p>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。</p>
<ol>
<li>一开始， curOrder 为 [“king”].</li>
<li>调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。</li>
<li>调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。</li>
<li>调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。</li>
<li>调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。</li>
</ol>
<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>
<p>请你实现 ThroneInheritance 类：</p>
<ul>
<li>ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。</li>
<li>void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。</li>
<li>void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>
<li>string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。</li>
</ul>
<p><strong>示例：</strong></p>
<p><strong>输入：</strong></p>
<pre><code>[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;]
[[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]</code></pre><p><strong>输出：</strong></p>
<pre><code>[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]</code></pre><p><strong>解释：</strong></p>
<pre><code>ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：king
t.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andy
t.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bob
t.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherine
t.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine
t.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine
t.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine
t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]
t.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine
t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]</code></pre><p><strong>提示：</strong></p>
<ol>
<li>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</li>
<li>kingName，parentName， childName 和 name 仅包含小写英文字母。</li>
<li>所有的参数 childName 和 kingName 互不相同。</li>
<li>所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。</li>
<li>每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。</li>
<li>最多调用 105 次birth 和 death 。</li>
<li>最多调用 10 次 getInheritanceOrder 。</li>
</ol>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThroneInheritance</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string root<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> isdeath<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> family<span class="token punctuation">;</span>
    <span class="token function">ThroneInheritance</span><span class="token punctuation">(</span>string kingName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> kingName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">birth</span><span class="token punctuation">(</span>string parentName<span class="token punctuation">,</span> string childName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        family<span class="token punctuation">[</span>parentName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>childName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">death</span><span class="token punctuation">(</span>string name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isdeath<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> ans<span class="token punctuation">,</span> string root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isdeath<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>string str<span class="token operator">:</span> family<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">getInheritanceOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> ans<span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * Your ThroneInheritance object will be instantiated and called as such:
 * ThroneInheritance* obj = new ThroneInheritance(kingName);
 * obj->birth(parentName,childName);
 * obj->death(name);
 * vector&lt;string> param_3 = obj->getInheritanceOrder();
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day56】401-二进制手表"><a href="#【Day56】401-二进制手表" class="headerlink" title="【Day56】401.二进制手表"></a>【Day56】401.二进制手表</h2><h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noopener">401. 二进制手表</a></h4><p>二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。</p>
<ul>
<li>例如，下面的二进制手表读取 “3:25” 。</li>
</ul>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg" alt="（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）"></p>
<p>给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p>小时不会以零开头：</p>
<ul>
<li>例如，”01:00” 是无效的时间，正确的写法应该是 “1:00” 。</li>
</ul>
<p>分钟必须由两位数组成，可能会以零开头：</p>
<p>例如，”10:2” 是无效的时间，正确的写法应该是 “10:02” 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：turnedOn = 1
输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：turnedOn = 9
输出：[]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= turnedOn &lt;= 10</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">readBinaryWatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//直接遍历  0:00 -> 12:00   每个时间有多少1</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count1</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count1</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>
                                  <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token string">"0"</span><span class="token operator">+</span><span class="token function">to_string</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to_string</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//计算二进制中1的个数</span>
    <span class="token keyword">int</span> <span class="token function">count1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            n <span class="token operator">=</span> n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day57】剑指-Offer-15-二进制中1的个数"><a href="#【Day57】剑指-Offer-15-二进制中1的个数" class="headerlink" title="【Day57】剑指 Offer 15.二进制中1的个数"></a>【Day57】剑指 Offer 15.二进制中1的个数</h2><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></h4><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 32 的 二进制串 。</li>
</ul>
<blockquote>
<p>注意：本题与主站 191 题相同：<a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>
</blockquote>
<p><strong>题解：</strong></p>
<p>右移再 &amp; 1</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>uint32_t n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day58】149-直线上最多的点数"><a href="#【Day58】149-直线上最多的点数" class="headerlink" title="【Day58】149. 直线上最多的点数"></a>【Day58】149. 直线上最多的点数</h2><h4 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149. 直线上最多的点数"></a><a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">149. 直线上最多的点数</a></h4><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt></p>
<pre><code>输入：points = [[1,1],[2,2],[3,3]]
输出：3</code></pre><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt></p>
<pre><code>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= points.length &lt;= 300</li>
<li>points[i].length == 2</li>
<li>-104 &lt;= xi, yi &lt;= 104</li>
<li>points 中的所有点 互不相同</li>
</ul>
<p><strong>题解：</strong></p>
<p>直接枚举，比较斜率</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxPoints</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 点的数量不够</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> len<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> maxNum <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 遍历每两个点</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 统计斜率相等个数</span>
                <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> dx <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> dy <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 与其他点比较</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> k <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 如果斜率相等</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>dx <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> dy <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        count <span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                maxNum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxNum<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>maxNum <span class="token operator">></span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day59】752-打开转盘锁"><a href="#【Day59】752-打开转盘锁" class="headerlink" title="【Day59】752.打开转盘锁"></a>【Day59】752.打开转盘锁</h2><h4 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">752. 打开转盘锁</a></h4><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;
输出：6
解释：
可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。
注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，
因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;
输出：1
解释：
把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;
输出：-1
解释：
无法旋转到目标数字且不被锁定。</code></pre><p><strong>示例 4:</strong></p>
<pre><code>输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;
输出：-1</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= deadends.length &lt;= 500</li>
<li>deadends[i].length == 4</li>
<li>target.length == 4</li>
<li>target 不在 deadends 之中</li>
<li>target 和 deadends[i] 仅由若干位数字组成</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> seen<span class="token punctuation">[</span><span class="token number">10010</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录搜到过的轮盘锁数字</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> dead<span class="token punctuation">[</span><span class="token number">10010</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录死亡数字</span>
    <span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token number">10010</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模拟队列</span>
    <span class="token keyword">int</span> <span class="token function">openLock</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> deadends<span class="token punctuation">,</span> string target<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> d <span class="token operator">:</span> deadends<span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">//将死亡数字转int作为下标存储在dead数组中</span>
            <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
            dead<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//如果"0000"是死亡数字直接返回0,如果target为0000直接返回-1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>dead<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token string">"0000"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> tar<span class="token operator">=</span><span class="token function">stoi</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">bfs</span><span class="token punctuation">(</span>tar<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">numsadd</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>    
        <span class="token comment" spellcheck="true">//hh队头，tt队尾</span>
        <span class="token keyword">int</span> hh<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//先将队头初始化为0,代表从"0000"开始旋转</span>
        q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">auto</span> t <span class="token operator">=</span> q<span class="token punctuation">[</span>hh<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> prev <span class="token operator">=</span> t<span class="token punctuation">;</span>

            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000</span> <span class="token punctuation">;</span> i <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">int</span> num <span class="token operator">=</span> t <span class="token operator">/</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span> 
                <span class="token keyword">int</span> temp<span class="token operator">=</span>t<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">//正向旋转当前位的数字</span>
                <span class="token keyword">int</span> tmp <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token function">numsadd</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>i<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>seen<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>dead<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">//满足条件就将temp插入队尾</span>
                    q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//更新新转盘锁数字的操作次数</span>
                    seen<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> seen<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">//反向旋转当前位的数字</span>
                tmp <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token function">numsadd</span><span class="token punctuation">(</span>num<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>i<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>seen<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>dead<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
                    seen<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> seen<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>           
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>seen<span class="token punctuation">[</span>target<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                ans <span class="token operator">=</span> seen<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整整两个月就刷完啦，发现这些题更适合于找工作，而我目前没有这方面的需要，所以以后偶尔刷一下，有时间就发在博客上hh</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/shu-jia-leetcode-shua-ti-ji-he-shang.html">暑假LeetCode刷题集合（上）</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-27T13:12:16.000Z" itemprop="datePublished">
    2021-06-27
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/LeetCode/">LeetCode</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/每日一题/">每日一题</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>最近决定巩固一下算法，开始刷leetcode每日一题，具体刷多久还不知道，刚开始是有点吃力，慢慢来。</strong></p>
<h2 id="【Day01】938-二叉搜索树的范围和"><a href="#【Day01】938-二叉搜索树的范围和" class="headerlink" title="【Day01】938.二叉搜索树的范围和"></a>【Day01】938.二叉搜索树的范围和</h2><p><strong>题目：</strong></p>
<p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>
<p><strong>示例1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt></p>
<pre><code>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15
输出：32</code></pre><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt></p>
<pre><code>输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出：23</code></pre><p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 [1, 2 * 104] 内</li>
<li>1 &lt;= Node.val &lt;= 105</li>
<li>1 &lt;= low &lt;= high &lt;= 105</li>
<li>所有 Node.val 互不相同</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>递归</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (!root) return 0;
        int sum = 0;
        sum += rangeSumBST(root->left, low, high);
        if (root->val >= low && root->val <= high) sum += root->val;
        sum += rangeSumBST(root->right, low, high);
        return sum;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>非递归</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (!root) return 0;
        queue<TreeNode*> q;
        TreeNode* p = root;
        int sum = 0;
        while (p || q.size()) {
            while (p) {
                q.push(p);
                p = p->left;
            }
            if (q.size()) {
                p = q.front();
                q.pop();
                if (p->val >= low && p->val <= high) {
                    sum += p->val;
                }
                p = p->right;       
            }    
        }
        return sum;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day02】633-平方数之和"><a href="#【Day02】633-平方数之和" class="headerlink" title="【Day02】633.平方数之和"></a>【Day02】633.平方数之和</h2><p><strong>题目：</strong></p>
<p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：c = 5
输出：true
解释：1 * 1 + 2 * 2 = 5</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：c = 3
输出：false</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：c = 4
输出：true</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：c = 2
输出：true</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：c = 1
输出：true</code></pre><p><strong>枚举</strong></p>
<p>对 a 从 0 开始到 n√n 枚举，然后判断是否存在 b。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    bool judgeSquareSum(int c) {
        for (int i = 0; (long long)(i) * i <= c; i++) {
            int j = sqrt(c - i * i);
            if (i * i + j * j == c)
                return true;
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>预处理+查询</strong></p>
<p>如果存在符合条件的a，b，那么a和b一定在1和sqrt(c)之间。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    typedef unsigned long long ULL;
    bool judgeSquareSum(int c) {
        if (c == 0) return true;
        unordered_map<ULL, ULL> um;
        for (int i = 1; i <= sqrt(c); i++) {
            um[i*i]++;
        }

        for (int i = 1; i <= sqrt(c); i++) {
            if (i*i == c || um.count(c - i*i)) return true;
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>双指针</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    bool judgeSquareSum(int c) {
        int j = sqrt(c);
        int i = 0;
        while (i <= j) {
            if (i*i > c - j*j) {
                j--;
            } else if (i*i < c - j*j) {
                i++;
            } else {
                return true;
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day03】403-青蛙过河"><a href="#【Day03】403-青蛙过河" class="headerlink" title="【Day03】403.青蛙过河"></a>【Day03】403.青蛙过河</h2><h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode-cn.com/problems/frog-jump/" target="_blank" rel="noopener">403. 青蛙过河</a></h3><p><strong>题目描述：</strong></p>
<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>
<p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p>
<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>  <strong>示例 1：</strong></p>
<pre><code>输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：stones = [0,1,2,3,4,8,9,11]
输出：false
解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= stones.length &lt;= 2000</li>
<li>0 &lt;= stones[i] &lt;= 231 - 1</li>
<li>stones[0] == 0</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>递归:</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    unordered_map<int, int> um;
    bool canCross(vector<int>& stones) {

        for (int i = 0; i < stones.size(); i++) {
            um[stones[i]] = i;  // key:石子值 value是第几块石子
        }
        if (!um.count(1)) return false;
        return dfs(stones, stones.size(), 1, 1);
    }
    bool dfs(vector<int>& stones, int n, int cur, int k) {
        if (cur == n - 1) return true;
        for (int i = -1; i <= 1; i++) {
            if (k + i == 0) continue;
            int next = stones[cur] + k + i;
            if (um.count(next)) { // 存在
                bool choose = dfs(stones, n, um[next], k + i);
                if (choose) return true;
            }
        }
        return false;
    }

};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>dfs记忆化搜索:</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    unordered_map<int, int> um;
    vector<vector<int>> memo;
    bool canCross(vector<int>& stones) {

        for (int i = 0; i < stones.size(); i++) {
            um[stones[i]] = i;  // key:石子值 value是第几块石子
        }
        if (!um.count(1)) return false;
        memo = vector<vector<int>>(stones.size(), vector<int>(stones.size(), -1));
        return dfs(stones, stones.size(), 1, 1);
    }
    bool dfs(vector<int>& stones, int n, int cur, int k) {
        if (memo[cur][k] != -1) return memo[cur][k];
        if (cur == n - 1) return memo[cur][k] = true;
        for (int i = -1; i <= 1; i++) {
            if (k + i == 0) continue;  // 原地跳过
            int next = stones[cur] + k + i;
            if (um.count(next)) { // 存在
                bool choose = dfs(stones, n, um[next], k + i);
                if (choose) return memo[cur][k] = true;
            }
        }
        return memo[cur][k] = false;
    }

};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>动态规划：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    bool canCross(vector<int>& stones) {
        int n = stones.size();
        if (stones[1] != 1) return false;
        vector<vector<bool>> dp(n, vector<bool>(n));
        // dp[i][k] 表示在第i个位置且跳k个单位到第i块石子。
        dp[1][1] = true;
        for (int i = 2; i < n; i++) {
            for (int j = 1; j < i; j++) {
                int k = stones[i] - stones[j];
                if (k > j + 1) continue;
                // 因为题目要求 青蛙第一次只能跳1步，那么第二次至多跳2步，以此类推，青蛙在第i块（i从0开始）石头上至多只能跳i+1步。在第j块石头上至多只能跳 j+1 步 ，如果k > j+1，说明石头 i 隔石头 j 太远了，远到不满足题目的隐藏规则，所以青蛙必定跳不过去。
                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k+1];
            }
        }
        for (int i = 1; i < n; i++) {
            if (dp[n-1][i]) return true;
        }        
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>另一种动态规划:</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    bool canCross(vector<int>& stones) {
        // dp[i][j] 表示 第 i 个石头是否可以跳 j 步
        int n = stones.size();
        vector<vector<bool>> dp(n, vector<bool>(n));
        dp[0][1] = true;
        for (int i = 1; i < n; i++) {
            bool flag = false;
            for (int j = i - 1; j >= 0; j--) {
                int k = stones[i] - stones[j];
                if (k > i) break;
                if (dp[j][k]) {
                    dp[i][k - 1] = dp[i][k] = dp[i][k + 1] = true;
                    flag = true;
                }
            }
            if (i == n - 1 && !flag) {
                return false;
            }
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day04】137-只出现一次的数字II"><a href="#【Day04】137-只出现一次的数字II" class="headerlink" title="【Day04】137.只出现一次的数字II"></a>【Day04】137.只出现一次的数字II</h2><h4 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></h4><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>
<p> <strong>示例1：</strong></p>
<pre><code>输入：nums = [2,2,3,2]
输出：3</code></pre><p><strong>示例2：</strong></p>
<pre><code>输入：nums = [0,1,0,1,0,1,99]
输出：99</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 3 * 104</li>
<li>-231 &lt;= nums[i] &lt;= 231 - 1</li>
<li>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</li>
</ul>
<p><strong>题解：</strong></p>
<p> <strong>有限状态自动机：</strong></p>
<p>使用二进制表示每个元素，对应二进制位的1相加，最后相加对3取余</p>
<p>对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0,1,2 。由于二进制只能表示 0, 10,1 ，因此需要使用两个二进制位来表示 3 个状态。设此两位分别为 one，two.</p>
<p><strong>计算 one方法：</strong></p>
<p>设当前状态为 one ，two 此时输入二进制位 nn 。如下图所示，通过对状态表的情况拆分，可推出 one的计算方法为：</p>
<pre><code>if two == 0:
  if n == 0:
    one = one
  if n == 1:
    one = ~one
if two == 1:
    one = 0</code></pre><p>引入 异或运算 ，可将以上拆分简化为：</p>
<pre><code>if two == 0:
    one = one ^ n
if two == 1:
    one = 0</code></pre><p>引入 与运算 ，可继续简化为：</p>
<pre><code>one = one ^ n &amp; ~two</code></pre><p>同理：</p>
<pre><code>two = two ^ n &amp; ~one</code></pre><p>代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int two = 0, one = 0;
        for (auto x: nums) {
            one = (one ^ x) & ~two;
            two = (two ^ x) & ~one;
        }
        return one;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>哈希表：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> um;
        for (auto x : nums) {
            um[x]++;
        }

        for (auto x : um) {
            if (x.second == 1) return x.first;
        }
        return -1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day05】690-员工的重要性"><a href="#【Day05】690-员工的重要性" class="headerlink" title="【Day05】690.员工的重要性"></a>【Day05】690.员工的重要性</h2><h4 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">690. 员工的重要性</a></h4><p>给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。</p>
<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。</p>
<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
输出：11
解释：
员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>一个员工最多有一个 直系 领导，但是可以有多个 直系 下属</li>
<li>员工数量不超过 2000 。</li>
</ul>
<p><strong>题解：</strong></p>
<p>今天的题不是很难，直接遍历所有节点相加就行了，使用哈希表将id指向映射到指针，遍历一遍。</p>
<p><strong>dfs</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    unordered_map<int, Employee*> hash;

    int getImportance(vector<Employee*> employees, int id) {
        for (auto& p: employees) hash[p->id] = p;
        return dfs(id);
    }

    int dfs(int id) {
        auto p = hash[id];
        int res = p->importance;
        for (auto son: p->subordinates)
            res += dfs(son);
        return res;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day06】554-砖墙"><a href="#【Day06】554-砖墙" class="headerlink" title="【Day06】554.砖墙"></a>【Day06】554.砖墙</h2><h4 id="554-砖墙"><a href="#554-砖墙" class="headerlink" title="554. 砖墙"></a><a href="https://leetcode-cn.com/problems/brick-wall/" target="_blank" rel="noopener">554. 砖墙</a></h4><p>你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。</p>
<p>你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</p>
<p>给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg" alt></p>
<pre><code>输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：wall = [[1],[1],[1]]
输出：3</code></pre><p><strong>提示：</strong></p>
<ul>
<li>n == wall.length</li>
<li>1 &lt;= n &lt;= 104</li>
<li>1 &lt;= wall[i].length &lt;= 104</li>
<li>1 &lt;= sum(wall[i].length) &lt;= 2 * 104</li>
<li>对于每一行 i ，sum(wall[i]) 应当是相同的</li>
<li>1 &lt;= wall[i][j] &lt;= 231 - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>贪心，哈希表</strong></p>
<p>显然最优的线一定是沿某个块砖的边缘穿过的。<br>统计每一行的砖可以从左到右可以构成的长度值，用 unordered_map 哈希表统计长度值出现的次数。出现次数最多的值就应该是这条线所在的位置。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        unordered_map<int, int> cnt;
        for (auto& line: wall) {
            for (int i = 0, s = 0; i + 1 < line.size(); i ++ ) {
                s += line[i];
                cnt[s] ++ ;
            }
        }
        int res = 0;
        for (auto [k, v]: cnt) res = max(res, v);
        return wall.size() - res;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day07】7-整数反转7-整数反转"><a href="#【Day07】7-整数反转7-整数反转" class="headerlink" title="【Day07】7.整数反转7. 整数反转"></a>【Day07】7.整数反转<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：x = 123
输出：321</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：x = -123
输出：-321</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：x = 120
输出：21</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：x = 0
输出：0</code></pre><p><strong>提示：</strong></p>
<ul>
<li>-231 &lt;= x &lt;= 231 - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>(循环) O(logn)</strong><br>依次从右往左计算出每位数字，然后逆序累加在一个整数中。<br>另外，这题有两点需要注意：</p>
<ul>
<li><p>因为int型整数逆序后可能会溢出，所以我们要用long long记录中间结果；</p>
</li>
<li><p>在C++中，负数的取模运算和数学意义上的取模运算不同，结果还是负数，比如 −12%10=−2−12%10=−2，所以我们不需要对负数进行额外处理。</p>
</li>
</ul>
<p>时间复杂度分析：一共有 O(logn) 位，对于每一位的计算量是常数级的，所以总时间复杂度是  O(logn)</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while (x) {
            if (x > 0 && res > (INT_MAX - x % 10) / 10) return 0;
            if (x < 0 && res < (INT_MIN - x % 10) / 10) return 0;
            res = res * 10 + x % 10;
            x /= 10;
        }
        return res;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day08】1473-粉刷房子III"><a href="#【Day08】1473-粉刷房子III" class="headerlink" title="【Day08】1473.粉刷房子III"></a>【Day08】1473.粉刷房子III</h2><h4 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/" target="_blank" rel="noopener">1473. 粉刷房子 III</a></h4><p>在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p>
<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）</p>
<p>给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：</p>
<ul>
<li>houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。</li>
<li>cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。</li>
</ul>
<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：9
解释：房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：11
解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
输出：5</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
输出：-1
解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>m == houses.length == cost.length</li>
<li>n == cost[i].length</li>
<li>1 &lt;= m &lt;= 100</li>
<li>1 &lt;= n &lt;= 20</li>
<li>1 &lt;= target &lt;= m</li>
<li>0 &lt;= houses[i] &lt;= n</li>
<li>1 &lt;= cost[i][j] &lt;= 10^4</li>
</ul>
<p><strong>题解·：</strong></p>
<p>很明显的DP</p>
<ol>
<li><p>设状态  f(i,j,k) 表示处理了前 i 个房屋，有 j 个社区，最后一个房屋的颜色为 k 的最小花费，其中房屋的有效下标从 1 开始。建立辅助数组 g(i,j,k) 表示同样含义下，最后一个房屋颜色 不是 k 的最小花费。</p>
</li>
<li><p>初始时，f(0,0,k)=g(0,0,k)=0，其余为正无穷或者待定。<br>转移时，分两种情况</p>
</li>
<li><p>如果第 i 个房屋已经有了颜色 c，则有两种选择，上一个房屋颜色为 c 或者不为 c，转移<br>$$<br>f(i, j, c)=\min (f(i-1, j, c), g(i-1, j-1, c))<br>$$</p>
</li>
<li><p>如果第 i 个房屋没有颜色，则枚举一个颜色 k，然后同样根据上一个房屋的颜色，转移<br>$$<br>f(i, j, k)=\min (f(i-1, j, k), g(i-1, j-1, k))+\operatorname{cost}(i, k-1)_{\text {。 }}<br>$$</p>
</li>
<li><p>对于 g 数组的维护如下，假设当前需要维护前 i 个房屋且有 j 个社区下的 g 数组，则我们找 f(i,j,k) 中的最小值 m1 和次小值 m2。如果 m1=m2，则说明对于所有 k， g(i,j,k)=m1；否则，对于 f(i,j,k0)=m1 的那个 k0，其 g(i,j,k0)=m2g，其余 k≠k0都有 g(i,j,k)=m1。</p>
</li>
<li><p>最终答案为<br>$$<br>\min (f(m, \text { target }, k)<br>$$</p>
</li>
</ol>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        const int MAX = 0x3f3f3f3f;
        const int M = 110;
        const int N = 30;

        int f[M][M][N], g[M][M][N];
        memset(f, 0x3f, sizeof(f));
        memset(g, 0x3f, sizeof(g));

        for (int k = 1; k <= n; k++)
            f[0][0][k] = g[0][0][k] = 0;

        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= min(i, target); j++) {
                if (houses[i - 1] > 0) {
                    int c = houses[i - 1];
                    f[i][j][c] = min(f[i - 1][j][c], g[i - 1][j - 1][c]);
                } else {
                    for (int k = 1; k <= n; k++)
                        f[i][j][k] = min(f[i - 1][j][k], g[i - 1][j - 1][k])
                                        + cost[i - 1][k - 1];
                }

                int m1 = MAX, m2 = MAX;
                for (int k = 1; k <= n; k++)
                    if (m1 > f[i][j][k]) {
                        m2 = m1;
                        m1 = f[i][j][k];
                    } else if (m2 > f[i][j][k])
                        m2 = f[i][j][k];

                if (m1 == m2) {
                    for (int k = 1; k <= n; k++)
                        g[i][j][k] = m1;
                } else {
                    for (int k = 1; k <= n; k++)
                        if (f[i][j][k] == m1) g[i][j][k] = m2;
                        else g[i][j][k] = m1;
                }
            }

        int ans = MAX;
        for (int k = 1; k <= n; k++)
            ans = min(ans, f[m][target][k]);

        if (ans == MAX)
            ans = -1;

        return ans;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day09】740-删除并获得点数"><a href="#【Day09】740-删除并获得点数" class="headerlink" title="【Day09】740.删除并获得点数"></a>【Day09】740.删除并获得点数</h2><h4 id="740-删除并获得点数-https-leetcode-cn-com-problems-delete-and-earn"><a href="#740-删除并获得点数-https-leetcode-cn-com-problems-delete-and-earn" class="headerlink" title="740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)"></a>740. 删除并获得点数](<a href="https://leetcode-cn.com/problems/delete-and-earn/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-and-earn/</a>)</h4><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 2 * 104</li>
<li>1 &lt;= nums[i] &lt;= 104</li>
</ul>
<p><strong>题解：</strong></p>
<p>首先，我们先明确一个概念，就是每个位置上的数字是可以在两种前结果之上进行选择的：</p>
<p>如果你不删除当前位置的数字，那么你得到就是前一个数字的位置的最优结果。<br>如果你觉得当前的位置数字i需要被删，那么你就会得到i - 2位置的那个最优结果加上当前位置的数字乘以个数。<br>以上两个结果，你每次取最大的，记录下来，然后答案就是最后那个数字了。</p>
<p>如果你看到现在有点迷糊，那么我们先把数字进行整理一下。</p>
<p>我们在原来的 nums 的基础上构造一个临时的数组 all，这个数组，以元素的值来做下标，下标对应的元素是原来的元素的个数。</p>
<p>举个例子：</p>
<pre><code>nums = [2, 2, 3, 3, 3, 4]</code></pre><p>构造后：</p>
<pre><code>all=[0, 0, 2, 3, 1];</code></pre><p>就是代表着 22 的个数有两个，33 的个数有 33 个，44 的个数有 11 个。</p>
<p>其实这样就可以变成打家劫舍的问题了呗。</p>
<p>我们来看看，打家劫舍的最优子结构的公式：</p>
<p>$$<br>\mathrm{dp}[\mathrm{i}]=\text { Math.max }(\mathrm{d} \mathrm{p}[\mathrm{i}-1], \mathrm{dp}[\mathrm{i}-2]+\mathrm{nums}[\mathrm{i}])<br>$$<br>再来看看现在对这个问题的最优子结构公式：</p>
<p>$$<br>\mathrm{dp}[\mathrm{i}]=\text { Math.max }\left(\mathrm{dp}[\mathrm{i}-1], \mathrm{dp}[\mathrm{i}-2]+\mathrm{i}^{\star} \mathrm{all}[\mathrm{i}]\right)<br>$$</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        if(nums.size() < 1) return 0;
        int maxn = 0;
        for(int it : nums)
            maxn = max(maxn, it);
        vector<int> cnt(maxn+1), dp(maxn+1);
        for(int it : nums)
            cnt[it]++;
        dp[1] = cnt[1];
        for(int i = 2; i <= maxn; i++)
            dp[i] = max(dp[i-1], dp[i-2] + cnt[i] * i);
        return dp[maxn];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day10】1720-解码异或后的数组"><a href="#【Day10】1720-解码异或后的数组" class="headerlink" title="【Day10】1720. 解码异或后的数组"></a>【Day10】1720. 解码异或后的数组</h2><h4 id="1720-解码异或后的数组"><a href="#1720-解码异或后的数组" class="headerlink" title="1720. 解码异或后的数组"></a><a href="https://leetcode-cn.com/problems/decode-xored-array/" target="_blank" rel="noopener">1720. 解码异或后的数组</a></h4><p>未知 整数数组 arr 由 n 个非负整数组成。</p>
<p>经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。</p>
<p>给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。</p>
<p>请解码返回原数组 arr 。可以证明答案存在并且是唯一的。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：encoded = [1,2,3], first = 1
输出：[1,0,2,1]
解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：encoded = [6,2,7,3], first = 4
输出：[4,2,0,7,4]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= n &lt;= 104</li>
<li>encoded.length == n - 1</li>
<li>0 &lt;= encoded[i] &lt;= 105</li>
<li>0 &lt;= first &lt;= 105</li>
</ul>
<p><strong>题解：</strong></p>
<p>异或运算满足交换律和结合律；</p>
<p>任意整数和自身做异或运算的结果都等于 0，即 x⊕x=0；</p>
<p>任意整数和 0 做异或运算的结果都等于其自身，即 x⊕0=0⊕x=x。</p>
<p>在等号两边同时异或 arr[i]</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        int n = encoded.size();
        vector<int> arr(n + 1);
        arr[0] = first;
        for (int i = 0; i < n; i ++)
            arr[i + 1] = arr[i] ^ encoded[i];
        return arr;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day11】1486-数组异或操作"><a href="#【Day11】1486-数组异或操作" class="headerlink" title="【Day11】1486.数组异或操作"></a>【Day11】1486.数组异或操作</h2><h4 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/" target="_blank" rel="noopener">1486. 数组异或操作</a></h4><p>给你两个整数，n 和 start 。</p>
<p>数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。</p>
<p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     &quot;^&quot; 为按位异或 XOR 运算符。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：n = 1, start = 7
输出：7</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：n = 10, start = 5
输出：2</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= n &lt;= 1000</li>
<li>0 &lt;= start &lt;= 1000</li>
<li>n == nums.length</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int xorOperation(int n, int start)
    {
        int result = start, i;
        for (i = 1; i < n; i++)
        {
            result = result ^ (start + i * 2);
        }
        return result;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day12】1723-完成所有工作的最短时间"><a href="#【Day12】1723-完成所有工作的最短时间" class="headerlink" title="【Day12】1723.完成所有工作的最短时间"></a>【Day12】1723.完成所有工作的最短时间</h2><h4 id="1723-完成所有工作的最短时间"><a href="#1723-完成所有工作的最短时间" class="headerlink" title="1723. 完成所有工作的最短时间"></a><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/" target="_blank" rel="noopener">1723. 完成所有工作的最短时间</a></h4><p>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。</p>
<p>请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。</p>
<p>返回分配方案中尽可能 最小 的 最大工作时间 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：jobs = [3,2,3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：jobs = [1,2,4,7,8], k = 2
输出：11
解释：按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= k &lt;= jobs.length &lt;= 12</li>
<li>1 &lt;= jobs[i] &lt;= 107</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>回溯法+剪枝</strong></p>
<p>用一个 vector<int> block 记录每个人分配到的工作量，尝试将一份工作分配给一个人，且它的工作时间不超过lim要求，之后开启递归分配下一项工作，尝试找到一个成功分配全部工作的路径</int></p>
<p>递归深度为 n=jobs.length 工作数量，每次递归需要检测范围为 k 员工数量并开启分支，最坏情况下走满树时间复杂度为 O(k^n)<br>题设 1 &lt;= k &lt;= jobs.length &lt;= 12，最坏情况下 12^12 = 8.9E12，外面还套了一个二分，还要再乘 log12 = 3.xxxx，远超1s极限算量1E8</p>
<p>因此我们需要考虑一些剪枝的方法，首先我们可以 sort 一下 jobs ，时长从大到小开始分配，进而能够更快的超出限制，被剪枝掉，其次是朴素写法中存在很多重复的路径</p>
<p>例如对于第一份工作的分配，所有人工作时长全部是0，我们只需要分配一次</p>
<pre><code>[t1,0,0,0,0]
之后的
[0,t1,0,0,0]
...</code></pre><p>都是重复操作。</p>
<p> 56号测试用例：</p>
<pre><code>[5,5,4,4,4]
2</code></pre><p>如果先将 5h 分配给两个人block [5,5]，之后分配4时，只需要走一次 [9,5]，后面的[5,9] 是重复操作</p>
<p>由于jobs已排序，因此我们每次枚举到的 block[i] 应当和上一次不一样，才是没走过的路径，进而排除全0时的重复放置，或是出现相同工作时长分配时的重复放置</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int k;
    vector<int>  block;
    bool backtracking(vector<int>& jobs,int id,int lim) {
        if(id==-1) return true; //出口 全部放完了

        bool res=false;
        int last=INT_MIN; 

        for(int i=0;i<k;++i) {
            if(res) 
                break;
            if(block[i]==last) 
                continue; //剪枝 因为jobs已排序所以应枚举和上一次不一样的结果

            last=block[i];

            if(block[i]<=lim-jobs[id]){ //小心越界
                block[i]+=jobs[id];
                res = backtracking(jobs,id-1,lim);
                block[i]-=jobs[id];
            }
        }
        return res;
    }
    int minimumTimeRequired(vector<int>& jobs, int k) {
        this->k = k;
        int s=0; //区间左端点（最小）
        int e=0; //区间右端点（最大）
        int m;//中间
        int n = jobs.size()-1;//起手下标
        block = vector<int>(k,0); // 拷贝初始化
        sort(jobs.begin(),jobs.end());    
        s=jobs[n];//结果最小应是 jobs[i] 的最大值

        for(auto i : jobs) { //最大应是 sum(jobs.begin(),jobs.end()) 小心越界
            if(e<=INT_MAX-i) e+=i;
            else e=INT_MAX;
        }        
        while(s!=e) {
            int m = (s+e)/2;
            if(backtracking(jobs,n,m)) { //成功 尝试缩减区间
                e=m;//m无法排除
            }else {//失败 扩大
                s=m+1;//m肯定不对最少加1
            }
        }
        return s;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day13】1482-制作m束花所需的最少天数"><a href="#【Day13】1482-制作m束花所需的最少天数" class="headerlink" title="【Day13】1482.制作m束花所需的最少天数"></a>【Day13】1482.制作m束花所需的最少天数</h2><h4 id="1482-制作-m-束花所需的最少天数"><a href="#1482-制作-m-束花所需的最少天数" class="headerlink" title="1482. 制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">1482. 制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</p>
<p>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。</p>
<p>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。</p>
<p>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1
输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：bloomDay = [1,10,3,10,2], m = 3, k = 2
输出：-1
解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
输出：12
解释：要制作 2 束花，每束需要 3 朵。
花园在 7 天后和 12 天后的情况如下：
7 天后：[x, x, x, x, _, x, x]
可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
12 天后：[x, x, x, x, x, x, x]
显然，我们可以用不同的方式制作两束花。</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：bloomDay = [1000000000,1000000000], m = 1, k = 1
输出：1000000000
解释：需要等 1000000000 天才能采到花来制作花束</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
输出：9</code></pre><p><strong>提示：</strong></p>
<ul>
<li>bloomDay.length == n</li>
<li>1 &lt;= n &lt;= 10^5</li>
<li>1 &lt;= bloomDay[i] &lt;= 10^9</li>
<li>1 &lt;= m &lt;= 10^6</li>
<li>1 &lt;= k &lt;= n</li>
</ul>
<p><strong>题解：</strong></p>
<p>假设制作m束花需要等待的最少天数是x天，那么有：</p>
<ul>
<li>[0, x)天无法制作出来m束</li>
<li>[x,maxDay]可以制作出m束</li>
</ul>
<p>求出给定花开数组中最大值，进行二分计算即可。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int minDays(vector<int>& bloomDay, int m, int k) {
        int n = bloomDay.size();
        if (m * k  > n) return -1;
        int l = 0, r = 0;
        for (auto x : bloomDay) {
            r = max(r, x);
        }
        while(l < r) {
            int mid = l + r >> 1;
            if (check(bloomDay, mid, m, k)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
    bool check(vector<int>& bloomDay, int mid, int m, int k) {
        int sum = 0;
        // 计算是否满足m束花且每一束都有相邻的k个
        for (int i = 0; i < bloomDay.size() && sum < m; i++) {
            int cur_sum = 0;
            if (bloomDay[i] <= mid) { // 可以开
                cur_sum++;
                int j = i + 1;
                while (j < bloomDay.size() && bloomDay[j] <= mid && cur_sum < k) {
                    j++;
                    cur_sum++;
                }
                if (cur_sum == k) sum++;
                i = j - 1;
            } 
        }
        return sum >= m;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day14】872-叶子相似的树"><a href="#【Day14】872-叶子相似的树" class="headerlink" title="【Day14】872.叶子相似的树"></a>【Day14】872.叶子相似的树</h2><h4 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/" target="_blank" rel="noopener">872. 叶子相似的树</a></h4><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。</p>
<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p>
<p>如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg" alt></p>
<pre><code>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
输出：true</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：root1 = [1], root2 = [1]
输出：true</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：root1 = [1], root2 = [2]
输出：false</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：root1 = [1,2], root2 = [2,2]
输出：true</code></pre><p><strong>示例 5：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg" alt></p>
<pre><code>输入：root1 = [1,2,3], root2 = [1,3,2]
输出：false</code></pre><p><strong>提示：</strong></p>
<ul>
<li>给定的两棵树可能会有 1 到 200 个结点。</li>
<li>给定的两棵树上的值介于 0 到 200 之间。</li>
</ul>
<p><strong>题解：</strong></p>
<p>将第一次的结果存储下来后，后面直接比较并返回结果。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int index = 0;
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector<int> r1;
        dfs1(root1, r1);
        return dfs2(root2, r1) && index == r1.size();
    }
    void dfs1(TreeNode* root, vector<int>& res) {
        if (!root) return;
        if (!root->left && !root->right) {
            res.push_back(root->val);
            return;
        }
        dfs1(root->left, res);
        dfs1(root->right, res);
    }
    bool dfs2(TreeNode* root, vector<int>& res) {
        if (!root) return true;
        if (!root->left && !root->right) {
            if (index >= res.size()) return false;
            if (root->val != res[index]) return false;
            index++;
            return true;
        }
        return dfs2(root->left, res) && dfs2(root->right, res);
    }

};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day15】1734-解码异或后的排列"><a href="#【Day15】1734-解码异或后的排列" class="headerlink" title="【Day15】1734.解码异或后的排列"></a>【Day15】1734.解码异或后的排列</h2><h4 id="1734-解码异或后的排列"><a href="#1734-解码异或后的排列" class="headerlink" title="1734. 解码异或后的排列"></a><a href="https://leetcode-cn.com/problems/decode-xored-permutation/" target="_blank" rel="noopener">1734. 解码异或后的排列</a></h4><p>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。</p>
<p>它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。</p>
<p>给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：encoded = [3,1]
输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：encoded = [6,5,4,6]
输出：[2,4,1,5,3]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>3 &lt;= n &lt; 105</li>
<li>n 是奇数。</li>
<li>encoded.length == n - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p>perm = [A,B,C,D,E]</p>
<p>encoded = [A^B, B^C, C^D, D^E]</p>
<p>而B^C^D^E = encoded[1] ^ encode[3]</p>
<p>A^B^C^D^E = total</p>
<p>total ^ (B^C^D^E) = first</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    vector<int> decode(vector<int>& encoded) {
        int n = encoded.size() + 1;
        int total = 0;
        for (int i = 1; i <= n; i++) {
            total ^= i;
        }

        int e = 0;
        for (int i = 1; i < n - 1; i += 2) {
            e ^= encoded[i];
        }

        vector<int> ans(n);
        ans[0] = total ^ e;
        for (int i = 1; i < n; i++) {
            ans[i] = ans[i-1] ^ encoded[i-1];
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day16】1310-子数组异或查询"><a href="#【Day16】1310-子数组异或查询" class="headerlink" title="【Day16】1310.子数组异或查询"></a>【Day16】1310.子数组异或查询</h2><h4 id="1310-子数组异或查询"><a href="#1310-子数组异或查询" class="headerlink" title="1310. 子数组异或查询"></a><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/" target="_blank" rel="noopener">1310. 子数组异或查询</a></h4><p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出：[2,7,14,8] 
解释：
数组中元素的二进制表示形式是：
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
查询的 XOR 值为：
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
输出：[8,0,4,4]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= arr.length &lt;= 3 * 10^4</li>
<li>1 &lt;= arr[i] &lt;= 10^9</li>
<li>1 &lt;= queries.length &lt;= 3 * 10^4</li>
<li>queries[i].length == 2</li>
<li>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</li>
</ul>
<p><strong>题解：</strong></p>
<p>利用前缀和思想：sum(i,j) = sum(j) - sum(i-1);</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        vector<int> ans;
        int sum[arr.size() + 1];
        for (int i = 1; i <= arr.size(); i++) {
            sum[i] = sum[i - 1] ^ arr[i - 1];
        }

        for (auto q : queries) {
            ans.push_back(sum[q[1] + 1] ^ sum[q[0]]);
        }
        return ans;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day17】1269-停在原地的方案数"><a href="#【Day17】1269-停在原地的方案数" class="headerlink" title="【Day17】1269.停在原地的方案数"></a>【Day17】1269.停在原地的方案数</h2><h4 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a></h4><p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：steps = 3, arrLen = 2
输出：4
解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动</code></pre><p><strong>示例  2：</strong></p>
<pre><code>输入：steps = 2, arrLen = 4
输出：2
解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：steps = 4, arrLen = 2
输出：8</code></pre><p><strong>提示：</strong></p>
<pre><code>1 &lt;= steps &lt;= 500
1 &lt;= arrLen &lt;= 10^6</code></pre><p><strong>题解：</strong></p>
<p><strong>暴力递归</strong></p>
<p>pos表示移动的index,st表示当前还剩步数。结果超时- _ -</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
 public:
  const int N = 1000000007;
  int numWays(int steps, int arrLen) { 
      int res = dfs(steps, arrLen, 0);
      return res % N; 
  }

  int dfs(int st, int arrLen, int pos) {
    if (st < 0 || pos < 0 || pos >= arrLen) return 0;
    if (st == 0 && pos == 0) {
      return 1;
    }
    int ans = 0;
    if (pos >= 0 && pos <= arrLen - 1)
      // 不动
      ans = dfs(st - 1, arrLen, pos);
    if (pos >= 1)
      // 向左
      ans += dfs(st - 1, arrLen, pos - 1);
    if (pos <= arrLen - 2)
      // 向右
      ans += dfs(st- 1, arrLen, pos + 1);
    return ans;
  }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>记忆化搜索</strong></p>
<p><strong>一开始开辟空间太大，过不了，发现开辟很大空间后，使用map性能比vector好，而实际只需要开辟steps*steps即可。</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">int memo[505][505];
// vector<vector<int>> memo;
class Solution {
 public:
  static const int N = 1000000007;
  int numWays(int steps, int arrLen) { 
      memset(memo, -1, sizeof(memo));
    //   memo = vector<vector<int>>(505, vector<int>(505,-1));
      int res = dfs(steps, arrLen, 0);
      return res % N; 
  }

  int dfs(int st, int arrLen, int pos) {
    if (st < 0 || pos < 0 || pos >= arrLen) return 0;
    if (memo[st][pos] != -1) return memo[st][pos];
    if (st == 0 && pos == 0) {
      return memo[st][pos] = 1;
    }
    int ans = 0;
    if (pos >= 0 && pos <= arrLen - 1) 
      // 不动
      ans = dfs(st - 1, arrLen, pos) % N;
    if (pos >= 1)
      // 向左
      ans =  ans % N + dfs(st - 1, arrLen, pos - 1) % N;
    if (pos <= arrLen - 2)
      // 向右
      ans = ans % N + dfs(st- 1, arrLen, pos + 1) % N;
    return memo[st][pos] = ans;
  }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>动态规划</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
 public:
  static const int N = 1000000007;
  int numWays(int steps, int arrLen) { 
      int maxLen = min(steps, arrLen);
      long long dp[steps + 1][maxLen + 1];
      memset(dp, 0, sizeof dp);
      dp[1][0] = 1;
      dp[1][1] = 1; // step=1 pos=1

      for (int s = 1; s <= steps; s++) {
          for (int l = 0; l < maxLen; l++) {
            // 原地
                dp[s][l] = dp[s][l] + dp[s - 1][l];
            // 右
                dp[s][l] = dp[s][l]  + dp[s - 1][l + 1];
            // 左

                if (l - 1 >= 0)
                    dp[s][l] =  dp[s][l] + dp[s - 1][l - 1];

              dp[s][l] %= N;
          }
      }     
      return dp[steps][0]; 
  }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day18】12-整数转罗马数字"><a href="#【Day18】12-整数转罗马数字" class="headerlink" title="【Day18】12.整数转罗马数字"></a>【Day18】12.整数转罗马数字</h2><h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字</a></h4><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</code></pre><blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
</blockquote>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: num = 3
输出: &quot;III&quot;</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: num = 4
输出: &quot;IV&quot;</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: num = 9
输出: &quot;IX&quot;</code></pre><p><strong>示例 4:</strong></p>
<pre><code>输入: num = 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>
<pre><code>输入: num = 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= num &lt;= 3999</li>
</ul>
<p><strong>题解：</strong></p>
<p>第一想到贪心，使用哈希表排序罗马数字并遍历，从高到低进行匹配。暴力匹配也可以的，</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    string intToRoman(int num) {
        int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        string reps[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        string ans;
        int 
        for (int i = 0; i < 13; i ++ ) 
            while(num >= values[i])
            {
                num -= values[i];
                ans += reps[i];
            }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day19】13-罗马数字转整数"><a href="#【Day19】13-罗马数字转整数" class="headerlink" title="【Day19】13.罗马数字转整数"></a>【Day19】13.罗马数字转整数</h2><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</code></pre><blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
</blockquote>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;III&quot;
输出: 3</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;IV&quot;
输出: 4</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: &quot;IX&quot;
输出: 9</code></pre><p><strong>示例 4:</strong></p>
<pre><code>输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>
<pre><code>输入: &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= s.length &lt;= 15</li>
<li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li>
<li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>
</ul>
<p><strong>题解：</strong></p>
<ul>
<li><p>当小值在大值的左边，则减小值，如 IV=5-1=4；</p>
</li>
<li><p>当小值在大值的右边，则加小值，如 VI=5+1=6；</p>
</li>
<li><p>小值放在大值的左边，就是做减法，否则为加法。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int romanToInt(string s) {
    int r=0;

    for(int i=0;i<s.length();i++)
    {
        switch(s[i])
        {
            case 'I' : r += ('V' == s[i+1] || 'X' == s[i+1]) ?-1 : 1 ; break;
            case 'V' : r += 5; break;
            case 'X' : r += ('L' == s[i+1] || 'C' == s[i+1]) ?-10: 10 ; break;
            case 'L' : r += 50; break;
            case 'C' : r += ('D' == s[i+1] || 'M' == s[i+1]) ?-100: 100 ; break;
            case 'D' : r += 500; break;
            case 'M' : r += 1000; break;
        }
    }
    return r;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day20】421-数组中两个数的最大异或值"><a href="#【Day20】421-数组中两个数的最大异或值" class="headerlink" title="【Day20】421.数组中两个数的最大异或值"></a>【Day20】421.数组中两个数的最大异或值</h2><h4 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a></h4><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p>
<p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0]
输出：0</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [2,4]
输出：6</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：nums = [8,10,2]
输出：10</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
输出：127</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 2 * 104</li>
<li>0 &lt;= nums[i] &lt;= 231 - 1</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>前缀树</strong></p>
<p>将所有数据从最高位开始取每一个bit，构建出树形结构，尽可能保证最高位为1，也就是说当循环到当前数的时候，如果当前数的bit与当前数中某一个数的某一位是相反的，那么可以保证为1，也就是最大，否则向低位继续循环。</p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Node{
    Node* next[2] = {nullptr};
};
class Solution {
public:
    void insert(int num, Node* root) {
        for (int i = 30; i >= 0; --i) {
            int t = (num >> i & 1);
            if (!root->next[t]) {
                root->next[t] = new Node();
            }
            root = root->next[t];
        }
    }
    int findMaximumXOR(vector<int>& nums) {
        Node* root = new Node();
        for (auto val : nums) {
            insert(val, root);
        }
        int res = 0, tmp = 0;
        Node* p = root;
        for (auto val : nums) {
            p = root; tmp = 0;
            for (int i = 30; i >= 0; --i) {
                int t = (val >> i) & 1;
                if (p->next[!t]) {
                    p = p->next[!t];
                    tmp += (1 << i);
                }else p = p->next[t];
            }
            res = max(res, tmp);
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>暴力+剪枝</strong></p>
<p>剪枝策略两数异或最大不超过两数之和，先排序再剪枝。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        sort(nums.begin(), nums.end(), [](auto a, auto b) {return a > b;});
        int ans = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                long long x = (long long)nums[i] + nums[j];
                if (ans > x) break;
                ans = max(ans, nums[i] ^ nums[j]);
            }
        }
        return ans;     
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day21】993-二叉树的堂兄弟节点"><a href="#【Day21】993-二叉树的堂兄弟节点" class="headerlink" title="【Day21】993.二叉树的堂兄弟节点"></a>【Day21】993.二叉树的堂兄弟节点</h2><h4 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" target="_blank" rel="noopener">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>
<p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>
<p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p>
<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt></p>
<pre><code>输入：root = [1,2,3,4], x = 4, y = 3
输出：false</code></pre><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" alt></p>
<pre><code>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true</code></pre><p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" alt></p>
<pre><code>输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false</code></pre><p><strong>提示：</strong></p>
<ul>
<li>二叉树的节点数介于 2 到 100 之间。</li>
<li>每个节点的值都是唯一的、范围为 1 到 100 的整数。</li>
</ul>
<p><strong>题解：</strong></p>
<p>假设从根节点开始编号1，依次往后编号，其两个孩子是<code>2*n</code>与<code>2*n+1</code>。反过来便是根据两个孩子节点判断是否是同一个父亲，那便是直接除以2，向下取整，看两者是否一样即可。</p>
<p>例如：2、3是同一父亲，2、4不是。</p>
<p>在BFS过程中记录节点编号以及x、y节点，最后判断即可。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        queue<TreeNode*> q;
        q.push(root);
        int cnt = 1;
        while (q.size()) {
            int sz = q.size();
            bool xt = false, yt = false;
            int xcnt, ycnt;
            while (sz--) {
                auto p = q.front();
                q.pop();
                if (p) {
                    if (x == p->val) {
                        xt = true;
                        xcnt = cnt;
                    }
                    if (y == p->val) { 
                        yt = true;
                        ycnt = cnt;
                    }

                    if (xt && yt && int(xcnt / 2) != int(ycnt / 2) ) {
                        return true;
                    }
                    q.push(p->left); q.push(p->right);
                }
                cnt++;
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day22】1442-形成两个异或相等数组的三元组数目"><a href="#【Day22】1442-形成两个异或相等数组的三元组数目" class="headerlink" title="【Day22】1442.形成两个异或相等数组的三元组数目"></a>【Day22】1442.形成两个异或相等数组的三元组数目</h2><h4 id="1442-形成两个异或相等数组的三元组数目"><a href="#1442-形成两个异或相等数组的三元组数目" class="headerlink" title="1442. 形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">1442. 形成两个异或相等数组的三元组数目</a></h4><p> 给你一个整数数组 arr 。</p>
<p>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。</p>
<p>a 和 b 定义如下：</p>
<ul>
<li>a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>
<li>b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>
</ul>
<p>注意：^ 表示 按位异或 操作。</p>
<p>请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：arr = [2,3,1,6,7]
输出：4
解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：arr = [1,1,1,1,1]
输出：10</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：arr = [2,3]
输出：0</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：arr = [1,3,5,7,9]
输出：3</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：arr = [7,11,12,9,5,2,7,17,22]
输出：8</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= arr.length &lt;= 300</li>
<li>1 &lt;= arr[i] &lt;= 10^8</li>
</ul>
<p><strong>题解：</strong></p>
<p>∵   a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</p>
<p>​     b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</p>
<p>∴  arr[i] ^ arr[i + 1] ^ … ^ arr[k] = a ^ b = 0;</p>
<p>a^b=0得到区间[i,k]中有k-i个元组，全部累加即可。区间内三元组的个数为 k - i（因为区间内的任意一个j，都和i，k组成满足题目的一个三元组）。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int countTriplets(vector<int>& arr) {
        int ans = 0;
        for (int i = 0; i < arr.size(); i++) {
            int s = arr[i];
            for (int k = i + 1; k < arr.size(); k++) {
                s ^= arr[k];
                if (s == 0) ans += k - i;
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day23】1738-找出第-K-大的异或坐标值"><a href="#【Day23】1738-找出第-K-大的异或坐标值" class="headerlink" title="【Day23】1738.找出第 K 大的异或坐标值"></a>【Day23】1738.找出第 K 大的异或坐标值</h2><h4 id="1738-找出第-K-大的异或坐标值"><a href="#1738-找出第-K-大的异或坐标值" class="headerlink" title="1738. 找出第 K 大的异或坐标值"></a><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/" target="_blank" rel="noopener">1738. 找出第 K 大的异或坐标值</a></h4><p>给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。</p>
<p>矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>
<p>请你找出 matrix 的所有坐标中第 k 大的值（<strong>k 的值从 1 开始计数</strong>）。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：matrix = [[5,2],[1,6]], k = 1
输出：7
解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：matrix = [[5,2],[1,6]], k = 2
输出：5
解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：matrix = [[5,2],[1,6]], k = 3
输出：4
解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：matrix = [[5,2],[1,6]], k = 4
输出：0
解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 1000</li>
<li>0 &lt;= matrix[i][j] &lt;= 106</li>
<li>1 &lt;= k &lt;= m * n</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>二维差分+最小堆</strong></p>
<p>前缀和模板+维护k个元素的最小堆</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int prefix[1000][1000];
    int kthLargestValue(vector<vector<int>>& matrix, int k) {
        int m = matrix.size();
        int n = matrix[0].size();
        prefix[0][0] = matrix[0][0];
        // 处理第一行
        for (int i = 1; i < n; i++) {
            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];
        }
        // 处理第一列
        for (int i = 1; i < m; i++) {
            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];
            }
        }

        priority_queue<int, vector<int>, std::greater<int>> pq;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                pq.push(prefix[i][j]);
                if (pq.size() > k) pq.pop();
            }
        }
        return pq.top();
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>二分搜值</strong></p>
<p>每次猜测一个值x，然后遍历前缀和矩阵，统计有多少个元素大于等于x，如果count小于k，那么x肯定不可能是答案，我们将猜测的上界下调至x-1；否则，我们就将猜测的下界调整至x。可以看到问题可以转换为查找最后一个小于等于target的数。因为当查找到大于等于target时要往上不断压缩区间，直到小于等于k为止。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int prefix[1000][1000];
    int m, n;
    int kthLargestValue(vector<vector<int>>& matrix, int k) {
        m = matrix.size();
        n = matrix[0].size();
        prefix[0][0] = matrix[0][0];
        // 处理第一行
        for (int i = 1; i < n; i++) {
            prefix[0][i] = prefix[0][i - 1] ^ matrix[0][i];
        }
        // 处理第一列
        for (int i = 1; i < m; i++) {
            prefix[i][0] = prefix[i - 1][0] ^ matrix[i][0];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ matrix[i][j] ^ prefix[i - 1][j - 1];
            }
        }

        int left = 0, right = 1e6;
        while (left < right) {
            int mid = right - (right - left - 1) / 2;
            if (count(mid) < k) { // 缩小值
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return left;
    }
    int count (int mid) {
        int cnt = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (prefix[i][j] >= mid) cnt++;
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day24】692-前K个高频单词"><a href="#【Day24】692-前K个高频单词" class="headerlink" title="【Day24】692.前K个高频单词"></a>【Day24】692.前K个高频单词</h2><h4 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-words/" target="_blank" rel="noopener">692. 前K个高频单词</a></h4><p>给一非空的单词列表，返回前 k 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2
输出: [&quot;i&quot;, &quot;love&quot;]
解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4
输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]
解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。</code></pre><p><strong>注意：</strong></p>
<ul>
<li>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。</li>
<li>输入的单词均由小写字母组成。</li>
</ul>
<p><strong>扩展练习：</strong></p>
<blockquote>
<p>尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p>
</blockquote>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">struct Cmp {
    bool operator()(const pair<string, int>& p1, const pair<string, int>& p2) {
        if(p1.second != p2.second) return p1.second > p2.second;
        else return p1.first < p2.first;
    }
};

class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> m;
        for(string& word : words) m[word]++;
        vector<pair<string, int>> sorted_list(m.begin(), m.end());
        sort(sorted_list.begin(), sorted_list.end(), Cmp());
        vector<string> res;
        for(int i = 0; i < k; i++) res.push_back(sorted_list[i].first);
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day25】1035-不相交的线"><a href="#【Day25】1035-不相交的线" class="headerlink" title="【Day25】1035.不相交的线"></a>【Day25】1035.不相交的线</h2><h4 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode-cn.com/problems/uncrossed-lines/" target="_blank" rel="noopener">1035. 不相交的线</a></h4><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p>
<ul>
<li>nums1[i] == nums2[j]</li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png" alt></p>
<pre><code>输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums1.length &lt;= 500</li>
<li>1 &lt;= nums2.length &lt;= 500</li>
<li>1 &lt;= nums1[i], nums2[i] &lt;= 2000</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    vector<vector<int>> dp;
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[n][m];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day26】810-黑板异或游戏"><a href="#【Day26】810-黑板异或游戏" class="headerlink" title="【Day26】810.黑板异或游戏"></a>【Day26】810.黑板异或游戏</h2><h4 id="810-黑板异或游戏"><a href="#810-黑板异或游戏" class="headerlink" title="810. 黑板异或游戏"></a><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/" target="_blank" rel="noopener">810. 黑板异或游戏</a></h4><p>黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p>
<p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>
<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: nums = [1, 1, 2]
输出: false
解释: 
Alice 有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= N &lt;= 1000</li>
<li>0 &lt;= nums[i] &lt;= 2^16</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    bool xorGame(vector<int>& nums) {
        //数组元素个数是奇数/偶数，有决定性作用：
        //如果是偶数，先手必胜；
        //如果是奇数，只有当一上来所有元素异或的结果为0，先手才获胜，
        //否则，接下来轮到后手，此时元素个数为偶数，则后手必胜，先手必败！
        int len = nums.size(), t = 0;
        if(len % 2)
        {
            for(auto& x:nums) t ^= x; //所有元素异或的结果
            if(t) return false;
            else return true;
        }
        else return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day27】1707-与数组中元素的最大异或值"><a href="#【Day27】1707-与数组中元素的最大异或值" class="headerlink" title="【Day27】1707.与数组中元素的最大异或值"></a>【Day27】1707.与数组中元素的最大异或值</h2><h4 id="1707-与数组中元素的最大异或值"><a href="#1707-与数组中元素的最大异或值" class="headerlink" title="1707. 与数组中元素的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/" target="_blank" rel="noopener">1707. 与数组中元素的最大异或值</a></h4><p>给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。</p>
<p>第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] &lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。</p>
<p>返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
输出：[3,3,7]
解释：
1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
输出：[15,-1,5]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length, queries.length &lt;= 105</li>
<li>queries[i].length == 2</li>
<li>0 &lt;= nums[j], xi, mi &lt;= 109</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">const int N = 1e5 + 50, M = 32 * N;
int son[M][2];
int idx;

void insert(int x){
    int p = 0;
    for(int i = 31; i >= 0; i--){
        int u = (x >> i) & 1;
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
}
int query(int x){
    int ans = 0, p = 0;
    for(int i = 31; i >= 0; i--){
        int u = (x >> i) & 1;
        if(son[p][!u]) {
            ans += (1 << i);
            p = son[p][!u];
        }
        else p = son[p][u];
    }
    return ans;
}

class Solution {
public:
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        memset(son,0,sizeof son);
        idx = 0;
        sort(nums.begin(),nums.end());
        //离线思想，因此需要对queries加一个pos，因为回答是乱序的
        int pos = 0;
        for(auto& q: queries){
            q.push_back(pos++);
        }
        sort(queries.begin(),queries.end(),[](const auto& a,const auto& b){
            return a[1] < b[1];
        });
        vector<int> ans(queries.size());
        int cur = 0;
        for(const auto& q : queries){
            int xi = q[0], mi = q[1],id = q[2];
            while(cur < nums.size() and nums[cur] <= mi){
                insert(nums[cur]);
                cur++;
            }
            if(cur == 0) ans[id] = -1;
            else ans[id] = query(xi);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day28】664-奇怪的打印机"><a href="#【Day28】664-奇怪的打印机" class="headerlink" title="【Day28】664.奇怪的打印机"></a>【Day28】664.奇怪的打印机</h2><h4 id="664-奇怪的打印机"><a href="#664-奇怪的打印机" class="headerlink" title="664. 奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/" target="_blank" rel="noopener">664. 奇怪的打印机</a></h4><p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 同一个字符 组成的序列。</li>
<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;aaabbb&quot;
输出：2
解释：首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;aba&quot;
输出：2
解释：首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 &#39;a&#39;。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= s.length &lt;= 100</li>
<li>s 由小写英文字母组成</li>
</ul>
<p><strong>题解：</strong></p>
<p>区间dp问题，对于[i,j]区间i&lt;j，如果s[i] == s[j]，那么dp[i][j] = dp[i - 1][j] 或者dp[i + 1][j]，例如：aba 等于 ab或者 ba</p>
<p>如果s[i]!=s[j]，那么对于区间[i,j]的所有组合，进行累加求min即可。</p>
<p>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])</p>
<p>目标是求dp[0][n - 1]，因此，对于这道题有两种遍历方式。</p>
<p><strong>第一种：从下往上，从左到右。</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int strangePrinter(string s) {
        // aba
        // aaabbb
        int n = s.size();
        int dp[n][n];
        memset(dp, 0x3f3f3f3f, sizeof(dp));
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i][j - 1];
                } else {
                    for (int k = i; k < j; k++) {
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
                    }
                }
            }
        }     
        return dp[0][n - 1];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>第二种：斜着遍历。</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int strangePrinter(string s) {
        // aba
        // aaabbb
        int n = s.size();
        int dp[n][n];
        memset(dp, 0x3f3f3f3f, sizeof(dp));
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        for (int l = 2; l <= n; l++) {
            for (int i = 0; i < n - l + 1; i++) {
                int j = l + i - 1;
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i][j - 1];
                } else {
                    for (int k = i; k < j; k++) {
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
                    }
                }
            }
        }


        return dp[0][n - 1];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day29】1787-使所有区间的异或结果为零"><a href="#【Day29】1787-使所有区间的异或结果为零" class="headerlink" title="【Day29】1787.使所有区间的异或结果为零"></a>【Day29】1787.使所有区间的异或结果为零</h2><h4 id="1787-使所有区间的异或结果为零"><a href="#1787-使所有区间的异或结果为零" class="headerlink" title="1787. 使所有区间的异或结果为零"></a><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/" target="_blank" rel="noopener">1787. 使所有区间的异或结果为零</a></h4><p>给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left &lt;= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR … XOR nums[right] 。</p>
<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 k 的区间异或结果等于零。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,0,3,0], k = 1
输出：3
解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [3,4,5,2,1,7,3,4,7], k = 3
输出：3
解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [1,2,4,1,2,5,1,2,6], k = 3
输出：3
解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]</code></pre><p><strong>提示：</strong></p>
<ul>
<li><p>1 &lt;= k &lt;= nums.length &lt;= 2000</p>
</li>
<li><p>0 &lt;= nums[i] &lt; 210</p>
<p><strong>题解：</strong></p>
</li>
</ul>
<p>第一种情况采用贪心的方法求得最优解。因为修改后的元素可能是原序列中没有出现过的元素。如果修改的某一列的元素是原序列中没有出现过的元素，那么这种情况下一定可以用贪心的办法求出最优解，做法是将众数最小的一列中的每个数变成一个全新的，该列中没有出现的，使得每个周期内的元素的异或和为0的数。</p>
<p>第二种情况采用dp的方法求得最优解在这种情况下，由于没有最终修改后的元素是原数组中存在的数，因此可以从前往后枚举每一列，然后枚举选择第几行的数作为这列元素修改后的元素，由于异或具有交换性质，因此不具有顺序的问题，所以可以采用dp的方法递推出将序列变成数组中本来存在的某个数的情况。边界，f[0] [0] = 0，目标状态是f[k] [0]，状态表示f[i] [j]为前i列异或和为j的情况下的最小值。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    // 1.某一列用了一个全新的数
    // 2.每一列用了原来的数

    const int N = 1024, INF = 1e8;
    int s[1024]; // 求众数
    int minChanges(vector<int>& nums, int k) {
        int n = nums.size(), m = (n + k - 1) / k;
        vector<vector<int>> f(k + 1, vector<int>(N, INF));
        int cnt = 0, minv = INF; // 每一列代价
        // f[i][j] 第i列的异或和为j
        f[0][0] = 0;
        for (int i = 1; i <= k; i++) {
            int len = m;
            memset(s, 0 , sizeof s);
            if (n % k && n % k < i) len--;
            for (int j = 0; j < len; j ++) {
                s[nums[j * k + i - 1]]++;
            }
            int maxv = 0;
            for (int j = 0; j < N; j++) {
                maxv = max(maxv, s[j]);
            }
            cnt += len - maxv;
            minv = min(minv, maxv); // 众数最少的那一列  不用众数  而用全新的数

            for (int j = 0; j < N; j++) { // 异或和为j
                for (int u = 0; u < len; u++) { // 每一行
                    int x = nums[u * k + i - 1], cost = len - s[x];
                    f[i][j] = min(f[i][j], f[i - 1][j ^ x] + cost);
                }
            }
        }
        // cnt: 每一列的代价
        // minv表示 某一列不用众数时的代价 si - maxv -> si 变成全新的数代价
        return min(cnt + minv, f[k][0]);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="【Day30】1190-反转每对括号间的子串"><a href="#【Day30】1190-反转每对括号间的子串" class="headerlink" title="【Day30】1190.反转每对括号间的子串"></a>【Day30】1190.反转每对括号间的子串</h2><h4 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190. 反转每对括号间的子串"></a><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/" target="_blank" rel="noopener">1190. 反转每对括号间的子串</a></h4><p>给出一个字符串 s（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p><strong>注意，您的结果中 不应 包含任何括号。</strong></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;(abcd)&quot;
输出：&quot;dcba&quot;</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;(u(love)i)&quot;
输出：&quot;iloveu&quot;</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：s = &quot;(ed(et(oc))el)&quot;
输出：&quot;leetcode&quot;</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;
输出：&quot;apmnolkjihgfedcbq&quot;</code></pre><p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= s.length &lt;= 2000</li>
<li>s 中只有小写英文字母和括号</li>
<li>我们确保所有括号都是成对出现的</li>
</ul>
<p><strong>题解：</strong></p>
<p><img src="https://cdn.acwing.com/media/article/image/2021/05/26/30502_ed3e6737bd-aa.gif" alt></p>
<p>挨个遍历， 左括号和普通字符直接入栈；遇到右括号 ，就依次出栈直到栈顶为左括号 ，出栈的这些字符按出栈顺序链接自然也就是逆序的，然后栈顶左括号出栈 把组合成的逆序串重新压入栈。</p>
<p>遍历完字符串 栈中从栈底到栈顶 自然也就想要的结果，如果依次出栈 要注意连接顺序，还需要一次整体反转。</p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    string reverseParentheses(string s) {
        stack<char> st;
        for (auto c : s) {
            if (c != ')') {
                st.push(c);
            } else {
                string tmp;
                while (st.top() != '(') {
                    tmp += st.top();
                    st.pop();
                }
                st.pop();
                for (auto s : tmp) {
                    st.push(s);
                }
            }
        }
        string ans;
        while (!st.empty()) {
            ans = st.top() + ans; st.pop();
        }
        return ans;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>几天刚好一个月结束啦，收获还是很多的，困难我唯唯诺诺，简单重拳出击！！！hhh~</p>

      
    </div>
</article>

    </li>
  
</ul>



            <footer>
    <div>© 2023 - Tyzhao </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>