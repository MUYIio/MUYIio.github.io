{"title":"C++学习笔记整理-数据的共享与保护","date":"2020-04-23T04:59:54.000Z","toc":true,"summary":"第五章数据的共享与保护,作用域是一个标识符在程序正文中有效的区域。","source":"_posts/C-学习笔记整理-第五章《数据的共享与保护》.md","raw":"---\ntitle: C++学习笔记整理-数据的共享与保护\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-04-23 12:59:54\npassword:\nsummary:  第五章数据的共享与保护,作用域是一个标识符在程序正文中有效的区域。\ntags:\n- 学习笔记\ncategories:\n- C++\n---\n\n\n\n------\n\n\n\n# 第五章数据的共享与保护\n\n## 1.标识符的作用域与可见性\n\n### ①作用域\n\n**作用域是一个标识符在程序正文中有效的区域。**\n\n- 函数原型作用域\n\n- 局部作用域(块作用域)\n\n- 类作用域\n\n- 文件作用域\n\n- 命名空间作用域\n\n\n\n**函数原形的作用域**\n\n\n\n函数原型中的参数，其作用域始于\"(\"，结束于\")\"。\n\n```c++\n//例如，设有下列原型声明：\ndouble area(double radius);\n//radius 的作用域仅在于此area，不能用于程序正文其他地方，因而可有可无。\n```\n\n\n\n**局部作用域**\n\n\n\n函数的形参，在块中声明的标识符，其作用域自声明处起，限于块中，例如：\n\n```c++\nvoid fun(int a) {\n   int b = a;\n   cin >> b;\n   if (b > 0) {\n     int c;\n\n     ......\n   }\n}\n\n//a的作用域是整个fun函数，b作用域在fun函数内，而c作用域在if语句内\n```\n\n\n\n\n\n**类作用域**\n\n\n\n- 类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。\n\n- 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）。\n\n\n\n**文件作用域**\n\n不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束于文件尾。\n\n```c++\n//example.1\n#include <iostream>\nusing namespace std;\n\nint i;\t\t\t\t//全局变量，文件作用域\nint main() { \n     i = 5;\t\t\t//为全局变量i赋值\n     {\t\t\t\t//子块1\n         int i;\t\t//局部变量，局部作用域\n         i = 7;\n         cout << \"i = \" << i << endl;//输出7\n      }\n      cout << “i = ” << i << endl;//输出5\n      return 0;\n}\n\n```\n\n\n\n### ②可见性\n\n\n\n- 可见性是从对标识符的引用的角度来谈的概念\n\n- 可见性表示从内层作用域向外层作用域“看”时能看见什么。\n\n- 如果标识在某处可见，则就可以在该处引用此标识符。\n\n\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片9.png)\n\n- 标识符应声明在先，引用在后。\n- 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见。\n- 对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。\n\n\n\n**同一作用域中的同名标识符**\n\n\n\n- 在同一作用域内的对象名、函数名、枚举常量名会隐藏同名的类名或枚举类型名。\n\n- 重载的函数可以有相同的函数名。\n\n\n\n------\n\n\n\n## 2.对象的生存期\n\n**对象从产生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的值，直到被更新为止。**\n\n\n\n**①静态生存期**\n\n\n\n- 这种生存期与程序的运行期相同。\n\n- 在文件作用域中声明的对象具有这种生存期。\n\n- 在函数内部声明静态生存期对象，要冠以关键字static 。\n\n\n\n**②动态生存期**\n\n\n\n- 块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。\n\n- 开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。\n\n\n\n```c++\n//1.变量的生存期与可见性\n\n\n#include<iostream>\nusing namespace std;\nint i = 1; // i 为全局变量，具有静态生存期。\nvoid other() {\n  static int a = 2;\n  static int b;\n   // a,b为静态局部变量，具有全局寿命，局部可见。\n   //只第一次进入函数时被初始化。\n  int c = 10; // C为局部变量，具有动态生存期，\n            //每次进入函数时都初始化。\n  a += 2; i += 32; c += 5;\n  cout<<\"---OTHER---\\n\";\n  cout<<\" i: \"<<i<<\" a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<endl;\n  b = a;\n}\n\nint main() {\n  static int a;//静态局部变量，有全局寿命，局部可见。\n  int b = -10; // b, c为局部变量，具有动态生存期。\n  int c = 0;\n\tcout << \"---MAIN---\\n\";\n  cout<<\" i: \"<<i<<\" a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<endl;\n  c += 8; other();\n  cout<<\"---MAIN---\\n\";\n  cout<<\" i: \"<<i<<\" a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<endl;\n  i += 10; other();  \n\treturn 0;\n}\n\n//运行结果：\n---MAIN---\n i: 1 a: 0 b: -10 c: 0\n---OTHER---\n i: 33 a: 4 b: 0 c: 15\n---MAIN---\n i: 33 a: 0 b: -10 c: 8\n---OTHER---\n i: 75 a: 6 b: 4 c: 15\n```\n\n\n\n\n\n## 3.类的静态成员\n\n**静态数据成员**\n\n- 用关键字static声明\n\n- 为该类的所有对象共享，静态数据成员具有静态生存期。\n\n- 必须在类外定义和初始化，用(::)来指明所属的类。\n\n\n\n**具有静态数据成员的Point类**\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片10.png)\n\n\n\n```c++\n//1.具有静态数据成员的Point类\n\n#include <iostream>\nusing namespace std;\n\nclass Point {\t//Point类定义\npublic:\t//外部接口\n\tPoint(int x = 0, int y = 0) : x(x), y(y) { //构造函数\n\t\t//在构造函数中对count累加，所有对象共同维护同一个count\n\t\tcount++;\n\t}\n\tPoint(Point &p) {\t//复制构造函数\n\t\tx = p.x;\n\t\ty = p.y;\n\t\tcount++;\n\t}\n\t~Point() {  count--; }\n\tint getX() { return x; }\n\tint getY() { return y; }\n\n void showCount() {\t\t//输出静态数据成员\n\t\tcout << \"  Object count = \" << count << endl;\n\t}\nprivate:\t//私有数据成员\n\tint x, y;\n\tstatic int count;\t//静态数据成员声明，用于记录点的个数\n};\nint Point::count = 0;//静态数据成员定义和初始化，使用类名限定\nint main() {\t//主函数\n\tPoint a(4, 5);\t//定义对象a，其构造函数回使count增1\n\tcout << \"Point A: \" << a.getX() << \", \" << a.getY();\n\ta.showCount();\t//输出对象个数\n\n\tPoint b(a);\t//定义对象b，其构造函数回使count增1\n\tcout << \"Point B: \" << b.getX() << \", \" << b.getY();\n\tb.showCount();\t//输出对象个数\n\treturn 0;\n}\n\n\n\n//运行结果：\n Point A: 4, 5  Object count=1\n Point B: 4, 5  Object count=2\n```\n\n\n\n**静态函数成员**\n\n- 类外代码可以使用类名和作用域操作符来调用静态成员函数。\n- 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。\n\n\n\n**具有静态数据、函数成员的 Point类**\n\n\n\n![](https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C笔记/图片11.png)\n\n\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Point {\t//Point类定义\npublic:\t//外部接口\n\tPoint(int x = 0, int y = 0) : x(x), y(y) { //构造函数\n\t\t//在构造函数中对count累加，所有对象共同维护同一个count\n\t\tcount++;\n\t}\t\n\tPoint(Point &p) {\t//复制构造函数\n\t\tx = p.x;\n\t\ty = p.y;\n\t\tcount++;\n\t}\n\t~Point() {  count--; }\n\tint getX() { return x; }\n\tint getY() { return y; }\n\n\tstatic void showCount() {\t\t//静态函数成员\n\t\tcout << \"  Object count = \" << count << endl;\n\t}\n\nprivate:\t//私有数据成员\n\tint x, y;\n\tstatic int count;\t//静态数据成员声明，用于记录点的个数\n};\n \nint Point::count = 0;//静态数据成员定义和初始化，使用类名限定\n \nint main() {\t//主函数\n\tPoint a(4, 5);\t//定义对象a，其构造函数回使count增1\n\tcout << \"Point A: \" << a.getX() << \", \" << a.getY();\n\tPoint::showCount();\t//输出对象个数\n \n\tPoint b(a);\t//定义对象b，其构造函数回使count增1\n\tcout << \"Point B: \" << b.getX() << \", \" << b.getY();\n\tPoint::showCount();\t//输出对象个数\n \n\treturn 0;\n}\n```\n\n\n\n------\n\n\n\n## 4.类的友元\n\n友元是C++提供的一种破坏数据封装和数据隐藏的机制。\n\n通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。\n\n可以使用友元函数和友元类。\n\n为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。\n\n","slug":"C-学习笔记整理-第五章《数据的共享与保护》","published":true,"updated":"2021-05-18T07:58:26.907Z","_id":"clq6dy486000aikw06ntsrm97","comments":true,"layout":"post","photos":[],"link":"","html":"<hr>\n<h1 id=\"第五章数据的共享与保护\"><a href=\"#第五章数据的共享与保护\" class=\"headerlink\" title=\"第五章数据的共享与保护\"></a>第五章数据的共享与保护</h1><h2 id=\"1-标识符的作用域与可见性\"><a href=\"#1-标识符的作用域与可见性\" class=\"headerlink\" title=\"1.标识符的作用域与可见性\"></a>1.标识符的作用域与可见性</h2><h3 id=\"①作用域\"><a href=\"#①作用域\" class=\"headerlink\" title=\"①作用域\"></a>①作用域</h3><p><strong>作用域是一个标识符在程序正文中有效的区域。</strong></p>\n<ul>\n<li><p>函数原型作用域</p>\n</li>\n<li><p>局部作用域(块作用域)</p>\n</li>\n<li><p>类作用域</p>\n</li>\n<li><p>文件作用域</p>\n</li>\n<li><p>命名空间作用域</p>\n</li>\n</ul>\n<p><strong>函数原形的作用域</strong></p>\n<p>函数原型中的参数，其作用域始于”(“，结束于”)”。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//例如，设有下列原型声明：\ndouble area(double radius);\n//radius 的作用域仅在于此area，不能用于程序正文其他地方，因而可有可无。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>局部作用域</strong></p>\n<p>函数的形参，在块中声明的标识符，其作用域自声明处起，限于块中，例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void fun(int a) {\n   int b = a;\n   cin >> b;\n   if (b > 0) {\n     int c;\n\n     ......\n   }\n}\n\n//a的作用域是整个fun函数，b作用域在fun函数内，而c作用域在if语句内<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>类作用域</strong></p>\n<ul>\n<li><p>类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。</p>\n</li>\n<li><p>如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）。</p>\n</li>\n</ul>\n<p><strong>文件作用域</strong></p>\n<p>不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束于文件尾。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//example.1\n#include <iostream>\nusing namespace std;\n\nint i;                //全局变量，文件作用域\nint main() { \n     i = 5;            //为全局变量i赋值\n     {                //子块1\n         int i;        //局部变量，局部作用域\n         i = 7;\n         cout << \"i = \" << i << endl;//输出7\n      }\n      cout << “i = ” << i << endl;//输出5\n      return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"②可见性\"><a href=\"#②可见性\" class=\"headerlink\" title=\"②可见性\"></a>②可见性</h3><ul>\n<li><p>可见性是从对标识符的引用的角度来谈的概念</p>\n</li>\n<li><p>可见性表示从内层作用域向外层作用域“看”时能看见什么。</p>\n</li>\n<li><p>如果标识在某处可见，则就可以在该处引用此标识符。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%879.png\" alt></p>\n<ul>\n<li>标识符应声明在先，引用在后。</li>\n<li>如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见。</li>\n<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。</li>\n</ul>\n<p><strong>同一作用域中的同名标识符</strong></p>\n<ul>\n<li><p>在同一作用域内的对象名、函数名、枚举常量名会隐藏同名的类名或枚举类型名。</p>\n</li>\n<li><p>重载的函数可以有相同的函数名。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-对象的生存期\"><a href=\"#2-对象的生存期\" class=\"headerlink\" title=\"2.对象的生存期\"></a>2.对象的生存期</h2><p><strong>对象从产生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的值，直到被更新为止。</strong></p>\n<p><strong>①静态生存期</strong></p>\n<ul>\n<li><p>这种生存期与程序的运行期相同。</p>\n</li>\n<li><p>在文件作用域中声明的对象具有这种生存期。</p>\n</li>\n<li><p>在函数内部声明静态生存期对象，要冠以关键字static 。</p>\n</li>\n</ul>\n<p><strong>②动态生存期</strong></p>\n<ul>\n<li><p>块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。</p>\n</li>\n<li><p>开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//1.变量的生存期与可见性\n\n\n#include<iostream>\nusing namespace std;\nint i = 1; // i 为全局变量，具有静态生存期。\nvoid other() {\n  static int a = 2;\n  static int b;\n   // a,b为静态局部变量，具有全局寿命，局部可见。\n   //只第一次进入函数时被初始化。\n  int c = 10; // C为局部变量，具有动态生存期，\n            //每次进入函数时都初始化。\n  a += 2; i += 32; c += 5;\n  cout<<\"---OTHER---\\n\";\n  cout<<\" i: \"<<i<<\" a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<endl;\n  b = a;\n}\n\nint main() {\n  static int a;//静态局部变量，有全局寿命，局部可见。\n  int b = -10; // b, c为局部变量，具有动态生存期。\n  int c = 0;\n    cout << \"---MAIN---\\n\";\n  cout<<\" i: \"<<i<<\" a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<endl;\n  c += 8; other();\n  cout<<\"---MAIN---\\n\";\n  cout<<\" i: \"<<i<<\" a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<endl;\n  i += 10; other();  \n    return 0;\n}\n\n//运行结果：\n---MAIN---\n i: 1 a: 0 b: -10 c: 0\n---OTHER---\n i: 33 a: 4 b: 0 c: 15\n---MAIN---\n i: 33 a: 0 b: -10 c: 8\n---OTHER---\n i: 75 a: 6 b: 4 c: 15<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-类的静态成员\"><a href=\"#3-类的静态成员\" class=\"headerlink\" title=\"3.类的静态成员\"></a>3.类的静态成员</h2><p><strong>静态数据成员</strong></p>\n<ul>\n<li><p>用关键字static声明</p>\n</li>\n<li><p>为该类的所有对象共享，静态数据成员具有静态生存期。</p>\n</li>\n<li><p>必须在类外定义和初始化，用(::)来指明所属的类。</p>\n</li>\n</ul>\n<p><strong>具有静态数据成员的Point类</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%8710.png\" alt></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//1.具有静态数据成员的Point类\n\n#include <iostream>\nusing namespace std;\n\nclass Point {    //Point类定义\npublic:    //外部接口\n    Point(int x = 0, int y = 0) : x(x), y(y) { //构造函数\n        //在构造函数中对count累加，所有对象共同维护同一个count\n        count++;\n    }\n    Point(Point &p) {    //复制构造函数\n        x = p.x;\n        y = p.y;\n        count++;\n    }\n    ~Point() {  count--; }\n    int getX() { return x; }\n    int getY() { return y; }\n\n void showCount() {        //输出静态数据成员\n        cout << \"  Object count = \" << count << endl;\n    }\nprivate:    //私有数据成员\n    int x, y;\n    static int count;    //静态数据成员声明，用于记录点的个数\n};\nint Point::count = 0;//静态数据成员定义和初始化，使用类名限定\nint main() {    //主函数\n    Point a(4, 5);    //定义对象a，其构造函数回使count增1\n    cout << \"Point A: \" << a.getX() << \", \" << a.getY();\n    a.showCount();    //输出对象个数\n\n    Point b(a);    //定义对象b，其构造函数回使count增1\n    cout << \"Point B: \" << b.getX() << \", \" << b.getY();\n    b.showCount();    //输出对象个数\n    return 0;\n}\n\n\n\n//运行结果：\n Point A: 4, 5  Object count=1\n Point B: 4, 5  Object count=2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>静态函数成员</strong></p>\n<ul>\n<li>类外代码可以使用类名和作用域操作符来调用静态成员函数。</li>\n<li>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。</li>\n</ul>\n<p><strong>具有静态数据、函数成员的 Point类</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%8711.png\" alt></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <iostream>\nusing namespace std;\n\nclass Point {    //Point类定义\npublic:    //外部接口\n    Point(int x = 0, int y = 0) : x(x), y(y) { //构造函数\n        //在构造函数中对count累加，所有对象共同维护同一个count\n        count++;\n    }    \n    Point(Point &p) {    //复制构造函数\n        x = p.x;\n        y = p.y;\n        count++;\n    }\n    ~Point() {  count--; }\n    int getX() { return x; }\n    int getY() { return y; }\n\n    static void showCount() {        //静态函数成员\n        cout << \"  Object count = \" << count << endl;\n    }\n\nprivate:    //私有数据成员\n    int x, y;\n    static int count;    //静态数据成员声明，用于记录点的个数\n};\n\nint Point::count = 0;//静态数据成员定义和初始化，使用类名限定\n\nint main() {    //主函数\n    Point a(4, 5);    //定义对象a，其构造函数回使count增1\n    cout << \"Point A: \" << a.getX() << \", \" << a.getY();\n    Point::showCount();    //输出对象个数\n\n    Point b(a);    //定义对象b，其构造函数回使count增1\n    cout << \"Point B: \" << b.getX() << \", \" << b.getY();\n    Point::showCount();    //输出对象个数\n\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"4-类的友元\"><a href=\"#4-类的友元\" class=\"headerlink\" title=\"4.类的友元\"></a>4.类的友元</h2><p>友元是C++提供的一种破坏数据封装和数据隐藏的机制。</p>\n<p>通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。</p>\n<p>可以使用友元函数和友元类。</p>\n<p>为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。</p>\n","excerpt":"","more":"<hr>\n<h1 id=\"第五章数据的共享与保护\"><a href=\"#第五章数据的共享与保护\" class=\"headerlink\" title=\"第五章数据的共享与保护\"></a>第五章数据的共享与保护</h1><h2 id=\"1-标识符的作用域与可见性\"><a href=\"#1-标识符的作用域与可见性\" class=\"headerlink\" title=\"1.标识符的作用域与可见性\"></a>1.标识符的作用域与可见性</h2><h3 id=\"①作用域\"><a href=\"#①作用域\" class=\"headerlink\" title=\"①作用域\"></a>①作用域</h3><p><strong>作用域是一个标识符在程序正文中有效的区域。</strong></p>\n<ul>\n<li><p>函数原型作用域</p>\n</li>\n<li><p>局部作用域(块作用域)</p>\n</li>\n<li><p>类作用域</p>\n</li>\n<li><p>文件作用域</p>\n</li>\n<li><p>命名空间作用域</p>\n</li>\n</ul>\n<p><strong>函数原形的作用域</strong></p>\n<p>函数原型中的参数，其作用域始于”(“，结束于”)”。</p>\n<pre><code class=\"c++\">//例如，设有下列原型声明：\ndouble area(double radius);\n//radius 的作用域仅在于此area，不能用于程序正文其他地方，因而可有可无。</code></pre>\n<p><strong>局部作用域</strong></p>\n<p>函数的形参，在块中声明的标识符，其作用域自声明处起，限于块中，例如：</p>\n<pre><code class=\"c++\">void fun(int a) {\n   int b = a;\n   cin &gt;&gt; b;\n   if (b &gt; 0) {\n     int c;\n\n     ......\n   }\n}\n\n//a的作用域是整个fun函数，b作用域在fun函数内，而c作用域在if语句内</code></pre>\n<p><strong>类作用域</strong></p>\n<ul>\n<li><p>类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。</p>\n</li>\n<li><p>如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）。</p>\n</li>\n</ul>\n<p><strong>文件作用域</strong></p>\n<p>不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束于文件尾。</p>\n<pre><code class=\"c++\">//example.1\n#include &lt;iostream&gt;\nusing namespace std;\n\nint i;                //全局变量，文件作用域\nint main() { \n     i = 5;            //为全局变量i赋值\n     {                //子块1\n         int i;        //局部变量，局部作用域\n         i = 7;\n         cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;//输出7\n      }\n      cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;//输出5\n      return 0;\n}\n</code></pre>\n<h3 id=\"②可见性\"><a href=\"#②可见性\" class=\"headerlink\" title=\"②可见性\"></a>②可见性</h3><ul>\n<li><p>可见性是从对标识符的引用的角度来谈的概念</p>\n</li>\n<li><p>可见性表示从内层作用域向外层作用域“看”时能看见什么。</p>\n</li>\n<li><p>如果标识在某处可见，则就可以在该处引用此标识符。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%879.png\" alt></p>\n<ul>\n<li>标识符应声明在先，引用在后。</li>\n<li>如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见。</li>\n<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。</li>\n</ul>\n<p><strong>同一作用域中的同名标识符</strong></p>\n<ul>\n<li><p>在同一作用域内的对象名、函数名、枚举常量名会隐藏同名的类名或枚举类型名。</p>\n</li>\n<li><p>重载的函数可以有相同的函数名。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-对象的生存期\"><a href=\"#2-对象的生存期\" class=\"headerlink\" title=\"2.对象的生存期\"></a>2.对象的生存期</h2><p><strong>对象从产生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的值，直到被更新为止。</strong></p>\n<p><strong>①静态生存期</strong></p>\n<ul>\n<li><p>这种生存期与程序的运行期相同。</p>\n</li>\n<li><p>在文件作用域中声明的对象具有这种生存期。</p>\n</li>\n<li><p>在函数内部声明静态生存期对象，要冠以关键字static 。</p>\n</li>\n</ul>\n<p><strong>②动态生存期</strong></p>\n<ul>\n<li><p>块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。</p>\n</li>\n<li><p>开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//1.变量的生存期与可见性\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nint i = 1; // i 为全局变量，具有静态生存期。\nvoid other() {\n  static int a = 2;\n  static int b;\n   // a,b为静态局部变量，具有全局寿命，局部可见。\n   //只第一次进入函数时被初始化。\n  int c = 10; // C为局部变量，具有动态生存期，\n            //每次进入函数时都初始化。\n  a += 2; i += 32; c += 5;\n  cout&lt;&lt;&quot;---OTHER---\\n&quot;;\n  cout&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;&quot; a: &quot;&lt;&lt;a&lt;&lt;&quot; b: &quot;&lt;&lt;b&lt;&lt;&quot; c: &quot;&lt;&lt;c&lt;&lt;endl;\n  b = a;\n}\n\nint main() {\n  static int a;//静态局部变量，有全局寿命，局部可见。\n  int b = -10; // b, c为局部变量，具有动态生存期。\n  int c = 0;\n    cout &lt;&lt; &quot;---MAIN---\\n&quot;;\n  cout&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;&quot; a: &quot;&lt;&lt;a&lt;&lt;&quot; b: &quot;&lt;&lt;b&lt;&lt;&quot; c: &quot;&lt;&lt;c&lt;&lt;endl;\n  c += 8; other();\n  cout&lt;&lt;&quot;---MAIN---\\n&quot;;\n  cout&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;&quot; a: &quot;&lt;&lt;a&lt;&lt;&quot; b: &quot;&lt;&lt;b&lt;&lt;&quot; c: &quot;&lt;&lt;c&lt;&lt;endl;\n  i += 10; other();  \n    return 0;\n}\n\n//运行结果：\n---MAIN---\n i: 1 a: 0 b: -10 c: 0\n---OTHER---\n i: 33 a: 4 b: 0 c: 15\n---MAIN---\n i: 33 a: 0 b: -10 c: 8\n---OTHER---\n i: 75 a: 6 b: 4 c: 15</code></pre>\n<h2 id=\"3-类的静态成员\"><a href=\"#3-类的静态成员\" class=\"headerlink\" title=\"3.类的静态成员\"></a>3.类的静态成员</h2><p><strong>静态数据成员</strong></p>\n<ul>\n<li><p>用关键字static声明</p>\n</li>\n<li><p>为该类的所有对象共享，静态数据成员具有静态生存期。</p>\n</li>\n<li><p>必须在类外定义和初始化，用(::)来指明所属的类。</p>\n</li>\n</ul>\n<p><strong>具有静态数据成员的Point类</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%8710.png\" alt></p>\n<pre><code class=\"c++\">//1.具有静态数据成员的Point类\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point {    //Point类定义\npublic:    //外部接口\n    Point(int x = 0, int y = 0) : x(x), y(y) { //构造函数\n        //在构造函数中对count累加，所有对象共同维护同一个count\n        count++;\n    }\n    Point(Point &amp;p) {    //复制构造函数\n        x = p.x;\n        y = p.y;\n        count++;\n    }\n    ~Point() {  count--; }\n    int getX() { return x; }\n    int getY() { return y; }\n\n void showCount() {        //输出静态数据成员\n        cout &lt;&lt; &quot;  Object count = &quot; &lt;&lt; count &lt;&lt; endl;\n    }\nprivate:    //私有数据成员\n    int x, y;\n    static int count;    //静态数据成员声明，用于记录点的个数\n};\nint Point::count = 0;//静态数据成员定义和初始化，使用类名限定\nint main() {    //主函数\n    Point a(4, 5);    //定义对象a，其构造函数回使count增1\n    cout &lt;&lt; &quot;Point A: &quot; &lt;&lt; a.getX() &lt;&lt; &quot;, &quot; &lt;&lt; a.getY();\n    a.showCount();    //输出对象个数\n\n    Point b(a);    //定义对象b，其构造函数回使count增1\n    cout &lt;&lt; &quot;Point B: &quot; &lt;&lt; b.getX() &lt;&lt; &quot;, &quot; &lt;&lt; b.getY();\n    b.showCount();    //输出对象个数\n    return 0;\n}\n\n\n\n//运行结果：\n Point A: 4, 5  Object count=1\n Point B: 4, 5  Object count=2</code></pre>\n<p><strong>静态函数成员</strong></p>\n<ul>\n<li>类外代码可以使用类名和作用域操作符来调用静态成员函数。</li>\n<li>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。</li>\n</ul>\n<p><strong>具有静态数据、函数成员的 Point类</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%8711.png\" alt></p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Point {    //Point类定义\npublic:    //外部接口\n    Point(int x = 0, int y = 0) : x(x), y(y) { //构造函数\n        //在构造函数中对count累加，所有对象共同维护同一个count\n        count++;\n    }    \n    Point(Point &amp;p) {    //复制构造函数\n        x = p.x;\n        y = p.y;\n        count++;\n    }\n    ~Point() {  count--; }\n    int getX() { return x; }\n    int getY() { return y; }\n\n    static void showCount() {        //静态函数成员\n        cout &lt;&lt; &quot;  Object count = &quot; &lt;&lt; count &lt;&lt; endl;\n    }\n\nprivate:    //私有数据成员\n    int x, y;\n    static int count;    //静态数据成员声明，用于记录点的个数\n};\n\nint Point::count = 0;//静态数据成员定义和初始化，使用类名限定\n\nint main() {    //主函数\n    Point a(4, 5);    //定义对象a，其构造函数回使count增1\n    cout &lt;&lt; &quot;Point A: &quot; &lt;&lt; a.getX() &lt;&lt; &quot;, &quot; &lt;&lt; a.getY();\n    Point::showCount();    //输出对象个数\n\n    Point b(a);    //定义对象b，其构造函数回使count增1\n    cout &lt;&lt; &quot;Point B: &quot; &lt;&lt; b.getX() &lt;&lt; &quot;, &quot; &lt;&lt; b.getY();\n    Point::showCount();    //输出对象个数\n\n    return 0;\n}</code></pre>\n<hr>\n<h2 id=\"4-类的友元\"><a href=\"#4-类的友元\" class=\"headerlink\" title=\"4.类的友元\"></a>4.类的友元</h2><p>友元是C++提供的一种破坏数据封装和数据隐藏的机制。</p>\n<p>通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。</p>\n<p>可以使用友元函数和友元类。</p>\n<p>为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。</p>\n","path":"c-xue-xi-bi-ji-zheng-li-di-wu-zhang-shu-ju-de-gong-xiang-yu-bao-hu.html","permalink":"https://www.yshawlon.cn/c-xue-xi-bi-ji-zheng-li-di-wu-zhang-shu-ju-de-gong-xiang-yu-bao-hu.html","tags":[{"name":"学习笔记","_id":"clq6dy48u0013ikw0galx0575","slug":"学习笔记","path":"tags/学习笔记/","permalink":"https://www.yshawlon.cn/tags/学习笔记/","length":9}],"categories":[{"name":"C++","_id":"clq6dy48e000hikw0uy63x2a1","slug":"C","path":"categories/C/","permalink":"https://www.yshawlon.cn/categories/C/","length":5}],"prev":{"title":"C++编程题目整合","date":"2020-04-26T10:51:17.000Z","summary":"就从第四章类与对象开始吧，前面的章节和c差不多在另一篇文章。","slug":"C-编程题目整合","published":true,"updated":"2020-04-26T16:18:14.999Z","_id":"clq6dy48a000eikw0vvn61mq2","layout":"post","photos":[],"link":"","excerpt":"","path":"c-bian-cheng-ti-mu-zheng-he.html","permalink":"https://www.yshawlon.cn/c-bian-cheng-ti-mu-zheng-he.html","__post":true},"next":{"title":"C语言编程题目整合","date":"2020-04-13T06:50:08.000Z","summary":"做过的题目渐渐变得生疏，索性记录在博客上，看着更直观些，好记性不如烂笔头！","slug":"C语言编程题目整合","published":true,"updated":"2020-04-26T14:44:31.157Z","_id":"clq6dy48i000kikw088mtkeaj","layout":"post","photos":[],"link":"","excerpt":"","path":"c-yu-yan-bian-cheng-ti-mu-zheng-he.html","permalink":"https://www.yshawlon.cn/c-yu-yan-bian-cheng-ti-mu-zheng-he.html","__post":true},"__post":true}