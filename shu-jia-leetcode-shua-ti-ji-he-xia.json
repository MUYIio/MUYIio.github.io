{"title":"暑假LeetCode刷题集合（下）","date":"2021-07-27T08:48:27.000Z","toc":true,"summary":"不知不觉就已经一个月了，对基本的算法熟悉了很多，争取再坚持一个月hh","source":"_posts/暑假LeetCode刷题集合（下）.md","raw":"---\ntitle: 暑假LeetCode刷题集合（下）\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-27 16:48:27\npassword:\nsummary: 不知不觉就已经一个月了，对基本的算法熟悉了很多，争取再坚持一个月hh\ntags:\n- LeetCode\ncategories:\n- 每日一题\nkeywords: 汉明距离\ndescription:\n---\n\n## 【Day31】461. 汉明距离\n\n#### [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n\n**注意：**\n\n- 0 ≤ x, y < 231.\n\n**示例:**\n\n```\n输入: x = 1, y = 4\n\n输出: 2\n\n解释:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\n上面的箭头指出了对应二进制位不同的位置。\n```\n\n**题解：**\n\n可以考虑为求异或结果值当中1的个数，进一步转换为求二进制中1的个数。\n\n```cpp\nclass Solution {\npublic:\n    int lowbit(int x) {\n        return x & (-x);\n    }\n    int hammingDistance(int x, int y) {\n        int ret = x ^ y;\n        int ans = 0;\n        while (ret) {\n            ret -= lowbit(ret);\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n\n## 【Day32】477.汉明距离总和\n\n#### [477. 汉明距离总和](https://leetcode-cn.com/problems/total-hamming-distance/)\n\n两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。\n\n计算一个数组中，任意两个数之间汉明距离的总和。\n\n**示例:**\n\n```\n输入: 4, 14, 2\n\n输出: 6\n\n解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n```\n\n**注意:**\n\n- 数组中元素的范围为从 0到 10^9。\n- 数组的长度不超过 10^4。\n\n**题解：**\n\n\n\n\n\n```cpp\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 0; i < 31; i++) {\n            int cnt[]  = {0, 0};\n            for (auto& num : nums) {\n                cnt[num & 1]++;\n                num >>= 1;\n            }\n            ans += cnt[0] * cnt[1];\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## 【Day33】1074.元素和为目标值的子矩阵数量\n\n#### [1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)\n\n给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。\n\n子矩阵 x1, y1, x2, y2 是满足 x1 <= x <= x2 且 y1 <= y <= y2 的所有单元 matrix[x][y] 的集合。\n\n如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。\n\n \n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg)\n\n```\n输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n输出：4\n解释：四个只含 0 的 1x1 子矩阵。\n```\n\n\n**示例 2：**\n\n```\n输入：matrix = [[1,-1],[-1,1]], target = 0\n输出：5\n解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。\n```\n\n\n**示例 3：**\n\n```\n输入：matrix = [[904]], target = 0\n输出：0\n```\n\n**提示：**\n\n- 1 <= matrix.length <= 100\n- 1 <= matrix[0].length <= 100\n- -1000 <= matrix[i] <= 1000\n- -10^8 <= target <= 10^8\n\n**题解：**\n\n二维前缀和的题目，使用哈希表来优化\n\n```cpp\n#define HT_LENGTH 256\n\nstruct HashTable {\n    int keys[HT_LENGTH];\n    int vals[HT_LENGTH];\n    \n    HashTable() {\n        this->clear();\n    }\n    \n    void clear() {\n        keys[0] = 0; vals[0] = 1;\n        for (int i = 1;i < HT_LENGTH;i++) keys[i] = -1;\n    }\n    \n    bool find(int key, int& ret) {\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\n        for (int i = 0;i < HT_LENGTH;i++) {\n            if (keys[ikey] == -1) return false;\n            if (keys[ikey] == key) {\n                ret = vals[ikey];\n                return true;\n            }\n            ikey ++;\n            ikey = ikey == HT_LENGTH ? 0 : ikey;\n        }\n        return false;\n    }\n    \n    void inc(int key) {\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\n        for (int i = 0;i < HT_LENGTH;i++) {\n            if (keys[ikey] == -1) {\n                keys[ikey] = key;\n                vals[ikey] = 1;\n                return;\n            }\n            if (keys[ikey] == key) {\n                vals[ikey]++;\n                return;\n            }\n            ikey ++;\n            ikey = ikey == HT_LENGTH ? 0 : ikey;\n        }\n    }\n};\n\nclass Solution {\nprivate:\n    HashTable ht;\npublic:\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\n        int rprefix[100][101];\n        int m = matrix.size(), n = matrix[0].size();\n        int ret = 0;\n        for (int i = 0;i < m;i++) {\n            rprefix[i][0] = 0;\n            for (int j = 1;j <= n;j ++) {\n                rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1];\n            }\n        }\n        \n        for (int i = 1;i <= n;i++) {\n            for (int j = i;j <= n;j++) {\n                ht.clear();\n                int cprefix = 0, val;\n                for (int row = 0;row < m;row++) {\n                    cprefix += rprefix[row][j] - rprefix[row][i - 1];\n                    if (ht.find(cprefix - target, val)) ret += val;\n                    ht.inc(cprefix);\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n## 【Day34】231. 2 的幂\n\n#### [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。\n\n如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。\n\n \n\n**示例 1：**\n\n```\n输入：n = 1\n输出：true\n解释：20 = 1\n```\n\n\n**示例 2：**\n\n```\n输入：n = 16\n输出：true\n解释：24 = 16\n```\n\n\n**示例 3：**\n\n```\n输入：n = 3\n输出：false\n```\n\n\n**示例 4：**\n\n```\n输入：n = 4\n输出：true\n```\n\n**示例 5：**\n\n```\n输入：n = 5\n输出：false\n```\n\n**提示：**\n\n- -231 <= n <= 231 - 1\n\n**题解：**\n\n**位运算**\n\n若 n = 2^x 且 x为自然数（即 n 为 2 的幂），则一定满足以下条件：\n\n首先，恒有 n & (n - 1) == 0，因为：\n\n- n 二进制最高位为 11，其余所有位为 00；\n- n−1 二进制最高位为 00，其余所有位为 11；\n\n其次，我们只需要限定n > 0 即可。\n\n\n\n```cpp\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n         return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n```\n\n## 【Day35】342. 4的幂\n\n#### [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)\n\n给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。\n\n整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x\n\n \n\n**示例 1：**\n\n```\n输入：n = 16\n输出：true\n```\n\n\n**示例 2：**\n\n```\n输入：n = 5\n输出：false\n```\n\n\n**示例 3：**\n\n```\n输入：n = 1\n输出：true\n```\n\n**提示：**\n\n- -231 <= n <= 231 - 1\n\n**题解：**\n\n一个数是`2`的幂，那么二进制从右边数奇数位是`1`的一定是`4`的幂。判断是`2`的幂，我们只需要判断二进制中`1`的个数，用昨天的解即可。\n\n```\n0x55555555的  二进制是  01010101 01010101 01010101 01010101\n```\n\n```cpp\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n    return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) == n;\n    }\n};\n```\n\n## 【Day36】LeetCode 1744\n\n#### [1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/)\n\n给你一个下标从 **0** 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。\n\n你按照如下规则进行一场游戏：\n\n- 你从第 0 天开始吃糖果。\n- 你在吃完 **所有** 第 i - 1 类糖果之前，**不能** 吃任何一颗第 i 类糖果。\n- 在吃完所有糖果之前，你必须每天 **至少** 吃 一颗 糖果。\n\n请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 **不超过** dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。\n\n请你返回得到的数组 answer 。\n\n \n\n**示例 1：**\n\n```\n输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n输出：[true,false,true]\n提示：\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。\n```\n\n\n**示例 2：**\n\n```text\n输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n输出：[false,true,true,false,false]\n```\n\n**提示：**\n\n- 1 <= candiesCount.length <= 105\n- 1 <= candiesCount[i] <= 105\n- 1 <= queries.length <= 105\n- queries[i].length == 3\n- 0 <= favoriteTypei < candiesCount.length\n- 0 <= favoriteDayi <= 109\n- 1 <= dailyCapi <= 109\n\n**题解：**\n\n使用前缀和解题：\n\n```cpp\nclass Solution {\npublic:\n    vector<long long> sum;\n    bool check(vector<int>& candiesCount, vector<int>& q) {\n        int favoriteType = q[0], favoriteDay = q[1], dailyCap = q[2];\n        // 第favoriteType类型的前缀和\n        int l = sum[favoriteType + 1];\n        // 每天吃一颗糖 \n        if (favoriteDay + 1 > sum[favoriteType + 1]) return false;\n        // 吃最多糖\n        if (sum[favoriteType] >= 1ll*(favoriteDay + 1) * dailyCap) return false;\n        return true;\n    }\n    vector<bool> canEat(vector<int>& candiesCount, vector<vector<int>>& queries) {\n        int n = candiesCount.size();\n        sum = vector<long long>(n + 1, 0);\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i - 1] + candiesCount[i - 1];\n        }\n        \n        vector<bool> ans;\n        for (auto q : queries)\n            ans.push_back(check(candiesCount, q));\n        return ans;\n    }\n};\n```\n\n## 【Day37】523.连续的子数组和\n\n#### [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)\n\n给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n\n- 子数组大小 **至少为 2** ，且\n- 子数组元素总和为 k 的倍数。\n\n如果存在，返回 true ；否则，返回 false 。\n\n如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [23,2,4,6,7], k = 6\n输出：true\n解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。\n```\n\n\n**示例 2：**\n\n```\n输入：nums = [23,2,6,4,7], k = 6\n输出：true\n解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n```\n\n\n**示例 3：**\n\n```\n输入：nums = [23,2,6,4,7], k = 13\n输出：false\n```\n\n**提示：**\n\n- 1 <= nums.length <= 105\n- 0 <= nums[i] <= 109\n- 0 <= sum(nums[i]) <= 231 - 1\n- 1 <= k <= 231 - 1\n\n\n\n**题解：**\n\n经典的前缀和\n\n```cpp\nclass Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        int sum = 0;\n        unordered_set<int> st;\n        for(int i = 0; i < nums.size(); i++) {\n            sum += nums[i];\n            if(st.count(sum % k)) return true;\n            st.insert((sum - nums[i]) % k); \n        }\n        return false;\n    }\n};\n```\n\n##  【Day38】525.连续数组\n\n#### [525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)\n\n给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [0,1]\n输出: 2\n说明: [0, 1] 是具有相同数量0和1的最长连续子数组。\n```\n\n\n**示例 2:**\n\n```\n输入: nums = [0,1,0]\n输出: 2\n说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。\n```\n\n**提示：**\n\n- 1 <= nums.length <= 105\n- nums[i] 不是 0 就是 1\n\n**题解：**\n\n前缀和＋哈希\n\n```cpp\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        for (auto& num : nums) {\n            num = num == 0 ? -1 : num;\n        }\n        map<int, int> m;\n        int sum = 0, ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            sum += nums[i];\n            if (sum == 0) {\n                ans = i + 1;\n            }\n            if (m.count(sum)) {\n                ans = max(i - m[sum], ans);\n            } else {\n                m[sum] = i;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 【Day39】160.相交链表\n\n#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**：函数返回结果后，链表必须 保持其**原始结构** 。\n\n \n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)\n\n```\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n\n**示例 2：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)\n\n```\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n\n**示例 3：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)\n\n```\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n```\n\n**提示：**\n\n- listA 中节点数目为 m\n- listB 中节点数目为 n\n- 0 <= m, n <= 3 * 104\n- 1 <= Node.val <= 105\n- 0 <= skipA <= m\n- 0 <= skipB <= n\n- 如果 listA 和 listB 没有交点，intersectVal 为 0\n- 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n\n**进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？\n\n**题解：**\n\npA走过的路径为A链+B链\n\npB走过的路径为B链+A链\n\npA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。\n\n```\npA:1->2->3->4->5->6->null->9->5->6->null\npB:9->5->6->null->1->2->3->4->5->6->null\n```\n\n\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p = headA, *q = headB;\n        while (p != q) {\n            p = p ? p->next : headB;\n            q = q ? q->next : headA;\n        }\n        return p;\n    }\n};\n```\n\n## 【Day40】203.移除链表元素\n\n#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)\n\n```\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [], val = 1\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [7,7,7,7], val = 7\n输出：[]\n```\n\n**提示：**\n\n- 列表中的节点在范围 [0, 104] 内\n- 1 <= Node.val <= 50\n- 0 <= k <= 50\n\n**题解：**\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *removeElements(ListNode *head, int val)\n    {\n        if (!head)\n            return head;\n        head->next = removeElements(head->next, val);\n        return head->val == val ? head->next : head;\n    }\n};\n```\n\n## 【Day41】474.一和零\n\n#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n\n请你找出并返回 strs 的最大子集的大小，该子集中 **最多** 有 m 个 0 和 n 个 1 。\n\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 **子集** 。\n\n \n\n**示例 1：**\n\n```\n输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n输出：4\n解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n```\n\n\n**示例 2：**\n\n```\n输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n输出：2\n解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。\n```\n\n**提示：**\n\n- 1 <= strs.length <= 600\n- 1 <= strs[i].length <= 100\n- strs[i] 仅由 '0' 和 '1' 组成\n- 1 <= m, n <= 100\n\n**题解：**\n\n动态规划\n\n```cpp\nconst int N = 101;\nclass Solution {\npublic:\n    int dp[N][N];\n\n    int findMaxForm(vector<string>& strs, int m, int n)\n    {\n        for (auto &str:strs)\n        {\n            int one = 0, zero = 0;\n            for (auto &c:str)\n            {\n                if(c=='1')\n                    ++one;\n                else\n                    ++zero;\n            }\n            // zero = str.size() - one;\n            for (int j=m; j>=zero; --j)\n            {\n                for (int k=n; k>=one; --k)\n                {\n                    dp[j][k] = max(dp[j][k], dp[j-zero][k-one] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n## 【Day42】494. 目标和\n\n#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给你一个整数数组 nums 和一个整数 target 。\n\n向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 **表达式** ：\n\n> 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。\n\n返回可以通过上述方法构造的、运算结果等于 target 的不同 **表达式** 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,1,1,1,1], target = 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n```\n\n\n**示例 2：**\n\n```\n输入：nums = [1], target = 1\n输出：1\n```\n\n**提示：**\n\n- 1 <= nums.length <= 20\n- 0 <= nums[i] <= 1000\n- 0 <= sum(nums[i]) <= 1000\n- -1000 <= target <= 100\n\n\n\n**题解：**\n\n还是动态规划\n\n```cpp\nclass Solution {\n    int n;\n    int ans = 0;\n    int t;\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        n = nums.size();\n        t = target;\n        dfs(0,nums,  0);\n        return ans;\n    }\n    void dfs(int u, vector <int> & nums, int s){\n        if(u == n){\n            if(s == t) ++ans;\n            return;\n        }\n        dfs(u + 1, nums, s + nums[u]);\n        dfs(u + 1, nums, s - nums[u]);\n    }\n};\n```\n\n## 【Day43】1049. 最后一块石头的重量 II\n\n#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)\n\n有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：\n\n- 如果 x == y，那么两块石头都会被完全粉碎；\n- 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。\n\n最后，**最多只会剩下一块 石头**。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 0。\n\n \n\n**示例 1：**\n\n```\n输入：stones = [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n```\n\n\n**示例 2：**\n\n```\n输入：stones = [31,26,33,21,40]\n输出：5\n```\n\n\n**示例 3：**\n\n```\n输入：stones = [1,2]\n输出：1\n```\n\n**提示：**\n\n- 1 <= stones.length <= 30\n- 1 <= stones[i] <= 100\n\n **题解：**\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeightII(vector<int>& stones) {\n        auto sum = accumulate(stones.begin(), stones.end(), 0);\n        vector<int> dp(sum / 2 + 1);\n        for (const auto& stone : stones) {\n            for (auto j = sum / 2; j >= stone; j--) {\n                dp[j] = max(dp[j], dp[j - stone] + stone);\n            }\n        }\n        return sum - dp[sum / 2] * 2;\n    }\n};\n\n```\n\n##  【Day44】879. 盈利计划\n\n#### [879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)\n\n集团里有 n 名员工，他们可以完成各种各样的工作创造利润。\n\n第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。\n\n工作的任何至少产生 minProfit 利润的子集称为 **盈利计划** 。并且工作的成员总数最多为 n 。\n\n有多少种计划可以选择？因为答案很大，所以 **返回结果模** 10^9 + 7 的**值**。\n\n \n\n**示例 1：**\n\n```\n输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n输出：2\n解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。\n```\n\n\n**示例 2：**\n\n```\n输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n输出：7\n解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。\n```\n\n**提示：**\n\n- 1 <= n <= 100\n- 0 <= minProfit <= 100\n- 1 <= group.length <= 100\n- 1 <= group[i] <= 100\n- profit.length == group.length\n- 0 <= profit[i] <= 100\n\n**题解：**\n\n这题不会，贴一个题解吧\n\n```cpp\nclass Solution {\npublic:\n    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {\n        int mod = 1e9 + 7;\n        int size = group.size();\n        int dp[n + 1][minProfit + 1];\n        memset(dp, 0, sizeof(dp));\n        for (int i = 0; i <= n; ++i) {\n            dp[i][0] = 1;\n        }\n\n        for (int i = 1; i <= size; ++i) {\n            int cur_group = group[i - 1], cur_profit = profit[i - 1];\n            for (int j = n; j >= cur_group; --j) {\n                for (int k = minProfit; k >= 0; --k) {\n                    dp[j][k] += dp[j - cur_group][max(k - cur_profit, 0)];\n                    dp[j][k] %= mod;\n                }\n            }\n        }\n        return dp[n][minProfit];\n    }\n};\n```\n\n## 【Day45】518. 零钱兑换 II\n\n#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 \n\n \n\n**示例 1:**\n\n```\n输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n\n**示例 2:**\n\n```\n输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。\n```\n\n\n**示例 3:**\n\n```\n输入: amount = 10, coins = [10] \n输出: 1\n```\n\n**注意:**\n\n\n\n- 0 <= amount (总金额) <= 5000\n- 1 <= coin (硬币面额) <= 5000\n- 硬币种类不超过 500 种\n- 结果符合 32 位符号整数\n\n**题解：**\n\n```cpp\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        int n = coins.size();\n        vector<int> dp(amount+1);\n        dp[0] = 1;\n        for(int i = 1; i<=n; i++)\n        {\n            int val = coins[i-1];\n            for(int j = val; j <= amount;++j)\n            {\n                dp[j] += dp[j-val];\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n## 【Day46】279. 完全平方数\n\n#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n给你一个整数 n ，返回和为 n 的完全平方数的 **最少数量** 。\n\n**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n \n\n**示例 1：**\n\n```\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4\n```\n\n\n**示例 2：**\n\n```\n输入：n = 13\n输出：2\n解释：13 = 4 + 9\n```\n\n**提示：**\n\n- 1 <= n <= 104\n\n**题解：**\n\n```cpp\n//假设最小公式值m = ƒ(n) \n//那么n的值满足下列公式 ∑(A[i] * A[i]) = n \n//令 k 为满足最小值 m 的时候，最大的平方数  。 令  d + k * k; = n ;  d >= 0; \n   // 注意：一定要是满足m最小的时候的k值,一味的取最大平方数,就是贪心算法了\n//得出 f(d) + f(k*k) = f(n);\n//显然 f(k*k) = 1; 则  f(d) + 1 = f(n); 因为 d = n - k*k;\n//则可以推出ƒ(n - k * k) + 1 = ƒ(n) ;  且 k * k <= n;\n\nclass Solution {\npublic:\n    int numSquares(int n) {\n        if (n <= 0) return 0;\n        std::vector<int> nums(n+1);\n        for(int i = 1; i <= n;i++)\n        {\n            int min = i;\n            for(int j = 1;i - j*j >= 0;j++)\n            {\n                int tmp = nums[i-j*j] + 1;\n                min = min > tmp ?  tmp:min; \n            }\n            nums[i] = min;\n        }\n        return nums[n];\n       \n    }\n};\n```\n\n## 【Day47】1449. 数位成本和为目标值的最大数字\n\n#### [1449. 数位成本和为目标值的最大数字](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/)\n\n给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 **最大** 整数：\n\n- 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。\n- 总成本必须恰好等于 target 。\n- 添加的数位中没有数字 0 。\n\n由于答案可能会很大，请你以字符串形式返回。\n\n如果按照上述要求无法得到任何整数，请你返回 \"0\" 。\n\n \n\n**示例 1：**\n\n```\n输入：cost = [4,3,2,5,6,7,2,5,5], target = 9\n输出：\"7772\"\n解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 \"7772\" 的代价为 2*3+ 3*1 = 9 。 \"977\" 也是满足要求的数字，但 \"7772\" 是较大的数字。\n 数字     成本\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n```\n\n\n**示例 2：**\n\n```\n输入：cost = [7,6,5,5,5,6,8,7,8], target = 12\n输出：\"85\"\n解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。\"85\" 的成本为 7 + 5 = 12 。\n```\n\n\n**示例 3：**\n\n```\n输入：cost = [2,4,6,2,4,6,4,4,4], target = 5\n输出：\"0\"\n解释：总成本是 target 的条件下，无法生成任何整数。\n```\n\n\n**示例 4：**\n\n```\n输入：cost = [6,10,15,40,40,40,40,40,40], target = 47\n输出：\"32211\"\n```\n\n**提示：**\n\n- cost.length == 9\n- 1 <= cost[i] <= 5000\n- 1 <= target <= 5000\n\n**题解：**\n\n```cpp\nclass Solution {\npublic:\n    string largestNumber(vector<int>& cost, int target) {\n        int len=cost.size();\n        vector<string> dp(target+1,\"#\");\n        dp[0]=\"\";\n        //因为i遍历的顺序是从小到大，就保证了整数的高位一定大于等于整数的低位，也就保证了整数最大\n        for(int i=1;i<len+1;++i)\n            for(int j=1;j<target+1;++j){    \n                if(j>=cost[i-1]&&dp[j-cost[i-1]]!=\"#\"){\n                    dp[j]=CompareString(dp[j],to_string(i)+dp[j-cost[i-1]]);\n                }\n            }\n        return dp[target]==\"#\"?\"0\":dp[target];\n    }\nprivate:\n    string CompareString(const string& s1,const string& s2){\n        int m=s1.size(),n=s2.size();\n        if(m==n)return max(s1,s2);\n        return m>n?s1:s2;\n    }\n};\n```\n\n##  【Day48】278. 第一个错误的版本\n\n#### [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n**示例:**\n\n```\n给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n调用 isBadVersion(3) -> false\n调用 isBadVersion(5) -> true\n调用 isBadVersion(4) -> true\n\n所以，4 是第一个错误的版本。 \n```\n\n**题解：**\n\n二分\n\n```cpp\nbool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int lo = 1;\n        int hi = n;\n        \n        while(lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (isBadVersion(mid)) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return hi;\n    }\n};\n```\n\n## 【Day49】374. 猜数字大小\n\n#### [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)\n\n猜数字游戏的规则如下：\n\n- 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。\n- 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n\n你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：\n\n- -1：我选出的数字比你猜的数字小 pick < num\n- 1：我选出的数字比你猜的数字大 pick > num\n- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num\n\n返回我选出的数字。\n\n \n\n**示例 1：**\n\n```\n输入：n = 10, pick = 6\n输出：6\n```\n\n\n**示例 2：**\n\n```\n输入：n = 1, pick = 1\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：n = 2, pick = 1\n输出：1\n```\n\n\n**示例 4：**\n\n```\n输入：n = 2, pick = 2\n输出：2\n```\n\n**提示：**\n\n- 1 <= n <= 231 - 1\n- 1 <= pick <= n\n\n**题解：**\n\n```cpp\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        int l = 0;\n        int r = n;\n        while (l <= r)\n        {\n            int m = (l-r)/2 + r;\n            int res = guess(m);\n            if (res == 0)\n            {\n                return m;\n            }\n            else if (res < 0)\n            {\n                r = m-1;\n            }\n            else\n            {\n                l = m + 1;\n            }\n        }\n\n        return -1;\n    }\n};\n```\n\n## 【Day50】852. 山脉数组的峰顶索引\n\n#### [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)\n\n符合下列属性的数组 arr 称为 **山脉数组** ：\n\n- arr.length >= 3\n- 存在 i（0 < i < arr.length - 1）使得：\n  - arr[0] < arr[1] < ... arr[i-1] < arr[i]\n  - arr[i] > arr[i+1] > ... > arr[arr.length - 1]\n\n 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。\n\n**示例 1：**\n\n```\n输入：arr = [0,1,0]\n输出：1\n```\n\n\n**示例 2：**\n\n```\n输入：arr = [0,2,1,0]\n输出：1\n```\n\n\n**示例 3：**\n\n```\n输入：arr = [0,10,5,2]\n输出：1\n```\n\n\n**示例 4：**\n\n```\n输入：arr = [3,4,5,1]\n输出：2\n```\n\n\n**示例 5：**\n\n```\n输入：arr = [24,69,100,99,79,78,67,36,26,19]\n输出：2\n```\n\n**提示：**\n\n- 3 <= arr.length <= 104\n- 0 <= arr[i] <= 106\n- 题目数据保证 arr 是一个山脉数组\n\n**题解：**\n\n二分法\n\n```cpp\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n            //根据 arr[mid-1]和arr[mid]对比\n        //所以搜索范围是 [1,arr.length -1]\n        int left = 1;\n        int right = arr.size() - 1;\n        \n        while(left < right){\n            //如果check 函数调整的是left，则+1. 否则有可能陷入死循环\n            int mid = left + right + 1 >> 1;\n            if(arr[mid-1] < arr[mid])\n            left = mid;\n            else\n            right = mid -1;\n        }\n        return right;\n    }\n};\n```\n\n## 【Day51】877. 石子游戏\n\n#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子**排成一行**，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n \n\n**示例：**\n\n```\n输入：[5,3,4,5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。\n如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。\n```\n\n**提示：**\n\n- 2 <= piles.length <= 500\n- piles.length 是偶数。\n- 1 <= piles[i] <= 500\n- sum(piles) 是奇数。\n\n**题解：**\n\n**博弈论**\n\n[三叶的题解](https://leetcode-cn.com/problems/stone-game/solution/gong-shui-san-xie-jing-dian-qu-jian-dp-j-wn31/)\n\n```cpp\nclass Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};\n```\n\n## 【Day52】65. 有效数字\n\n**有效数字**（按顺序）可以分成以下几个部分：\n\n1. 一个 **小数** 或者 **整数**\n2. （可选）一个 'e' 或 'E' ，后面跟着一个 **整数**\n\n**小数**（按顺序）可以分成以下几个部分：\n\n1. （可选）一个符号字符（'+' 或 '-'）\n2. 下述格式之一：\n   1. 至少一位数字，后面跟着一个点 '.'\n   2. 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字\n   3. 一个点 '.' ，后面跟着至少一位数字\n\n\n\n**整数**（按顺序）可以分成以下几个部分：\n\n- （可选）一个符号字符（'+' 或 '-'）\n- 至少一位数字\n\n部分有效数字列举如下：\n\n- [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]\n\n部分无效数字列举如下：\n\n- [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]\n\n给你一个字符串 s ，如果 s 是一个 **有效数字** ，请返回 true 。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"0\"\n输出：true\n```\n\n\n**示例 2：**\n\n```\n输入：s = \"e\"\n输出：false\n```\n\n\n**示例 3：**\n\n```\n输入：s = \".\"\n输出：false\n```\n\n\n**示例 4：**\n\n```\n输入：s = \".1\"\n输出：true\n```\n\n**提示：**\n\n- 1 <= s.length <= 20\n- s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，或者点 '.' 。\n\n**题解：**\n\n\n\n```cpp\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        int l = 0, r = s.size() - 1;\n        //去掉前后空格\n        while (l <= r && s[l] == ' ') l ++ ;\n        while (l <= r && s[r] == ' ') r -- ;\n        if (l > r) return false;\n        s = s.substr(l, r - l + 1);\n        //去掉正负号\n        if (s[0] == '+' || s[0] == '-') s = s.substr(1);\n        //如果只有正负号，false\n        if (s.empty()) return false;\n        //如果只有一个点，或者.e || .E 返回false\n        if (s[0] == '.' && (s.size() == 1 || s[1] == 'e' || s[1] == 'E'))\n            return false;\n\n        //记录点和e的次数\n        int dot = 0, e = 0;\n        for (int i = 0; i < s.size(); i ++ ) {\n            if (s[i] == '.') {\n                //如果出现多个点或者e ，fasle\n                if (dot > 0 || e > 0) return false;\n                dot ++ ;\n            } else if (s[i] == 'e' || s[i] == 'E') {\n                //如果e的前面没东西或者后面没东西，或者多个e ，false\n                if (!i || i + 1 == s.size() || e > 0) return false;\n                //如果e的后面是正负号\n                if (s[i + 1] == '+' || s[i + 1] == '-') {\n                    //但是后面没东西了，返回false\n                    if (i + 2 == s.size()) return false;\n                    i ++ ;\n                }\n                e ++ ;\n                //不合法\n            } else if (s[i] < '0' || s[i] > '9') return false;\n        }\n        return true;\n    }\n};\n```\n\n## 【Day53】483. 最小好进制\n\n#### [483. 最小好进制](https://leetcode-cn.com/problems/smallest-good-base/)\n\n对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个**好进制**。\n\n以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。\n\n \n\n**示例 1：**\n\n```\n输入：\"13\"\n输出：\"3\"\n解释：13 的 3 进制是 111。\n```\n\n\n**示例 2：**\n\n```\n输入：\"4681\"\n输出：\"8\"\n解释：4681 的 8 进制是 11111。\n```\n\n\n**示例 3：**\n\n```\n输入：\"1000000000000000000\"\n输出：\"999999999999999999\"\n解释：1000000000000000000 的 999999999999999999 进制是 11。\n```\n\n**提示：**\n\n1. n的取值范围是 [3, 10^18]。\n2. 输入总是有效且没有前导 0。\n\n**题解：**\n\n```cpp\nclass Solution {\npublic:\n    using LL = long long;\n    string smallestGoodBase(string n) {\n        LL x = stoll(n);\n        for(int m = 2; m <= 60; m++){\n            LL k = (LL)pow(x, 1. / m);\n            if(k > 1){\n                LL cur = 1;\n                for(LL i = 1, base = 1; i <= m; i++){\n                    base *= k;\n                    cur += base;\n                }\n                if(cur == x) return to_string(k);\n            }\n        }\n        return to_string(x - 1);\n    }\n};\n```\n\n\n\n## 【Day54】1239. 串联字符串的最大长度\n\n#### [1239. 串联字符串的最大长度](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)\n\n给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。\n\n请返回所有可行解 s 中最长长度。\n\n \n\n**示例 1：**\n\n```\n输入：arr = [\"un\",\"iq\",\"ue\"]\n输出：4\n解释：所有可能的串联组合是 \"\",\"un\",\"iq\",\"ue\",\"uniq\" 和 \"ique\"，最大长度为 4。\n```\n\n\n**示例 2：**\n\n```\n输入：arr = [\"cha\",\"r\",\"act\",\"ers\"]\n输出：6\n解释：可能的解答有 \"chaers\" 和 \"acters\"。\n```\n\n\n**示例 3：**\n\n```\n输入：arr = [\"abcdefghijklmnopqrstuvwxyz\"]\n输出：26\n```\n\n**提示：**\n\n- 1 <= arr.length <= 16\n- 1 <= arr[i].length <= 26\n- arr[i] 中只含有小写英文字母\n\n**题解：**\n\n\n\n```cpp\nclass Solution {\npublic:\n    int maxLength(vector<string> &arr) {\n        int ans = 0;\n        vector<int> masks = {0};\n        for (string &s : arr) {\n            int mask = 0;\n            for (char ch : s) {\n                ch -= 'a';\n                if ((mask >> ch) & 1) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解\n                    mask = 0;\n                    break;\n                }\n                mask |= 1 << ch; // 将 ch 加入 mask 中\n            }\n            if (mask == 0) {\n                continue;\n            }\n            int n = masks.size();\n            for (int i = 0; i < n; ++i) {\n                int m = masks[i];\n                if ((m & mask) == 0) { // m 和 mask 无公共元素\n                    masks.push_back(m | mask);\n                    ans = max(ans, __builtin_popcount(m | mask));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 【Day55】1600.皇位继承顺序\n\n#### [1600. 皇位继承顺序](https://leetcode-cn.com/problems/throne-inheritance/)\n\n一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。\n\n这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。\n\n> Successor(x, curOrder):\n>  如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：\n>      如果 x 是国王，那么返回 null\n>      否则，返回 Successor(x 的父亲, curOrder)\n>  否则，返回 x 不在 curOrder 中最年长的孩子\n\n比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。\n\n1. 一开始， curOrder 为 [\"king\"].\n2. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [\"king\", \"Alice\"] 。\n3. 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [\"king\", \"Alice\", \"Jack\"] 。\n4. 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [\"king\", \"Alice\", \"Jack\", \"Bob\"] 。\n5. 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [\"king\", \"Alice\", \"Jack\", \"Bob\"] 。\n\n通过以上的函数，我们总是能得到一个唯一的继承顺序。\n\n请你实现 ThroneInheritance 类：\n\n- ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。\n- void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。\n- void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。\n- string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n\n**示例：**\n\n**输入：**\n\n```\n[\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n[[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\n```\n\n**输出：**\n\n```\n[null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]]\n```\n\n**解释：**\n\n```\nThroneInheritance t= new ThroneInheritance(\"king\"); // 继承顺序：king\nt.birth(\"king\", \"andy\"); // 继承顺序：king > andy\nt.birth(\"king\", \"bob\"); // 继承顺序：king > andy > bob\nt.birth(\"king\", \"catherine\"); // 继承顺序：king > andy > bob > catherine\nt.birth(\"andy\", \"matthew\"); // 继承顺序：king > andy > matthew > bob > catherine\nt.birth(\"bob\", \"alex\"); // 继承顺序：king > andy > matthew > bob > alex > catherine\nt.birth(\"bob\", \"asha\"); // 继承顺序：king > andy > matthew > bob > alex > asha > catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"]\nt.death(\"bob\"); // 继承顺序：king > andy > matthew > bob（已经去世）> alex > asha > catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\n```\n\n**提示：**\n\n1. 1 <= kingName.length, parentName.length, childName.length, name.length <= 15\n2. kingName，parentName， childName 和 name 仅包含小写英文字母。\n3. 所有的参数 childName 和 kingName 互不相同。\n4. 所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。\n5. 每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。\n6. 最多调用 105 次birth 和 death 。\n7. 最多调用 10 次 getInheritanceOrder 。\n\n**题解：**\n\n\n\n```cpp\nclass ThroneInheritance {\npublic:\n    string root;\n    unordered_map<string, bool> isdeath;\n    unordered_map<string, vector<string>> family;\n    ThroneInheritance(string kingName) {\n        root = kingName;\n    }\n    \n    void birth(string parentName, string childName) {\n        family[parentName].push_back(childName);\n    }\n    \n    void death(string name) {\n        isdeath[name] = true;\n    }\n    \n    void dfs(vector<string>& ans, string root) {\n        if (!isdeath[root])\n            ans.push_back(root);\n        for (string str: family[root])\n            dfs(ans, str);\n    }\n\n    vector<string> getInheritanceOrder() {\n        vector<string> ans;\n        dfs(ans, root);\n        return ans;\n    }\n};\n\n/**\n * Your ThroneInheritance object will be instantiated and called as such:\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\n * obj->birth(parentName,childName);\n * obj->death(name);\n * vector<string> param_3 = obj->getInheritanceOrder();\n */\n```\n\n## 【Day56】401.二进制手表\n\n#### [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)\n\n二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。\n\n- 例如，下面的二进制手表读取 \"3:25\" 。\n\n\n\n![（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg)\n\n给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 **按任意顺序** 返回答案。\n\n小时不会以零开头：\n\n- 例如，\"01:00\" 是无效的时间，正确的写法应该是 \"1:00\" 。\n\n分钟必须由两位数组成，可能会以零开头：\n\n例如，\"10:2\" 是无效的时间，正确的写法应该是 \"10:02\" 。\n\n**示例 1：**\n\n```\n输入：turnedOn = 1\n输出：[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n```\n\n\n**示例 2：**\n\n```\n输入：turnedOn = 9\n输出：[]\n```\n\n**提示：**\n\n- 0 <= turnedOn <= 10\n\n**题解：**\n\n```cpp\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int num) {\n        vector<string> res;\n        //直接遍历  0:00 -> 12:00   每个时间有多少1\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 60; j++) {\n                if (count1(i) + count1(j) == num) {\n                    res.push_back(to_string(i)+\":\"+\n                                  (j < 10 ? \"0\"+to_string(j) : to_string(j)));\n                }\n            }\n        }\n        return res;\n    }\n    //计算二进制中1的个数\n    int count1(int n) {\n        int res = 0;\n        while (n != 0) {\n            n = n & (n - 1);\n            res++;\n        }\n        return res;\n    }\n};\n\n\n```\n\n## 【Day57】剑指 Offer 15.二进制中1的个数\n\n#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)\n\n请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n\n \n\n**示例 1：**\n\n```\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n```\n\n\n**示例 2：**\n\n```\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n```\n\n\n**示例 3：**\n\n```\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n**提示：**\n\n- 输入必须是长度为 32 的 二进制串 。\n\n> 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/\n\n**题解：**\n\n右移再 & 1\n\n```cpp\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int ans = 0;\n        for (int i = 0; i < 32; i++) {\n            ans += ((n >> i) & 1);\n        }\n        return ans;\n    }\n};\n```\n\n## 【Day58】149. 直线上最多的点数\n\n#### [149. 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)\n\n给你一个数组 points ，其中 points[i] = [xi, yi] 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。\n\n \n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)\n\n```\n输入：points = [[1,1],[2,2],[3,3]]\n输出：3\n```\n\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)\n\n```\n输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n输出：4\n```\n\n**提示：**\n\n- 1 <= points.length <= 300\n- points[i].length == 2\n- -104 <= xi, yi <= 104\n- points 中的所有点 互不相同\n\n**题解：**\n\n直接枚举，比较斜率\n\n```cpp\nclass Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        int len = points.size();\n        // 点的数量不够\n        if(len < 3) {\n            return len;\n        }\n        int maxNum = 2;\n        // 遍历每两个点\n        for(int i = 0; i < len - 1; i ++) {\n            for(int j = i + 1; j < len; j ++) {\n                // 统计斜率相等个数\n                int count = 2;\n                long long dx = points[i][0] - points[j][0];\n                long long dy = points[i][1] - points[j][1];\n                // 与其他点比较\n                for(int k = j + 1; k < len; k ++) {\n                    // 如果斜率相等\n                    if(dx * (points[i][1] - points[k][1]) == dy * (points[i][0] - points[k][0])) {\n                        count ++;\n                    }\n                }\n                maxNum = max(maxNum, count);\n                if(maxNum > len / 2) return maxNum;\n            }  \n        }\n        return maxNum;\n    }\n};\n```\n\n## 【Day59】752.打开转盘锁\n\n#### [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)\n\n你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。\n\n锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。\n\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n\n字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。\n\n \n\n**示例 1:**\n\n```\n输入：deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n输出：6\n解释：\n可能的移动序列为 \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\"。\n注意 \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" 这样的序列是不能解锁的，\n因为当拨动到 \"0102\" 时这个锁就会被锁定。\n```\n\n\n**示例 2:**\n\n```\n输入: deadends = [\"8888\"], target = \"0009\"\n输出：1\n解释：\n把最后一位反向旋转一次即可 \"0000\" -> \"0009\"。\n```\n\n\n**示例 3:**\n\n```\n输入: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n输出：-1\n解释：\n无法旋转到目标数字且不被锁定。\n```\n\n\n**示例 4:**\n\n```\n输入: deadends = [\"0000\"], target = \"8888\"\n输出：-1\n```\n\n**提示：**\n\n- 1 <= deadends.length <= 500\n- deadends[i].length == 4\n- target.length == 4\n- target 不在 deadends 之中\n- target 和 deadends[i] 仅由若干位数字组成\n\n**题解：**\n\n\n\n```cpp\nclass Solution {\npublic:\n    int seen[10010];//记录搜到过的轮盘锁数字\n    int ans = -1;\n    bool dead[10010];//记录死亡数字\n    int q[10010];//模拟队列\n    int openLock(vector<string>& deadends, string target) { \n        for(auto d : deadends){\n            \n            //将死亡数字转int作为下标存储在dead数组中\n            int tmp = stoi(d);\n            dead[tmp] = 1;\n        }\n\n        //如果\"0000\"是死亡数字直接返回0,如果target为0000直接返回-1\n        if(dead[0])return -1;\n        if(target == \"0000\") return 0;\n        int tar=stoi(target);\n        bfs(tar);\n        return ans;\n    }\n  \n    int numsadd(int num)\n    {\n        if(num == 10)\n        return -9;\n        if(num == -1)\n        return -9;\n        else return 1;\n    }\n  \n    void bfs(int target)\n    {    \n        //hh队头，tt队尾\n        int hh=0,tt=0;\n\n        //先将队头初始化为0,代表从\"0000\"开始旋转\n        q[0] = 0;\n        while(hh <= tt){\n            auto t = q[hh++];\n            int prev = t;\n\n            for(int i = 1 ; i <= 1000 ; i *= 10){\n                int num = t / i % 10; \n                int temp=t;\n\n                //正向旋转当前位的数字\n                int tmp = temp + numsadd(num+1)*i;\n                if(!seen[tmp] && !dead[tmp]){\n\n                    //满足条件就将temp插入队尾\n                    q[++tt] = tmp;\n                    //更新新转盘锁数字的操作次数\n                    seen[tmp] = seen[prev]+1;\n                }\n\n                //反向旋转当前位的数字\n                tmp = temp - numsadd(num-1)*i;\n                if(!seen[tmp] && !dead[tmp]){\n                    q[++tt] = tmp;\n                    seen[tmp] = seen[prev]+1;\n                }           \n            }\n\n            if(seen[target] != 0){\n                ans = seen[target];\n                break;\n            }\n        }\n    }\n};\n```\n\n整整两个月就刷完啦，发现这些题更适合于找工作，而我目前没有这方面的需要，所以以后偶尔刷一下，有时间就发在博客上hh","slug":"暑假LeetCode刷题集合（下）","published":true,"updated":"2022-05-23T15:24:45.762Z","_id":"clq6dy4ar003pikw0vg0q3poc","comments":true,"layout":"post","photos":[],"link":"","html":"<h2 id=\"【Day31】461-汉明距离\"><a href=\"#【Day31】461-汉明距离\" class=\"headerlink\" title=\"【Day31】461. 汉明距离\"></a>【Day31】461. 汉明距离</h2><h4 id=\"461-汉明距离\"><a href=\"#461-汉明距离\" class=\"headerlink\" title=\"461. 汉明距离\"></a><a href=\"https://leetcode-cn.com/problems/hamming-distance/\" target=\"_blank\" rel=\"noopener\">461. 汉明距离</a></h4><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>\n<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>0 ≤ x, y &lt; 231.</li>\n</ul>\n<p><strong>示例:</strong></p>\n<pre><code>输入: x = 1, y = 4\n\n输出: 2\n\n解释:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\n上面的箭头指出了对应二进制位不同的位置。</code></pre><p><strong>题解：</strong></p>\n<p>可以考虑为求异或结果值当中1的个数，进一步转换为求二进制中1的个数。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">lowbit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">hammingDistance</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> x <span class=\"token operator\">^</span> y<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ret <span class=\"token operator\">-</span><span class=\"token operator\">=</span> <span class=\"token function\">lowbit</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ans<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day32】477-汉明距离总和\"><a href=\"#【Day32】477-汉明距离总和\" class=\"headerlink\" title=\"【Day32】477.汉明距离总和\"></a>【Day32】477.汉明距离总和</h2><h4 id=\"477-汉明距离总和\"><a href=\"#477-汉明距离总和\" class=\"headerlink\" title=\"477. 汉明距离总和\"></a><a href=\"https://leetcode-cn.com/problems/total-hamming-distance/\" target=\"_blank\" rel=\"noopener\">477. 汉明距离总和</a></h4><p>两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。</p>\n<p>计算一个数组中，任意两个数之间汉明距离的总和。</p>\n<p><strong>示例:</strong></p>\n<pre><code>输入: 4, 14, 2\n\n输出: 6\n\n解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</code></pre><p><strong>注意:</strong></p>\n<ul>\n<li>数组中元素的范围为从 0到 10^9。</li>\n<li>数组的长度不超过 10^4。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">totalHammingDistance</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">31</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span><span class=\"token operator\">&amp;</span> num <span class=\"token operator\">:</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                cnt<span class=\"token punctuation\">[</span>num <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                num <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> cnt<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> cnt<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day33】1074-元素和为目标值的子矩阵数量\"><a href=\"#【Day33】1074-元素和为目标值的子矩阵数量\" class=\"headerlink\" title=\"【Day33】1074.元素和为目标值的子矩阵数量\"></a>【Day33】1074.元素和为目标值的子矩阵数量</h2><h4 id=\"1074-元素和为目标值的子矩阵数量\"><a href=\"#1074-元素和为目标值的子矩阵数量\" class=\"headerlink\" title=\"1074. 元素和为目标值的子矩阵数量\"></a><a href=\"https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/\" target=\"_blank\" rel=\"noopener\">1074. 元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。</p>\n<p>子矩阵 x1, y1, x2, y2 是满足 x1 &lt;= x &lt;= x2 且 y1 &lt;= y &lt;= y2 的所有单元 matrix[x][y] 的集合。</p>\n<p>如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 != x1’），那么这两个子矩阵也不同。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg\" alt></p>\n<pre><code>输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n输出：4\n解释：四个只含 0 的 1x1 子矩阵。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：matrix = [[1,-1],[-1,1]], target = 0\n输出：5\n解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：matrix = [[904]], target = 0\n输出：0</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= matrix.length &lt;= 100</li>\n<li>1 &lt;= matrix[0].length &lt;= 100</li>\n<li>-1000 &lt;= matrix[i] &lt;= 1000</li>\n<li>-10^8 &lt;= target &lt;= 10^8</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>二维前缀和的题目，使用哈希表来优化</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> HT_LENGTH 256</span>\n\n<span class=\"token keyword\">struct</span> HashTable <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> keys<span class=\"token punctuation\">[</span>HT_LENGTH<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> vals<span class=\"token punctuation\">[</span>HT_LENGTH<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">HashTable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        keys<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> vals<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> HT_LENGTH<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        uint32_t ikey <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>uint32_t<span class=\"token punctuation\">)</span>key <span class=\"token operator\">%</span> HT_LENGTH<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> HT_LENGTH<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                ret <span class=\"token operator\">=</span> vals<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            ikey <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            ikey <span class=\"token operator\">=</span> ikey <span class=\"token operator\">==</span> HT_LENGTH <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> ikey<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        uint32_t ikey <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>uint32_t<span class=\"token punctuation\">)</span>key <span class=\"token operator\">%</span> HT_LENGTH<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> HT_LENGTH<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                keys<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n                vals<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                vals<span class=\"token punctuation\">[</span>ikey<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            ikey <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            ikey <span class=\"token operator\">=</span> ikey <span class=\"token operator\">==</span> HT_LENGTH <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> ikey<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    HashTable ht<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">numSubmatrixSumTarget</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> matrix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> rprefix<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            rprefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span>j <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                rprefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> rprefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                ht<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> cprefix <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> row <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>row <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span>row<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    cprefix <span class=\"token operator\">+</span><span class=\"token operator\">=</span> rprefix<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> rprefix<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ht<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>cprefix <span class=\"token operator\">-</span> target<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> ret <span class=\"token operator\">+</span><span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n                    ht<span class=\"token punctuation\">.</span><span class=\"token function\">inc</span><span class=\"token punctuation\">(</span>cprefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day34】231-2-的幂\"><a href=\"#【Day34】231-2-的幂\" class=\"headerlink\" title=\"【Day34】231. 2 的幂\"></a>【Day34】231. 2 的幂</h2><h4 id=\"231-2-的幂\"><a href=\"#231-2-的幂\" class=\"headerlink\" title=\"231. 2 的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-two/\" target=\"_blank\" rel=\"noopener\">231. 2 的幂</a></h4><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>\n<p>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 1\n输出：true\n解释：20 = 1</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 16\n输出：true\n解释：24 = 16</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 3\n输出：false</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：n = 4\n输出：true</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：n = 5\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>-231 &lt;= n &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>位运算</strong></p>\n<p>若 n = 2^x 且 x为自然数（即 n 为 2 的幂），则一定满足以下条件：</p>\n<p>首先，恒有 n &amp; (n - 1) == 0，因为：</p>\n<ul>\n<li>n 二进制最高位为 11，其余所有位为 00；</li>\n<li>n−1 二进制最高位为 00，其余所有位为 11；</li>\n</ul>\n<p>其次，我们只需要限定n &gt; 0 即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isPowerOfTwo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">return</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day35】342-4的幂\"><a href=\"#【Day35】342-4的幂\" class=\"headerlink\" title=\"【Day35】342. 4的幂\"></a>【Day35】342. 4的幂</h2><h4 id=\"342-4的幂\"><a href=\"#342-4的幂\" class=\"headerlink\" title=\"342. 4的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-four/\" target=\"_blank\" rel=\"noopener\">342. 4的幂</a></h4><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。</p>\n<p>整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 16\n输出：true</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 5\n输出：false</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 1\n输出：true</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>-231 &lt;= n &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>一个数是<code>2</code>的幂，那么二进制从右边数奇数位是<code>1</code>的一定是<code>4</code>的幂。判断是<code>2</code>的幂，我们只需要判断二进制中<code>1</code>的个数，用昨天的解即可。</p>\n<pre><code>0x55555555的  二进制是  01010101 01010101 01010101 01010101</code></pre><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isPowerOfFour</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> <span class=\"token number\">0x55555555</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day36】LeetCode-1744\"><a href=\"#【Day36】LeetCode-1744\" class=\"headerlink\" title=\"【Day36】LeetCode 1744\"></a>【Day36】LeetCode 1744</h2><h4 id=\"1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？\"><a href=\"#1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？\" class=\"headerlink\" title=\"1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？\"></a><a href=\"https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\" target=\"_blank\" rel=\"noopener\">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</a></h4><p>给你一个下标从 <strong>0</strong> 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。</p>\n<p>你按照如下规则进行一场游戏：</p>\n<ul>\n<li>你从第 0 天开始吃糖果。</li>\n<li>你在吃完 <strong>所有</strong> 第 i - 1 类糖果之前，<strong>不能</strong> 吃任何一颗第 i 类糖果。</li>\n<li>在吃完所有糖果之前，你必须每天 <strong>至少</strong> 吃 一颗 糖果。</li>\n</ul>\n<p>请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 <strong>不超过</strong> dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p>\n<p>请你返回得到的数组 answer 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n输出：[true,false,true]\n提示：\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。</code></pre><p><strong>示例 2：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n输出：[false,true,true,false,false]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= candiesCount.length &lt;= 105</li>\n<li>1 &lt;= candiesCount[i] &lt;= 105</li>\n<li>1 &lt;= queries.length &lt;= 105</li>\n<li>queries[i].length == 3</li>\n<li>0 &lt;= favoriteTypei &lt; candiesCount.length</li>\n<li>0 &lt;= favoriteDayi &lt;= 109</li>\n<li>1 &lt;= dailyCapi &lt;= 109</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>使用前缀和解题：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token operator\">></span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> candiesCount<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> favoriteType <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> favoriteDay <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dailyCap <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 第favoriteType类型的前缀和</span>\n        <span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">[</span>favoriteType <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 每天吃一颗糖 </span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>favoriteDay <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">></span> sum<span class=\"token punctuation\">[</span>favoriteType <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 吃最多糖</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">[</span>favoriteType<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">1ll</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>favoriteDay <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> dailyCap<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> <span class=\"token function\">canEat</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> candiesCount<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> queries<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> candiesCount<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sum <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> candiesCount<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> ans<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> q <span class=\"token operator\">:</span> queries<span class=\"token punctuation\">)</span>\n            ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">check</span><span class=\"token punctuation\">(</span>candiesCount<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day37】523-连续的子数组和\"><a href=\"#【Day37】523-连续的子数组和\" class=\"headerlink\" title=\"【Day37】523.连续的子数组和\"></a>【Day37】523.连续的子数组和</h2><h4 id=\"523-连续的子数组和\"><a href=\"#523-连续的子数组和\" class=\"headerlink\" title=\"523. 连续的子数组和\"></a><a href=\"https://leetcode-cn.com/problems/continuous-subarray-sum/\" target=\"_blank\" rel=\"noopener\">523. 连续的子数组和</a></h4><p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>\n<ul>\n<li>子数组大小 <strong>至少为 2</strong> ，且</li>\n<li>子数组元素总和为 k 的倍数。</li>\n</ul>\n<p>如果存在，返回 true ；否则，返回 false 。</p>\n<p>如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [23,2,4,6,7], k = 6\n输出：true\n解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [23,2,6,4,7], k = 6\n输出：true\n解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [23,2,6,4,7], k = 13\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 105</li>\n<li>0 &lt;= nums[i] &lt;= 109</li>\n<li>0 &lt;= sum(nums[i]) &lt;= 231 - 1</li>\n<li>1 &lt;= k &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>经典的前缀和</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">checkSubarraySum</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        unordered_set<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> st<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>st<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span>sum <span class=\"token operator\">%</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            st<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day38】525-连续数组\"><a href=\"#【Day38】525-连续数组\" class=\"headerlink\" title=\"【Day38】525.连续数组\"></a>【Day38】525.连续数组</h2><h4 id=\"525-连续数组\"><a href=\"#525-连续数组\" class=\"headerlink\" title=\"525. 连续数组\"></a><a href=\"https://leetcode-cn.com/problems/contiguous-array/\" target=\"_blank\" rel=\"noopener\">525. 连续数组</a></h4><p>给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: nums = [0,1]\n输出: 2\n说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: nums = [0,1,0]\n输出: 2\n说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 105</li>\n<li>nums[i] 不是 0 就是 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>前缀和＋哈希</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">findMaxLength</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span><span class=\"token operator\">&amp;</span> num <span class=\"token operator\">:</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            num <span class=\"token operator\">=</span> num <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">:</span> num<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> m<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                ans <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> m<span class=\"token punctuation\">[</span>sum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                m<span class=\"token punctuation\">[</span>sum<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day39】160-相交链表\"><a href=\"#【Day39】160-相交链表\" class=\"headerlink\" title=\"【Day39】160.相交链表\"></a>【Day39】160.相交链表</h2><h4 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">160. 相交链表</a></h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" alt></p>\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n<p><strong>注意</strong>：函数返回结果后，链表必须 保持其<strong>原始结构</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" alt></p>\n<pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at &#39;8&#39;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" alt></p>\n<pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at &#39;2&#39;\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" alt></p>\n<pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>listA 中节点数目为 m</li>\n<li>listB 中节点数目为 n</li>\n<li>0 &lt;= m, n &lt;= 3 * 104</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>0 &lt;= skipA &lt;= m</li>\n<li>0 &lt;= skipB &lt;= n</li>\n<li>如果 listA 和 listB 没有交点，intersectVal 为 0</li>\n<li>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</li>\n</ul>\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n<p><strong>题解：</strong></p>\n<p>pA走过的路径为A链+B链</p>\n<p>pB走过的路径为B链+A链</p>\n<p>pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。</p>\n<pre><code>pA:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null-&gt;9-&gt;5-&gt;6-&gt;null\npB:9-&gt;5-&gt;6-&gt;null-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null</code></pre><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    ListNode <span class=\"token operator\">*</span><span class=\"token function\">getIntersectionNode</span><span class=\"token punctuation\">(</span>ListNode <span class=\"token operator\">*</span>headA<span class=\"token punctuation\">,</span> ListNode <span class=\"token operator\">*</span>headB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ListNode <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> headA<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> headB<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            p <span class=\"token operator\">=</span> p <span class=\"token operator\">?</span> p<span class=\"token operator\">-</span><span class=\"token operator\">></span>next <span class=\"token operator\">:</span> headB<span class=\"token punctuation\">;</span>\n            q <span class=\"token operator\">=</span> q <span class=\"token operator\">?</span> q<span class=\"token operator\">-</span><span class=\"token operator\">></span>next <span class=\"token operator\">:</span> headA<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day40】203-移除链表元素\"><a href=\"#【Day40】203-移除链表元素\" class=\"headerlink\" title=\"【Day40】203.移除链表元素\"></a>【Day40】203.移除链表元素</h2><h4 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">203. 移除链表元素</a></h4><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\" alt></p>\n<pre><code>输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：head = [], val = 1\n输出：[]</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：head = [7,7,7,7], val = 7\n输出：[]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>列表中的节点在范围 [0, 104] 内</li>\n<li>1 &lt;= Node.val &lt;= 50</li>\n<li>0 &lt;= k &lt;= 50</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    ListNode <span class=\"token operator\">*</span><span class=\"token function\">removeElements</span><span class=\"token punctuation\">(</span>ListNode <span class=\"token operator\">*</span>head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>head<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n        head<span class=\"token operator\">-</span><span class=\"token operator\">></span>next <span class=\"token operator\">=</span> <span class=\"token function\">removeElements</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">-</span><span class=\"token operator\">></span>next<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> head<span class=\"token operator\">-</span><span class=\"token operator\">></span>val <span class=\"token operator\">==</span> val <span class=\"token operator\">?</span> head<span class=\"token operator\">-</span><span class=\"token operator\">></span>next <span class=\"token operator\">:</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day41】474-一和零\"><a href=\"#【Day41】474-一和零\" class=\"headerlink\" title=\"【Day41】474.一和零\"></a>【Day41】474.一和零</h2><h4 id=\"474-一和零\"><a href=\"#474-一和零\" class=\"headerlink\" title=\"474. 一和零\"></a><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\" target=\"_blank\" rel=\"noopener\">474. 一和零</a></h4><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>\n<p>请你找出并返回 strs 的最大子集的大小，该子集中 <strong>最多</strong> 有 m 个 0 和 n 个 1 。</p>\n<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 <strong>子集</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3\n输出：4\n解释：最多有 5 个 0 和 3 个 1 的最大子集是 {&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {&quot;0001&quot;,&quot;1&quot;} 和 {&quot;10&quot;,&quot;1&quot;,&quot;0&quot;} 。{&quot;111001&quot;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1\n输出：2\n解释：最大的子集是 {&quot;0&quot;, &quot;1&quot;} ，所以答案是 2 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= strs.length &lt;= 600</li>\n<li>1 &lt;= strs[i].length &lt;= 100</li>\n<li>strs[i] 仅由 ‘0’ 和 ‘1’ 组成</li>\n<li>1 &lt;= m, n &lt;= 100</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>动态规划</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">101</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> dp<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> <span class=\"token function\">findMaxForm</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> strs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>str<span class=\"token operator\">:</span>strs<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> one <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> zero <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>c<span class=\"token operator\">:</span>str<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">==</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token operator\">++</span>one<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">else</span>\n                    <span class=\"token operator\">++</span>zero<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// zero = str.size() - one;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>m<span class=\"token punctuation\">;</span> j<span class=\"token operator\">>=</span>zero<span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>j<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token operator\">=</span>n<span class=\"token punctuation\">;</span> k<span class=\"token operator\">>=</span>one<span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>k<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>zero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span>one<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day42】494-目标和\"><a href=\"#【Day42】494-目标和\" class=\"headerlink\" title=\"【Day42】494. 目标和\"></a>【Day42】494. 目标和</h2><h4 id=\"494-目标和\"><a href=\"#494-目标和\" class=\"headerlink\" title=\"494. 目标和\"></a><a href=\"https://leetcode-cn.com/problems/target-sum/\" target=\"_blank\" rel=\"noopener\">494. 目标和</a></h4><p>给你一个整数数组 nums 和一个整数 target 。</p>\n<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>\n<blockquote>\n<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</p>\n</blockquote>\n<p>返回可以通过上述方法构造的、运算结果等于 target 的不同 <strong>表达式</strong> 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [1,1,1,1,1], target = 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [1], target = 1\n输出：1</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 20</li>\n<li>0 &lt;= nums[i] &lt;= 1000</li>\n<li>0 &lt;= sum(nums[i]) &lt;= 1000</li>\n<li>-1000 &lt;= target &lt;= 100</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>还是动态规划</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">findTargetSumWays</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        t <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> vector <span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">==</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> t<span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>ans<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> s <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> s <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day43】1049-最后一块石头的重量-II\"><a href=\"#【Day43】1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"【Day43】1049. 最后一块石头的重量 II\"></a>【Day43】1049. 最后一块石头的重量 II</h2><h4 id=\"1049-最后一块石头的重量-II\"><a href=\"#1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"1049. 最后一块石头的重量 II\"></a><a href=\"https://leetcode-cn.com/problems/last-stone-weight-ii/\" target=\"_blank\" rel=\"noopener\">1049. 最后一块石头的重量 II</a></h4><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p>\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>\n<ul>\n<li>如果 x == y，那么两块石头都会被完全粉碎；</li>\n<li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>\n</ul>\n<p>最后，<strong>最多只会剩下一块 石头</strong>。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 0。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：stones = [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：stones = [31,26,33,21,40]\n输出：5</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：stones = [1,2]\n输出：1</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li><p>1 &lt;= stones.length &lt;= 30</p>\n</li>\n<li><p>1 &lt;= stones[i] &lt;= 100</p>\n<p><strong>题解：</strong></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">lastStoneWeightII</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> stones<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">auto</span> sum <span class=\"token operator\">=</span> <span class=\"token function\">accumulate</span><span class=\"token punctuation\">(</span>stones<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> stones<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>sum <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span><span class=\"token operator\">&amp;</span> stone <span class=\"token operator\">:</span> stones<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> j <span class=\"token operator\">=</span> sum <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> stone<span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> stone<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> stone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> sum <span class=\"token operator\">-</span> dp<span class=\"token punctuation\">[</span>sum <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day44】879-盈利计划\"><a href=\"#【Day44】879-盈利计划\" class=\"headerlink\" title=\"【Day44】879. 盈利计划\"></a>【Day44】879. 盈利计划</h2><h4 id=\"879-盈利计划\"><a href=\"#879-盈利计划\" class=\"headerlink\" title=\"879. 盈利计划\"></a><a href=\"https://leetcode-cn.com/problems/profitable-schemes/\" target=\"_blank\" rel=\"noopener\">879. 盈利计划</a></h4><p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p>\n<p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>\n<p>工作的任何至少产生 minProfit 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 n 。</p>\n<p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> 10^9 + 7 的<strong>值</strong>。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n输出：2\n解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n输出：7\n解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 100</li>\n<li>0 &lt;= minProfit &lt;= 100</li>\n<li>1 &lt;= group.length &lt;= 100</li>\n<li>1 &lt;= group[i] &lt;= 100</li>\n<li>profit.length == group.length</li>\n<li>0 &lt;= profit[i] &lt;= 100</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>这题不会，贴一个题解吧</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">profitableSchemes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> minProfit<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> group<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> profit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> group<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> dp<span class=\"token punctuation\">[</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>minProfit <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> size<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> cur_group <span class=\"token operator\">=</span> group<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> cur_profit <span class=\"token operator\">=</span> profit<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> cur_group<span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> minProfit<span class=\"token punctuation\">;</span> k <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> cur_group<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">-</span> cur_profit<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>minProfit<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day45】518-零钱兑换-II\"><a href=\"#【Day45】518-零钱兑换-II\" class=\"headerlink\" title=\"【Day45】518. 零钱兑换 II\"></a>【Day45】518. 零钱兑换 II</h2><h4 id=\"518-零钱兑换-II\"><a href=\"#518-零钱兑换-II\" class=\"headerlink\" title=\"518. 零钱兑换 II\"></a><a href=\"https://leetcode-cn.com/problems/coin-change-2/\" target=\"_blank\" rel=\"noopener\">518. 零钱兑换 II</a></h4><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: amount = 10, coins = [10] \n输出: 1</code></pre><p><strong>注意:</strong></p>\n<ul>\n<li>0 &lt;= amount (总金额) &lt;= 5000</li>\n<li>1 &lt;= coin (硬币面额) &lt;= 5000</li>\n<li>硬币种类不超过 500 种</li>\n<li>结果符合 32 位符号整数</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">change</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> coins<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> coins<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> coins<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> amount<span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>amount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day46】279-完全平方数\"><a href=\"#【Day46】279-完全平方数\" class=\"headerlink\" title=\"【Day46】279. 完全平方数\"></a>【Day46】279. 完全平方数</h2><h4 id=\"279-完全平方数\"><a href=\"#279-完全平方数\" class=\"headerlink\" title=\"279. 完全平方数\"></a><a href=\"https://leetcode-cn.com/problems/perfect-squares/\" target=\"_blank\" rel=\"noopener\">279. 完全平方数</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>\n<p>给你一个整数 n ，返回和为 n 的完全平方数的 <strong>最少数量</strong> 。</p>\n<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 13\n输出：2\n解释：13 = 4 + 9</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 104</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//假设最小公式值m = ƒ(n) </span>\n<span class=\"token comment\" spellcheck=\"true\">//那么n的值满足下列公式 ∑(A[i] * A[i]) = n </span>\n<span class=\"token comment\" spellcheck=\"true\">//令 k 为满足最小值 m 的时候，最大的平方数  。 令  d + k * k; = n ;  d >= 0; </span>\n   <span class=\"token comment\" spellcheck=\"true\">// 注意：一定要是满足m最小的时候的k值,一味的取最大平方数,就是贪心算法了</span>\n<span class=\"token comment\" spellcheck=\"true\">//得出 f(d) + f(k*k) = f(n);</span>\n<span class=\"token comment\" spellcheck=\"true\">//显然 f(k*k) = 1; 则  f(d) + 1 = f(n); 因为 d = n - k*k;</span>\n<span class=\"token comment\" spellcheck=\"true\">//则可以推出ƒ(n - k * k) + 1 = ƒ(n) ;  且 k * k &lt;= n;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">numSquares</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">-</span> j<span class=\"token operator\">*</span>j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span>j<span class=\"token operator\">*</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                min <span class=\"token operator\">=</span> min <span class=\"token operator\">></span> tmp <span class=\"token operator\">?</span>  tmp<span class=\"token operator\">:</span>min<span class=\"token punctuation\">;</span> \n            <span class=\"token punctuation\">}</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> min<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day47】1449-数位成本和为目标值的最大数字\"><a href=\"#【Day47】1449-数位成本和为目标值的最大数字\" class=\"headerlink\" title=\"【Day47】1449. 数位成本和为目标值的最大数字\"></a>【Day47】1449. 数位成本和为目标值的最大数字</h2><h4 id=\"1449-数位成本和为目标值的最大数字\"><a href=\"#1449-数位成本和为目标值的最大数字\" class=\"headerlink\" title=\"1449. 数位成本和为目标值的最大数字\"></a><a href=\"https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/\" target=\"_blank\" rel=\"noopener\">1449. 数位成本和为目标值的最大数字</a></h4><p>给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>\n<ul>\n<li>给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。</li>\n<li>总成本必须恰好等于 target 。</li>\n<li>添加的数位中没有数字 0 。</li>\n</ul>\n<p>由于答案可能会很大，请你以字符串形式返回。</p>\n<p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：cost = [4,3,2,5,6,7,2,5,5], target = 9\n输出：&quot;7772&quot;\n解释：添加数位 &#39;7&#39; 的成本为 2 ，添加数位 &#39;2&#39; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。\n 数字     成本\n  1  -&gt;   4\n  2  -&gt;   3\n  3  -&gt;   2\n  4  -&gt;   5\n  5  -&gt;   6\n  6  -&gt;   7\n  7  -&gt;   2\n  8  -&gt;   5\n  9  -&gt;   5</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：cost = [7,6,5,5,5,6,8,7,8], target = 12\n输出：&quot;85&quot;\n解释：添加数位 &#39;8&#39; 的成本是 7 ，添加数位 &#39;5&#39; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：cost = [2,4,6,2,4,6,4,4,4], target = 5\n输出：&quot;0&quot;\n解释：总成本是 target 的条件下，无法生成任何整数。</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：cost = [6,10,15,40,40,40,40,40,40], target = 47\n输出：&quot;32211&quot;</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>cost.length == 9</li>\n<li>1 &lt;= cost[i] &lt;= 5000</li>\n<li>1 &lt;= target &lt;= 5000</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    string <span class=\"token function\">largestNumber</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> cost<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> len<span class=\"token operator\">=</span>cost<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"#\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//因为i遍历的顺序是从小到大，就保证了整数的高位一定大于等于整数的低位，也就保证了整数最大</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>len<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>target<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    \n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">>=</span>cost<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&amp;&amp;</span>dp<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>cost<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span><span class=\"token string\">\"#\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token function\">CompareString</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>dp<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>cost<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>target<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token string\">\"#\"</span><span class=\"token operator\">?</span><span class=\"token string\">\"0\"</span><span class=\"token operator\">:</span>dp<span class=\"token punctuation\">[</span>target<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    string <span class=\"token function\">CompareString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> string<span class=\"token operator\">&amp;</span> s1<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> string<span class=\"token operator\">&amp;</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> m<span class=\"token operator\">=</span>s1<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">=</span>s2<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">==</span>n<span class=\"token punctuation\">)</span><span class=\"token keyword\">return</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">,</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> m<span class=\"token operator\">></span>n<span class=\"token operator\">?</span>s1<span class=\"token operator\">:</span>s2<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day48】278-第一个错误的版本\"><a href=\"#【Day48】278-第一个错误的版本\" class=\"headerlink\" title=\"【Day48】278. 第一个错误的版本\"></a>【Day48】278. 第一个错误的版本</h2><h4 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278. 第一个错误的版本\"></a><a href=\"https://leetcode-cn.com/problems/first-bad-version/\" target=\"_blank\" rel=\"noopener\">278. 第一个错误的版本</a></h4><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n<p><strong>示例:</strong></p>\n<pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n调用 isBadVersion(3) -&gt; false\n调用 isBadVersion(5) -&gt; true\n调用 isBadVersion(4) -&gt; true\n\n所以，4 是第一个错误的版本。 </code></pre><p><strong>题解：</strong></p>\n<p>二分</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">isBadVersion</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> version<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">firstBadVersion</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> hi <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;</span> hi<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isBadVersion</span><span class=\"token punctuation\">(</span>mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                hi <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> hi<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day49】374-猜数字大小\"><a href=\"#【Day49】374-猜数字大小\" class=\"headerlink\" title=\"【Day49】374. 猜数字大小\"></a>【Day49】374. 猜数字大小</h2><h4 id=\"374-猜数字大小\"><a href=\"#374-猜数字大小\" class=\"headerlink\" title=\"374. 猜数字大小\"></a><a href=\"https://leetcode-cn.com/problems/guess-number-higher-or-lower/\" target=\"_blank\" rel=\"noopener\">374. 猜数字大小</a></h4><p>猜数字游戏的规则如下：</p>\n<ul>\n<li>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。</li>\n<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>\n</ul>\n<p>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>\n<ul>\n<li>-1：我选出的数字比你猜的数字小 pick &lt; num</li>\n<li>1：我选出的数字比你猜的数字大 pick &gt; num</li>\n<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num</li>\n</ul>\n<p>返回我选出的数字。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 10, pick = 6\n输出：6</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 1, pick = 1\n输出：1</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 2, pick = 1\n输出：1</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：n = 2, pick = 2\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 231 - 1</li>\n<li>1 &lt;= pick &lt;= n</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return          -1 if num is lower than the guess number\n *                  1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">guessNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> r <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l<span class=\"token operator\">-</span>r<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span> <span class=\"token operator\">+</span> r<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token function\">guess</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> m<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                r <span class=\"token operator\">=</span> m<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                l <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day50】852-山脉数组的峰顶索引\"><a href=\"#【Day50】852-山脉数组的峰顶索引\" class=\"headerlink\" title=\"【Day50】852. 山脉数组的峰顶索引\"></a>【Day50】852. 山脉数组的峰顶索引</h2><h4 id=\"852-山脉数组的峰顶索引\"><a href=\"#852-山脉数组的峰顶索引\" class=\"headerlink\" title=\"852. 山脉数组的峰顶索引\"></a><a href=\"https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\" target=\"_blank\" rel=\"noopener\">852. 山脉数组的峰顶索引</a></h4><p>符合下列属性的数组 arr 称为 <strong>山脉数组</strong> ：</p>\n<ul>\n<li><p>arr.length &gt;= 3</p>\n</li>\n<li><p>存在 i（0 &lt; i &lt; arr.length - 1）使得：</p>\n<ul>\n<li>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]</li>\n<li>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]</li>\n</ul>\n<p>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p>\n</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [0,1,0]\n输出：1</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [0,2,1,0]\n输出：1</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：arr = [0,10,5,2]\n输出：1</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：arr = [3,4,5,1]\n输出：2</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：arr = [24,69,100,99,79,78,67,36,26,19]\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>3 &lt;= arr.length &lt;= 104</li>\n<li>0 &lt;= arr[i] &lt;= 106</li>\n<li>题目数据保证 arr 是一个山脉数组</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>二分法</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">peakIndexInMountainArray</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//根据 arr[mid-1]和arr[mid]对比</span>\n        <span class=\"token comment\" spellcheck=\"true\">//所以搜索范围是 [1,arr.length -1]</span>\n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果check 函数调整的是left，则+1. 否则有可能陷入死循环</span>\n            <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> left <span class=\"token operator\">+</span> right <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>mid<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            left <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span>\n            right <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> right<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day51】877-石子游戏\"><a href=\"#【Day51】877-石子游戏\" class=\"headerlink\" title=\"【Day51】877. 石子游戏\"></a>【Day51】877. 石子游戏</h2><h4 id=\"877-石子游戏\"><a href=\"#877-石子游戏\" class=\"headerlink\" title=\"877. 石子游戏\"></a><a href=\"https://leetcode-cn.com/problems/stone-game/\" target=\"_blank\" rel=\"noopener\">877. 石子游戏</a></h4><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子<strong>排成一行</strong>，每堆都有正整数颗石子 piles[i] 。</p>\n<p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p>\n<p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p>\n<p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入：[5,3,4,5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。\n如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>2 &lt;= piles.length &lt;= 500</li>\n<li>piles.length 是偶数。</li>\n<li>1 &lt;= piles[i] &lt;= 500</li>\n<li>sum(piles) 是奇数。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>博弈论</strong></p>\n<p><a href=\"https://leetcode-cn.com/problems/stone-game/solution/gong-shui-san-xie-jing-dian-qu-jian-dp-j-wn31/\" target=\"_blank\" rel=\"noopener\">三叶的题解</a></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">stoneGame</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> piles<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day52】65-有效数字\"><a href=\"#【Day52】65-有效数字\" class=\"headerlink\" title=\"【Day52】65. 有效数字\"></a>【Day52】65. 有效数字</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>\n<ol>\n<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 <strong>整数</strong></li>\n</ol>\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n<ol>\n<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>\n<li>下述格式之一：<ol>\n<li>至少一位数字，后面跟着一个点 ‘.’</li>\n<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>\n<li>一个点 ‘.’ ，后面跟着至少一位数字</li>\n</ol>\n</li>\n</ol>\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n<ul>\n<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>\n<li>至少一位数字</li>\n</ul>\n<p>部分有效数字列举如下：</p>\n<ul>\n<li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li>\n</ul>\n<p>部分无效数字列举如下：</p>\n<ul>\n<li>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</li>\n</ul>\n<p>给你一个字符串 s ，如果 s 是一个 <strong>有效数字</strong> ，请返回 true 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;0&quot;\n输出：true</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;e&quot;\n输出：false</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;.&quot;\n输出：false</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：s = &quot;.1&quot;\n输出：true</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= s.length &lt;= 20</li>\n<li>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，或者点 ‘.’ 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isNumber</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> r <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//去掉前后空格</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">&lt;=</span> r <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">)</span> l <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">&lt;=</span> r <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">)</span> r <span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">></span> r<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        s <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">,</span> r <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//去掉正负号</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'+'</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span> s <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果只有正负号，false</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果只有一个点，或者.e || .E 返回false</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'e'</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'E'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//记录点和e的次数</span>\n        <span class=\"token keyword\">int</span> dot <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//如果出现多个点或者e ，fasle</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dot <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> e <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                dot <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'e'</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'E'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//如果e的前面没东西或者后面没东西，或者多个e ，false</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>i <span class=\"token operator\">||</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> e <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//如果e的后面是正负号</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'+'</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//但是后面没东西了，返回false</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    i <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                e <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//不合法</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token string\">'0'</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day53】483-最小好进制\"><a href=\"#【Day53】483-最小好进制\" class=\"headerlink\" title=\"【Day53】483. 最小好进制\"></a>【Day53】483. 最小好进制</h2><h4 id=\"483-最小好进制\"><a href=\"#483-最小好进制\" class=\"headerlink\" title=\"483. 最小好进制\"></a><a href=\"https://leetcode-cn.com/problems/smallest-good-base/\" target=\"_blank\" rel=\"noopener\">483. 最小好进制</a></h4><p>对于给定的整数 n, 如果n的k（k&gt;=2）进制数的所有数位全为1，则称 k（k&gt;=2）是 n 的一个<strong>好进制</strong>。</p>\n<p>以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：&quot;13&quot;\n输出：&quot;3&quot;\n解释：13 的 3 进制是 111。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：&quot;4681&quot;\n输出：&quot;8&quot;\n解释：4681 的 8 进制是 11111。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：&quot;1000000000000000000&quot;\n输出：&quot;999999999999999999&quot;\n解释：1000000000000000000 的 999999999999999999 进制是 11。</code></pre><p><strong>提示：</strong></p>\n<ol>\n<li>n的取值范围是 [3, 10^18]。</li>\n<li>输入总是有效且没有前导 0。</li>\n</ol>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">using</span> LL <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n    string <span class=\"token function\">smallestGoodBase</span><span class=\"token punctuation\">(</span>string n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        LL x <span class=\"token operator\">=</span> <span class=\"token function\">stoll</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> m <span class=\"token operator\">&lt;=</span> <span class=\"token number\">60</span><span class=\"token punctuation\">;</span> m<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            LL k <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>LL<span class=\"token punctuation\">)</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">/</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                LL cur <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>LL i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> base <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    base <span class=\"token operator\">*</span><span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span>\n                    cur <span class=\"token operator\">+</span><span class=\"token operator\">=</span> base<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day54】1239-串联字符串的最大长度\"><a href=\"#【Day54】1239-串联字符串的最大长度\" class=\"headerlink\" title=\"【Day54】1239. 串联字符串的最大长度\"></a>【Day54】1239. 串联字符串的最大长度</h2><h4 id=\"1239-串联字符串的最大长度\"><a href=\"#1239-串联字符串的最大长度\" class=\"headerlink\" title=\"1239. 串联字符串的最大长度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/\" target=\"_blank\" rel=\"noopener\">1239. 串联字符串的最大长度</a></h4><p>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。</p>\n<p>请返回所有可行解 s 中最长长度。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]\n输出：4\n解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]\n输出：6\n解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]\n输出：26</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= arr.length &lt;= 16</li>\n<li>1 &lt;= arr[i].length &lt;= 26</li>\n<li>arr[i] 中只含有小写英文字母</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">maxLength</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> masks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>string <span class=\"token operator\">&amp;</span>s <span class=\"token operator\">:</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> mask <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                ch <span class=\"token operator\">-</span><span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>mask <span class=\"token operator\">>></span> ch<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解</span>\n                    mask <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                mask <span class=\"token operator\">|</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> ch<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 将 ch 加入 mask 中</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mask <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> masks<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> masks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">&amp;</span> mask<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// m 和 mask 无公共元素</span>\n                    masks<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">|</span> mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> <span class=\"token function\">__builtin_popcount</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">|</span> mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day55】1600-皇位继承顺序\"><a href=\"#【Day55】1600-皇位继承顺序\" class=\"headerlink\" title=\"【Day55】1600.皇位继承顺序\"></a>【Day55】1600.皇位继承顺序</h2><h4 id=\"1600-皇位继承顺序\"><a href=\"#1600-皇位继承顺序\" class=\"headerlink\" title=\"1600. 皇位继承顺序\"></a><a href=\"https://leetcode-cn.com/problems/throne-inheritance/\" target=\"_blank\" rel=\"noopener\">1600. 皇位继承顺序</a></h4><p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>\n<p>这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。</p>\n<blockquote>\n<p>Successor(x, curOrder):<br> 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：<br>     如果 x 是国王，那么返回 null<br>     否则，返回 Successor(x 的父亲, curOrder)<br> 否则，返回 x 不在 curOrder 中最年长的孩子</p>\n</blockquote>\n<p>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。</p>\n<ol>\n<li>一开始， curOrder 为 [“king”].</li>\n<li>调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。</li>\n<li>调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。</li>\n<li>调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。</li>\n<li>调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。</li>\n</ol>\n<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>\n<p>请你实现 ThroneInheritance 类：</p>\n<ul>\n<li>ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。</li>\n<li>void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。</li>\n<li>void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>\n<li>string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><strong>输入：</strong></p>\n<pre><code>[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;]\n[[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]</code></pre><p><strong>输出：</strong></p>\n<pre><code>[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]</code></pre><p><strong>解释：</strong></p>\n<pre><code>ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：king\nt.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andy\nt.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bob\nt.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherine\nt.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine\nt.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine\nt.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]\nt.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]</code></pre><p><strong>提示：</strong></p>\n<ol>\n<li>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</li>\n<li>kingName，parentName， childName 和 name 仅包含小写英文字母。</li>\n<li>所有的参数 childName 和 kingName 互不相同。</li>\n<li>所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。</li>\n<li>每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。</li>\n<li>最多调用 105 次birth 和 death 。</li>\n<li>最多调用 10 次 getInheritanceOrder 。</li>\n</ol>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ThroneInheritance</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    string root<span class=\"token punctuation\">;</span>\n    unordered_map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span><span class=\"token operator\">></span> isdeath<span class=\"token punctuation\">;</span>\n    unordered_map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> family<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">ThroneInheritance</span><span class=\"token punctuation\">(</span>string kingName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        root <span class=\"token operator\">=</span> kingName<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">birth</span><span class=\"token punctuation\">(</span>string parentName<span class=\"token punctuation\">,</span> string childName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        family<span class=\"token punctuation\">[</span>parentName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>childName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">death</span><span class=\"token punctuation\">(</span>string name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        isdeath<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> ans<span class=\"token punctuation\">,</span> string root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isdeath<span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>string str<span class=\"token operator\">:</span> family<span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">getInheritanceOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> ans<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Your ThroneInheritance object will be instantiated and called as such:\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\n * obj->birth(parentName,childName);\n * obj->death(name);\n * vector&lt;string> param_3 = obj->getInheritanceOrder();\n */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day56】401-二进制手表\"><a href=\"#【Day56】401-二进制手表\" class=\"headerlink\" title=\"【Day56】401.二进制手表\"></a>【Day56】401.二进制手表</h2><h4 id=\"401-二进制手表\"><a href=\"#401-二进制手表\" class=\"headerlink\" title=\"401. 二进制手表\"></a><a href=\"https://leetcode-cn.com/problems/binary-watch/\" target=\"_blank\" rel=\"noopener\">401. 二进制手表</a></h4><p>二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。</p>\n<ul>\n<li>例如，下面的二进制手表读取 “3:25” 。</li>\n</ul>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg\" alt=\"（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）\"></p>\n<p>给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<p>小时不会以零开头：</p>\n<ul>\n<li>例如，”01:00” 是无效的时间，正确的写法应该是 “1:00” 。</li>\n</ul>\n<p>分钟必须由两位数组成，可能会以零开头：</p>\n<p>例如，”10:2” 是无效的时间，正确的写法应该是 “10:02” 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：turnedOn = 1\n输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：turnedOn = 9\n输出：[]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>0 &lt;= turnedOn &lt;= 10</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">readBinaryWatch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> res<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//直接遍历  0:00 -> 12:00   每个时间有多少1</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">60</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">count1</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">count1</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\":\"</span><span class=\"token operator\">+</span>\n                                  <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"0\"</span><span class=\"token operator\">+</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//计算二进制中1的个数</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">count1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            n <span class=\"token operator\">=</span> n <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            res<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day57】剑指-Offer-15-二进制中1的个数\"><a href=\"#【Day57】剑指-Offer-15-二进制中1的个数\" class=\"headerlink\" title=\"【Day57】剑指 Offer 15.二进制中1的个数\"></a>【Day57】剑指 Offer 15.二进制中1的个数</h2><h4 id=\"剑指-Offer-15-二进制中1的个数\"><a href=\"#剑指-Offer-15-二进制中1的个数\" class=\"headerlink\" title=\"剑指 Offer 15. 二进制中1的个数\"></a><a href=\"https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\" target=\"_blank\" rel=\"noopener\">剑指 Offer 15. 二进制中1的个数</a></h4><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>输入必须是长度为 32 的 二进制串 。</li>\n</ul>\n<blockquote>\n<p>注意：本题与主站 191 题相同：<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<p>右移再 &amp; 1</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">hammingWeight</span><span class=\"token punctuation\">(</span>uint32_t n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">32</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">>></span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day58】149-直线上最多的点数\"><a href=\"#【Day58】149-直线上最多的点数\" class=\"headerlink\" title=\"【Day58】149. 直线上最多的点数\"></a>【Day58】149. 直线上最多的点数</h2><h4 id=\"149-直线上最多的点数\"><a href=\"#149-直线上最多的点数\" class=\"headerlink\" title=\"149. 直线上最多的点数\"></a><a href=\"https://leetcode-cn.com/problems/max-points-on-a-line/\" target=\"_blank\" rel=\"noopener\">149. 直线上最多的点数</a></h4><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" alt></p>\n<pre><code>输入：points = [[1,1],[2,2],[3,3]]\n输出：3</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" alt></p>\n<pre><code>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n输出：4</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= points.length &lt;= 300</li>\n<li>points[i].length == 2</li>\n<li>-104 &lt;= xi, yi &lt;= 104</li>\n<li>points 中的所有点 互不相同</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>直接枚举，比较斜率</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">maxPoints</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> points<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> points<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 点的数量不够</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> len<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> maxNum <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 遍历每两个点</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 统计斜率相等个数</span>\n                <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> dx <span class=\"token operator\">=</span> points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> points<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> dy <span class=\"token operator\">=</span> points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> points<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 与其他点比较</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> k <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果斜率相等</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dx <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> points<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> dy <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> points<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        count <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                maxNum <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxNum<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>maxNum <span class=\"token operator\">></span> len <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> maxNum<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>  \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> maxNum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"【Day59】752-打开转盘锁\"><a href=\"#【Day59】752-打开转盘锁\" class=\"headerlink\" title=\"【Day59】752.打开转盘锁\"></a>【Day59】752.打开转盘锁</h2><h4 id=\"752-打开转盘锁\"><a href=\"#752-打开转盘锁\" class=\"headerlink\" title=\"752. 打开转盘锁\"></a><a href=\"https://leetcode-cn.com/problems/open-the-lock/\" target=\"_blank\" rel=\"noopener\">752. 打开转盘锁</a></h4><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>\n<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n<p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;\n输出：6\n解释：\n可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。\n注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，\n因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;\n输出：1\n解释：\n把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;\n输出：-1\n解释：\n无法旋转到目标数字且不被锁定。</code></pre><p><strong>示例 4:</strong></p>\n<pre><code>输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;\n输出：-1</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= deadends.length &lt;= 500</li>\n<li>deadends[i].length == 4</li>\n<li>target.length == 4</li>\n<li>target 不在 deadends 之中</li>\n<li>target 和 deadends[i] 仅由若干位数字组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> seen<span class=\"token punctuation\">[</span><span class=\"token number\">10010</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//记录搜到过的轮盘锁数字</span>\n    <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> dead<span class=\"token punctuation\">[</span><span class=\"token number\">10010</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//记录死亡数字</span>\n    <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">[</span><span class=\"token number\">10010</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//模拟队列</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">openLock</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> deadends<span class=\"token punctuation\">,</span> string target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> d <span class=\"token operator\">:</span> deadends<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//将死亡数字转int作为下标存储在dead数组中</span>\n            <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">stoi</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            dead<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//如果\"0000\"是死亡数字直接返回0,如果target为0000直接返回-1</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dead<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>target <span class=\"token operator\">==</span> <span class=\"token string\">\"0000\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> tar<span class=\"token operator\">=</span><span class=\"token function\">stoi</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>tar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> <span class=\"token function\">numsadd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>    \n        <span class=\"token comment\" spellcheck=\"true\">//hh队头，tt队尾</span>\n        <span class=\"token keyword\">int</span> hh<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>tt<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//先将队头初始化为0,代表从\"0000\"开始旋转</span>\n        q<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>hh <span class=\"token operator\">&lt;=</span> tt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">auto</span> t <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>hh<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> prev <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1000</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> t <span class=\"token operator\">/</span> i <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> \n                <span class=\"token keyword\">int</span> temp<span class=\"token operator\">=</span>t<span class=\"token punctuation\">;</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">//正向旋转当前位的数字</span>\n                <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> temp <span class=\"token operator\">+</span> <span class=\"token function\">numsadd</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>seen<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>dead<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">//满足条件就将temp插入队尾</span>\n                    q<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>tt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//更新新转盘锁数字的操作次数</span>\n                    seen<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> seen<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">//反向旋转当前位的数字</span>\n                tmp <span class=\"token operator\">=</span> temp <span class=\"token operator\">-</span> <span class=\"token function\">numsadd</span><span class=\"token punctuation\">(</span>num<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>seen<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>dead<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    q<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>tt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                    seen<span class=\"token punctuation\">[</span>tmp<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> seen<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>           \n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>seen<span class=\"token punctuation\">[</span>target<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                ans <span class=\"token operator\">=</span> seen<span class=\"token punctuation\">[</span>target<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>整整两个月就刷完啦，发现这些题更适合于找工作，而我目前没有这方面的需要，所以以后偶尔刷一下，有时间就发在博客上hh</p>\n","excerpt":"","more":"<h2 id=\"【Day31】461-汉明距离\"><a href=\"#【Day31】461-汉明距离\" class=\"headerlink\" title=\"【Day31】461. 汉明距离\"></a>【Day31】461. 汉明距离</h2><h4 id=\"461-汉明距离\"><a href=\"#461-汉明距离\" class=\"headerlink\" title=\"461. 汉明距离\"></a><a href=\"https://leetcode-cn.com/problems/hamming-distance/\" target=\"_blank\" rel=\"noopener\">461. 汉明距离</a></h4><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>\n<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>0 ≤ x, y &lt; 231.</li>\n</ul>\n<p><strong>示例:</strong></p>\n<pre><code>输入: x = 1, y = 4\n\n输出: 2\n\n解释:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\n上面的箭头指出了对应二进制位不同的位置。</code></pre><p><strong>题解：</strong></p>\n<p>可以考虑为求异或结果值当中1的个数，进一步转换为求二进制中1的个数。</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int lowbit(int x) {\n        return x &amp; (-x);\n    }\n    int hammingDistance(int x, int y) {\n        int ret = x ^ y;\n        int ans = 0;\n        while (ret) {\n            ret -= lowbit(ret);\n            ans++;\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day32】477-汉明距离总和\"><a href=\"#【Day32】477-汉明距离总和\" class=\"headerlink\" title=\"【Day32】477.汉明距离总和\"></a>【Day32】477.汉明距离总和</h2><h4 id=\"477-汉明距离总和\"><a href=\"#477-汉明距离总和\" class=\"headerlink\" title=\"477. 汉明距离总和\"></a><a href=\"https://leetcode-cn.com/problems/total-hamming-distance/\" target=\"_blank\" rel=\"noopener\">477. 汉明距离总和</a></h4><p>两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。</p>\n<p>计算一个数组中，任意两个数之间汉明距离的总和。</p>\n<p><strong>示例:</strong></p>\n<pre><code>输入: 4, 14, 2\n\n输出: 6\n\n解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</code></pre><p><strong>注意:</strong></p>\n<ul>\n<li>数组中元素的范围为从 0到 10^9。</li>\n<li>数组的长度不超过 10^4。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int totalHammingDistance(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        for (int i = 0; i &lt; 31; i++) {\n            int cnt[]  = {0, 0};\n            for (auto&amp; num : nums) {\n                cnt[num &amp; 1]++;\n                num &gt;&gt;= 1;\n            }\n            ans += cnt[0] * cnt[1];\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day33】1074-元素和为目标值的子矩阵数量\"><a href=\"#【Day33】1074-元素和为目标值的子矩阵数量\" class=\"headerlink\" title=\"【Day33】1074.元素和为目标值的子矩阵数量\"></a>【Day33】1074.元素和为目标值的子矩阵数量</h2><h4 id=\"1074-元素和为目标值的子矩阵数量\"><a href=\"#1074-元素和为目标值的子矩阵数量\" class=\"headerlink\" title=\"1074. 元素和为目标值的子矩阵数量\"></a><a href=\"https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/\" target=\"_blank\" rel=\"noopener\">1074. 元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。</p>\n<p>子矩阵 x1, y1, x2, y2 是满足 x1 &lt;= x &lt;= x2 且 y1 &lt;= y &lt;= y2 的所有单元 matrix[x][y] 的集合。</p>\n<p>如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 != x1’），那么这两个子矩阵也不同。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg\" alt></p>\n<pre><code>输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n输出：4\n解释：四个只含 0 的 1x1 子矩阵。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：matrix = [[1,-1],[-1,1]], target = 0\n输出：5\n解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：matrix = [[904]], target = 0\n输出：0</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= matrix.length &lt;= 100</li>\n<li>1 &lt;= matrix[0].length &lt;= 100</li>\n<li>-1000 &lt;= matrix[i] &lt;= 1000</li>\n<li>-10^8 &lt;= target &lt;= 10^8</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>二维前缀和的题目，使用哈希表来优化</p>\n<pre><code class=\"cpp\">#define HT_LENGTH 256\n\nstruct HashTable {\n    int keys[HT_LENGTH];\n    int vals[HT_LENGTH];\n\n    HashTable() {\n        this-&gt;clear();\n    }\n\n    void clear() {\n        keys[0] = 0; vals[0] = 1;\n        for (int i = 1;i &lt; HT_LENGTH;i++) keys[i] = -1;\n    }\n\n    bool find(int key, int&amp; ret) {\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\n        for (int i = 0;i &lt; HT_LENGTH;i++) {\n            if (keys[ikey] == -1) return false;\n            if (keys[ikey] == key) {\n                ret = vals[ikey];\n                return true;\n            }\n            ikey ++;\n            ikey = ikey == HT_LENGTH ? 0 : ikey;\n        }\n        return false;\n    }\n\n    void inc(int key) {\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\n        for (int i = 0;i &lt; HT_LENGTH;i++) {\n            if (keys[ikey] == -1) {\n                keys[ikey] = key;\n                vals[ikey] = 1;\n                return;\n            }\n            if (keys[ikey] == key) {\n                vals[ikey]++;\n                return;\n            }\n            ikey ++;\n            ikey = ikey == HT_LENGTH ? 0 : ikey;\n        }\n    }\n};\n\nclass Solution {\nprivate:\n    HashTable ht;\npublic:\n    int numSubmatrixSumTarget(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        int rprefix[100][101];\n        int m = matrix.size(), n = matrix[0].size();\n        int ret = 0;\n        for (int i = 0;i &lt; m;i++) {\n            rprefix[i][0] = 0;\n            for (int j = 1;j &lt;= n;j ++) {\n                rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1];\n            }\n        }\n\n        for (int i = 1;i &lt;= n;i++) {\n            for (int j = i;j &lt;= n;j++) {\n                ht.clear();\n                int cprefix = 0, val;\n                for (int row = 0;row &lt; m;row++) {\n                    cprefix += rprefix[row][j] - rprefix[row][i - 1];\n                    if (ht.find(cprefix - target, val)) ret += val;\n                    ht.inc(cprefix);\n                }\n            }\n        }\n        return ret;\n    }\n};</code></pre>\n<h2 id=\"【Day34】231-2-的幂\"><a href=\"#【Day34】231-2-的幂\" class=\"headerlink\" title=\"【Day34】231. 2 的幂\"></a>【Day34】231. 2 的幂</h2><h4 id=\"231-2-的幂\"><a href=\"#231-2-的幂\" class=\"headerlink\" title=\"231. 2 的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-two/\" target=\"_blank\" rel=\"noopener\">231. 2 的幂</a></h4><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>\n<p>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 1\n输出：true\n解释：20 = 1</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 16\n输出：true\n解释：24 = 16</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 3\n输出：false</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：n = 4\n输出：true</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：n = 5\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>-231 &lt;= n &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>位运算</strong></p>\n<p>若 n = 2^x 且 x为自然数（即 n 为 2 的幂），则一定满足以下条件：</p>\n<p>首先，恒有 n &amp; (n - 1) == 0，因为：</p>\n<ul>\n<li>n 二进制最高位为 11，其余所有位为 00；</li>\n<li>n−1 二进制最高位为 00，其余所有位为 11；</li>\n</ul>\n<p>其次，我们只需要限定n &gt; 0 即可。</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n         return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;\n    }\n};</code></pre>\n<h2 id=\"【Day35】342-4的幂\"><a href=\"#【Day35】342-4的幂\" class=\"headerlink\" title=\"【Day35】342. 4的幂\"></a>【Day35】342. 4的幂</h2><h4 id=\"342-4的幂\"><a href=\"#342-4的幂\" class=\"headerlink\" title=\"342. 4的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-four/\" target=\"_blank\" rel=\"noopener\">342. 4的幂</a></h4><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。</p>\n<p>整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 16\n输出：true</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 5\n输出：false</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 1\n输出：true</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>-231 &lt;= n &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>一个数是<code>2</code>的幂，那么二进制从右边数奇数位是<code>1</code>的一定是<code>4</code>的幂。判断是<code>2</code>的幂，我们只需要判断二进制中<code>1</code>的个数，用昨天的解即可。</p>\n<pre><code>0x55555555的  二进制是  01010101 01010101 01010101 01010101</code></pre><pre><code class=\"cpp\">class Solution {\npublic:\n    bool isPowerOfFour(int n) {\n    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0 &amp;&amp; (n &amp; 0x55555555) == n;\n    }\n};</code></pre>\n<h2 id=\"【Day36】LeetCode-1744\"><a href=\"#【Day36】LeetCode-1744\" class=\"headerlink\" title=\"【Day36】LeetCode 1744\"></a>【Day36】LeetCode 1744</h2><h4 id=\"1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？\"><a href=\"#1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？\" class=\"headerlink\" title=\"1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？\"></a><a href=\"https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\" target=\"_blank\" rel=\"noopener\">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</a></h4><p>给你一个下标从 <strong>0</strong> 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。</p>\n<p>你按照如下规则进行一场游戏：</p>\n<ul>\n<li>你从第 0 天开始吃糖果。</li>\n<li>你在吃完 <strong>所有</strong> 第 i - 1 类糖果之前，<strong>不能</strong> 吃任何一颗第 i 类糖果。</li>\n<li>在吃完所有糖果之前，你必须每天 <strong>至少</strong> 吃 一颗 糖果。</li>\n</ul>\n<p>请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 <strong>不超过</strong> dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p>\n<p>请你返回得到的数组 answer 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n输出：[true,false,true]\n提示：\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code class=\"text\">输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n输出：[false,true,true,false,false]</code></pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= candiesCount.length &lt;= 105</li>\n<li>1 &lt;= candiesCount[i] &lt;= 105</li>\n<li>1 &lt;= queries.length &lt;= 105</li>\n<li>queries[i].length == 3</li>\n<li>0 &lt;= favoriteTypei &lt; candiesCount.length</li>\n<li>0 &lt;= favoriteDayi &lt;= 109</li>\n<li>1 &lt;= dailyCapi &lt;= 109</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>使用前缀和解题：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;long long&gt; sum;\n    bool check(vector&lt;int&gt;&amp; candiesCount, vector&lt;int&gt;&amp; q) {\n        int favoriteType = q[0], favoriteDay = q[1], dailyCap = q[2];\n        // 第favoriteType类型的前缀和\n        int l = sum[favoriteType + 1];\n        // 每天吃一颗糖 \n        if (favoriteDay + 1 &gt; sum[favoriteType + 1]) return false;\n        // 吃最多糖\n        if (sum[favoriteType] &gt;= 1ll*(favoriteDay + 1) * dailyCap) return false;\n        return true;\n    }\n    vector&lt;bool&gt; canEat(vector&lt;int&gt;&amp; candiesCount, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {\n        int n = candiesCount.size();\n        sum = vector&lt;long long&gt;(n + 1, 0);\n        for (int i = 1; i &lt;= n; i++) {\n            sum[i] = sum[i - 1] + candiesCount[i - 1];\n        }\n\n        vector&lt;bool&gt; ans;\n        for (auto q : queries)\n            ans.push_back(check(candiesCount, q));\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day37】523-连续的子数组和\"><a href=\"#【Day37】523-连续的子数组和\" class=\"headerlink\" title=\"【Day37】523.连续的子数组和\"></a>【Day37】523.连续的子数组和</h2><h4 id=\"523-连续的子数组和\"><a href=\"#523-连续的子数组和\" class=\"headerlink\" title=\"523. 连续的子数组和\"></a><a href=\"https://leetcode-cn.com/problems/continuous-subarray-sum/\" target=\"_blank\" rel=\"noopener\">523. 连续的子数组和</a></h4><p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>\n<ul>\n<li>子数组大小 <strong>至少为 2</strong> ，且</li>\n<li>子数组元素总和为 k 的倍数。</li>\n</ul>\n<p>如果存在，返回 true ；否则，返回 false 。</p>\n<p>如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [23,2,4,6,7], k = 6\n输出：true\n解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [23,2,6,4,7], k = 6\n输出：true\n解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [23,2,6,4,7], k = 13\n输出：false</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 105</li>\n<li>0 &lt;= nums[i] &lt;= 109</li>\n<li>0 &lt;= sum(nums[i]) &lt;= 231 - 1</li>\n<li>1 &lt;= k &lt;= 231 - 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>经典的前缀和</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {\n        int sum = 0;\n        unordered_set&lt;int&gt; st;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            sum += nums[i];\n            if(st.count(sum % k)) return true;\n            st.insert((sum - nums[i]) % k); \n        }\n        return false;\n    }\n};</code></pre>\n<h2 id=\"【Day38】525-连续数组\"><a href=\"#【Day38】525-连续数组\" class=\"headerlink\" title=\"【Day38】525.连续数组\"></a>【Day38】525.连续数组</h2><h4 id=\"525-连续数组\"><a href=\"#525-连续数组\" class=\"headerlink\" title=\"525. 连续数组\"></a><a href=\"https://leetcode-cn.com/problems/contiguous-array/\" target=\"_blank\" rel=\"noopener\">525. 连续数组</a></h4><p>给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: nums = [0,1]\n输出: 2\n说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: nums = [0,1,0]\n输出: 2\n说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 105</li>\n<li>nums[i] 不是 0 就是 1</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>前缀和＋哈希</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int findMaxLength(vector&lt;int&gt;&amp; nums) {\n        for (auto&amp; num : nums) {\n            num = num == 0 ? -1 : num;\n        }\n        map&lt;int, int&gt; m;\n        int sum = 0, ans = 0;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            sum += nums[i];\n            if (sum == 0) {\n                ans = i + 1;\n            }\n            if (m.count(sum)) {\n                ans = max(i - m[sum], ans);\n            } else {\n                m[sum] = i;\n            }\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day39】160-相交链表\"><a href=\"#【Day39】160-相交链表\" class=\"headerlink\" title=\"【Day39】160.相交链表\"></a>【Day39】160.相交链表</h2><h4 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">160. 相交链表</a></h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" alt></p>\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n<p><strong>注意</strong>：函数返回结果后，链表必须 保持其<strong>原始结构</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" alt></p>\n<pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at &#39;8&#39;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" alt></p>\n<pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at &#39;2&#39;\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" alt></p>\n<pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>listA 中节点数目为 m</li>\n<li>listB 中节点数目为 n</li>\n<li>0 &lt;= m, n &lt;= 3 * 104</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>0 &lt;= skipA &lt;= m</li>\n<li>0 &lt;= skipB &lt;= n</li>\n<li>如果 listA 和 listB 没有交点，intersectVal 为 0</li>\n<li>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</li>\n</ul>\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n<p><strong>题解：</strong></p>\n<p>pA走过的路径为A链+B链</p>\n<p>pB走过的路径为B链+A链</p>\n<p>pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。</p>\n<pre><code>pA:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null-&gt;9-&gt;5-&gt;6-&gt;null\npB:9-&gt;5-&gt;6-&gt;null-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null</code></pre><pre><code class=\"cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p = headA, *q = headB;\n        while (p != q) {\n            p = p ? p-&gt;next : headB;\n            q = q ? q-&gt;next : headA;\n        }\n        return p;\n    }\n};</code></pre>\n<h2 id=\"【Day40】203-移除链表元素\"><a href=\"#【Day40】203-移除链表元素\" class=\"headerlink\" title=\"【Day40】203.移除链表元素\"></a>【Day40】203.移除链表元素</h2><h4 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">203. 移除链表元素</a></h4><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\" alt></p>\n<pre><code>输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：head = [], val = 1\n输出：[]</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：head = [7,7,7,7], val = 7\n输出：[]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>列表中的节点在范围 [0, 104] 内</li>\n<li>1 &lt;= Node.val &lt;= 50</li>\n<li>0 &lt;= k &lt;= 50</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *removeElements(ListNode *head, int val)\n    {\n        if (!head)\n            return head;\n        head-&gt;next = removeElements(head-&gt;next, val);\n        return head-&gt;val == val ? head-&gt;next : head;\n    }\n};</code></pre>\n<h2 id=\"【Day41】474-一和零\"><a href=\"#【Day41】474-一和零\" class=\"headerlink\" title=\"【Day41】474.一和零\"></a>【Day41】474.一和零</h2><h4 id=\"474-一和零\"><a href=\"#474-一和零\" class=\"headerlink\" title=\"474. 一和零\"></a><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\" target=\"_blank\" rel=\"noopener\">474. 一和零</a></h4><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>\n<p>请你找出并返回 strs 的最大子集的大小，该子集中 <strong>最多</strong> 有 m 个 0 和 n 个 1 。</p>\n<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 <strong>子集</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3\n输出：4\n解释：最多有 5 个 0 和 3 个 1 的最大子集是 {&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {&quot;0001&quot;,&quot;1&quot;} 和 {&quot;10&quot;,&quot;1&quot;,&quot;0&quot;} 。{&quot;111001&quot;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1\n输出：2\n解释：最大的子集是 {&quot;0&quot;, &quot;1&quot;} ，所以答案是 2 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= strs.length &lt;= 600</li>\n<li>1 &lt;= strs[i].length &lt;= 100</li>\n<li>strs[i] 仅由 ‘0’ 和 ‘1’ 组成</li>\n<li>1 &lt;= m, n &lt;= 100</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>动态规划</p>\n<pre><code class=\"cpp\">const int N = 101;\nclass Solution {\npublic:\n    int dp[N][N];\n\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n)\n    {\n        for (auto &amp;str:strs)\n        {\n            int one = 0, zero = 0;\n            for (auto &amp;c:str)\n            {\n                if(c==&#39;1&#39;)\n                    ++one;\n                else\n                    ++zero;\n            }\n            // zero = str.size() - one;\n            for (int j=m; j&gt;=zero; --j)\n            {\n                for (int k=n; k&gt;=one; --k)\n                {\n                    dp[j][k] = max(dp[j][k], dp[j-zero][k-one] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};</code></pre>\n<h2 id=\"【Day42】494-目标和\"><a href=\"#【Day42】494-目标和\" class=\"headerlink\" title=\"【Day42】494. 目标和\"></a>【Day42】494. 目标和</h2><h4 id=\"494-目标和\"><a href=\"#494-目标和\" class=\"headerlink\" title=\"494. 目标和\"></a><a href=\"https://leetcode-cn.com/problems/target-sum/\" target=\"_blank\" rel=\"noopener\">494. 目标和</a></h4><p>给你一个整数数组 nums 和一个整数 target 。</p>\n<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>\n<blockquote>\n<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</p>\n</blockquote>\n<p>返回可以通过上述方法构造的、运算结果等于 target 的不同 <strong>表达式</strong> 的数目。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [1,1,1,1,1], target = 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [1], target = 1\n输出：1</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 20</li>\n<li>0 &lt;= nums[i] &lt;= 1000</li>\n<li>0 &lt;= sum(nums[i]) &lt;= 1000</li>\n<li>-1000 &lt;= target &lt;= 100</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>还是动态规划</p>\n<pre><code class=\"cpp\">class Solution {\n    int n;\n    int ans = 0;\n    int t;\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {\n        n = nums.size();\n        t = target;\n        dfs(0,nums,  0);\n        return ans;\n    }\n    void dfs(int u, vector &lt;int&gt; &amp; nums, int s){\n        if(u == n){\n            if(s == t) ++ans;\n            return;\n        }\n        dfs(u + 1, nums, s + nums[u]);\n        dfs(u + 1, nums, s - nums[u]);\n    }\n};</code></pre>\n<h2 id=\"【Day43】1049-最后一块石头的重量-II\"><a href=\"#【Day43】1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"【Day43】1049. 最后一块石头的重量 II\"></a>【Day43】1049. 最后一块石头的重量 II</h2><h4 id=\"1049-最后一块石头的重量-II\"><a href=\"#1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"1049. 最后一块石头的重量 II\"></a><a href=\"https://leetcode-cn.com/problems/last-stone-weight-ii/\" target=\"_blank\" rel=\"noopener\">1049. 最后一块石头的重量 II</a></h4><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p>\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>\n<ul>\n<li>如果 x == y，那么两块石头都会被完全粉碎；</li>\n<li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>\n</ul>\n<p>最后，<strong>最多只会剩下一块 石头</strong>。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 0。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：stones = [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：stones = [31,26,33,21,40]\n输出：5</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：stones = [1,2]\n输出：1</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li><p>1 &lt;= stones.length &lt;= 30</p>\n</li>\n<li><p>1 &lt;= stones[i] &lt;= 100</p>\n<p><strong>题解：</strong></p>\n</li>\n</ul>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) {\n        auto sum = accumulate(stones.begin(), stones.end(), 0);\n        vector&lt;int&gt; dp(sum / 2 + 1);\n        for (const auto&amp; stone : stones) {\n            for (auto j = sum / 2; j &gt;= stone; j--) {\n                dp[j] = max(dp[j], dp[j - stone] + stone);\n            }\n        }\n        return sum - dp[sum / 2] * 2;\n    }\n};\n</code></pre>\n<h2 id=\"【Day44】879-盈利计划\"><a href=\"#【Day44】879-盈利计划\" class=\"headerlink\" title=\"【Day44】879. 盈利计划\"></a>【Day44】879. 盈利计划</h2><h4 id=\"879-盈利计划\"><a href=\"#879-盈利计划\" class=\"headerlink\" title=\"879. 盈利计划\"></a><a href=\"https://leetcode-cn.com/problems/profitable-schemes/\" target=\"_blank\" rel=\"noopener\">879. 盈利计划</a></h4><p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p>\n<p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>\n<p>工作的任何至少产生 minProfit 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 n 。</p>\n<p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> 10^9 + 7 的<strong>值</strong>。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n输出：2\n解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n输出：7\n解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 100</li>\n<li>0 &lt;= minProfit &lt;= 100</li>\n<li>1 &lt;= group.length &lt;= 100</li>\n<li>1 &lt;= group[i] &lt;= 100</li>\n<li>profit.length == group.length</li>\n<li>0 &lt;= profit[i] &lt;= 100</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>这题不会，贴一个题解吧</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) {\n        int mod = 1e9 + 7;\n        int size = group.size();\n        int dp[n + 1][minProfit + 1];\n        memset(dp, 0, sizeof(dp));\n        for (int i = 0; i &lt;= n; ++i) {\n            dp[i][0] = 1;\n        }\n\n        for (int i = 1; i &lt;= size; ++i) {\n            int cur_group = group[i - 1], cur_profit = profit[i - 1];\n            for (int j = n; j &gt;= cur_group; --j) {\n                for (int k = minProfit; k &gt;= 0; --k) {\n                    dp[j][k] += dp[j - cur_group][max(k - cur_profit, 0)];\n                    dp[j][k] %= mod;\n                }\n            }\n        }\n        return dp[n][minProfit];\n    }\n};</code></pre>\n<h2 id=\"【Day45】518-零钱兑换-II\"><a href=\"#【Day45】518-零钱兑换-II\" class=\"headerlink\" title=\"【Day45】518. 零钱兑换 II\"></a>【Day45】518. 零钱兑换 II</h2><h4 id=\"518-零钱兑换-II\"><a href=\"#518-零钱兑换-II\" class=\"headerlink\" title=\"518. 零钱兑换 II\"></a><a href=\"https://leetcode-cn.com/problems/coin-change-2/\" target=\"_blank\" rel=\"noopener\">518. 零钱兑换 II</a></h4><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: amount = 10, coins = [10] \n输出: 1</code></pre><p><strong>注意:</strong></p>\n<ul>\n<li>0 &lt;= amount (总金额) &lt;= 5000</li>\n<li>1 &lt;= coin (硬币面额) &lt;= 5000</li>\n<li>硬币种类不超过 500 种</li>\n<li>结果符合 32 位符号整数</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int change(int amount, vector&lt;int&gt;&amp; coins) {\n        int n = coins.size();\n        vector&lt;int&gt; dp(amount+1);\n        dp[0] = 1;\n        for(int i = 1; i&lt;=n; i++)\n        {\n            int val = coins[i-1];\n            for(int j = val; j &lt;= amount;++j)\n            {\n                dp[j] += dp[j-val];\n            }\n        }\n        return dp[amount];\n    }\n};</code></pre>\n<h2 id=\"【Day46】279-完全平方数\"><a href=\"#【Day46】279-完全平方数\" class=\"headerlink\" title=\"【Day46】279. 完全平方数\"></a>【Day46】279. 完全平方数</h2><h4 id=\"279-完全平方数\"><a href=\"#279-完全平方数\" class=\"headerlink\" title=\"279. 完全平方数\"></a><a href=\"https://leetcode-cn.com/problems/perfect-squares/\" target=\"_blank\" rel=\"noopener\">279. 完全平方数</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>\n<p>给你一个整数 n ，返回和为 n 的完全平方数的 <strong>最少数量</strong> 。</p>\n<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 13\n输出：2\n解释：13 = 4 + 9</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 104</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">//假设最小公式值m = ƒ(n) \n//那么n的值满足下列公式 ∑(A[i] * A[i]) = n \n//令 k 为满足最小值 m 的时候，最大的平方数  。 令  d + k * k; = n ;  d &gt;= 0; \n   // 注意：一定要是满足m最小的时候的k值,一味的取最大平方数,就是贪心算法了\n//得出 f(d) + f(k*k) = f(n);\n//显然 f(k*k) = 1; 则  f(d) + 1 = f(n); 因为 d = n - k*k;\n//则可以推出ƒ(n - k * k) + 1 = ƒ(n) ;  且 k * k &lt;= n;\n\nclass Solution {\npublic:\n    int numSquares(int n) {\n        if (n &lt;= 0) return 0;\n        std::vector&lt;int&gt; nums(n+1);\n        for(int i = 1; i &lt;= n;i++)\n        {\n            int min = i;\n            for(int j = 1;i - j*j &gt;= 0;j++)\n            {\n                int tmp = nums[i-j*j] + 1;\n                min = min &gt; tmp ?  tmp:min; \n            }\n            nums[i] = min;\n        }\n        return nums[n];\n\n    }\n};</code></pre>\n<h2 id=\"【Day47】1449-数位成本和为目标值的最大数字\"><a href=\"#【Day47】1449-数位成本和为目标值的最大数字\" class=\"headerlink\" title=\"【Day47】1449. 数位成本和为目标值的最大数字\"></a>【Day47】1449. 数位成本和为目标值的最大数字</h2><h4 id=\"1449-数位成本和为目标值的最大数字\"><a href=\"#1449-数位成本和为目标值的最大数字\" class=\"headerlink\" title=\"1449. 数位成本和为目标值的最大数字\"></a><a href=\"https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/\" target=\"_blank\" rel=\"noopener\">1449. 数位成本和为目标值的最大数字</a></h4><p>给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>\n<ul>\n<li>给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。</li>\n<li>总成本必须恰好等于 target 。</li>\n<li>添加的数位中没有数字 0 。</li>\n</ul>\n<p>由于答案可能会很大，请你以字符串形式返回。</p>\n<p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：cost = [4,3,2,5,6,7,2,5,5], target = 9\n输出：&quot;7772&quot;\n解释：添加数位 &#39;7&#39; 的成本为 2 ，添加数位 &#39;2&#39; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。\n 数字     成本\n  1  -&gt;   4\n  2  -&gt;   3\n  3  -&gt;   2\n  4  -&gt;   5\n  5  -&gt;   6\n  6  -&gt;   7\n  7  -&gt;   2\n  8  -&gt;   5\n  9  -&gt;   5</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：cost = [7,6,5,5,5,6,8,7,8], target = 12\n输出：&quot;85&quot;\n解释：添加数位 &#39;8&#39; 的成本是 7 ，添加数位 &#39;5&#39; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：cost = [2,4,6,2,4,6,4,4,4], target = 5\n输出：&quot;0&quot;\n解释：总成本是 target 的条件下，无法生成任何整数。</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：cost = [6,10,15,40,40,40,40,40,40], target = 47\n输出：&quot;32211&quot;</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>cost.length == 9</li>\n<li>1 &lt;= cost[i] &lt;= 5000</li>\n<li>1 &lt;= target &lt;= 5000</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    string largestNumber(vector&lt;int&gt;&amp; cost, int target) {\n        int len=cost.size();\n        vector&lt;string&gt; dp(target+1,&quot;#&quot;);\n        dp[0]=&quot;&quot;;\n        //因为i遍历的顺序是从小到大，就保证了整数的高位一定大于等于整数的低位，也就保证了整数最大\n        for(int i=1;i&lt;len+1;++i)\n            for(int j=1;j&lt;target+1;++j){    \n                if(j&gt;=cost[i-1]&amp;&amp;dp[j-cost[i-1]]!=&quot;#&quot;){\n                    dp[j]=CompareString(dp[j],to_string(i)+dp[j-cost[i-1]]);\n                }\n            }\n        return dp[target]==&quot;#&quot;?&quot;0&quot;:dp[target];\n    }\nprivate:\n    string CompareString(const string&amp; s1,const string&amp; s2){\n        int m=s1.size(),n=s2.size();\n        if(m==n)return max(s1,s2);\n        return m&gt;n?s1:s2;\n    }\n};</code></pre>\n<h2 id=\"【Day48】278-第一个错误的版本\"><a href=\"#【Day48】278-第一个错误的版本\" class=\"headerlink\" title=\"【Day48】278. 第一个错误的版本\"></a>【Day48】278. 第一个错误的版本</h2><h4 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278. 第一个错误的版本\"></a><a href=\"https://leetcode-cn.com/problems/first-bad-version/\" target=\"_blank\" rel=\"noopener\">278. 第一个错误的版本</a></h4><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n<p><strong>示例:</strong></p>\n<pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n调用 isBadVersion(3) -&gt; false\n调用 isBadVersion(5) -&gt; true\n调用 isBadVersion(4) -&gt; true\n\n所以，4 是第一个错误的版本。 </code></pre><p><strong>题解：</strong></p>\n<p>二分</p>\n<pre><code class=\"cpp\">bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int lo = 1;\n        int hi = n;\n\n        while(lo &lt; hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (isBadVersion(mid)) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return hi;\n    }\n};</code></pre>\n<h2 id=\"【Day49】374-猜数字大小\"><a href=\"#【Day49】374-猜数字大小\" class=\"headerlink\" title=\"【Day49】374. 猜数字大小\"></a>【Day49】374. 猜数字大小</h2><h4 id=\"374-猜数字大小\"><a href=\"#374-猜数字大小\" class=\"headerlink\" title=\"374. 猜数字大小\"></a><a href=\"https://leetcode-cn.com/problems/guess-number-higher-or-lower/\" target=\"_blank\" rel=\"noopener\">374. 猜数字大小</a></h4><p>猜数字游戏的规则如下：</p>\n<ul>\n<li>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。</li>\n<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>\n</ul>\n<p>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>\n<ul>\n<li>-1：我选出的数字比你猜的数字小 pick &lt; num</li>\n<li>1：我选出的数字比你猜的数字大 pick &gt; num</li>\n<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num</li>\n</ul>\n<p>返回我选出的数字。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：n = 10, pick = 6\n输出：6</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：n = 1, pick = 1\n输出：1</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：n = 2, pick = 1\n输出：1</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：n = 2, pick = 2\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= n &lt;= 231 - 1</li>\n<li>1 &lt;= pick &lt;= n</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return          -1 if num is lower than the guess number\n *                  1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        int l = 0;\n        int r = n;\n        while (l &lt;= r)\n        {\n            int m = (l-r)/2 + r;\n            int res = guess(m);\n            if (res == 0)\n            {\n                return m;\n            }\n            else if (res &lt; 0)\n            {\n                r = m-1;\n            }\n            else\n            {\n                l = m + 1;\n            }\n        }\n\n        return -1;\n    }\n};</code></pre>\n<h2 id=\"【Day50】852-山脉数组的峰顶索引\"><a href=\"#【Day50】852-山脉数组的峰顶索引\" class=\"headerlink\" title=\"【Day50】852. 山脉数组的峰顶索引\"></a>【Day50】852. 山脉数组的峰顶索引</h2><h4 id=\"852-山脉数组的峰顶索引\"><a href=\"#852-山脉数组的峰顶索引\" class=\"headerlink\" title=\"852. 山脉数组的峰顶索引\"></a><a href=\"https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\" target=\"_blank\" rel=\"noopener\">852. 山脉数组的峰顶索引</a></h4><p>符合下列属性的数组 arr 称为 <strong>山脉数组</strong> ：</p>\n<ul>\n<li><p>arr.length &gt;= 3</p>\n</li>\n<li><p>存在 i（0 &lt; i &lt; arr.length - 1）使得：</p>\n<ul>\n<li>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]</li>\n<li>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]</li>\n</ul>\n<p>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p>\n</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [0,1,0]\n输出：1</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [0,2,1,0]\n输出：1</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：arr = [0,10,5,2]\n输出：1</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：arr = [3,4,5,1]\n输出：2</code></pre><p><strong>示例 5：</strong></p>\n<pre><code>输入：arr = [24,69,100,99,79,78,67,36,26,19]\n输出：2</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>3 &lt;= arr.length &lt;= 104</li>\n<li>0 &lt;= arr[i] &lt;= 106</li>\n<li>题目数据保证 arr 是一个山脉数组</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>二分法</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {\n            //根据 arr[mid-1]和arr[mid]对比\n        //所以搜索范围是 [1,arr.length -1]\n        int left = 1;\n        int right = arr.size() - 1;\n\n        while(left &lt; right){\n            //如果check 函数调整的是left，则+1. 否则有可能陷入死循环\n            int mid = left + right + 1 &gt;&gt; 1;\n            if(arr[mid-1] &lt; arr[mid])\n            left = mid;\n            else\n            right = mid -1;\n        }\n        return right;\n    }\n};</code></pre>\n<h2 id=\"【Day51】877-石子游戏\"><a href=\"#【Day51】877-石子游戏\" class=\"headerlink\" title=\"【Day51】877. 石子游戏\"></a>【Day51】877. 石子游戏</h2><h4 id=\"877-石子游戏\"><a href=\"#877-石子游戏\" class=\"headerlink\" title=\"877. 石子游戏\"></a><a href=\"https://leetcode-cn.com/problems/stone-game/\" target=\"_blank\" rel=\"noopener\">877. 石子游戏</a></h4><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子<strong>排成一行</strong>，每堆都有正整数颗石子 piles[i] 。</p>\n<p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p>\n<p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p>\n<p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入：[5,3,4,5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。\n如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>2 &lt;= piles.length &lt;= 500</li>\n<li>piles.length 是偶数。</li>\n<li>1 &lt;= piles[i] &lt;= 500</li>\n<li>sum(piles) 是奇数。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p><strong>博弈论</strong></p>\n<p><a href=\"https://leetcode-cn.com/problems/stone-game/solution/gong-shui-san-xie-jing-dian-qu-jian-dp-j-wn31/\" target=\"_blank\" rel=\"noopener\">三叶的题解</a></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool stoneGame(vector&lt;int&gt;&amp; piles) {\n        return true;\n    }\n};</code></pre>\n<h2 id=\"【Day52】65-有效数字\"><a href=\"#【Day52】65-有效数字\" class=\"headerlink\" title=\"【Day52】65. 有效数字\"></a>【Day52】65. 有效数字</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>\n<ol>\n<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 <strong>整数</strong></li>\n</ol>\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n<ol>\n<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>\n<li>下述格式之一：<ol>\n<li>至少一位数字，后面跟着一个点 ‘.’</li>\n<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>\n<li>一个点 ‘.’ ，后面跟着至少一位数字</li>\n</ol>\n</li>\n</ol>\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n<ul>\n<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>\n<li>至少一位数字</li>\n</ul>\n<p>部分有效数字列举如下：</p>\n<ul>\n<li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li>\n</ul>\n<p>部分无效数字列举如下：</p>\n<ul>\n<li>[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</li>\n</ul>\n<p>给你一个字符串 s ，如果 s 是一个 <strong>有效数字</strong> ，请返回 true 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;0&quot;\n输出：true</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;e&quot;\n输出：false</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;.&quot;\n输出：false</code></pre><p><strong>示例 4：</strong></p>\n<pre><code>输入：s = &quot;.1&quot;\n输出：true</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= s.length &lt;= 20</li>\n<li>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，或者点 ‘.’ 。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool isNumber(string s) {\n        int l = 0, r = s.size() - 1;\n        //去掉前后空格\n        while (l &lt;= r &amp;&amp; s[l] == &#39; &#39;) l ++ ;\n        while (l &lt;= r &amp;&amp; s[r] == &#39; &#39;) r -- ;\n        if (l &gt; r) return false;\n        s = s.substr(l, r - l + 1);\n        //去掉正负号\n        if (s[0] == &#39;+&#39; || s[0] == &#39;-&#39;) s = s.substr(1);\n        //如果只有正负号，false\n        if (s.empty()) return false;\n        //如果只有一个点，或者.e || .E 返回false\n        if (s[0] == &#39;.&#39; &amp;&amp; (s.size() == 1 || s[1] == &#39;e&#39; || s[1] == &#39;E&#39;))\n            return false;\n\n        //记录点和e的次数\n        int dot = 0, e = 0;\n        for (int i = 0; i &lt; s.size(); i ++ ) {\n            if (s[i] == &#39;.&#39;) {\n                //如果出现多个点或者e ，fasle\n                if (dot &gt; 0 || e &gt; 0) return false;\n                dot ++ ;\n            } else if (s[i] == &#39;e&#39; || s[i] == &#39;E&#39;) {\n                //如果e的前面没东西或者后面没东西，或者多个e ，false\n                if (!i || i + 1 == s.size() || e &gt; 0) return false;\n                //如果e的后面是正负号\n                if (s[i + 1] == &#39;+&#39; || s[i + 1] == &#39;-&#39;) {\n                    //但是后面没东西了，返回false\n                    if (i + 2 == s.size()) return false;\n                    i ++ ;\n                }\n                e ++ ;\n                //不合法\n            } else if (s[i] &lt; &#39;0&#39; || s[i] &gt; &#39;9&#39;) return false;\n        }\n        return true;\n    }\n};</code></pre>\n<h2 id=\"【Day53】483-最小好进制\"><a href=\"#【Day53】483-最小好进制\" class=\"headerlink\" title=\"【Day53】483. 最小好进制\"></a>【Day53】483. 最小好进制</h2><h4 id=\"483-最小好进制\"><a href=\"#483-最小好进制\" class=\"headerlink\" title=\"483. 最小好进制\"></a><a href=\"https://leetcode-cn.com/problems/smallest-good-base/\" target=\"_blank\" rel=\"noopener\">483. 最小好进制</a></h4><p>对于给定的整数 n, 如果n的k（k&gt;=2）进制数的所有数位全为1，则称 k（k&gt;=2）是 n 的一个<strong>好进制</strong>。</p>\n<p>以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：&quot;13&quot;\n输出：&quot;3&quot;\n解释：13 的 3 进制是 111。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：&quot;4681&quot;\n输出：&quot;8&quot;\n解释：4681 的 8 进制是 11111。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：&quot;1000000000000000000&quot;\n输出：&quot;999999999999999999&quot;\n解释：1000000000000000000 的 999999999999999999 进制是 11。</code></pre><p><strong>提示：</strong></p>\n<ol>\n<li>n的取值范围是 [3, 10^18]。</li>\n<li>输入总是有效且没有前导 0。</li>\n</ol>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    using LL = long long;\n    string smallestGoodBase(string n) {\n        LL x = stoll(n);\n        for(int m = 2; m &lt;= 60; m++){\n            LL k = (LL)pow(x, 1. / m);\n            if(k &gt; 1){\n                LL cur = 1;\n                for(LL i = 1, base = 1; i &lt;= m; i++){\n                    base *= k;\n                    cur += base;\n                }\n                if(cur == x) return to_string(k);\n            }\n        }\n        return to_string(x - 1);\n    }\n};</code></pre>\n<h2 id=\"【Day54】1239-串联字符串的最大长度\"><a href=\"#【Day54】1239-串联字符串的最大长度\" class=\"headerlink\" title=\"【Day54】1239. 串联字符串的最大长度\"></a>【Day54】1239. 串联字符串的最大长度</h2><h4 id=\"1239-串联字符串的最大长度\"><a href=\"#1239-串联字符串的最大长度\" class=\"headerlink\" title=\"1239. 串联字符串的最大长度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/\" target=\"_blank\" rel=\"noopener\">1239. 串联字符串的最大长度</a></h4><p>给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。</p>\n<p>请返回所有可行解 s 中最长长度。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]\n输出：4\n解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]\n输出：6\n解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]\n输出：26</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= arr.length &lt;= 16</li>\n<li>1 &lt;= arr[i].length &lt;= 26</li>\n<li>arr[i] 中只含有小写英文字母</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxLength(vector&lt;string&gt; &amp;arr) {\n        int ans = 0;\n        vector&lt;int&gt; masks = {0};\n        for (string &amp;s : arr) {\n            int mask = 0;\n            for (char ch : s) {\n                ch -= &#39;a&#39;;\n                if ((mask &gt;&gt; ch) &amp; 1) { // 若 mask 已有 ch，则说明 s 含有重复字母，无法构成可行解\n                    mask = 0;\n                    break;\n                }\n                mask |= 1 &lt;&lt; ch; // 将 ch 加入 mask 中\n            }\n            if (mask == 0) {\n                continue;\n            }\n            int n = masks.size();\n            for (int i = 0; i &lt; n; ++i) {\n                int m = masks[i];\n                if ((m &amp; mask) == 0) { // m 和 mask 无公共元素\n                    masks.push_back(m | mask);\n                    ans = max(ans, __builtin_popcount(m | mask));\n                }\n            }\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day55】1600-皇位继承顺序\"><a href=\"#【Day55】1600-皇位继承顺序\" class=\"headerlink\" title=\"【Day55】1600.皇位继承顺序\"></a>【Day55】1600.皇位继承顺序</h2><h4 id=\"1600-皇位继承顺序\"><a href=\"#1600-皇位继承顺序\" class=\"headerlink\" title=\"1600. 皇位继承顺序\"></a><a href=\"https://leetcode-cn.com/problems/throne-inheritance/\" target=\"_blank\" rel=\"noopener\">1600. 皇位继承顺序</a></h4><p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>\n<p>这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。</p>\n<blockquote>\n<p>Successor(x, curOrder):<br> 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：<br>     如果 x 是国王，那么返回 null<br>     否则，返回 Successor(x 的父亲, curOrder)<br> 否则，返回 x 不在 curOrder 中最年长的孩子</p>\n</blockquote>\n<p>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。</p>\n<ol>\n<li>一开始， curOrder 为 [“king”].</li>\n<li>调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。</li>\n<li>调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。</li>\n<li>调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。</li>\n<li>调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。</li>\n</ol>\n<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>\n<p>请你实现 ThroneInheritance 类：</p>\n<ul>\n<li>ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。</li>\n<li>void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。</li>\n<li>void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>\n<li>string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p><strong>输入：</strong></p>\n<pre><code>[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;]\n[[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]</code></pre><p><strong>输出：</strong></p>\n<pre><code>[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]</code></pre><p><strong>解释：</strong></p>\n<pre><code>ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：king\nt.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andy\nt.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bob\nt.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherine\nt.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine\nt.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine\nt.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]\nt.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]</code></pre><p><strong>提示：</strong></p>\n<ol>\n<li>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</li>\n<li>kingName，parentName， childName 和 name 仅包含小写英文字母。</li>\n<li>所有的参数 childName 和 kingName 互不相同。</li>\n<li>所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。</li>\n<li>每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。</li>\n<li>最多调用 105 次birth 和 death 。</li>\n<li>最多调用 10 次 getInheritanceOrder 。</li>\n</ol>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class ThroneInheritance {\npublic:\n    string root;\n    unordered_map&lt;string, bool&gt; isdeath;\n    unordered_map&lt;string, vector&lt;string&gt;&gt; family;\n    ThroneInheritance(string kingName) {\n        root = kingName;\n    }\n\n    void birth(string parentName, string childName) {\n        family[parentName].push_back(childName);\n    }\n\n    void death(string name) {\n        isdeath[name] = true;\n    }\n\n    void dfs(vector&lt;string&gt;&amp; ans, string root) {\n        if (!isdeath[root])\n            ans.push_back(root);\n        for (string str: family[root])\n            dfs(ans, str);\n    }\n\n    vector&lt;string&gt; getInheritanceOrder() {\n        vector&lt;string&gt; ans;\n        dfs(ans, root);\n        return ans;\n    }\n};\n\n/**\n * Your ThroneInheritance object will be instantiated and called as such:\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\n * obj-&gt;birth(parentName,childName);\n * obj-&gt;death(name);\n * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder();\n */</code></pre>\n<h2 id=\"【Day56】401-二进制手表\"><a href=\"#【Day56】401-二进制手表\" class=\"headerlink\" title=\"【Day56】401.二进制手表\"></a>【Day56】401.二进制手表</h2><h4 id=\"401-二进制手表\"><a href=\"#401-二进制手表\" class=\"headerlink\" title=\"401. 二进制手表\"></a><a href=\"https://leetcode-cn.com/problems/binary-watch/\" target=\"_blank\" rel=\"noopener\">401. 二进制手表</a></h4><p>二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。</p>\n<ul>\n<li>例如，下面的二进制手表读取 “3:25” 。</li>\n</ul>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg\" alt=\"（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）\"></p>\n<p>给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<p>小时不会以零开头：</p>\n<ul>\n<li>例如，”01:00” 是无效的时间，正确的写法应该是 “1:00” 。</li>\n</ul>\n<p>分钟必须由两位数组成，可能会以零开头：</p>\n<p>例如，”10:2” 是无效的时间，正确的写法应该是 “10:02” 。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：turnedOn = 1\n输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：turnedOn = 9\n输出：[]</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>0 &lt;= turnedOn &lt;= 10</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;string&gt; readBinaryWatch(int num) {\n        vector&lt;string&gt; res;\n        //直接遍历  0:00 -&gt; 12:00   每个时间有多少1\n        for (int i = 0; i &lt; 12; i++) {\n            for (int j = 0; j &lt; 60; j++) {\n                if (count1(i) + count1(j) == num) {\n                    res.push_back(to_string(i)+&quot;:&quot;+\n                                  (j &lt; 10 ? &quot;0&quot;+to_string(j) : to_string(j)));\n                }\n            }\n        }\n        return res;\n    }\n    //计算二进制中1的个数\n    int count1(int n) {\n        int res = 0;\n        while (n != 0) {\n            n = n &amp; (n - 1);\n            res++;\n        }\n        return res;\n    }\n};\n\n</code></pre>\n<h2 id=\"【Day57】剑指-Offer-15-二进制中1的个数\"><a href=\"#【Day57】剑指-Offer-15-二进制中1的个数\" class=\"headerlink\" title=\"【Day57】剑指 Offer 15.二进制中1的个数\"></a>【Day57】剑指 Offer 15.二进制中1的个数</h2><h4 id=\"剑指-Offer-15-二进制中1的个数\"><a href=\"#剑指-Offer-15-二进制中1的个数\" class=\"headerlink\" title=\"剑指 Offer 15. 二进制中1的个数\"></a><a href=\"https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\" target=\"_blank\" rel=\"noopener\">剑指 Offer 15. 二进制中1的个数</a></h4><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre><p><strong>示例 2：</strong></p>\n<pre><code>输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre><p><strong>示例 3：</strong></p>\n<pre><code>输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>输入必须是长度为 32 的 二进制串 。</li>\n</ul>\n<blockquote>\n<p>注意：本题与主站 191 题相同：<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>\n</blockquote>\n<p><strong>题解：</strong></p>\n<p>右移再 &amp; 1</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int ans = 0;\n        for (int i = 0; i &lt; 32; i++) {\n            ans += ((n &gt;&gt; i) &amp; 1);\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"【Day58】149-直线上最多的点数\"><a href=\"#【Day58】149-直线上最多的点数\" class=\"headerlink\" title=\"【Day58】149. 直线上最多的点数\"></a>【Day58】149. 直线上最多的点数</h2><h4 id=\"149-直线上最多的点数\"><a href=\"#149-直线上最多的点数\" class=\"headerlink\" title=\"149. 直线上最多的点数\"></a><a href=\"https://leetcode-cn.com/problems/max-points-on-a-line/\" target=\"_blank\" rel=\"noopener\">149. 直线上最多的点数</a></h4><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" alt></p>\n<pre><code>输入：points = [[1,1],[2,2],[3,3]]\n输出：3</code></pre><p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" alt></p>\n<pre><code>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n输出：4</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= points.length &lt;= 300</li>\n<li>points[i].length == 2</li>\n<li>-104 &lt;= xi, yi &lt;= 104</li>\n<li>points 中的所有点 互不相同</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>直接枚举，比较斜率</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        int len = points.size();\n        // 点的数量不够\n        if(len &lt; 3) {\n            return len;\n        }\n        int maxNum = 2;\n        // 遍历每两个点\n        for(int i = 0; i &lt; len - 1; i ++) {\n            for(int j = i + 1; j &lt; len; j ++) {\n                // 统计斜率相等个数\n                int count = 2;\n                long long dx = points[i][0] - points[j][0];\n                long long dy = points[i][1] - points[j][1];\n                // 与其他点比较\n                for(int k = j + 1; k &lt; len; k ++) {\n                    // 如果斜率相等\n                    if(dx * (points[i][1] - points[k][1]) == dy * (points[i][0] - points[k][0])) {\n                        count ++;\n                    }\n                }\n                maxNum = max(maxNum, count);\n                if(maxNum &gt; len / 2) return maxNum;\n            }  \n        }\n        return maxNum;\n    }\n};</code></pre>\n<h2 id=\"【Day59】752-打开转盘锁\"><a href=\"#【Day59】752-打开转盘锁\" class=\"headerlink\" title=\"【Day59】752.打开转盘锁\"></a>【Day59】752.打开转盘锁</h2><h4 id=\"752-打开转盘锁\"><a href=\"#752-打开转盘锁\" class=\"headerlink\" title=\"752. 打开转盘锁\"></a><a href=\"https://leetcode-cn.com/problems/open-the-lock/\" target=\"_blank\" rel=\"noopener\">752. 打开转盘锁</a></h4><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>\n<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n<p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p>\n<p><strong>示例 1:</strong></p>\n<pre><code>输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;\n输出：6\n解释：\n可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。\n注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，\n因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</code></pre><p><strong>示例 2:</strong></p>\n<pre><code>输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;\n输出：1\n解释：\n把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</code></pre><p><strong>示例 3:</strong></p>\n<pre><code>输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;\n输出：-1\n解释：\n无法旋转到目标数字且不被锁定。</code></pre><p><strong>示例 4:</strong></p>\n<pre><code>输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;\n输出：-1</code></pre><p><strong>提示：</strong></p>\n<ul>\n<li>1 &lt;= deadends.length &lt;= 500</li>\n<li>deadends[i].length == 4</li>\n<li>target.length == 4</li>\n<li>target 不在 deadends 之中</li>\n<li>target 和 deadends[i] 仅由若干位数字组成</li>\n</ul>\n<p><strong>题解：</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int seen[10010];//记录搜到过的轮盘锁数字\n    int ans = -1;\n    bool dead[10010];//记录死亡数字\n    int q[10010];//模拟队列\n    int openLock(vector&lt;string&gt;&amp; deadends, string target) { \n        for(auto d : deadends){\n\n            //将死亡数字转int作为下标存储在dead数组中\n            int tmp = stoi(d);\n            dead[tmp] = 1;\n        }\n\n        //如果&quot;0000&quot;是死亡数字直接返回0,如果target为0000直接返回-1\n        if(dead[0])return -1;\n        if(target == &quot;0000&quot;) return 0;\n        int tar=stoi(target);\n        bfs(tar);\n        return ans;\n    }\n\n    int numsadd(int num)\n    {\n        if(num == 10)\n        return -9;\n        if(num == -1)\n        return -9;\n        else return 1;\n    }\n\n    void bfs(int target)\n    {    \n        //hh队头，tt队尾\n        int hh=0,tt=0;\n\n        //先将队头初始化为0,代表从&quot;0000&quot;开始旋转\n        q[0] = 0;\n        while(hh &lt;= tt){\n            auto t = q[hh++];\n            int prev = t;\n\n            for(int i = 1 ; i &lt;= 1000 ; i *= 10){\n                int num = t / i % 10; \n                int temp=t;\n\n                //正向旋转当前位的数字\n                int tmp = temp + numsadd(num+1)*i;\n                if(!seen[tmp] &amp;&amp; !dead[tmp]){\n\n                    //满足条件就将temp插入队尾\n                    q[++tt] = tmp;\n                    //更新新转盘锁数字的操作次数\n                    seen[tmp] = seen[prev]+1;\n                }\n\n                //反向旋转当前位的数字\n                tmp = temp - numsadd(num-1)*i;\n                if(!seen[tmp] &amp;&amp; !dead[tmp]){\n                    q[++tt] = tmp;\n                    seen[tmp] = seen[prev]+1;\n                }           \n            }\n\n            if(seen[target] != 0){\n                ans = seen[target];\n                break;\n            }\n        }\n    }\n};</code></pre>\n<p>整整两个月就刷完啦，发现这些题更适合于找工作，而我目前没有这方面的需要，所以以后偶尔刷一下，有时间就发在博客上hh</p>\n","path":"shu-jia-leetcode-shua-ti-ji-he-xia.html","permalink":"https://www.yshawlon.cn/shu-jia-leetcode-shua-ti-ji-he-xia.html","tags":[{"name":"LeetCode","_id":"clq6dy4bk0061ikw0iij4um88","slug":"LeetCode","path":"tags/LeetCode/","permalink":"https://www.yshawlon.cn/tags/LeetCode/","length":2}],"categories":[{"name":"每日一题","_id":"clq6dy4b4004oikw0s0mv2rlx","slug":"每日一题","path":"categories/每日一题/","permalink":"https://www.yshawlon.cn/categories/每日一题/","length":2}],"prev":{"title":"C++ 中关于Lambda 表达式的总结","date":"2021-10-18T08:57:56.000Z","summary":"Lambda表达式是C++ 11新特性之一，总的来说就是一个函数。","slug":"C-中关于Lambda-表达式的总结","published":true,"updated":"2022-05-23T15:03:31.054Z","_id":"clq6dy4810008ikw0poi31mhm","layout":"post","photos":[],"link":"","excerpt":"","path":"c-zhong-guan-yu-lambda-biao-da-shi-de-zong-jie.html","permalink":"https://www.yshawlon.cn/c-zhong-guan-yu-lambda-biao-da-shi-de-zong-jie.html","__post":true},"next":{"title":"使用Java开发一个记事本","date":"2021-07-17T14:20:07.000Z","summary":"大二下的Java课程设计，仿的Windows记事本，使用Java Swing组件开发。","slug":"使用Java开发一个记事本","published":true,"updated":"2021-10-20T13:17:18.866Z","_id":"clq6dy4a9002nikw0ng08ymvi","layout":"post","photos":[],"link":"","excerpt":"","path":"shi-yong-java-kai-fa-yi-ge-ji-shi-ben.html","permalink":"https://www.yshawlon.cn/shi-yong-java-kai-fa-yi-ge-ji-shi-ben.html","__post":true},"__post":true}