{"title":"《汇编语言》王爽著学习笔记记录(后半部分)","date":"2021-05-08T15:08:22.000Z","toc":true,"summary":"8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 [...] 中来进行内存单元的寻址。","source":"_posts/《汇编语言》王爽著学习笔记记录-后半部分.md","raw":"---\ntitle: 《汇编语言》王爽著学习笔记记录(后半部分)\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-05-08 23:08:22\npassword:\nsummary: 8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 [...] 中来进行内存单元的寻址。\ntags:\n- 学习笔记\ncategories:\n- 汇编\n---\n\n### 第七章：更灵活的定位内存地址的方法\n\n1. and 和 or 指令：\n\n   | 指令 |                功能                 |                 例                 |\n   | :--: | :---------------------------------: | :--------------------------------: |\n   | and  | 将操作对象的相应位设为0，其它位不变 | 将al的第0位设为0：and al,11111110B |\n   |  or  |     逻辑或指令，按位进行或运算      | 将al的第6位设为1：or al,01000000B  |\n\n   使用这两个命令可以帮助我们对内存中的数据按位置 0 或 1.\n\n2. 指明内存单元的另一个方法：**[bx + idata]来访问一个内存单元(一个变量一个常量)，其代表的是一个偏移地址；**这种内存访问方式为高级语言实现数组提供了便利机制。\n\n   **命令 mov ax,[200 + bx] 的含义为： (ax) = ((ds) * 16 + (bx) + 200)**\n\n   通用写法：\n\n   1.  mov ax,[bx + 200] \n   2. mov ax,200[bx] \n   3. mov ax,[bx].200 \n\n3. si 和 di 是8086CPU中两个和 bx 功能相近的寄存器， 但不能分为两个 8 为寄存器来使用。\n\n   1. ```asm\n      mov bx，0\n      mov ax，[bx]\n      mov si，0\n      mov ax，[si]\n      mov di，0\n      mov ax，[di]\n      mov bx,0\n      \n      mov ax,[bx + 123]\n      mov si,0\n      mov ax,[si + 123]\n      mov di,0\n      mov ax,[di + 123]\n      ```\n\n      \n\n   上面的代码说明了si 与 di 同 bx 使用上的相同之处。\n\n4. 我们可以使用 [bx (si 或 di)]（一个变量） 、[bx (si 或 di) + idata] （一个变量和一个常量）来指明一个内存单元，还有 [bx + si] 、[bx + di] （两个变量）\n\n   > mov ax,[bx + si]         ;(ax) = ((ds) * 16 + (bx) + (si))\n   >\n   > 常用形式: mov ax,[bx] [si]\n\n5. 更多的内存访问方式：[bx + si + idata] 、[bx + di + idata]（两个变量，一个常量）\n\n   > mov ax,[bx + si + idata]  ;(ax) = ((ds) * 16 + (bx) + (si) + idata) \n\n   常用形式：\n\n   ```asm\n   mov ax,[bx + 200 + si]\n   mov ax,[200 + bx + si]\n   mov ax,200[bx][si]\n   mov ax,[bx].200[si]\n   mov ax,[bx] [si].200\n   ```\n\n6. 将datasg中的每个单词改为大写字母：\n\n   ```asm\n    ;版本1\n    ;使用 dx 寄存器临时保存 cx 中的值\n   assume cs:codesg,ds:datasg\n    \n   datasg segment\n    \tdb 'ibm             '\n   \tdb 'dec             '\n   \tdb 'dos             '\n   \tdb 'vax             '\n   datasg ends\n   \n   codesg segment\n   start: mov ax,datasg\n          mov ds,ax\n          mov bx,0                  ;此时指向第一行第一个字节的字母\n          \n          mov cx,4\n          \n      s0: mov dx,cx                 ;将 cx 的值暂存到 dx 中\n      \t   mov si,0\n      \t   mov cx,3\n      \t   \n       s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))\n          and al,11011111b          ;将小写字母改为大写字母\n          mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)\n          inc si                    ;si + 1\n          \n          loop s\n          \n          add bx,16                 ;00 → 10 → 20 → 30 ...\n          mov cx,dx                 ;将暂存的 cx 返回\n          loop s0                   ;cx - 1\n   \t   \n   codesg ends\n   end start\n   ```\n\n   ```asm\n    ;版本2\n    ;使用栈空间来暂存数据，前面我们使用的是寄存器，但有些时候寄存器是不足的，不是可取的办法\n   assume cs:codesg,ds:datasg,ss:stacksg\n    \n   datasg segment\n    \tdb 'ibm             '\n   \tdb 'dec             '\n   \tdb 'dos             '\n   \tdb 'vax             '\n   datasg ends\n   \n   stacksg segnebt\n   \t\tdw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节\n   stacksg ends\n   \n   codesg segment\n   start: mov ax,stacksg\n          mov ss,ax\n          mov sp,16\n          mov ax,datasg\n          mov ds,ax\n          mov bx,0                  ;此时指向第一行第一个字节的字母\n          \n          mov cx,4\n          \n      s0: push cx                   ;将外循环 cx 的值压栈\n      \t   mov si,0\n      \t   mov cx,3                  ;内循环 cx 的值\n      \t   \n       s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))\n          and al,11011111b          ;将小写字母改为大写字母\n          mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)\n          inc si                    ;si + 1\n          \n          loop s\n          \n          add bx,16                 ;00 → 10 → 20 → 30 ...\n          pop cx                    ;将暂存的 cx 返回\n          loop s0                   ;cx - 1\n          \n          mov ax,4c00H\n          int 21H\n          \n   codesg ends\n   end start\n   ```\n\n   **在需要暂存数据的时候，一般使用栈来操作**\n\n7. 将 datasg 段中每个单词前4个字母改为大写：\n\n   ```asm\n   assume cs:codesg,ds:datasg,ss:stacksg\n    \n   datasg segment\n    \tdb '1. display      '\n   \tdb '2. brows        '\n   \tdb '3. replace      '\n   \tdb '4. modify       '\n   datasg ends\n   \n   stacksg segnebt\n   \t\tdw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节\n   stacksg ends\n   \n   codesg segment\n   start: mov ax,stacksg\n          mov ss,ax\n          mov sp,16\n          mov ax,datasg\n          mov ds,ax\n          mov bx,0                  ;此时指向第一行第一个字节的字母\n          \n          mov cx,4\n          \n      s0: push cx                   ;将外循环 cx 的值压栈\n      \t   mov si,0\n      \t   mov cx,4                  ;内循环 cx 的值\n      \t   \n       s: mov al,[bx + 3 + si]      ;(al) = ((ds) * 16 + (bx) + (si) + 3)\n          and al,11011111b          ;将小写字母改为大写字母\n          mov [bx + 3 + si],al      ;((ds) * 16 +(bx) + (si) + 3) = (al)\n          inc si                    ;si + 1\n          \n          loop s\n          \n          add bx,16                 ;00 → 10 → 20 → 30 ...\n          pop cx                    ;将暂存的 cx 返回\n          loop s0                   ;cx - 1\n          \n          mov ax,4c00H\n          int 21H\n          \n   codesg ends\n   end start\n   ```\n\n   \n\n### 第八章：数据处理的两个基本问题\n\n1. 描述性符号：\n\n   | 符号 |       功能       |                             集合                             |\n   | :--: | :--------------: | :----------------------------------------------------------: |\n   | reg  |  代表一个寄存器  | ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di |\n   | sreg | 代表一个段寄存器 |                        ds、ss、cs、es                        |\n\n2. 在8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 [...] 中来进行内存单元的寻址。\n\n   在 [...] 中，这四个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di\n\n   ```asm\n   mov ax,[bx]\n   mov ax,[si]\n   mov ax,[di]\n   mov ax,[bp]\n   mov ax,[bx + si]\n   mov ax,[bx + di]\n   mov ax,[bp + si]\n   mov ax,[bp + di]\n   mov ax,[bx + si + idata]\n   mov ax,[bx + di + idata]\n   mov ax,[bp + si + idata]\n   mov ax,[bp + di + idata]\n   ```\n\n3. 使用寄存器 bp 进行寻址，如果没有显性的给出段地址，那么段地址默认在 ss 段寄存器中\n\n   ```asm\n   mov ax,[bp] ;(ax) = ((ss) * 16 + (bp))\n   mov ax,[bp + si + idata] ;(ax) = ((ss) * 16 + (bp) + (si) + idata)\n   ```\n\n4. 处理指令大致分为3类：读取、写入、运算；指令执行前，数据一般在3个地方：CPU内部、内存、端口\n\n5. 数据的位置：\n\n   1. 立即数（idata）：在汇编指令中字节给出\n\n      ```asm\n      mov ax,1\n      add bx,2000H\n      ```\n\n   2. 寄存器：要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名就可以。\n\n   3. 段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，使用段地址+偏移地址定位内存单元。\n\n6. **寻址方式总结：**\n\n   |     寻址方式      |                含义                |       名称       |            常用格式             |\n   | :---------------: | :--------------------------------: | :--------------: | :-----------------------------: |\n   |      [idata]      |        EA = idata;SA = (ds)        |     直接寻址     |             [idata]             |\n   |       [bx]        |        EA = (bx);SA = (ds)         |  寄存器间接寻址  |              [bx]               |\n   |       [si]        |        EA = (si) ;SA = (ds)        |                  |                                 |\n   |       [di]        |        EA = (di);SA = (ds)         |                  |                                 |\n   |       [bp]        |        EA = (bp);SA = (ds)         |                  |                                 |\n   |   [bx + idata]    |    EA = (bx) + idata;SA = (ds)     |  寄存器相对寻址  |      用于结构体:[bx].idata      |\n   |   [si + idata]    |    EA = (si) + idata;SA = (ds)     |                  |  用于数组:idata[si],idata[di]   |\n   |   [di + idata]    |    EA = (di) + idata;SA = (ds)     |                  |    用于二维数组:[bx] [idata]    |\n   |   [bp + idata]    |    EA = (bp) + idata;SA = (ss)     |                  |                                 |\n   |     [bx + si]     |     EA = (bx) + (si);SA = (ds)     |   基址变址寻址   |     用于二维数组:[bx] [si]      |\n   |     [bx + di]     |     EA = (bx) + (di);SA = (ds)     |                  |                                 |\n   |     [bp + si]     |     EA = (bp) + (si);SA = (ss)     |                  |                                 |\n   |     [bp + di]     |     EA = (bp) + (di);SA = (ss)     |                  |                                 |\n   | [bx + si + idata] | EA = (bx) + (si) + idata;SA = (ds) | 相对基址变址寻址 | 用于表格中的数组:[bx].idata[si] |\n   | [bx + di + idata] | EA = (bx) + (di) + idata;SA = (ds) |                  |                                 |\n   | [bp + si + idata] | EA = (bp) + (si) + idata;SA = (ss) |                  |   用于二维数组:idata[bx] [si]   |\n   | [bp + di + idata] | EA = (bp) + (di) + idata;SA = (ss) |                  |                                 |\n\n7. 8086CPU 可以处理 byte 和 word 两种尺寸的数据。\n\n   1. 通过寄存器名指明要处理的数据的尺寸：\n\n      ```asm\n      ;字操作\n      mov ax,1\n      add ax,1000\n      inc ax\n      ```\n\n      ```asm\n      ;字节操作\n      mov al\n      add al000\n      inc al\n      ```\n\n      \n\n   2. 没有寄存器名存在得情况下，用操作符 X ptr 指明内存单元的长度，X 可以为 byte 或 word：\n\n      ```asm\n      ;word ptr 表示访问一个字单元\n      mov word ptr ds:[0],1\n      inc word ptr [bx]\n      inc word ptr ds:[0]\n      add word ptr [bx],2\n      ```\n\n      ```asm\n      ;byte ptr 表示访问一个字节单元\n      mov byte ptr ds:[0],1\n      inc byte ptr [bx]\n      inc byte ptr ds:[0]\n      add byte ptr [bx],2\n      ```\n\n      \n\n   **在机器指令中指明要访问的是字单元还是字节单元是非常重要的，8086CPU中，一个byte为8bit，而一个字为2byte，如果不指明，那么在访问的时候是有区别的。**\n\n8. 使用 push 和 pop 指令就代表了是进行字操作，无需指明\n\n9. div 除法指令：\n\n   (1)除数：8位和16位两种，在一个reg或内存单元中\n\n   (2)被除数：默认在AX或AX和DX中，除数位8位，被除数位16位，默认在AX中存放；除数位16位，则被除数位32位，DX存放高16位，AX存放低16位。\n\n   (3)结果：如果除数位8位，则AL存储除法操作的商，AH存放余数；如果除数位16位，AX存储除法操作的商，DX存放余数\n\n   ```asm\n   ;格式\n   div reg\n   div 内存单元\n   ```\n\n   ```asm\n   ;示例\n   div byte ptr ds:[0]      ;(al) = (ax) / ((ds) * 16 + 0 )的商\n   \t\t\t\t\t   ;(ah) = (ax) / ((ds) * 16 + 0)的余数\n   \t\t\t\t\t  \n   div word ptr es:[0]      ;(ax) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的商\n   \t\t\t\t\t   ;(dx) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的余数\n   \n   div byte ptr [bx + si + 8]     ;(al) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的商\n   \t\t\t\t\t         ;(ah) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的余数\n   \n   div word ptr [bx + si + 8]     ;(ax) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的商\n   \t\t\t\t\t         ;(dx) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的余数js\n   ```\n\n10. 计算：100001 / 100\n\n    ```asm\n    ;100001 > 65535,所以除数得是32位，转为16进制为 186A1H，所以高16位在DX中，低16位在AX中\n    mov dx,1\n    mov ax,86A1H\n    mov bx,100\n    div bx\n    ```\n\n    \n\n    \n\n11. 伪指令 dd 、dup\n\n    | 指令 |                   功能                    |                 示例                 |\n    | :--: | :---------------------------------------: | :----------------------------------: |\n    |  db  |              定义字节型数据               |                 db 1                 |\n    |  dw  |               定义字型数据                |                dw 100                |\n    |  dd  |            定义dword双字型数据            |              dd 100001               |\n    | dup  | 与上面3个指令配合使用，用来进行数据的重复 | db(dw、dd) 重复次数 dup (重复的数据) |\n\n    \n\n12. 汇编语言实验七：\n\n    ```asm\n    ;题目太长，只贴代码，先思考写代码，而后体会别人的代码\n    assume cs:code\n    \n    data segment\n     db '1975','1976','1977','1978','1979','1980','1981','1982','1983','1984','1985'\n     db '1986','1987','1988','1989','1990','1991','1992','1993','1994','1995'\n     \n     dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514,345980\n     dd 590827,803530,1183000,1843000,2758000,3753000,4649000,5937000\n     \n     dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\n     dw 11542,14430,15257,17800\n    data ends\n    \n    stack segment\n     dw 0,0,0,0,0,0,0\n    stack ends\n    \n    table segment\n     db 21 dup ('year summ ne ?? ')\n    table ends\n    \n    code segment\n    \n    start:\n    \tmov ax,data\n    \tmov es,ax\n    \tmov si,0\n    \n    \tmov ax,table\n    \tmov ds,ax\n    \tmov di,0\n    \t\n    \tmov ax,stack\n    \tmov ss,ax\n    \tmov sp,16\n    \t\n    \tmov bx,0\n    \tmov cx,21\n    s0:\n    \tmov ax,es:[si]\t\n    \tmov ds:[di+bx],ax\n    \tadd si,2\n    \tadd di,2\n    \tmov ax,es:[si]\n    \tmov ds:[di+bx],ax\n    \t\n    \tmov ax,es:[si+82]\n    \tmov ds:[bx+di+3],ax\n    \tmov ax,es:[si+84]\n    \tmov ds:[bx+di+5],ax\n    \t\n    \tadd si,2\n    \tmov di,0\n    \tadd bx,16\n    \tloop s0\n    \t\n    \tmov bx,0\n    \tmov si,168\n    \tmov di,5\n    \tmov cx,21\n    s1:\t\n    \tmov ax,es:[si]\n    \tmov ds:[bx+di+5],ax\n    \t\n    \tmov ax,ds:[bx+di]\n    \tmov dx,ds:[bx+di+2]\n    \tdiv word ptr ds:[bx+di+5]\n    \tmov ds:[bx+di+8],ax\n    \t\n    \tadd si,2\n    \tadd bx,16\n    \tloop s1\n    \t\n    \tmov ax,4c00h\n    \tint 21h\n    \t\n    code ends\n    end start\n    ```\n    \n    \n\n### 第九章：转移指令的原理\n\n1. **可以修改 IP ，或者同时修改 CS 和 IP 得指令统称为转移指令。**\n\n   1. 段内转移：jmp ax\n      1. 短转移IP修改范围：-128~127\n      2. 近转移IP修改范围：-32768~32767\n   2. 段间转移：jmp 1000:0\n\n2. 转移指令分为无条件转移指令（jmp）和条件转移指令、循环指令、过程、中断等等\n\n3. 操作符 offset ，能够取得标号的偏移地址：\n\n   ```asm\n   start: mov ax,offset start  ;取得start的偏移地址，相当于 mov ax，0\n   ```\n\n4. \n\n\n\n\n\n\n\n### 第十章：CALL和RET指令\n\n1. \n\n### 第十一章：标志寄存器\n\n1. \n\n### 第十二章：内中断\n\n1. \n\n### 第十三章：int 指令\n\n1. \n\n### 第十四章：端口\n\n1. \n\n### 第十五章：外中断\n\n1. \n\n### 第十六章：直接定址表\n\n1. \n\n### 第十七章：使用BIOS进行键盘输入\n\n1. ","slug":"《汇编语言》王爽著学习笔记记录-后半部分","published":true,"updated":"2021-10-20T13:16:23.895Z","_id":"clq6dy49t001uikw07vacfjmw","comments":true,"layout":"post","photos":[],"link":"","html":"<h3 id=\"第七章：更灵活的定位内存地址的方法\"><a href=\"#第七章：更灵活的定位内存地址的方法\" class=\"headerlink\" title=\"第七章：更灵活的定位内存地址的方法\"></a>第七章：更灵活的定位内存地址的方法</h3><ol>\n<li><p>and 和 or 指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">and</td>\n<td align=\"center\">将操作对象的相应位设为0，其它位不变</td>\n<td align=\"center\">将al的第0位设为0：and al,11111110B</td>\n</tr>\n<tr>\n<td align=\"center\">or</td>\n<td align=\"center\">逻辑或指令，按位进行或运算</td>\n<td align=\"center\">将al的第6位设为1：or al,01000000B</td>\n</tr>\n</tbody></table>\n<p>使用这两个命令可以帮助我们对内存中的数据按位置 0 或 1.</p>\n</li>\n<li><p>指明内存单元的另一个方法：<strong>[bx + idata]来访问一个内存单元(一个变量一个常量)，其代表的是一个偏移地址；</strong>这种内存访问方式为高级语言实现数组提供了便利机制。</p>\n<p><strong>命令 mov ax,[200 + bx] 的含义为： (ax) = ((ds) * 16 + (bx) + 200)</strong></p>\n<p>通用写法：</p>\n<ol>\n<li>mov ax,[bx + 200] </li>\n<li>mov ax,200[bx] </li>\n<li>mov ax,[bx].200 </li>\n</ol>\n</li>\n<li><p>si 和 di 是8086CPU中两个和 bx 功能相近的寄存器， 但不能分为两个 8 为寄存器来使用。</p>\n<ol>\n<li><pre class=\"line-numbers language-asm\"><code class=\"language-asm\">mov bx，0\nmov ax，[bx]\nmov si，0\nmov ax，[si]\nmov di，0\nmov ax，[di]\nmov bx,0\n\nmov ax,[bx + 123]\nmov si,0\nmov ax,[si + 123]\nmov di,0\nmov ax,[di + 123]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>   上面的代码说明了si 与 di 同 bx 使用上的相同之处。</p>\n<ol start=\"4\">\n<li><p>我们可以使用 [bx (si 或 di)]（一个变量） 、[bx (si 或 di) + idata] （一个变量和一个常量）来指明一个内存单元，还有 [bx + si] 、[bx + di] （两个变量）</p>\n<blockquote>\n<p>mov ax,[bx + si]         ;(ax) = ((ds) * 16 + (bx) + (si))</p>\n<p>常用形式: mov ax,[bx] [si]</p>\n</blockquote>\n</li>\n<li><p>更多的内存访问方式：[bx + si + idata] 、[bx + di + idata]（两个变量，一个常量）</p>\n<blockquote>\n<p>mov ax,[bx + si + idata]  ;(ax) = ((ds) * 16 + (bx) + (si) + idata) </p>\n</blockquote>\n<p>常用形式：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">mov ax,[bx + 200 + si]\nmov ax,[200 + bx + si]\nmov ax,200[bx][si]\nmov ax,[bx].200[si]\nmov ax,[bx] [si].200<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将datasg中的每个单词改为大写字母：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\"> ;版本1\n ;使用 dx 寄存器临时保存 cx 中的值\nassume cs:codesg,ds:datasg\n\ndatasg segment\n     db 'ibm             '\n    db 'dec             '\n    db 'dos             '\n    db 'vax             '\ndatasg ends\n\ncodesg segment\nstart: mov ax,datasg\n       mov ds,ax\n       mov bx,0                  ;此时指向第一行第一个字节的字母\n\n       mov cx,4\n\n   s0: mov dx,cx                 ;将 cx 的值暂存到 dx 中\n          mov si,0\n          mov cx,3\n\n    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))\n       and al,11011111b          ;将小写字母改为大写字母\n       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)\n       inc si                    ;si + 1\n\n       loop s\n\n       add bx,16                 ;00 → 10 → 20 → 30 ...\n       mov cx,dx                 ;将暂存的 cx 返回\n       loop s0                   ;cx - 1\n\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\"> ;版本2\n ;使用栈空间来暂存数据，前面我们使用的是寄存器，但有些时候寄存器是不足的，不是可取的办法\nassume cs:codesg,ds:datasg,ss:stacksg\n\ndatasg segment\n     db 'ibm             '\n    db 'dec             '\n    db 'dos             '\n    db 'vax             '\ndatasg ends\n\nstacksg segnebt\n        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节\nstacksg ends\n\ncodesg segment\nstart: mov ax,stacksg\n       mov ss,ax\n       mov sp,16\n       mov ax,datasg\n       mov ds,ax\n       mov bx,0                  ;此时指向第一行第一个字节的字母\n\n       mov cx,4\n\n   s0: push cx                   ;将外循环 cx 的值压栈\n          mov si,0\n          mov cx,3                  ;内循环 cx 的值\n\n    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))\n       and al,11011111b          ;将小写字母改为大写字母\n       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)\n       inc si                    ;si + 1\n\n       loop s\n\n       add bx,16                 ;00 → 10 → 20 → 30 ...\n       pop cx                    ;将暂存的 cx 返回\n       loop s0                   ;cx - 1\n\n       mov ax,4c00H\n       int 21H\n\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>在需要暂存数据的时候，一般使用栈来操作</strong></p>\n</li>\n<li><p>将 datasg 段中每个单词前4个字母改为大写：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">assume cs:codesg,ds:datasg,ss:stacksg\n\ndatasg segment\n     db '1. display      '\n    db '2. brows        '\n    db '3. replace      '\n    db '4. modify       '\ndatasg ends\n\nstacksg segnebt\n        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节\nstacksg ends\n\ncodesg segment\nstart: mov ax,stacksg\n       mov ss,ax\n       mov sp,16\n       mov ax,datasg\n       mov ds,ax\n       mov bx,0                  ;此时指向第一行第一个字节的字母\n\n       mov cx,4\n\n   s0: push cx                   ;将外循环 cx 的值压栈\n          mov si,0\n          mov cx,4                  ;内循环 cx 的值\n\n    s: mov al,[bx + 3 + si]      ;(al) = ((ds) * 16 + (bx) + (si) + 3)\n       and al,11011111b          ;将小写字母改为大写字母\n       mov [bx + 3 + si],al      ;((ds) * 16 +(bx) + (si) + 3) = (al)\n       inc si                    ;si + 1\n\n       loop s\n\n       add bx,16                 ;00 → 10 → 20 → 30 ...\n       pop cx                    ;将暂存的 cx 返回\n       loop s0                   ;cx - 1\n\n       mov ax,4c00H\n       int 21H\n\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h3 id=\"第八章：数据处理的两个基本问题\"><a href=\"#第八章：数据处理的两个基本问题\" class=\"headerlink\" title=\"第八章：数据处理的两个基本问题\"></a>第八章：数据处理的两个基本问题</h3><ol>\n<li><p>描述性符号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">集合</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">reg</td>\n<td align=\"center\">代表一个寄存器</td>\n<td align=\"center\">ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</td>\n</tr>\n<tr>\n<td align=\"center\">sreg</td>\n<td align=\"center\">代表一个段寄存器</td>\n<td align=\"center\">ds、ss、cs、es</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>在8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 […] 中来进行内存单元的寻址。</p>\n<p>在 […] 中，这四个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">mov ax,[bx]\nmov ax,[si]\nmov ax,[di]\nmov ax,[bp]\nmov ax,[bx + si]\nmov ax,[bx + di]\nmov ax,[bp + si]\nmov ax,[bp + di]\nmov ax,[bx + si + idata]\nmov ax,[bx + di + idata]\nmov ax,[bp + si + idata]\nmov ax,[bp + di + idata]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用寄存器 bp 进行寻址，如果没有显性的给出段地址，那么段地址默认在 ss 段寄存器中</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">mov ax,[bp] ;(ax) = ((ss) * 16 + (bp))\nmov ax,[bp + si + idata] ;(ax) = ((ss) * 16 + (bp) + (si) + idata)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>处理指令大致分为3类：读取、写入、运算；指令执行前，数据一般在3个地方：CPU内部、内存、端口</p>\n</li>\n<li><p>数据的位置：</p>\n<ol>\n<li><p>立即数（idata）：在汇编指令中字节给出</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">mov ax,1\nadd bx,2000H<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>寄存器：要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名就可以。</p>\n</li>\n<li><p>段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，使用段地址+偏移地址定位内存单元。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>寻址方式总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">寻址方式</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">常用格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">[idata]</td>\n<td align=\"center\">EA = idata;SA = (ds)</td>\n<td align=\"center\">直接寻址</td>\n<td align=\"center\">[idata]</td>\n</tr>\n<tr>\n<td align=\"center\">[bx]</td>\n<td align=\"center\">EA = (bx);SA = (ds)</td>\n<td align=\"center\">寄存器间接寻址</td>\n<td align=\"center\">[bx]</td>\n</tr>\n<tr>\n<td align=\"center\">[si]</td>\n<td align=\"center\">EA = (si) ;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[di]</td>\n<td align=\"center\">EA = (di);SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp]</td>\n<td align=\"center\">EA = (bp);SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bx + idata]</td>\n<td align=\"center\">EA = (bx) + idata;SA = (ds)</td>\n<td align=\"center\">寄存器相对寻址</td>\n<td align=\"center\">用于结构体:[bx].idata</td>\n</tr>\n<tr>\n<td align=\"center\">[si + idata]</td>\n<td align=\"center\">EA = (si) + idata;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\">用于数组:idata[si],idata[di]</td>\n</tr>\n<tr>\n<td align=\"center\">[di + idata]</td>\n<td align=\"center\">EA = (di) + idata;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\">用于二维数组:[bx] [idata]</td>\n</tr>\n<tr>\n<td align=\"center\">[bp + idata]</td>\n<td align=\"center\">EA = (bp) + idata;SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bx + si]</td>\n<td align=\"center\">EA = (bx) + (si);SA = (ds)</td>\n<td align=\"center\">基址变址寻址</td>\n<td align=\"center\">用于二维数组:[bx] [si]</td>\n</tr>\n<tr>\n<td align=\"center\">[bx + di]</td>\n<td align=\"center\">EA = (bx) + (di);SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp + si]</td>\n<td align=\"center\">EA = (bp) + (si);SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp + di]</td>\n<td align=\"center\">EA = (bp) + (di);SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bx + si + idata]</td>\n<td align=\"center\">EA = (bx) + (si) + idata;SA = (ds)</td>\n<td align=\"center\">相对基址变址寻址</td>\n<td align=\"center\">用于表格中的数组:[bx].idata[si]</td>\n</tr>\n<tr>\n<td align=\"center\">[bx + di + idata]</td>\n<td align=\"center\">EA = (bx) + (di) + idata;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp + si + idata]</td>\n<td align=\"center\">EA = (bp) + (si) + idata;SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\">用于二维数组:idata[bx] [si]</td>\n</tr>\n<tr>\n<td align=\"center\">[bp + di + idata]</td>\n<td align=\"center\">EA = (bp) + (di) + idata;SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>8086CPU 可以处理 byte 和 word 两种尺寸的数据。</p>\n<ol>\n<li><p>通过寄存器名指明要处理的数据的尺寸：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;字操作\nmov ax,1\nadd ax,1000\ninc ax<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;字节操作\nmov al\nadd al000\ninc al<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>没有寄存器名存在得情况下，用操作符 X ptr 指明内存单元的长度，X 可以为 byte 或 word：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;word ptr 表示访问一个字单元\nmov word ptr ds:[0],1\ninc word ptr [bx]\ninc word ptr ds:[0]\nadd word ptr [bx],2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;byte ptr 表示访问一个字节单元\nmov byte ptr ds:[0],1\ninc byte ptr [bx]\ninc byte ptr ds:[0]\nadd byte ptr [bx],2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<p>   <strong>在机器指令中指明要访问的是字单元还是字节单元是非常重要的，8086CPU中，一个byte为8bit，而一个字为2byte，如果不指明，那么在访问的时候是有区别的。</strong></p>\n<ol start=\"8\">\n<li><p>使用 push 和 pop 指令就代表了是进行字操作，无需指明</p>\n</li>\n<li><p>div 除法指令：</p>\n<p>(1)除数：8位和16位两种，在一个reg或内存单元中</p>\n<p>(2)被除数：默认在AX或AX和DX中，除数位8位，被除数位16位，默认在AX中存放；除数位16位，则被除数位32位，DX存放高16位，AX存放低16位。</p>\n<p>(3)结果：如果除数位8位，则AL存储除法操作的商，AH存放余数；如果除数位16位，AX存储除法操作的商，DX存放余数</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;格式\ndiv reg\ndiv 内存单元<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;示例\ndiv byte ptr ds:[0]      ;(al) = (ax) / ((ds) * 16 + 0 )的商\n                       ;(ah) = (ax) / ((ds) * 16 + 0)的余数\n\ndiv word ptr es:[0]      ;(ax) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的商\n                       ;(dx) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的余数\n\ndiv byte ptr [bx + si + 8]     ;(al) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的商\n                             ;(ah) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的余数\n\ndiv word ptr [bx + si + 8]     ;(ax) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的商\n                             ;(dx) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的余数js<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>计算：100001 / 100</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;100001 > 65535,所以除数得是32位，转为16进制为 186A1H，所以高16位在DX中，低16位在AX中\nmov dx,1\nmov ax,86A1H\nmov bx,100\ndiv bx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol start=\"11\">\n<li><p>伪指令 dd 、dup</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">db</td>\n<td align=\"center\">定义字节型数据</td>\n<td align=\"center\">db 1</td>\n</tr>\n<tr>\n<td align=\"center\">dw</td>\n<td align=\"center\">定义字型数据</td>\n<td align=\"center\">dw 100</td>\n</tr>\n<tr>\n<td align=\"center\">dd</td>\n<td align=\"center\">定义dword双字型数据</td>\n<td align=\"center\">dd 100001</td>\n</tr>\n<tr>\n<td align=\"center\">dup</td>\n<td align=\"center\">与上面3个指令配合使用，用来进行数据的重复</td>\n<td align=\"center\">db(dw、dd) 重复次数 dup (重复的数据)</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>汇编语言实验七：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">;题目太长，只贴代码，先思考写代码，而后体会别人的代码\nassume cs:code\n\ndata segment\n db '1975','1976','1977','1978','1979','1980','1981','1982','1983','1984','1985'\n db '1986','1987','1988','1989','1990','1991','1992','1993','1994','1995'\n\n dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514,345980\n dd 590827,803530,1183000,1843000,2758000,3753000,4649000,5937000\n\n dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\n dw 11542,14430,15257,17800\ndata ends\n\nstack segment\n dw 0,0,0,0,0,0,0\nstack ends\n\ntable segment\n db 21 dup ('year summ ne ?? ')\ntable ends\n\ncode segment\n\nstart:\n    mov ax,data\n    mov es,ax\n    mov si,0\n\n    mov ax,table\n    mov ds,ax\n    mov di,0\n\n    mov ax,stack\n    mov ss,ax\n    mov sp,16\n\n    mov bx,0\n    mov cx,21\ns0:\n    mov ax,es:[si]    \n    mov ds:[di+bx],ax\n    add si,2\n    add di,2\n    mov ax,es:[si]\n    mov ds:[di+bx],ax\n\n    mov ax,es:[si+82]\n    mov ds:[bx+di+3],ax\n    mov ax,es:[si+84]\n    mov ds:[bx+di+5],ax\n\n    add si,2\n    mov di,0\n    add bx,16\n    loop s0\n\n    mov bx,0\n    mov si,168\n    mov di,5\n    mov cx,21\ns1:    \n    mov ax,es:[si]\n    mov ds:[bx+di+5],ax\n\n    mov ax,ds:[bx+di]\n    mov dx,ds:[bx+di+2]\n    div word ptr ds:[bx+di+5]\n    mov ds:[bx+di+8],ax\n\n    add si,2\n    add bx,16\n    loop s1\n\n    mov ax,4c00h\n    int 21h\n\ncode ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h3 id=\"第九章：转移指令的原理\"><a href=\"#第九章：转移指令的原理\" class=\"headerlink\" title=\"第九章：转移指令的原理\"></a>第九章：转移指令的原理</h3><ol>\n<li><p><strong>可以修改 IP ，或者同时修改 CS 和 IP 得指令统称为转移指令。</strong></p>\n<ol>\n<li>段内转移：jmp ax<ol>\n<li>短转移IP修改范围：-128~127</li>\n<li>近转移IP修改范围：-32768~32767</li>\n</ol>\n</li>\n<li>段间转移：jmp 1000:0</li>\n</ol>\n</li>\n<li><p>转移指令分为无条件转移指令（jmp）和条件转移指令、循环指令、过程、中断等等</p>\n</li>\n<li><p>操作符 offset ，能够取得标号的偏移地址：</p>\n<pre class=\"line-numbers language-asm\"><code class=\"language-asm\">start: mov ax,offset start  ;取得start的偏移地址，相当于 mov ax，0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li></li>\n</ol>\n<h3 id=\"第十章：CALL和RET指令\"><a href=\"#第十章：CALL和RET指令\" class=\"headerlink\" title=\"第十章：CALL和RET指令\"></a>第十章：CALL和RET指令</h3><ol>\n<li><h3 id=\"第十一章：标志寄存器\"><a href=\"#第十一章：标志寄存器\" class=\"headerlink\" title=\"第十一章：标志寄存器\"></a>第十一章：标志寄存器</h3></li>\n<li></li>\n</ol>\n<h3 id=\"第十二章：内中断\"><a href=\"#第十二章：内中断\" class=\"headerlink\" title=\"第十二章：内中断\"></a>第十二章：内中断</h3><ol>\n<li><h3 id=\"第十三章：int-指令\"><a href=\"#第十三章：int-指令\" class=\"headerlink\" title=\"第十三章：int 指令\"></a>第十三章：int 指令</h3></li>\n<li></li>\n</ol>\n<h3 id=\"第十四章：端口\"><a href=\"#第十四章：端口\" class=\"headerlink\" title=\"第十四章：端口\"></a>第十四章：端口</h3><ol>\n<li><h3 id=\"第十五章：外中断\"><a href=\"#第十五章：外中断\" class=\"headerlink\" title=\"第十五章：外中断\"></a>第十五章：外中断</h3></li>\n<li></li>\n</ol>\n<h3 id=\"第十六章：直接定址表\"><a href=\"#第十六章：直接定址表\" class=\"headerlink\" title=\"第十六章：直接定址表\"></a>第十六章：直接定址表</h3><ol>\n<li><h3 id=\"第十七章：使用BIOS进行键盘输入\"><a href=\"#第十七章：使用BIOS进行键盘输入\" class=\"headerlink\" title=\"第十七章：使用BIOS进行键盘输入\"></a>第十七章：使用BIOS进行键盘输入</h3></li>\n<li></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"第七章：更灵活的定位内存地址的方法\"><a href=\"#第七章：更灵活的定位内存地址的方法\" class=\"headerlink\" title=\"第七章：更灵活的定位内存地址的方法\"></a>第七章：更灵活的定位内存地址的方法</h3><ol>\n<li><p>and 和 or 指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">and</td>\n<td align=\"center\">将操作对象的相应位设为0，其它位不变</td>\n<td align=\"center\">将al的第0位设为0：and al,11111110B</td>\n</tr>\n<tr>\n<td align=\"center\">or</td>\n<td align=\"center\">逻辑或指令，按位进行或运算</td>\n<td align=\"center\">将al的第6位设为1：or al,01000000B</td>\n</tr>\n</tbody></table>\n<p>使用这两个命令可以帮助我们对内存中的数据按位置 0 或 1.</p>\n</li>\n<li><p>指明内存单元的另一个方法：<strong>[bx + idata]来访问一个内存单元(一个变量一个常量)，其代表的是一个偏移地址；</strong>这种内存访问方式为高级语言实现数组提供了便利机制。</p>\n<p><strong>命令 mov ax,[200 + bx] 的含义为： (ax) = ((ds) * 16 + (bx) + 200)</strong></p>\n<p>通用写法：</p>\n<ol>\n<li>mov ax,[bx + 200] </li>\n<li>mov ax,200[bx] </li>\n<li>mov ax,[bx].200 </li>\n</ol>\n</li>\n<li><p>si 和 di 是8086CPU中两个和 bx 功能相近的寄存器， 但不能分为两个 8 为寄存器来使用。</p>\n<ol>\n<li><pre><code class=\"asm\">mov bx，0\nmov ax，[bx]\nmov si，0\nmov ax，[si]\nmov di，0\nmov ax，[di]\nmov bx,0\n\nmov ax,[bx + 123]\nmov si,0\nmov ax,[si + 123]\nmov di,0\nmov ax,[di + 123]</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>   上面的代码说明了si 与 di 同 bx 使用上的相同之处。</p>\n<ol start=\"4\">\n<li><p>我们可以使用 [bx (si 或 di)]（一个变量） 、[bx (si 或 di) + idata] （一个变量和一个常量）来指明一个内存单元，还有 [bx + si] 、[bx + di] （两个变量）</p>\n<blockquote>\n<p>mov ax,[bx + si]         ;(ax) = ((ds) * 16 + (bx) + (si))</p>\n<p>常用形式: mov ax,[bx] [si]</p>\n</blockquote>\n</li>\n<li><p>更多的内存访问方式：[bx + si + idata] 、[bx + di + idata]（两个变量，一个常量）</p>\n<blockquote>\n<p>mov ax,[bx + si + idata]  ;(ax) = ((ds) * 16 + (bx) + (si) + idata) </p>\n</blockquote>\n<p>常用形式：</p>\n<pre><code class=\"asm\">mov ax,[bx + 200 + si]\nmov ax,[200 + bx + si]\nmov ax,200[bx][si]\nmov ax,[bx].200[si]\nmov ax,[bx] [si].200</code></pre>\n</li>\n<li><p>将datasg中的每个单词改为大写字母：</p>\n<pre><code class=\"asm\"> ;版本1\n ;使用 dx 寄存器临时保存 cx 中的值\nassume cs:codesg,ds:datasg\n\ndatasg segment\n     db &#39;ibm             &#39;\n    db &#39;dec             &#39;\n    db &#39;dos             &#39;\n    db &#39;vax             &#39;\ndatasg ends\n\ncodesg segment\nstart: mov ax,datasg\n       mov ds,ax\n       mov bx,0                  ;此时指向第一行第一个字节的字母\n\n       mov cx,4\n\n   s0: mov dx,cx                 ;将 cx 的值暂存到 dx 中\n          mov si,0\n          mov cx,3\n\n    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))\n       and al,11011111b          ;将小写字母改为大写字母\n       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)\n       inc si                    ;si + 1\n\n       loop s\n\n       add bx,16                 ;00 → 10 → 20 → 30 ...\n       mov cx,dx                 ;将暂存的 cx 返回\n       loop s0                   ;cx - 1\n\ncodesg ends\nend start</code></pre>\n<pre><code class=\"asm\"> ;版本2\n ;使用栈空间来暂存数据，前面我们使用的是寄存器，但有些时候寄存器是不足的，不是可取的办法\nassume cs:codesg,ds:datasg,ss:stacksg\n\ndatasg segment\n     db &#39;ibm             &#39;\n    db &#39;dec             &#39;\n    db &#39;dos             &#39;\n    db &#39;vax             &#39;\ndatasg ends\n\nstacksg segnebt\n        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节\nstacksg ends\n\ncodesg segment\nstart: mov ax,stacksg\n       mov ss,ax\n       mov sp,16\n       mov ax,datasg\n       mov ds,ax\n       mov bx,0                  ;此时指向第一行第一个字节的字母\n\n       mov cx,4\n\n   s0: push cx                   ;将外循环 cx 的值压栈\n          mov si,0\n          mov cx,3                  ;内循环 cx 的值\n\n    s: mov al,[bx + si]          ;(al) = ((ds) * 16 + (bx) + (si))\n       and al,11011111b          ;将小写字母改为大写字母\n       mov [bx + si],al          ;((ds) * 16 +(bx) + (si)) = (al)\n       inc si                    ;si + 1\n\n       loop s\n\n       add bx,16                 ;00 → 10 → 20 → 30 ...\n       pop cx                    ;将暂存的 cx 返回\n       loop s0                   ;cx - 1\n\n       mov ax,4c00H\n       int 21H\n\ncodesg ends\nend start</code></pre>\n<p><strong>在需要暂存数据的时候，一般使用栈来操作</strong></p>\n</li>\n<li><p>将 datasg 段中每个单词前4个字母改为大写：</p>\n<pre><code class=\"asm\">assume cs:codesg,ds:datasg,ss:stacksg\n\ndatasg segment\n     db &#39;1. display      &#39;\n    db &#39;2. brows        &#39;\n    db &#39;3. replace      &#39;\n    db &#39;4. modify       &#39;\ndatasg ends\n\nstacksg segnebt\n        dw 0,0,0,0,0,0,0,0,0   ;定义一个段用作栈段，容量为16字节\nstacksg ends\n\ncodesg segment\nstart: mov ax,stacksg\n       mov ss,ax\n       mov sp,16\n       mov ax,datasg\n       mov ds,ax\n       mov bx,0                  ;此时指向第一行第一个字节的字母\n\n       mov cx,4\n\n   s0: push cx                   ;将外循环 cx 的值压栈\n          mov si,0\n          mov cx,4                  ;内循环 cx 的值\n\n    s: mov al,[bx + 3 + si]      ;(al) = ((ds) * 16 + (bx) + (si) + 3)\n       and al,11011111b          ;将小写字母改为大写字母\n       mov [bx + 3 + si],al      ;((ds) * 16 +(bx) + (si) + 3) = (al)\n       inc si                    ;si + 1\n\n       loop s\n\n       add bx,16                 ;00 → 10 → 20 → 30 ...\n       pop cx                    ;将暂存的 cx 返回\n       loop s0                   ;cx - 1\n\n       mov ax,4c00H\n       int 21H\n\ncodesg ends\nend start</code></pre>\n</li>\n</ol>\n<h3 id=\"第八章：数据处理的两个基本问题\"><a href=\"#第八章：数据处理的两个基本问题\" class=\"headerlink\" title=\"第八章：数据处理的两个基本问题\"></a>第八章：数据处理的两个基本问题</h3><ol>\n<li><p>描述性符号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">集合</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">reg</td>\n<td align=\"center\">代表一个寄存器</td>\n<td align=\"center\">ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</td>\n</tr>\n<tr>\n<td align=\"center\">sreg</td>\n<td align=\"center\">代表一个段寄存器</td>\n<td align=\"center\">ds、ss、cs、es</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>在8086CPU中，只有bx 、si、di、bp四个寄存器可以用在 […] 中来进行内存单元的寻址。</p>\n<p>在 […] 中，这四个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di</p>\n<pre><code class=\"asm\">mov ax,[bx]\nmov ax,[si]\nmov ax,[di]\nmov ax,[bp]\nmov ax,[bx + si]\nmov ax,[bx + di]\nmov ax,[bp + si]\nmov ax,[bp + di]\nmov ax,[bx + si + idata]\nmov ax,[bx + di + idata]\nmov ax,[bp + si + idata]\nmov ax,[bp + di + idata]</code></pre>\n</li>\n<li><p>使用寄存器 bp 进行寻址，如果没有显性的给出段地址，那么段地址默认在 ss 段寄存器中</p>\n<pre><code class=\"asm\">mov ax,[bp] ;(ax) = ((ss) * 16 + (bp))\nmov ax,[bp + si + idata] ;(ax) = ((ss) * 16 + (bp) + (si) + idata)</code></pre>\n</li>\n<li><p>处理指令大致分为3类：读取、写入、运算；指令执行前，数据一般在3个地方：CPU内部、内存、端口</p>\n</li>\n<li><p>数据的位置：</p>\n<ol>\n<li><p>立即数（idata）：在汇编指令中字节给出</p>\n<pre><code class=\"asm\">mov ax,1\nadd bx,2000H</code></pre>\n</li>\n<li><p>寄存器：要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名就可以。</p>\n</li>\n<li><p>段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，使用段地址+偏移地址定位内存单元。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>寻址方式总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">寻址方式</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">常用格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">[idata]</td>\n<td align=\"center\">EA = idata;SA = (ds)</td>\n<td align=\"center\">直接寻址</td>\n<td align=\"center\">[idata]</td>\n</tr>\n<tr>\n<td align=\"center\">[bx]</td>\n<td align=\"center\">EA = (bx);SA = (ds)</td>\n<td align=\"center\">寄存器间接寻址</td>\n<td align=\"center\">[bx]</td>\n</tr>\n<tr>\n<td align=\"center\">[si]</td>\n<td align=\"center\">EA = (si) ;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[di]</td>\n<td align=\"center\">EA = (di);SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp]</td>\n<td align=\"center\">EA = (bp);SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bx + idata]</td>\n<td align=\"center\">EA = (bx) + idata;SA = (ds)</td>\n<td align=\"center\">寄存器相对寻址</td>\n<td align=\"center\">用于结构体:[bx].idata</td>\n</tr>\n<tr>\n<td align=\"center\">[si + idata]</td>\n<td align=\"center\">EA = (si) + idata;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\">用于数组:idata[si],idata[di]</td>\n</tr>\n<tr>\n<td align=\"center\">[di + idata]</td>\n<td align=\"center\">EA = (di) + idata;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\">用于二维数组:[bx] [idata]</td>\n</tr>\n<tr>\n<td align=\"center\">[bp + idata]</td>\n<td align=\"center\">EA = (bp) + idata;SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bx + si]</td>\n<td align=\"center\">EA = (bx) + (si);SA = (ds)</td>\n<td align=\"center\">基址变址寻址</td>\n<td align=\"center\">用于二维数组:[bx] [si]</td>\n</tr>\n<tr>\n<td align=\"center\">[bx + di]</td>\n<td align=\"center\">EA = (bx) + (di);SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp + si]</td>\n<td align=\"center\">EA = (bp) + (si);SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp + di]</td>\n<td align=\"center\">EA = (bp) + (di);SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bx + si + idata]</td>\n<td align=\"center\">EA = (bx) + (si) + idata;SA = (ds)</td>\n<td align=\"center\">相对基址变址寻址</td>\n<td align=\"center\">用于表格中的数组:[bx].idata[si]</td>\n</tr>\n<tr>\n<td align=\"center\">[bx + di + idata]</td>\n<td align=\"center\">EA = (bx) + (di) + idata;SA = (ds)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">[bp + si + idata]</td>\n<td align=\"center\">EA = (bp) + (si) + idata;SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\">用于二维数组:idata[bx] [si]</td>\n</tr>\n<tr>\n<td align=\"center\">[bp + di + idata]</td>\n<td align=\"center\">EA = (bp) + (di) + idata;SA = (ss)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>8086CPU 可以处理 byte 和 word 两种尺寸的数据。</p>\n<ol>\n<li><p>通过寄存器名指明要处理的数据的尺寸：</p>\n<pre><code class=\"asm\">;字操作\nmov ax,1\nadd ax,1000\ninc ax</code></pre>\n<pre><code class=\"asm\">;字节操作\nmov al\nadd al000\ninc al</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>没有寄存器名存在得情况下，用操作符 X ptr 指明内存单元的长度，X 可以为 byte 或 word：</p>\n<pre><code class=\"asm\">;word ptr 表示访问一个字单元\nmov word ptr ds:[0],1\ninc word ptr [bx]\ninc word ptr ds:[0]\nadd word ptr [bx],2</code></pre>\n<pre><code class=\"asm\">;byte ptr 表示访问一个字节单元\nmov byte ptr ds:[0],1\ninc byte ptr [bx]\ninc byte ptr ds:[0]\nadd byte ptr [bx],2</code></pre>\n</li>\n</ol>\n<p>   <strong>在机器指令中指明要访问的是字单元还是字节单元是非常重要的，8086CPU中，一个byte为8bit，而一个字为2byte，如果不指明，那么在访问的时候是有区别的。</strong></p>\n<ol start=\"8\">\n<li><p>使用 push 和 pop 指令就代表了是进行字操作，无需指明</p>\n</li>\n<li><p>div 除法指令：</p>\n<p>(1)除数：8位和16位两种，在一个reg或内存单元中</p>\n<p>(2)被除数：默认在AX或AX和DX中，除数位8位，被除数位16位，默认在AX中存放；除数位16位，则被除数位32位，DX存放高16位，AX存放低16位。</p>\n<p>(3)结果：如果除数位8位，则AL存储除法操作的商，AH存放余数；如果除数位16位，AX存储除法操作的商，DX存放余数</p>\n<pre><code class=\"asm\">;格式\ndiv reg\ndiv 内存单元</code></pre>\n<pre><code class=\"asm\">;示例\ndiv byte ptr ds:[0]      ;(al) = (ax) / ((ds) * 16 + 0 )的商\n                       ;(ah) = (ax) / ((ds) * 16 + 0)的余数\n\ndiv word ptr es:[0]      ;(ax) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的商\n                       ;(dx) = [(dx) * 10000H + (ax) / (es) * 16 + 0]的余数\n\ndiv byte ptr [bx + si + 8]     ;(al) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的商\n                             ;(ah) = (ax) / ((ds) * 16 + (bx) + (si) + 8)的余数\n\ndiv word ptr [bx + si + 8]     ;(ax) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的商\n                             ;(dx) = [(dx) * 10000H + (ax) / (ds) * 16 + (si) + 8]的余数js</code></pre>\n</li>\n<li><p>计算：100001 / 100</p>\n<pre><code class=\"asm\">;100001 &gt; 65535,所以除数得是32位，转为16进制为 186A1H，所以高16位在DX中，低16位在AX中\nmov dx,1\nmov ax,86A1H\nmov bx,100\ndiv bx</code></pre>\n</li>\n</ol>\n<ol start=\"11\">\n<li><p>伪指令 dd 、dup</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">db</td>\n<td align=\"center\">定义字节型数据</td>\n<td align=\"center\">db 1</td>\n</tr>\n<tr>\n<td align=\"center\">dw</td>\n<td align=\"center\">定义字型数据</td>\n<td align=\"center\">dw 100</td>\n</tr>\n<tr>\n<td align=\"center\">dd</td>\n<td align=\"center\">定义dword双字型数据</td>\n<td align=\"center\">dd 100001</td>\n</tr>\n<tr>\n<td align=\"center\">dup</td>\n<td align=\"center\">与上面3个指令配合使用，用来进行数据的重复</td>\n<td align=\"center\">db(dw、dd) 重复次数 dup (重复的数据)</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>汇编语言实验七：</p>\n<pre><code class=\"asm\">;题目太长，只贴代码，先思考写代码，而后体会别人的代码\nassume cs:code\n\ndata segment\n db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;,&#39;1984&#39;,&#39;1985&#39;\n db &#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;,&#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;\n\n dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514,345980\n dd 590827,803530,1183000,1843000,2758000,3753000,4649000,5937000\n\n dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\n dw 11542,14430,15257,17800\ndata ends\n\nstack segment\n dw 0,0,0,0,0,0,0\nstack ends\n\ntable segment\n db 21 dup (&#39;year summ ne ?? &#39;)\ntable ends\n\ncode segment\n\nstart:\n    mov ax,data\n    mov es,ax\n    mov si,0\n\n    mov ax,table\n    mov ds,ax\n    mov di,0\n\n    mov ax,stack\n    mov ss,ax\n    mov sp,16\n\n    mov bx,0\n    mov cx,21\ns0:\n    mov ax,es:[si]    \n    mov ds:[di+bx],ax\n    add si,2\n    add di,2\n    mov ax,es:[si]\n    mov ds:[di+bx],ax\n\n    mov ax,es:[si+82]\n    mov ds:[bx+di+3],ax\n    mov ax,es:[si+84]\n    mov ds:[bx+di+5],ax\n\n    add si,2\n    mov di,0\n    add bx,16\n    loop s0\n\n    mov bx,0\n    mov si,168\n    mov di,5\n    mov cx,21\ns1:    \n    mov ax,es:[si]\n    mov ds:[bx+di+5],ax\n\n    mov ax,ds:[bx+di]\n    mov dx,ds:[bx+di+2]\n    div word ptr ds:[bx+di+5]\n    mov ds:[bx+di+8],ax\n\n    add si,2\n    add bx,16\n    loop s1\n\n    mov ax,4c00h\n    int 21h\n\ncode ends\nend start</code></pre>\n</li>\n</ol>\n<h3 id=\"第九章：转移指令的原理\"><a href=\"#第九章：转移指令的原理\" class=\"headerlink\" title=\"第九章：转移指令的原理\"></a>第九章：转移指令的原理</h3><ol>\n<li><p><strong>可以修改 IP ，或者同时修改 CS 和 IP 得指令统称为转移指令。</strong></p>\n<ol>\n<li>段内转移：jmp ax<ol>\n<li>短转移IP修改范围：-128~127</li>\n<li>近转移IP修改范围：-32768~32767</li>\n</ol>\n</li>\n<li>段间转移：jmp 1000:0</li>\n</ol>\n</li>\n<li><p>转移指令分为无条件转移指令（jmp）和条件转移指令、循环指令、过程、中断等等</p>\n</li>\n<li><p>操作符 offset ，能够取得标号的偏移地址：</p>\n<pre><code class=\"asm\">start: mov ax,offset start  ;取得start的偏移地址，相当于 mov ax，0</code></pre>\n</li>\n<li></li>\n</ol>\n<h3 id=\"第十章：CALL和RET指令\"><a href=\"#第十章：CALL和RET指令\" class=\"headerlink\" title=\"第十章：CALL和RET指令\"></a>第十章：CALL和RET指令</h3><ol>\n<li><h3 id=\"第十一章：标志寄存器\"><a href=\"#第十一章：标志寄存器\" class=\"headerlink\" title=\"第十一章：标志寄存器\"></a>第十一章：标志寄存器</h3></li>\n<li></li>\n</ol>\n<h3 id=\"第十二章：内中断\"><a href=\"#第十二章：内中断\" class=\"headerlink\" title=\"第十二章：内中断\"></a>第十二章：内中断</h3><ol>\n<li><h3 id=\"第十三章：int-指令\"><a href=\"#第十三章：int-指令\" class=\"headerlink\" title=\"第十三章：int 指令\"></a>第十三章：int 指令</h3></li>\n<li></li>\n</ol>\n<h3 id=\"第十四章：端口\"><a href=\"#第十四章：端口\" class=\"headerlink\" title=\"第十四章：端口\"></a>第十四章：端口</h3><ol>\n<li><h3 id=\"第十五章：外中断\"><a href=\"#第十五章：外中断\" class=\"headerlink\" title=\"第十五章：外中断\"></a>第十五章：外中断</h3></li>\n<li></li>\n</ol>\n<h3 id=\"第十六章：直接定址表\"><a href=\"#第十六章：直接定址表\" class=\"headerlink\" title=\"第十六章：直接定址表\"></a>第十六章：直接定址表</h3><ol>\n<li><h3 id=\"第十七章：使用BIOS进行键盘输入\"><a href=\"#第十七章：使用BIOS进行键盘输入\" class=\"headerlink\" title=\"第十七章：使用BIOS进行键盘输入\"></a>第十七章：使用BIOS进行键盘输入</h3></li>\n<li></li>\n</ol>\n","path":"hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu-hou-ban-bu-fen.html","permalink":"https://www.yshawlon.cn/hui-bian-yu-yan-wang-shuang-zhu-xue-xi-bi-ji-ji-lu-hou-ban-bu-fen.html","tags":[{"name":"学习笔记","_id":"clq6dy48u0013ikw0galx0575","slug":"学习笔记","path":"tags/学习笔记/","permalink":"https://www.yshawlon.cn/tags/学习笔记/","length":9}],"categories":[{"name":"汇编","_id":"clq6dy4ak0037ikw0ze8i7hy0","slug":"汇编","path":"categories/汇编/","permalink":"https://www.yshawlon.cn/categories/汇编/","length":3}],"prev":{"title":"《X86汇编语言从实模式到保护模式》阅读笔记","date":"2021-05-16T14:57:10.000Z","summary":"能够了解常见的汇编命令，实现能够看懂基本的汇编操作，理解所表示含义。","slug":"《X86汇编语言从实模式到保护模式》阅读笔记","published":true,"updated":"2021-10-29T08:40:26.833Z","_id":"clq6dy49m001rikw0427xduwm","layout":"post","photos":[],"link":"","excerpt":"","path":"x86-hui-bian-yu-yan-cong-shi-mo-shi-dao-bao-hu-mo-shi-yue-du-bi-ji.html","permalink":"https://www.yshawlon.cn/x86-hui-bian-yu-yan-cong-shi-mo-shi-dao-bao-hu-mo-shi-yue-du-bi-ji.html","__post":true},"next":{"title":"汇编语言学习 DOSBox+MASM 安装及使用教程","date":"2021-05-08T06:19:14.000Z","summary":"安装DOSBox和MASM 以及编写汇编程序实现输出 Hello Word，记录学习过程。","slug":"汇编语言学习-DOSBox-MASM-安装及使用教程","published":true,"updated":"2021-12-14T04:46:20.344Z","_id":"clq6dy4ao003iikw0s85badpy","layout":"post","photos":[],"link":"","excerpt":"","path":"hui-bian-yu-yan-xue-xi-dosbox-masm-an-zhuang-ji-shi-yong-jiao-cheng.html","permalink":"https://www.yshawlon.cn/hui-bian-yu-yan-xue-xi-dosbox-masm-an-zhuang-ji-shi-yong-jiao-cheng.html","__post":true},"__post":true}