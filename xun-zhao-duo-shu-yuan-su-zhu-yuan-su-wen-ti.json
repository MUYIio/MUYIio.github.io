{"title":"寻找多数元素（主元素）问题","date":"2021-01-06T16:31:05.000Z","toc":true,"summary":"给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数","source":"_posts/寻找多数元素（主元素）问题.md","raw":"---\ntitle: 寻找多数元素（主元素）问题\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-01-07 00:31:05\npassword:\nsummary: 给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数\ntags:\n- 主元素\n- 多数元素\ncategories:\n- 算法\n---\n\n\n\n### 问题描述：\n\n给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数.（默认都是存在众数的）\n\n**示例输入：**\n\n已知序列：[2,3,2,5,2,6,2,2]，找出主元素\n\n**示例输出：**\n\n2\n\n### 题解：\n\n#### 方法一：\n\n最简单的就是记录每个数字出现的次数，暴力解题。但是时间复杂度为O(n²)。\n\nc语言代码：\n\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n\tint n;\n\tint a[101];\n\tint count, max=0;\n\tprintf(\"数据个数:\\n\");\n\tscanf(\"%d\", &n);\n\tint i, j, k = 0;\n\tfor (i = 1; i <= n; ++i)           //循环存入数据\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (i = 1; i <= n; ++i)           //遍历每一个数据\n\t{\n\t\tcount = 0;\n\t\tfor (j = 1; j <= n; ++j)\n\t\t{\n\t\t\tif (a[i] == a[j] && i != j)       //遇到相同的数据，计数器加1\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > max)                //寻找有相同数据最多的数\n\t\t{\n\t\t\tmax = count;\n\t\t\tk = a[i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",k);\n\treturn 0;\n}\n```\n\n#### 方法二:\n\n对所有的数进行递增排序，如果有一个数出现的次数超过50%，那么它一定位于n/2这个位置。时间复杂度为O(nlogn)。\n\n```c\n/*对于堆，作向下调整，对内部变量h[101]作调整*/\nint* siftdown2(int x, int num, int h[101])\n{\n\tint n = num, flag = 0;\n\tint i, j;\n\tj = x;\n\twhile (j <= n && flag == 0)\n\t{\n\t\tif (h[j] > h[2 * j] && 2 * j <= n)\n\t\t{\n\t\t\ti = 2 * j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = j;\n\t\t}\n\t\tif (h[i] > h[2 * j + 1] && 2 * j + 1 <= n)\n\t\t{\n\t\t\ti = 2 * j + 1;\n\t\t}\n\t\tif (i != j)\n\t\t{\n\t\t\tint t;\n\t\t\tt = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = t;\n\t\t\tj = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = 1;\n\t\t}\n\t}\n\treturn h;\n}\n\n\nint main(void)\n{\n\tint count = 1, max = 0;\n\tprintf(\"数据个数:\\n\");\n\tscanf_s(\"%d\", &n);\n\tint i, k = 0;\n\tfor (i = 1; i <= n; ++i)           //循环存入数据\n\t{\n\t\tscanf_s(\"%d\", &a[i]);\n\t}\n\tsiftup(n, a);                        //堆排序\n\tint c = a[1]; \n\tint num = n;\n\tfor (i = 1; i <= n; ++i)           //遍历每一个数据\n\t{\n\t\ta[1] = a[num];\n\t\t--num;\n\t\tsiftdown2(1, num, a);          //对于堆，作向下调整，对内部变量h[101]作调整\n\t\tif (a[1] ==c)                  //找出下一个较小的数，与前一个比较是否相等\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (count > max)                //寻找有相同数据最多的数\n\t\t\t{\n\t\t\t\tmax = count;\n\t\t\t\tk = a[i];\n\t\t\t}\n\t\t\tcount = 1;\n\t\t}\n\t\tc = a[1];\n\t}\n\tprintf(\"%d\\n\",k);\n\treturn 0;\n}\n\n```\n\n\n\n#### 方法三：\n\n堆排序一个数组，排好后在主函数中给出第一个数，与第二个数比较，如相等count加1，如不相等，与max比较，更新max，最终找出多数元素\n\n```c\n/*对于堆，作向上调整，对内部变量h[101]作调整*/\nint* siftup(int n, int h[101])\n{\n\tint i = n, flag = 0, j;\n\twhile (i >= 1 && flag == 0)\n\t{\n\t\tif (h[i] < h[i / 2] && i >= 1)\n\t\t{\n\t\t\tj = i / 2;\n\t\t\tint t;\n\t\t\tt = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = t;\n\t\t\ti = j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = 1;\n\t\t}\n\t}\n\treturn h;\n}\n\n```\n\n\n\n这个算法的时间复杂度是O(N+M)，空间复杂度也是O(N+M)。但是，如果序列中数的大小跨度比较大这个方法就不行了，空间开销非常大。那么看看下面的方法。\n\n#### 方法四：\n\n也许你不知道，像这种序列的有一个特性，就是在**原序列中去除两个不一样的数，原序列中出现超过50%的那个数，在取出的新序列中出现的次数也一定会超过50%**。现在知道了，有没有想到解题的方法呢？\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n    int a[] = {3,1,1,2,3,1,3,3,3};\n    int i;\n    //初始化\n    int count = 1;\n    int temp = a[0];\n    for(i = 1; i < sizeof(a)/sizeof(int);i++)\n    {\n          if(count == 0)\n          {\n               temp = a[i];\n               count++;\n          }\n          else if(a[i] == temp)\n              count++;\n          else \n              count--;\n    }\n    printf(\"最多的数是:%d\\n\",temp);\n    system(\"pause\");\n    return 0;\n}\n```\n\n\n\n\n\n**Boyer-Moore 投票算法**\n\n**如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。**\n\n\n\nBoyer-Moore 算法的本质和分治十分类似。 Boyer-Moore 算法的详细步骤：\n\n我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；\n\n我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：\n\n如果 x 与 candidate 相等，那么计数器 count 的值增加 1；\n\n如果 x 与 candidate 不等，那么计数器 count 的值减少 1。\n\n在遍历完成后，candidate 即为整个数组的众数。\n\n举一个具体的例子，例如下面的这个数组：\n\n```\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\n```\n\n\n在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。\n\nBoyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：\n\n首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。\n\n那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组\n\n```\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\n```\n\n\n作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：\n\n```\nnums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\ncandidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7\ncount:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4\n```\n\n\n我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：\n\n```\nnums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\nvalue:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4\n```\n\n\n有没有发现什么？我们将 count 和 value 放在一起：\n\n```\nnums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\ncount:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4\nvalue:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4\n```\n\n\n发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！\n\n为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。\n\n**这样以来，由于：**\n\n我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；\n\n由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；\n\n在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int candidate = -1;\n        int count = 0;\n        for (int num : nums) {\n            if (num == candidate)\n                ++count;\n            else if (--count < 0) {\n                candidate = num;\n                count = 1;\n            }\n        }\n        return candidate;\n    }\n};\n```\n\n**复杂度分析:**\n\n- 时间复杂度：O(n)O(n)。Boyer-Moore 算法只对数组进行了一次遍历。\n\n- 空间复杂度：O(1)O(1)。Boyer-Moore 算法只需要常数级别的额外空间。\n\n\n\n这个算法最初是在《啊哈！算法》看到的，通过最后一个方法可以将时间复杂度优化到O(n)，\n\n","slug":"寻找多数元素（主元素）问题","published":true,"updated":"2021-03-25T06:51:37.432Z","_id":"clq6dy4al003aikw0necd4gos","comments":true,"layout":"post","photos":[],"link":"","html":"<h3 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h3><p>给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数.（默认都是存在众数的）</p>\n<p><strong>示例输入：</strong></p>\n<p>已知序列：[2,3,2,5,2,6,2,2]，找出主元素</p>\n<p><strong>示例输出：</strong></p>\n<p>2</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><h4 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h4><p>最简单的就是记录每个数字出现的次数，暴力解题。但是时间复杂度为O(n²)。</p>\n<p>c语言代码：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n    int n;\n    int a[101];\n    int count, max=0;\n    printf(\"数据个数:\\n\");\n    scanf(\"%d\", &n);\n    int i, j, k = 0;\n    for (i = 1; i <= n; ++i)           //循环存入数据\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    for (i = 1; i <= n; ++i)           //遍历每一个数据\n    {\n        count = 0;\n        for (j = 1; j <= n; ++j)\n        {\n            if (a[i] == a[j] && i != j)       //遇到相同的数据，计数器加1\n            {\n                count++;\n            }\n        }\n        if (count > max)                //寻找有相同数据最多的数\n        {\n            max = count;\n            k = a[i];\n        }\n    }\n    printf(\"%d\\n\",k);\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二:\"></a>方法二:</h4><p>对所有的数进行递增排序，如果有一个数出现的次数超过50%，那么它一定位于n/2这个位置。时间复杂度为O(nlogn)。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/*对于堆，作向下调整，对内部变量h[101]作调整*/</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token function\">siftdown2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> num<span class=\"token punctuation\">,</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>\n    j <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">&amp;&amp;</span> flag <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> h<span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            i <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            i <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> h<span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            i <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> j<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n            t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n            j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> max <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"数据个数:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf_s</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>           <span class=\"token comment\" spellcheck=\"true\">//循环存入数据</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">scanf_s</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">siftup</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                        <span class=\"token comment\" spellcheck=\"true\">//堆排序</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>           <span class=\"token comment\" spellcheck=\"true\">//遍历每一个数据</span>\n    <span class=\"token punctuation\">{</span>\n        a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">--</span>num<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">siftdown2</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">//对于堆，作向下调整，对内部变量h[101]作调整</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span>c<span class=\"token punctuation\">)</span>                  <span class=\"token comment\" spellcheck=\"true\">//找出下一个较小的数，与前一个比较是否相等</span>\n        <span class=\"token punctuation\">{</span>\n            count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span>                <span class=\"token comment\" spellcheck=\"true\">//寻找有相同数据最多的数</span>\n            <span class=\"token punctuation\">{</span>\n                max <span class=\"token operator\">=</span> count<span class=\"token punctuation\">;</span>\n                k <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"方法三：\"><a href=\"#方法三：\" class=\"headerlink\" title=\"方法三：\"></a>方法三：</h4><p>堆排序一个数组，排好后在主函数中给出第一个数，与第二个数比较，如相等count加1，如不相等，与max比较，更新max，最终找出多数元素</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/*对于堆，作向上调整，对内部变量h[101]作调整*/</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token function\">siftup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token punctuation\">,</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> flag <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> h<span class=\"token punctuation\">[</span>i <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            j <span class=\"token operator\">=</span> i <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n            t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n            i <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个算法的时间复杂度是O(N+M)，空间复杂度也是O(N+M)。但是，如果序列中数的大小跨度比较大这个方法就不行了，空间开销非常大。那么看看下面的方法。</p>\n<h4 id=\"方法四：\"><a href=\"#方法四：\" class=\"headerlink\" title=\"方法四：\"></a>方法四：</h4><p>也许你不知道，像这种序列的有一个特性，就是在<strong>原序列中去除两个不一样的数，原序列中出现超过50%的那个数，在取出的新序列中出现的次数也一定会超过50%</strong>。现在知道了，有没有想到解题的方法呢？</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{</span>\n               temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> temp<span class=\"token punctuation\">)</span>\n              count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">else</span> \n              count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最多的数是:%d\\n\"</span><span class=\"token punctuation\">,</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">system</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pause\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>Boyer-Moore 投票算法</strong></p>\n<p><strong>如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</strong></p>\n<p>Boyer-Moore 算法的本质和分治十分类似。 Boyer-Moore 算法的详细步骤：</p>\n<p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>\n<p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>\n<p>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p>\n<p>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p>\n<p>在遍历完成后，candidate 即为整个数组的众数。</p>\n<p>举一个具体的例子，例如下面的这个数组：</p>\n<pre><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></pre><p>在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</p>\n<p>Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p>\n<p>首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p>\n<p>那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p>\n<pre><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></pre><p>作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p>\n<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\ncandidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7\ncount:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</code></pre><p>我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p>\n<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\nvalue:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</code></pre><p>有没有发现什么？我们将 count 和 value 放在一起：</p>\n<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\ncount:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4\nvalue:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</code></pre><p>发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p>\n<p>为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p>\n<p><strong>这样以来，由于：</strong></p>\n<p>我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p>\n<p>由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p>\n<p>在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int candidate = -1;\n        int count = 0;\n        for (int num : nums) {\n            if (num == candidate)\n                ++count;\n            else if (--count < 0) {\n                candidate = num;\n                count = 1;\n            }\n        }\n        return candidate;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>复杂度分析:</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</p>\n</li>\n<li><p>空间复杂度：O(1)O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</p>\n</li>\n</ul>\n<p>这个算法最初是在《啊哈！算法》看到的，通过最后一个方法可以将时间复杂度优化到O(n)，</p>\n","excerpt":"","more":"<h3 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h3><p>给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数.（默认都是存在众数的）</p>\n<p><strong>示例输入：</strong></p>\n<p>已知序列：[2,3,2,5,2,6,2,2]，找出主元素</p>\n<p><strong>示例输出：</strong></p>\n<p>2</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><h4 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h4><p>最简单的就是记录每个数字出现的次数，暴力解题。但是时间复杂度为O(n²)。</p>\n<p>c语言代码：</p>\n<pre><code class=\"c++\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main(void)\n{\n    int n;\n    int a[101];\n    int count, max=0;\n    printf(&quot;数据个数:\\n&quot;);\n    scanf(&quot;%d&quot;, &amp;n);\n    int i, j, k = 0;\n    for (i = 1; i &lt;= n; ++i)           //循环存入数据\n    {\n        scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n    for (i = 1; i &lt;= n; ++i)           //遍历每一个数据\n    {\n        count = 0;\n        for (j = 1; j &lt;= n; ++j)\n        {\n            if (a[i] == a[j] &amp;&amp; i != j)       //遇到相同的数据，计数器加1\n            {\n                count++;\n            }\n        }\n        if (count &gt; max)                //寻找有相同数据最多的数\n        {\n            max = count;\n            k = a[i];\n        }\n    }\n    printf(&quot;%d\\n&quot;,k);\n    return 0;\n}</code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二:\"></a>方法二:</h4><p>对所有的数进行递增排序，如果有一个数出现的次数超过50%，那么它一定位于n/2这个位置。时间复杂度为O(nlogn)。</p>\n<pre><code class=\"c\">/*对于堆，作向下调整，对内部变量h[101]作调整*/\nint* siftdown2(int x, int num, int h[101])\n{\n    int n = num, flag = 0;\n    int i, j;\n    j = x;\n    while (j &lt;= n &amp;&amp; flag == 0)\n    {\n        if (h[j] &gt; h[2 * j] &amp;&amp; 2 * j &lt;= n)\n        {\n            i = 2 * j;\n        }\n        else\n        {\n            i = j;\n        }\n        if (h[i] &gt; h[2 * j + 1] &amp;&amp; 2 * j + 1 &lt;= n)\n        {\n            i = 2 * j + 1;\n        }\n        if (i != j)\n        {\n            int t;\n            t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n            j = i;\n        }\n        else\n        {\n            flag = 1;\n        }\n    }\n    return h;\n}\n\n\nint main(void)\n{\n    int count = 1, max = 0;\n    printf(&quot;数据个数:\\n&quot;);\n    scanf_s(&quot;%d&quot;, &amp;n);\n    int i, k = 0;\n    for (i = 1; i &lt;= n; ++i)           //循环存入数据\n    {\n        scanf_s(&quot;%d&quot;, &amp;a[i]);\n    }\n    siftup(n, a);                        //堆排序\n    int c = a[1]; \n    int num = n;\n    for (i = 1; i &lt;= n; ++i)           //遍历每一个数据\n    {\n        a[1] = a[num];\n        --num;\n        siftdown2(1, num, a);          //对于堆，作向下调整，对内部变量h[101]作调整\n        if (a[1] ==c)                  //找出下一个较小的数，与前一个比较是否相等\n        {\n            count++;\n        }\n        else\n        {\n            if (count &gt; max)                //寻找有相同数据最多的数\n            {\n                max = count;\n                k = a[i];\n            }\n            count = 1;\n        }\n        c = a[1];\n    }\n    printf(&quot;%d\\n&quot;,k);\n    return 0;\n}\n</code></pre>\n<h4 id=\"方法三：\"><a href=\"#方法三：\" class=\"headerlink\" title=\"方法三：\"></a>方法三：</h4><p>堆排序一个数组，排好后在主函数中给出第一个数，与第二个数比较，如相等count加1，如不相等，与max比较，更新max，最终找出多数元素</p>\n<pre><code class=\"c\">/*对于堆，作向上调整，对内部变量h[101]作调整*/\nint* siftup(int n, int h[101])\n{\n    int i = n, flag = 0, j;\n    while (i &gt;= 1 &amp;&amp; flag == 0)\n    {\n        if (h[i] &lt; h[i / 2] &amp;&amp; i &gt;= 1)\n        {\n            j = i / 2;\n            int t;\n            t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n            i = j;\n        }\n        else\n        {\n            flag = 1;\n        }\n    }\n    return h;\n}\n</code></pre>\n<p>这个算法的时间复杂度是O(N+M)，空间复杂度也是O(N+M)。但是，如果序列中数的大小跨度比较大这个方法就不行了，空间开销非常大。那么看看下面的方法。</p>\n<h4 id=\"方法四：\"><a href=\"#方法四：\" class=\"headerlink\" title=\"方法四：\"></a>方法四：</h4><p>也许你不知道，像这种序列的有一个特性，就是在<strong>原序列中去除两个不一样的数，原序列中出现超过50%的那个数，在取出的新序列中出现的次数也一定会超过50%</strong>。现在知道了，有没有想到解题的方法呢？</p>\n<pre><code class=\"c\">#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint main()\n{\n    int a[] = {3,1,1,2,3,1,3,3,3};\n    int i;\n    //初始化\n    int count = 1;\n    int temp = a[0];\n    for(i = 1; i &lt; sizeof(a)/sizeof(int);i++)\n    {\n          if(count == 0)\n          {\n               temp = a[i];\n               count++;\n          }\n          else if(a[i] == temp)\n              count++;\n          else \n              count--;\n    }\n    printf(&quot;最多的数是:%d\\n&quot;,temp);\n    system(&quot;pause&quot;);\n    return 0;\n}</code></pre>\n<p><strong>Boyer-Moore 投票算法</strong></p>\n<p><strong>如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</strong></p>\n<p>Boyer-Moore 算法的本质和分治十分类似。 Boyer-Moore 算法的详细步骤：</p>\n<p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>\n<p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>\n<p>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p>\n<p>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p>\n<p>在遍历完成后，candidate 即为整个数组的众数。</p>\n<p>举一个具体的例子，例如下面的这个数组：</p>\n<pre><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></pre><p>在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</p>\n<p>Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p>\n<p>首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p>\n<p>那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p>\n<pre><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></pre><p>作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p>\n<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\ncandidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7\ncount:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</code></pre><p>我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p>\n<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\nvalue:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</code></pre><p>有没有发现什么？我们将 count 和 value 放在一起：</p>\n<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\ncount:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4\nvalue:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</code></pre><p>发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p>\n<p>为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p>\n<p><strong>这样以来，由于：</strong></p>\n<p>我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p>\n<p>由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p>\n<p>在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) {\n        int candidate = -1;\n        int count = 0;\n        for (int num : nums) {\n            if (num == candidate)\n                ++count;\n            else if (--count &lt; 0) {\n                candidate = num;\n                count = 1;\n            }\n        }\n        return candidate;\n    }\n};</code></pre>\n<p><strong>复杂度分析:</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</p>\n</li>\n<li><p>空间复杂度：O(1)O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</p>\n</li>\n</ul>\n<p>这个算法最初是在《啊哈！算法》看到的，通过最后一个方法可以将时间复杂度优化到O(n)，</p>\n","path":"xun-zhao-duo-shu-yuan-su-zhu-yuan-su-wen-ti.html","permalink":"https://www.yshawlon.cn/xun-zhao-duo-shu-yuan-su-zhu-yuan-su-wen-ti.html","tags":[{"name":"主元素","_id":"clq6dy4bg005qikw006lyjp85","slug":"主元素","path":"tags/主元素/","permalink":"https://www.yshawlon.cn/tags/主元素/","length":1},{"name":"多数元素","_id":"clq6dy4bh005tikw0yneapu56","slug":"多数元素","path":"tags/多数元素/","permalink":"https://www.yshawlon.cn/tags/多数元素/","length":1}],"categories":[{"name":"算法","_id":"clq6dy491001eikw044hl9f0q","slug":"算法","path":"categories/算法/","permalink":"https://www.yshawlon.cn/categories/算法/","length":5}],"prev":{"title":"如何实现一个公平的洗牌算法","date":"2021-01-10T05:02:38.000Z","summary":"每一个元素都能独立等概率的出现在每一个位置，每一个位置都能独立等概率的放置每个元素","slug":"如何实现一个公平的洗牌算法","published":true,"updated":"2021-02-19T15:33:42.494Z","_id":"clq6dy4ag002zikw0t95tsm48","layout":"post","photos":[],"link":"","excerpt":"","path":"ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html","permalink":"https://www.yshawlon.cn/ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html","__post":true},"next":{"title":"怎样告别我的2020呢？","date":"2020-12-31T15:33:07.000Z","summary":"赶在2021前写下这篇文章，想要总结一下2020，实在没什么好总结的","slug":"怎样告别我的2020呢？","published":true,"updated":"2021-01-16T06:13:41.332Z","_id":"clq6dy4aj0035ikw0dbbc4qc9","layout":"post","photos":[],"link":"","excerpt":"","path":"zen-yang-gao-bie-wo-de-2020-ni.html","permalink":"https://www.yshawlon.cn/zen-yang-gao-bie-wo-de-2020-ni.html","__post":true},"__post":true}