{"title":"C++ 中关于Lambda 表达式的总结","date":"2021-10-18T08:57:56.000Z","toc":true,"summary":"Lambda表达式是C++ 11新特性之一，总的来说就是一个函数。","source":"_posts/C-中关于Lambda-表达式的总结.md","raw":"---\ntitle: C++ 中关于Lambda 表达式的总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-10-18 16:57:56\npassword:\nsummary: Lambda表达式是C++ 11新特性之一，总的来说就是一个函数。\ntags:\n- Lambda\ncategories:\n- C++\nkeywords:\ndescription:\n---\n\nLambda表达式是C++ 11新特性之一，总的来说就是一个函数，第一眼看到这个函数也是一脸懵逼，怎么没有见到过这个写法？于是查找了一些资料，按照我的理解记录一下\n\n## Lambda基本语法\n\nLambda标准语法定义：\n\n```cpp\n[capture] (parameters) mutable ->ret-type{body};\n```\n\n**说明：**\n\n- 1.[capture]：捕捉列表。捕捉列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数。捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，捕获列表可以是下面的类型：\n\n  > - 1.[var]表示值传递方式捕捉变量var；\n  >\n  > - 2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；\n  >\n  >   ```cpp\n  >   auto f1 = [=]{return a + 1;};    //按值捕获a\n  >   ```\n  >\n  > - 3.[&var]表示引用传递捕捉变量var；\n  >\n  > - 4.[&]表示引用传递方式捕捉所有父作用域的变量（包括this）；\n  >\n  >   ```cpp\n  >   auto f2 = [&]{return a + 1;};    //按引用捕获a\n  >   ```\n  >\n  > - 5.[this]表示值传递方式捕捉当前的this指针。\n  >\n  > - 6.[ ]表示不捕获任何变量。\n  >\n  > **捕获列表也可以组合：**\n  >\n  > - 1.[=,&a,&b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;\n  > - 2.[&,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。\n  >\n  > **如果重复是不允许的：**\n  >\n  > - 1.[=,x]这里已经以值传递方式捕捉了所有变量，但重复捕捉x;\n  >\n  > - 2.[&,&this]&已经相当于以引用传递方式捕捉了所有变量，再捕捉this则会重复。\n\n- 2.(parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略;\n\n- 3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）;\n\n- 4.->ret-type：返回类型。可以指定，也可以不指定，不指定编译器则会自动推导返回类型，例如：\n\n  ```cpp\n  [](double x ) {int y = x ;};\n  ```\n\n  如果函数有多个返回值，编译器不能推导，需要自行添加，例如：\n\n  ```cpp\n  [](double x )->double{int y = x ;return x - y;};\n  ```\n\n- 5.{body}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。\n\n## Lambda函数具体使用\n\n1.其中上面讲到了**父作用域**，简单来说就是包含Lambda函数的`{ }`代码段。\n\n**2. 另外，Lambda是匿名函数，但通常会给它取名，例如：**\n\n```cpp\nauto f = [](int x ) {return x % 3 ==0;};\n```\n\n这样就可以在程序中更方便的调用Lambda函数了：\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tint a = 10, b = 5;\n\tauto f = [=]{return a + b;};   //[=]按值捕获了a和b\n\tcout << f() << endl;         //值为15\n\treturn 0;\n}\n```\n\n**3.保持Lambda函数引用的变量的值是最新的：**\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tint a = 8;\n\tauto f1 = [=]{return a + 1;};  //按值捕获a\n\tauto f2 = [&]{return a + 1;};  //按引用捕获a\n\tcout << f1() << endl;\n\tcout << f2()<< endl;\n\ta++;\n\tcout << f1() << endl;\n\tcout << f2() << endl;\n\treturn 0;\n}\n\n程序结果：\n    8\n    8\n    8\n    9\n```\n\n按值捕获可以看作Lambda函数生成了一个const类型的变量，它的值是不会因为外部更新而更新的；同样引用捕获相当于调用a的内存地址，保证实时更新，如果想要Lambda函数在调用时访问的外部变量是最新的，我们就需要使用按引用捕获。\n\n如果非要做到修改值捕获变量的值，就可以使用mutale关键字；默认情况下，lambda函数是一个const函数，而mutable也可以取消常量性，例如：\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tint a = 10;\n\tauto f = [=]()mutable{return a *= 10;};//取消常量性\n\tcout << f() << endl;\n\treturn 0;\n}\n\n程序结果：\n    100\n```\n\n mutable 修饰的 Lambda 表达式就算没有参数也要写明参数列表，这里的`()`表示没有省略，只是没有参数而已。\n\n\n\n\n\n","slug":"C-中关于Lambda-表达式的总结","published":true,"updated":"2022-05-23T15:03:31.054Z","_id":"clq6dy4810008ikw0poi31mhm","comments":true,"layout":"post","photos":[],"link":"","html":"<p>Lambda表达式是C++ 11新特性之一，总的来说就是一个函数，第一眼看到这个函数也是一脸懵逼，怎么没有见到过这个写法？于是查找了一些资料，按照我的理解记录一下</p>\n<h2 id=\"Lambda基本语法\"><a href=\"#Lambda基本语法\" class=\"headerlink\" title=\"Lambda基本语法\"></a>Lambda基本语法</h2><p>Lambda标准语法定义：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span>capture<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>parameters<span class=\"token punctuation\">)</span> <span class=\"token keyword\">mutable</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span>ret<span class=\"token operator\">-</span>type<span class=\"token punctuation\">{</span>body<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>说明：</strong></p>\n<ul>\n<li><p>1.[capture]：捕捉列表。捕捉列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数。捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，捕获列表可以是下面的类型：</p>\n<blockquote>\n<ul>\n<li><p>1.[var]表示值传递方式捕捉变量var；</p>\n</li>\n<li><p>2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> f1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//按值捕获a</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>3.[&amp;var]表示引用传递捕捉变量var；</p>\n</li>\n<li><p>4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）；</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> f2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//按引用捕获a</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>5.[this]表示值传递方式捕捉当前的this指针。</p>\n</li>\n<li><p>6.[ ]表示不捕获任何变量。</p>\n</li>\n</ul>\n<p><strong>捕获列表也可以组合：</strong></p>\n<ul>\n<li>1.[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;</li>\n<li>2.[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。</li>\n</ul>\n<p><strong>如果重复是不允许的：</strong></p>\n<ul>\n<li><p>1.[=,x]这里已经以值传递方式捕捉了所有变量，但重复捕捉x;</p>\n</li>\n<li><p>2.[&amp;,&amp;this]&amp;已经相当于以引用传递方式捕捉了所有变量，再捕捉this则会重复。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>2.(parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略;</p>\n</li>\n<li><p>3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）;</p>\n</li>\n<li><p>4.-&gt;ret-type：返回类型。可以指定，也可以不指定，不指定编译器则会自动推导返回类型，例如：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> x <span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果函数有多个返回值，编译器不能推导，需要自行添加，例如：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x <span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token keyword\">double</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> x <span class=\"token punctuation\">;</span><span class=\"token keyword\">return</span> x <span class=\"token operator\">-</span> y<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>5.{body}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</p>\n</li>\n</ul>\n<h2 id=\"Lambda函数具体使用\"><a href=\"#Lambda函数具体使用\" class=\"headerlink\" title=\"Lambda函数具体使用\"></a>Lambda函数具体使用</h2><p>1.其中上面讲到了<strong>父作用域</strong>，简单来说就是包含Lambda函数的<code>{ }</code>代码段。</p>\n<p><strong>2. 另外，Lambda是匿名函数，但通常会给它取名，例如：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> x <span class=\"token operator\">%</span> <span class=\"token number\">3</span> <span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这样就可以在程序中更方便的调用Lambda函数了：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//[=]按值捕获了a和b</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>         <span class=\"token comment\" spellcheck=\"true\">//值为15</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3.保持Lambda函数引用的变量的值是最新的：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> f1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//按值捕获a</span>\n    <span class=\"token keyword\">auto</span> f2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//按引用捕获a</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    a<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n程序结果：\n    <span class=\"token number\">8</span>\n    <span class=\"token number\">8</span>\n    <span class=\"token number\">8</span>\n    <span class=\"token number\">9</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>按值捕获可以看作Lambda函数生成了一个const类型的变量，它的值是不会因为外部更新而更新的；同样引用捕获相当于调用a的内存地址，保证实时更新，如果想要Lambda函数在调用时访问的外部变量是最新的，我们就需要使用按引用捕获。</p>\n<p>如果非要做到修改值捕获变量的值，就可以使用mutale关键字；默认情况下，lambda函数是一个const函数，而mutable也可以取消常量性，例如：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">mutable</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//取消常量性</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n程序结果：\n    <span class=\"token number\">100</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p> mutable 修饰的 Lambda 表达式就算没有参数也要写明参数列表，这里的<code>()</code>表示没有省略，只是没有参数而已。</p>\n","excerpt":"","more":"<p>Lambda表达式是C++ 11新特性之一，总的来说就是一个函数，第一眼看到这个函数也是一脸懵逼，怎么没有见到过这个写法？于是查找了一些资料，按照我的理解记录一下</p>\n<h2 id=\"Lambda基本语法\"><a href=\"#Lambda基本语法\" class=\"headerlink\" title=\"Lambda基本语法\"></a>Lambda基本语法</h2><p>Lambda标准语法定义：</p>\n<pre><code class=\"cpp\">[capture] (parameters) mutable -&gt;ret-type{body};</code></pre>\n<p><strong>说明：</strong></p>\n<ul>\n<li><p>1.[capture]：捕捉列表。捕捉列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数。捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，捕获列表可以是下面的类型：</p>\n<blockquote>\n<ul>\n<li><p>1.[var]表示值传递方式捕捉变量var；</p>\n</li>\n<li><p>2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；</p>\n<pre><code class=\"cpp\">auto f1 = [=]{return a + 1;};    //按值捕获a</code></pre>\n</li>\n<li><p>3.[&amp;var]表示引用传递捕捉变量var；</p>\n</li>\n<li><p>4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）；</p>\n<pre><code class=\"cpp\">auto f2 = [&amp;]{return a + 1;};    //按引用捕获a</code></pre>\n</li>\n<li><p>5.[this]表示值传递方式捕捉当前的this指针。</p>\n</li>\n<li><p>6.[ ]表示不捕获任何变量。</p>\n</li>\n</ul>\n<p><strong>捕获列表也可以组合：</strong></p>\n<ul>\n<li>1.[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;</li>\n<li>2.[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。</li>\n</ul>\n<p><strong>如果重复是不允许的：</strong></p>\n<ul>\n<li><p>1.[=,x]这里已经以值传递方式捕捉了所有变量，但重复捕捉x;</p>\n</li>\n<li><p>2.[&amp;,&amp;this]&amp;已经相当于以引用传递方式捕捉了所有变量，再捕捉this则会重复。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>2.(parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略;</p>\n</li>\n<li><p>3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）;</p>\n</li>\n<li><p>4.-&gt;ret-type：返回类型。可以指定，也可以不指定，不指定编译器则会自动推导返回类型，例如：</p>\n<pre><code class=\"cpp\">[](double x ) {int y = x ;};</code></pre>\n<p>如果函数有多个返回值，编译器不能推导，需要自行添加，例如：</p>\n<pre><code class=\"cpp\">[](double x )-&gt;double{int y = x ;return x - y;};</code></pre>\n</li>\n<li><p>5.{body}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</p>\n</li>\n</ul>\n<h2 id=\"Lambda函数具体使用\"><a href=\"#Lambda函数具体使用\" class=\"headerlink\" title=\"Lambda函数具体使用\"></a>Lambda函数具体使用</h2><p>1.其中上面讲到了<strong>父作用域</strong>，简单来说就是包含Lambda函数的<code>{ }</code>代码段。</p>\n<p><strong>2. 另外，Lambda是匿名函数，但通常会给它取名，例如：</strong></p>\n<pre><code class=\"cpp\">auto f = [](int x ) {return x % 3 ==0;};</code></pre>\n<p>这样就可以在程序中更方便的调用Lambda函数了：</p>\n<pre><code class=\"cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int a = 10, b = 5;\n    auto f = [=]{return a + b;};   //[=]按值捕获了a和b\n    cout &lt;&lt; f() &lt;&lt; endl;         //值为15\n    return 0;\n}</code></pre>\n<p><strong>3.保持Lambda函数引用的变量的值是最新的：</strong></p>\n<pre><code class=\"cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int a = 8;\n    auto f1 = [=]{return a + 1;};  //按值捕获a\n    auto f2 = [&amp;]{return a + 1;};  //按引用捕获a\n    cout &lt;&lt; f1() &lt;&lt; endl;\n    cout &lt;&lt; f2()&lt;&lt; endl;\n    a++;\n    cout &lt;&lt; f1() &lt;&lt; endl;\n    cout &lt;&lt; f2() &lt;&lt; endl;\n    return 0;\n}\n\n程序结果：\n    8\n    8\n    8\n    9</code></pre>\n<p>按值捕获可以看作Lambda函数生成了一个const类型的变量，它的值是不会因为外部更新而更新的；同样引用捕获相当于调用a的内存地址，保证实时更新，如果想要Lambda函数在调用时访问的外部变量是最新的，我们就需要使用按引用捕获。</p>\n<p>如果非要做到修改值捕获变量的值，就可以使用mutale关键字；默认情况下，lambda函数是一个const函数，而mutable也可以取消常量性，例如：</p>\n<pre><code class=\"cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int a = 10;\n    auto f = [=]()mutable{return a *= 10;};//取消常量性\n    cout &lt;&lt; f() &lt;&lt; endl;\n    return 0;\n}\n\n程序结果：\n    100</code></pre>\n<p> mutable 修饰的 Lambda 表达式就算没有参数也要写明参数列表，这里的<code>()</code>表示没有省略，只是没有参数而已。</p>\n","path":"c-zhong-guan-yu-lambda-biao-da-shi-de-zong-jie.html","permalink":"https://www.yshawlon.cn/c-zhong-guan-yu-lambda-biao-da-shi-de-zong-jie.html","tags":[{"name":"Lambda","_id":"clq6dy48o000uikw0u5fbzyte","slug":"Lambda","path":"tags/Lambda/","permalink":"https://www.yshawlon.cn/tags/Lambda/","length":1}],"categories":[{"name":"C++","_id":"clq6dy48e000hikw0uy63x2a1","slug":"C","path":"categories/C/","permalink":"https://www.yshawlon.cn/categories/C/","length":5}],"prev":{"title":"使用Java Arrays类进行排序","date":"2021-10-21T06:02:24.000Z","summary":"C语言有qsort()函数，C++有sort()函数，java语言有Arrays类（与Array区分）","slug":"使用Java-Arrays类进行排序","published":true,"updated":"2021-10-21T06:58:21.958Z","_id":"clq6dy4a7002likw040vcio4s","layout":"post","photos":[],"link":"","excerpt":"","path":"shi-yong-java-arrays-lei-jin-xing-pai-xu.html","permalink":"https://www.yshawlon.cn/shi-yong-java-arrays-lei-jin-xing-pai-xu.html","__post":true},"next":{"title":"暑假LeetCode刷题集合（下）","date":"2021-07-27T08:48:27.000Z","summary":"不知不觉就已经一个月了，对基本的算法熟悉了很多，争取再坚持一个月hh","slug":"暑假LeetCode刷题集合（下）","published":true,"updated":"2022-05-23T15:24:45.762Z","_id":"clq6dy4ar003pikw0vg0q3poc","layout":"post","photos":[],"link":"","excerpt":"","path":"shu-jia-leetcode-shua-ti-ji-he-xia.html","permalink":"https://www.yshawlon.cn/shu-jia-leetcode-shua-ti-ji-he-xia.html","__post":true},"__post":true}