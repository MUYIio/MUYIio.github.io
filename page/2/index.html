<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Shawlon`s Blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script></head>


 <div id="loading-container">
     <p class="loading-text"></p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url()">
        </div>
    </section>
    <section class='menu'>
        <div>Shawlon`s Blog</div>
        
            <div>Yshawlon</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/windows-ubuntu20-04-shuang-xi-tong-an-zhuang-jiao-cheng.html">Windows+Ubuntu20.04双系统安装教程</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-08T06:07:52.000Z" itemprop="datePublished">
    2021-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Ubuntu20-04/">Ubuntu20.04</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Windows/">Windows</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/双系统/">双系统</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>由于需要在Linux下写代码，之前虚拟机安装过centos，但运行速度不理想，使用颇为受限，故安装双系统，这篇教程没有繁琐赘述，重要之处以及我所遇到的一些BUG都会详细说明。</p>
<h2 id="1-为什么选择Ubuntu20-04"><a href="#1-为什么选择Ubuntu20-04" class="headerlink" title="1. 为什么选择Ubuntu20.04"></a>1. 为什么选择Ubuntu20.04</h2><p>之前使用centos，但是centos8.x已经不再维护，综合其他一些原因选择Ubuntu，而且这个发行版本会维护5年（具体到哪一年忘记了），很多需要用到的软件也会一直支持。</p>
<h2 id="2-我的电脑配置"><a href="#2-我的电脑配置" class="headerlink" title="2. 我的电脑配置"></a>2. 我的电脑配置</h2><ul>
<li>惠普战99 工作站</li>
<li>Windows10 家庭版 64</li>
<li>16GRAM</li>
<li>固态硬盘256，2T机械</li>
</ul>
<h2 id="3-安装方式"><a href="#3-安装方式" class="headerlink" title="3. 安装方式"></a>3. 安装方式</h2><p>上面说到了，我的固态硬盘其实所剩无几，于是选择安装在机械硬盘（需要几百兆SSD容量），我压缩了500G的机械硬盘空间来给·Ubuntu，有条件的全部在分在固态硬盘就行。</p>
<p><strong>另外重要两点</strong></p>
<ul>
<li>Ubuntu的/SWAP（虚拟内存）分区最好在固态硬盘这样读写速度会快一点（建议），具体大小根据RAM决定，后面会说明。</li>
<li>Ubuntu的/boot分区要分在Windows系统盘，这样才能在Windows状态下读取到Ubuntu，否则会出现无法启动Ubuntu的情况。</li>
</ul>
<h1 id="一、制作启动硬盘"><a href="#一、制作启动硬盘" class="headerlink" title="一、制作启动硬盘"></a>一、制作启动硬盘</h1><h2 id="1-下载Ubuntu20-04-ISO"><a href="#1-下载Ubuntu20-04-ISO" class="headerlink" title="1. 下载Ubuntu20.04 ISO"></a>1. 下载Ubuntu20.04 ISO</h2><p><a href="https://ubuntu.com/#download" target="_blank" rel="noopener">官网入口</a>下载LTS版本，我是直接下载的，搭配迅雷下载器还是很快的几分钟吧，如果速度很慢可以从华为或者<a href="https://mirrors.tuna.tsinghua.edu.cn/#" target="_blank" rel="noopener">清华大学镜像网站</a>下载。</p>
<h2 id="2-下载-UltraISO并制作启动U盘"><a href="#2-下载-UltraISO并制作启动U盘" class="headerlink" title="2.下载 UltraISO并制作启动U盘"></a>2.下载 UltraISO并制作启动U盘</h2><p><a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">UltraISO官网入口</a>点免费下载试用，安装好后打开点击免费试用。</p>
<p><strong>准备一个4G以上大小的U盘，制作过程中会格式化U盘，记得备份文件</strong></p>
<p>选择好下载的UbuntuISO文件打开，点击【启动】→【写入硬盘映像】如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/01.png" alt></p>
<p>写入方式选择【USB-HDD+】<br><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/02.png" alt></p>
<p>点击【写入】会弹出格式化U盘提示点击确定等待写入完成即可。</p>
<h1 id="二、为Ubuntu分配磁盘空间"><a href="#二、为Ubuntu分配磁盘空间" class="headerlink" title="二、为Ubuntu分配磁盘空间"></a>二、为Ubuntu分配磁盘空间</h1><p>我们需要在固态硬盘（也就是系统盘）分出300M-500M的空间用于Ubuntu的/boot分区来作为启动引导文件（否则无法启动Ubuntu，具体原因百度），另外如果固态硬盘充足可以预留处/SWAP分区的空间。</p>
<p>swap,电脑内存8G大小就分配内存两倍的空间,8G以上跟内存一样大或者稍大1、2个G,交换空间,虚拟内存，这个建议分固态硬盘的区，不然会影响运行速度，机械硬盘也是可以用的.</p>
<p>右键点击【此电脑】，选择【管理】→【磁盘管理】，选择想压缩的盘右键单击可以看到压缩卷，点进去就能看到可压缩大小，单位是MB，我在机械硬盘分了500G大小，固态硬盘分了20G大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/03.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/04.png" alt></p>
<p>这是我压缩好后的样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/05.png" alt></p>
<p><strong>由于电脑存储文件并非连续的，比如前面20G使用了，之间空了10G，后面的又占用了，那么这10G也就无法压缩。所以会出现可压缩空间远远小于剩余空间</strong></p>
<p><strong>解决方法参考：</strong></p>
<p><a href="https://blog.csdn.net/yturhd87b_gdvy/article/details/87933467?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control" target="_blank" rel="noopener">进行磁盘分区时，“可用压缩空间”远小于真实的空间大小时的设置方法</a></p>
<p><a href="https://blog.csdn.net/Rained_99/article/details/54023914?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161781081216780264038570%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161781081216780264038570&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-54023914.first_rank_v2_pc_rank_v29&utm_term=c%E7%9B%98%E5%8E%8B%E7%BC%A9%E5%8D%B7%E5%8E%8B%E7%BC%A9%E7%A9%BA%E9%97%B4%E9%9D%9E%E5%B8%B8%E5%B0%8F%E6%80%8E%E4%B9%88%E5%8A%9E&spm=1018.2226.3001.4187" target="_blank" rel="noopener">Windows系统压缩卷时可压缩空间远小于实际剩余空间解决方法</a></p>
<h1 id="三、安装Ubuntu"><a href="#三、安装Ubuntu" class="headerlink" title="三、安装Ubuntu"></a>三、安装Ubuntu</h1><h2 id="1-查看电脑BIOS模式"><a href="#1-查看电脑BIOS模式" class="headerlink" title="1. 查看电脑BIOS模式"></a>1. 查看电脑BIOS模式</h2><p>WIN+R输入msinfo32，回车确认</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/06.png" alt></p>
<p><strong>BIOS模式，传统代表MBR，另外就是UEFI，Ubuntu是UFFI模式</strong></p>
<h2 id="2-BiOS安装准备"><a href="#2-BiOS安装准备" class="headerlink" title="2. BiOS安装准备"></a>2. BiOS安装准备</h2><p>插入我们制作好的启动硬盘，开机按F10进入BiOS模式（不同的电脑进入方式可能不同，另外建议把英文改为中文，方法自行百度）</p>
<p>不会操作先看说明，我的是按F1，选择【系统设置】→【启动选项】</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/07.png" alt></p>
<p>将【U盘/USB硬盘】更改为首选项，我的电脑是按F5/F6移动，F10保存。</p>
<p>保存退出后，电脑会自动重启进入Ubuntu的安装。</p>
<h2 id="3-开始安装"><a href="#3-开始安装" class="headerlink" title="3. 开始安装"></a>3. 开始安装</h2><p>①. 将语言改为中文或者英文，点击安装Ubuntu</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/08.png" alt></p>
<p>②. 键盘布局选择【Chinese】，后面的连接网络我就跳过了，如果要选择【正常安装】要联网。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/09.png" alt></p>
<p>③. 由于我准备的硬盘大小充足，所以我选择【正常安装】，也可以选择【最小安装】不影响使用。其他的在图中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/10.png" alt></p>
<p>④. 安装类型选择其他选择其他选项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/11.png" alt></p>
<p><strong>⑤. 创建分区，这是最重要的一步，我的分区如下：</strong></p>
<p><strong>- 注意：先分逻辑区，再分主分区</strong></p>
<ul>
<li><p>1./swap交换分区（虚拟内存），逻辑分区，我分了16GB（8G及以下RAM选择两倍大小，以上跟RAM大小一样就行）</p>
</li>
<li><p>2./boot分区 ，逻辑分区，默认ext4。 我分了将近300M，放置Ubuntu的启动引导文件，</p>
</li>
<li><p>3./ 根分区（root分区），逻辑分区，我选择100G就可以，默认ext4，</p>
</li>
<li><p>4./home分区，主分区，默认ext4，我选择400G，用户的所有文件都在这里。</p>
</li>
</ul>
<p><strong>说明：交换分区和/boot分区容量我都是在c盘压缩的，/和/home分区总共500G是在机械硬盘分的，另外根据自己的实际情况合理分配就行了，按照我的比例。</strong></p>
<p>不清楚Linux分区的自行百度或者查看这篇文章：<a href="https://zhuanlan.zhihu.com/p/122335496" target="_blank" rel="noopener">Linux下硬盘分区：根分区（/）交换分区（/swap）和/boot分区</a></p>
<p>分区按照我上面的说明来就行，我就不一一展示了，位置选择压缩好的空闲分区（或者用分区助手创建的分区，看大小和使用量就知道，创建的分区不是空闲分区，不能点加号，更改为可用就行），点左下角加号创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/12.png" alt></p>
<p><strong>安装启动引导器的设备选择/boot分区那个路径，然后点击【现在安装】</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/13.png" alt></p>
<p>⑥. 开始安装，我只用了20分钟不到就安装好了，没有几个小时，一次成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/14.png" alt></p>
<h2 id="4-更改BIOS启动选项"><a href="#4-更改BIOS启动选项" class="headerlink" title="4. 更改BIOS启动选项"></a>4. 更改BIOS启动选项</h2><p>安装好Ubuntu之后，<strong>拔下U盘（不拔等会开机还会进入Ubuntu安装）</strong>，右上角关机，彻底关机后开机F10进入BIOS，跟之前的步骤一样，<strong>选择【系统设置】→【启动选项】，将【操作系统的启动管理员】上移</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/15.png" alt></p>
<p>按ENTER将Ubuntu启动移到第一位，保存退出，开机进入启动界面就可以看到选项了，第一位是Ubuntu，第三个是Windows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/16.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/17.png" alt></p>
<h2 id="四-安装完成"><a href="#四-安装完成" class="headerlink" title="四. 安装完成"></a>四. 安装完成</h2><p>至此Ubuntu安装全部完成，接下来就可以愉快的使用Linux了，遇到不会的建议先查看官方文档。如果教程有什么不足之处欢迎指正评论。学无止境，希望这篇文章对你有所帮助！</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hexo-wang-zhan-bu-shu-node-ban-ben-guo-gao-pei-zhi-wen-ti.html">Hexo网站部署node版本过高配置问题</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-02-19T11:16:24.000Z" itemprop="datePublished">
    2021-02-19
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Hexo/">Hexo</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Blog/">Blog</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>前几天更新了node，部署博客的时候发现部署不了了。主要的提示如下，查了一下发现是node版本过高，更新前是13.x，更新后是14.15.5。</p>
<p><strong>The “mode” argument must be integer. Received an instance of Object</strong></p>
<p>网上的解决办法林林总总，使用NVM我感觉挺麻烦，于是来个直接点的。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener">点击此处</a>进入node官网下载，尽量选择与更新前版本相近的版本，我下载的13.14.0，选择.msi后缀下载到本地，卸载更新的nodejs，重新安装就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/node%E7%89%88%E6%9C%AC/6.png" alt></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="1】找到node安装位置"><a href="#1】找到node安装位置" class="headerlink" title="1】找到node安装位置"></a>1】找到node安装位置</h3><p>不知道安装位置的，可以Win+R输入cmd按下回车，输入where node查询：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/node%E7%89%88%E6%9C%AC/0.png" alt></p>
<h3 id="2】下载旧版本node"><a href="#2】下载旧版本node" class="headerlink" title="2】下载旧版本node"></a>2】下载旧版本node</h3><p><a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener">点击此处</a>进入node官网下载，尽量选择与更新前版本相近的版本，我下载的13.14.0，下载到本地文件夹解压打开如图，删除圈中的三个文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/node%E7%89%88%E6%9C%AC/1.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/node%E7%89%88%E6%9C%AC/2.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/node%E7%89%88%E6%9C%AC/3.png" alt></p>
<h3 id="3】替换node本地文件"><a href="#3】替换node本地文件" class="headerlink" title="3】替换node本地文件"></a>3】替换node本地文件</h3><p>打开本地node安装位置，删除里面的所有文件，将我们下载的node替换进去：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/node%E7%89%88%E6%9C%AC/4.png" alt></p>
<p>这样就🆗啦，如果不行重启一下试试，输入hexo -v可以看到node版本已经变更：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/node%E7%89%88%E6%9C%AC/5.png" alt></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/yong-ju-ti-shu-xue-jie-jue-yue-se-fu-huan-wen-ti.html">用具体数学解决约瑟夫环问题</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-01-10T05:03:34.000Z" itemprop="datePublished">
    2021-01-10
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/约瑟夫环/">约瑟夫环</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/算法/">算法</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p><strong>有 n 个人围成一个圈，每 q 个人踢掉一个人，问最后留下来的人是几号？</strong></p>
<p>使用链表暴力求解时间复杂度是 O(qn)，递归的话是 O(n) ,使用这个方法可以加速到 O(logn).</p>
<hr>
<h3 id="解法思路："><a href="#解法思路：" class="headerlink" title="解法思路："></a>解法思路：</h3><p>假设初始编号为<font color="red" size="4"> 1，2，3 … n </font>，现在考虑一种新的编号方式。</p>
<p>第一个人不会被踢掉，那么他的编号从<font color="red" size="4"> n </font>开始往后加<font color="red" size="4"> 1 </font>，变成<font color="red" size="4"> n+1 </font>，然后第二个人编号变为<font color="red" size="4"> n+2 </font>，直到第<font color="red" size="4"> q </font>个人，他被踢掉了。</p>
<p>然后第<font color="red" size="4"> q+1 </font>个人编号继续加<font color="red" size="4"> 1 </font>，变成了<font color="red" size="4"> n+q </font>，依次下去。</p>
<p>考虑当前踢到的人编号为<font color="red" size="4"> kq</font>，那么此时已经踢掉了<font color="red" size="4"> k </font>个人，所以接下去的人新的编号为<font color="red" size="4"> n+k(q-1)+1…</font>。</p>
<p>所以编号为<font color="red" size="4"> kq+d </font>的人编号变成了<font color="red" size="4"> n+k(q-1)+d </font> ，其中<font color="red" size="4"> 1&lt;=d&lt;q</font>;</p>
<p><strong>直到最后，可以发现活下来的人编号为<font color="red" size="4"> qn </font>，问题是怎么根据这个编号推出他原来的编号？</strong></p>
<p>以 n=10 , q=3 为例，下图就是每个人新的编号：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">11</td>
<td align="center">12</td>
<td align="center">T</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">T</td>
<td align="center">15</td>
<td align="center">16</td>
<td align="center">T</td>
<td align="center">17</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center">19</td>
<td align="center">20</td>
<td align="center"></td>
<td align="center">T</td>
<td align="center">21</td>
<td align="center"></td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">23</td>
<td align="center">24</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center">25</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">26</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">27</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">28</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">29</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">30</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>令：</strong><br>$$<br>\quad N=n+k(q-1)+d<br>$$<br>则他上一次的编号为：<br>$$<br>\quad kq+d=kq+N-n-k(q-1)=k+N-n<br>$$</p>
<p>$$<br>又 \because k=\frac{N-n-d}{q-1}=\left\lfloor\frac{N-n-1}{q-1}\right\rfloor<br>$$</p>
<p>所以他上一次的编号可以写为：<br>$$<br>\left\lfloor\frac{N-n-1}{q-1}\right\rfloor+N-n<br>$$</p>
<p>因此最后存活的人可以这样计算：</p>
<pre class="line-numbers language-c++"><code class="language-c++">N = qn
while N > n:
    N = k + N - n
ans = N<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<font color="red" size="4"> k </font>等于：<br>$$<br>k=\left\lfloor\frac{N-n-1}{q-1}\right\rfloor<br>$$<br><strong>如果用<font color="red" size="4"> D=qn+1-N </font>代替<font color="red" size="4"> N </font>,那么算法可以简化为：</strong><br>$$<br>\begin{array}{l}<br>D=q n+1-N \<br>=q n+1-\left(\left\lfloor\frac{(q n+1-D)-n-1}{q-1}\right\rfloor+q n+1-D-n\right) \<br>=n+D-\left[\frac{(q-1) n-D}{q-1}\right] \<br>=D-\left\lfloor\frac{D}{q 1}\right\rfloor \<br>=D+\left\lceil\frac{D}{q-1}\right\rceil \<br>=\left\lceil\frac{q}{q-1} D\right\rceil<br>\end{array}<br>$$<br>算法伪代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">D = 1
while D <= (q-1)n:
    D = k
ans = qn + 1 - D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<font color="red" size="4"> k</font> 等于：<br>$$<br>k=\left\lceil\frac{q}{q-1} D\right\rceil<br>$$</p>
<hr>
<h3 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h3><pre class="line-numbers language-c++"><code class="language-c++">//c++代码
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

LL Ceil(LL x, LL y) {
  return x / y + (x % y != 0);
}

LL J(LL n, LL q) {
  LL D = 1, end = (q - 1) * n;
  while (D <= end) {
​    D = Ceil(q * D, q - 1);
  }
  return q * n + 1 - D;
}

int main() {
  LL n, q;
  while (~scanf("%lld%lld", &n, &q)) {
​    printf("%lld\n", J(n, q));
  }
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/ru-he-shi-xian-yi-ge-gong-ping-de-xi-pai-suan-fa.html">如何实现一个公平的洗牌算法</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-01-10T05:02:38.000Z" itemprop="datePublished">
    2021-01-10
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/洗牌/">洗牌</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/随机/">随机</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/算法/">算法</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>设计一个公平的洗牌算法</p>
<p>就像打牌的时候一样，我们洗牌之后并不知道牌的顺序变成什么样，当然，前提是这个牌洗转了。正如这个问题，核心的点是<strong>公平</strong>，怎样才叫公平呢？</p>
<h3 id="暴力解法："><a href="#暴力解法：" class="headerlink" title="暴力解法："></a>暴力解法：</h3><p>n个数的全排列有n！个，那么随机拿出这里面任意一个结果也算公平。但是它的时间复杂度是O(n!)！原地爆炸boom<del>boom</del></p>
<h3 id="Knuth-洗牌算法"><a href="#Knuth-洗牌算法" class="headerlink" title="Knuth 洗牌算法:"></a>Knuth 洗牌算法:</h3><p>至于Knuth何许人也，感兴趣的可以去查一下。微软是 IT 界老大的年代，比尔盖茨直接说，如果你看完了Knuth写的《The Art of Computer Programming》第一卷本，请给我发简历。</p>
<p>生成的排列中，也就是我们的结果，<strong>每一个元素都能独立等概率的出现在每一个位置</strong>。或者反过来，<strong>每一个位置都能独立等概率的放置每个元素</strong>。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// rand(0, i) 生成 [0, i] 之间的随机整数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>很好理解，i从后向前，每次生成0~i之间的一个随机数，然后将i和这个随机数交换， swap(arr[i], arr[rand(0, i)]) 看出，i可以跟自己交换。（<strong>假想rand()无偏</strong>）</p>
<h4 id="为什么公平呢？"><a href="#为什么公平呢？" class="headerlink" title="为什么公平呢？"></a>为什么公平呢？</h4><p><strong>对于生成的排列，每一个元素都能等概率的出现在每一个位置</strong></p>
<p><strong>示例：</strong>现有6个数从小到大排列：1 2 3 4 5 6</p>
<ul>
<li>首先随机选择一个数和6进行交换，假设是3</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/1.png" alt></p>
<p>因为可以和自己交换，我们可以知道3出现在最后的概率是1/6</p>
<ul>
<li>选择到5，假设和2交换</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/2.png" alt></p>
<p>同样的第一轮2没有被选中，那么它逃掉的概率是5/6，第二轮被选中的概率是1/5，那么它被选中的概论等于5/6x1/5=1/6</p>
<ul>
<li>到4，假设和1交换</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/3.png" alt></p>
<p>1被选中的概率等于5/6x4/5x1/4=1/6</p>
<p><strong>看到这里，应该知道后面的概率也是1/6了，所以这个算法是公平的，可以自己去实验一下。最后这个算法的时间复杂度是O(n)</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/xun-zhao-duo-shu-yuan-su-zhu-yuan-su-wen-ti.html">寻找多数元素（主元素）问题</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-01-06T16:31:05.000Z" itemprop="datePublished">
    2021-01-07
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/主元素/">主元素</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/多数元素/">多数元素</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/算法/">算法</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>给定一个序列，如果其中一个数出现的次数超过50%，请找出这个数.（默认都是存在众数的）</p>
<p><strong>示例输入：</strong></p>
<p>已知序列：[2,3,2,5,2,6,2,2]，找出主元素</p>
<p><strong>示例输出：</strong></p>
<p>2</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>最简单的就是记录每个数字出现的次数，暴力解题。但是时间复杂度为O(n²)。</p>
<p>c语言代码：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
    int n;
    int a[101];
    int count, max=0;
    printf("数据个数:\n");
    scanf("%d", &n);
    int i, j, k = 0;
    for (i = 1; i <= n; ++i)           //循环存入数据
    {
        scanf("%d", &a[i]);
    }
    for (i = 1; i <= n; ++i)           //遍历每一个数据
    {
        count = 0;
        for (j = 1; j <= n; ++j)
        {
            if (a[i] == a[j] && i != j)       //遇到相同的数据，计数器加1
            {
                count++;
            }
        }
        if (count > max)                //寻找有相同数据最多的数
        {
            max = count;
            k = a[i];
        }
    }
    printf("%d\n",k);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h4><p>对所有的数进行递增排序，如果有一个数出现的次数超过50%，那么它一定位于n/2这个位置。时间复杂度为O(nlogn)。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*对于堆，作向下调整，对内部变量h[101]作调整*/</span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">siftdown2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> num<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    j <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> h<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token operator">*</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            i <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> h<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token operator">*</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> t<span class="token punctuation">;</span>
            t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
            j <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数据个数:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//循环存入数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">siftup</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//堆排序</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token keyword">int</span> num <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//遍历每一个数据</span>
    <span class="token punctuation">{</span>
        a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token operator">--</span>num<span class="token punctuation">;</span>
        <span class="token function">siftdown2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//对于堆，作向下调整，对内部变量h[101]作调整</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span>c<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">//找出下一个较小的数，与前一个比较是否相等</span>
        <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> max<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//寻找有相同数据最多的数</span>
            <span class="token punctuation">{</span>
                max <span class="token operator">=</span> count<span class="token punctuation">;</span>
                k <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        c <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>堆排序一个数组，排好后在主函数中给出第一个数，与第二个数比较，如相等count加1，如不相等，与max比较，更新max，最终找出多数元素</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*对于堆，作向上调整，对内部变量h[101]作调整*/</span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">siftup</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            j <span class="token operator">=</span> i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> t<span class="token punctuation">;</span>
            t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
            i <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个算法的时间复杂度是O(N+M)，空间复杂度也是O(N+M)。但是，如果序列中数的大小跨度比较大这个方法就不行了，空间开销非常大。那么看看下面的方法。</p>
<h4 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h4><p>也许你不知道，像这种序列的有一个特性，就是在<strong>原序列中去除两个不一样的数，原序列中出现超过50%的那个数，在取出的新序列中出现的次数也一定会超过50%</strong>。现在知道了，有没有想到解题的方法呢？</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//初始化</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
               temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
               count<span class="token operator">++</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> temp<span class="token punctuation">)</span>
              count<span class="token operator">++</span><span class="token punctuation">;</span>
          <span class="token keyword">else</span> 
              count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"最多的数是:%d\n"</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Boyer-Moore 投票算法</strong></p>
<p><strong>如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</strong></p>
<p>Boyer-Moore 算法的本质和分治十分类似。 Boyer-Moore 算法的详细步骤：</p>
<p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>
<p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>
<p>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p>
<p>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p>
<p>在遍历完成后，candidate 即为整个数组的众数。</p>
<p>举一个具体的例子，例如下面的这个数组：</p>
<pre><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></pre><p>在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</p>
<p>Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p>
<p>首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p>
<p>那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p>
<pre><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></pre><p>作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p>
<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</code></pre><p>我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p>
<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</code></pre><p>有没有发现什么？我们将 count 和 value 放在一起：</p>
<pre><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</code></pre><p>发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p>
<p>为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p>
<p><strong>这样以来，由于：</strong></p>
<p>我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p>
<p>由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p>
<p>在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>复杂度分析:</strong></p>
<ul>
<li><p>时间复杂度：O(n)O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</p>
</li>
<li><p>空间复杂度：O(1)O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</p>
</li>
</ul>
<p>这个算法最初是在《啊哈！算法》看到的，通过最后一个方法可以将时间复杂度优化到O(n)，</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/zen-yang-gao-bie-wo-de-2020-ni.html">怎样告别我的2020呢？</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-31T15:33:07.000Z" itemprop="datePublished">
    2020-12-31
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/随笔/">随笔</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/随笔/">随笔</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>赶在2021前写下这篇文章，想要总结一下2020，实在没什么好总结的，就是一团糟。</p>
<h2 id="一】"><a href="#一】" class="headerlink" title="一】"></a>一】</h2><p><strong>1.大二上快结束了，这一年也还凑合，懈怠了没有达到自己的目标。</strong></p>
<p>怎么说呢，一方面，定下的目标一拖再拖，拖延症重度。另一方面感觉时间太碎片化了，就很难专心的去做一件事。所以一年下来也没干什么，自己学了c++，看了几本操作系统的书，看完了《啊哈算法》，目前在学习数据结构。</p>
<hr>
<p><strong>2.跟我的丫头三年了，特此记录一下！年年岁岁有今朝！</strong></p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/qq_pic_merged_1609593274276.jpg" alt></p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/mmexport1609590475285.jpg" alt></p>
<h2 id="二】"><a href="#二】" class="headerlink" title="二】"></a>二】</h2><p><strong>总之，一步一步来吧，一口也吃不下大象。其他的就不一一列举了，不想为此贴上什么标准。思想上总是很矛盾的，行为上兴奋精神上疲惫。一步一步下来自己的目标变得清晰，感受到时间的紧迫，对未来越来越迷茫</strong></p>
<p>打出几个字好像就绞尽脑汁了，那就省去无病呻吟吧。希望2021能够有所改变。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hash-suan-fa.html">Hash算法</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-29T14:37:41.000Z" itemprop="datePublished">
    2020-12-29
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Hash/">Hash</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/算法/">算法</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h2 id="哈希算法-Hash-Function"><a href="#哈希算法-Hash-Function" class="headerlink" title="哈希算法(Hash Function)"></a>哈希算法(Hash Function)</h2><blockquote>
<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</p>
</blockquote>
<p><strong>构成哈希算法的条件：</strong></p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<h2 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h2><h3 id="一、MD5算法"><a href="#一、MD5算法" class="headerlink" title="一、MD5算法"></a>一、MD5算法</h3><p><strong>最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA（Secure Hash Algorithm，安全散列算法）。</strong></p>
<p>其他加密算法 <strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p>
<p><strong>加密哈希算法，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</strong></p>
<p>MD5目前最有效的攻击方式就是<strong>彩虹表</strong>，具体可以通过谷歌了解。 MD5相当于超损压缩。，但网络上也有针对MD5中出现的彩虹表，最常见的思路是在密码后面添加一组 盐码(salt), 比如可以使用md5(1234567.’2019@STARK-%$#&amp;-idje-789’),2019@STARK-%$#&amp;-idje-789作为盐码起到了一定的保护和安全的作用。</p>
<p>MD5不可逆的原因是其是一种<strong>散列函数</strong>，使用的是hash算法，在计算过程中原文的部分信息是丢失了的。像MD5,有2^128个不同的哈希值，所以散列冲突的概率是很小的；如果我们拿到一个 MD5 哈希值，希望通过毫无规律的穷举的方法，找到跟这个 MD5 值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是被很难破解的。</p>
<p>MD5算法：①确定性，②不可逆性</p>
<p><strong>主要用途：</strong></p>
<ol>
<li>防止被篡改：<ul>
<li>比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。</li>
<li>比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。</li>
<li>SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5.</li>
</ul>
</li>
<li>防止直接看到明文： 现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。）</li>
<li>防止抵赖（数字签名）： 这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。</li>
</ol>
<p><strong>实现：</strong><br>在包java.security有个类MessageDigest。<br><em>官方文档如下 ：</em></p>
<blockquote>
<p>MessageDigest 类为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。信息摘要是安全的单向哈希函数，它接收任意大小的数据，输出固定长度的哈希值。<br>MessageDigest 对象开始被初始化。该对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算。<br>对于给定数量的更新数据，digest 方法只能被调用一次。digest 被调用后，MessageDigest 对象被重新设置成其初始状态。</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>MessageDigest<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMD5</span> <span class="token punctuation">{</span>
<span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hex <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'0'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">,</span><span class="token string">'8'</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">,</span><span class="token string">'E'</span><span class="token punctuation">,</span><span class="token string">'F'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        MessageDigest md5 <span class="token operator">=</span> MessageDigest<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"MD5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//申明使用MD5算法</span>
        md5<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"md5(a)="</span><span class="token operator">+</span><span class="token function">byte2str</span><span class="token punctuation">(</span>md5<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        md5<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        md5<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"bc"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"md5(abc)="</span><span class="token operator">+</span><span class="token function">byte2str</span><span class="token punctuation">(</span>md5<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 将字节数组转换成十六进制字符串
 * @param bytes
 * @return
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">byte2str</span><span class="token punctuation">(</span><span class="token keyword">byte</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   
    StringBuffer result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        <span class="token keyword">byte</span> byte0 <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   
        result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>hex<span class="token punctuation">[</span>byte0 <span class="token operator">>>></span> <span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
        result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>hex<span class="token punctuation">[</span>byte0 <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二、唯一标识-uuid"><a href="#二、唯一标识-uuid" class="headerlink" title="二、唯一标识(uuid)"></a>二、唯一标识(uuid)</h3><p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。<br>如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。<br>如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p>
<h3 id="三、数据校验"><a href="#三、数据校验" class="headerlink" title="三、数据校验"></a>三、数据校验</h3><p>BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。Nginx上有个分片技术，大概就是这个意思。<br>我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。<br>还有网盘的闪存，当你提交上传文件时，会先在本地计算出文件的哈希值，然后与网盘服务器中的哈希值比较，如果有一样的，说明服务器已经有这个文件了，直接指向服务器中的文件地址就行了。当然整个过程并不是这么简单，还有其他算法。</p>
<h3 id="四、散列函数"><a href="#四、散列函数" class="headerlink" title="四、散列函数"></a>四、散列函数</h3><p>散列函数也是哈希算法的一种应用。</p>
<p><strong>核心思想：</strong>定义一个散列函数h（k），使得对于给定的关键字k，散列函数h（k）将其转换为k所对应的逻辑地址</p>
<p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p>
<p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
<p><strong>使用散列函数应当避免原始数据相同的概率</strong></p>
<p><strong>散列函数实现方法：</strong></p>
<ul>
<li>平方取中法</li>
<li>折叠法</li>
<li>随机数法</li>
<li>除留余数法</li>
</ul>
<h3 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h3><p>我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。<br>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p>
<p>如果客户端很多，映射表可能会很大，比较<strong>浪费内存空间</strong>；<br>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</p>
<p>如果借助哈希算法，这些问题都可以非常完美地解决。我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h3 id="六、数据分片"><a href="#六、数据分片" class="headerlink" title="六、数据分片"></a>六、数据分片</h3><ol>
<li><p><strong>如何统计“搜索关键词”出现的次数？</strong><br>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？<br>我们来分析一下。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。<br>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。<br>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
</li>
<li><p><strong>如何快速判断图片是否在图库中？</strong><br> 如何快速判断图片是否在图库中？上一节我们讲过这个例子，不知道你还记得吗？当时我介绍了一种方法，即给每个图片取唯一标识（或者信息摘要），然后构建散列表。<br> 假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。<br> 我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。<br> 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。<br> 散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。<br> 假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。<br> 实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。</p>
<h3 id="七、分布式存储"><a href="#七、分布式存储" class="headerlink" title="七、分布式存储"></a>七、分布式存储</h3><p><strong>一致性哈希算法</strong><br>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/hexo-bo-ke-tian-jia-zai-xian-liu-yan-daovoice-shi-shi-lian-xi.html">Hexo博客添加在线留言DaoVoice实时联系</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-16T03:05:03.000Z" itemprop="datePublished">
    2020-12-16
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/DaoVoice/">DaoVoice</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Blog/">Blog</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>DaoVoice简介：</strong>DaoVoice 是一款革命性的应用运营平台，致力于帮助企业实现以用户为中心的「精益运营」体系。融合「在线聊天」、「客服支持」、「用户画像」、「消息推送」、「行为引导」等功能为一体， 按需获取用户信息和行为，实现场景化消息推送，让通知更富有人情味。只需数分钟的安装，你将与你网站用户及访客开启便捷沟通的窗口。<br>更多请查看：<a href="http://guide.daocloud.io/daovoice" target="_blank" rel="noopener">DaoVoice 用户手册</a></p>
<blockquote>
<p>“DaoVoice 帮我们更好地运营用户。实时在线沟通，可更快解决用户问题。后台管理可帮我们建立用户画像，针对不同的用户需求进行精准运营。此外，DaoVoice 团队会快速响应我们的反馈，给予高质量服务支持。”<br>——————-Travis 创始人 &amp; CEO</p>
</blockquote>
<h2 id="1-注册DaoVoice并获取安装代码"><a href="#1-注册DaoVoice并获取安装代码" class="headerlink" title="1.注册DaoVoice并获取安装代码"></a>1.注册DaoVoice并获取安装代码</h2><p><a href="http://dashboard.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a>入口</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DaoVoice/1.png" alt></p>
<h2 id="2-本地配置部署"><a href="#2-本地配置部署" class="headerlink" title="2.本地配置部署"></a>2.本地配置部署</h2><p><strong>我使用的是<font color="red" size="4">Hexo matery</font>主题，配置如下，不同主题可能需要改动：</strong></p>
<p>①复制下面代码放到<font color="red" size="4">theme/layout/_partial/head.ejs</font>中的 <font color="red" size="4"> /head&gt; </font>之前</p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>theme<span class="token punctuation">.</span>daovoice<span class="token punctuation">.</span>enable <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>daovoice<span class="token punctuation">.</span>appid<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>

  <span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> o<span class="token punctuation">,</span> g<span class="token punctuation">,</span> r<span class="token punctuation">,</span> a<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      i<span class="token punctuation">[</span><span class="token string">'DaoVoiceObject'</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
      i<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">||</span>
        <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token punctuation">(</span>i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>q <span class="token operator">=</span> i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>q <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
      i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
      m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      a<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      a<span class="token punctuation">.</span>src <span class="token operator">=</span> g<span class="token punctuation">;</span>
      a<span class="token punctuation">.</span>charset <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">;</span>
      m<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">,</span> <span class="token string">'script'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'https:'</span> <span class="token operator">===</span> document<span class="token punctuation">.</span>location<span class="token punctuation">.</span>protocol <span class="token operator">?</span> <span class="token string">'https:'</span> <span class="token punctuation">:</span> <span class="token string">'http:'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"//widget.daovoice.io/widget/&lt;%= theme.daovoice.appid %>.js"</span><span class="token punctuation">,</span> <span class="token string">'daovoice'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">daovoice</span><span class="token punctuation">(</span><span class="token string">'init'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      app_id<span class="token punctuation">:</span> <span class="token string">"&lt;%= theme.daovoice.appid %>"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">daovoice</span><span class="token punctuation">(</span><span class="token string">'update'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>

<span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>②复制下面代码到<font color="red" size="4">theme/_config</font>并填入<font color="red" size="4">ID</font></p>
<pre class="line-numbers language-htmlh"><code class="language-htmlh"># Online contact 在线客服 Daovoice 参考：http://dashboard.daovoice.io
daovoice:  # 在线客服 Daovoice 参考：http://dashboard.daovoice.io
  enable: true # 是否开启在线客服聊天
  appid: 'xxxxxx'  # 应用ID设置
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>ID在图示位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DaoVoice/1.png" alt></p>
<p>③最后:</p>
<pre class="line-numbers language-c"><code class="language-c">hexo clean    #清除缓存
hexo g   #生成hexo文件
hexo s  #预览
hexo d  #部署<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-DaoVoice个性化配置"><a href="#3-DaoVoice个性化配置" class="headerlink" title="3.DaoVoice个性化配置"></a>3.DaoVoice个性化配置</h2><p>选择【聊天设置】个性化设置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DaoVoice/3.png" alt><br><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DaoVoice/4.png" alt></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/shi-yong-jsdelivr-jia-su-github-bo-ke-wen-jian.html">使用JSDelivr加速Github、博客文件</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-12-13T09:15:54.000Z" itemprop="datePublished">
    2020-12-13
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Github/">Github</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/JSDelivr/">JSDelivr</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Blog/">Blog</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>前言</strong>：当我们博客添加了本地视频或者大量图片等等，会导致加载时间过长，这里我们用JSDelivr对其进行加速，相当于免费的的CDN。</p>
<h2 id="一、新建一个GitHub仓库"><a href="#一、新建一个GitHub仓库" class="headerlink" title="一、新建一个GitHub仓库"></a>一、新建一个GitHub仓库</h2><ul>
<li>仓库名称随便</li>
<li>仓库属性Public，不然JSDelivr无法访问</li>
<li>初始化Readme</li>
</ul>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/1.png" alt></p>
<h2 id="二、克隆创建仓库到本地"><a href="#二、克隆创建仓库到本地" class="headerlink" title="二、克隆创建仓库到本地"></a>二、克隆创建仓库到本地</h2><ul>
<li>本地打开Git Bash Here克隆仓库到指定文件夹</li>
</ul>
<pre class="line-numbers language-php"><code class="language-php">git clone <span class="token comment" spellcheck="true">//复制的链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/2.png" alt></p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/3.png" alt></p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/4.png" alt></p>
<h2 id="三、上传需要加速的文件"><a href="#三、上传需要加速的文件" class="headerlink" title="三、上传需要加速的文件"></a>三、上传需要加速的文件</h2><p>把要加速的文件复制到克隆的文件夹里，<strong>注意：JSDelivr不能加速超过50M的文件，如果文件超过50M，可以分次上传，到时候在仓库设置版本号，加速不同的版本就行了。</strong></p>
<ul>
<li>复制下面四个命令，在本地克隆的文件夹下Git Bash Here输入：</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js">git status                    <span class="token comment" spellcheck="true">//查看状态</span>
git add <span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">//添加所有文件到暂存区</span>
git commit <span class="token operator">-</span>m <span class="token string">'第一次提交'</span>      <span class="token comment" spellcheck="true">//把文件提交到仓库</span>
git push                      <span class="token comment" spellcheck="true">//推送至远程仓库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注：每次提交记得标明，比如第二次第三次，才能分辨，克隆的文件夹下含有.git文件夹，上传时会自动上传到创建的文件夹</strong></p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/5.png" alt></p>
<h2 id="四、创建版本"><a href="#四、创建版本" class="headerlink" title="四、创建版本"></a>四、创建版本</h2><p>还是我们创建的仓库</p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/6.png" alt><br><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/7.png" alt></p>
<p>版本便于我们区别就行，更新一次就更新一下版本。</p>
<h2 id="五、JSDelivr加速并引用资源"><a href="#五、JSDelivr加速并引用资源" class="headerlink" title="五、JSDelivr加速并引用资源"></a>五、JSDelivr加速并引用资源</h2><p><strong>使用方法：<a href="https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a></strong><br><strong>格式：<a href="https://cdn.jsdelivr.net/gh/user/repo@version/file" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></strong><br>例如：</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.0/Images/avatars/csdn.ico" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.0/Images/avatars/csdn.ico</a><br><a href="https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.0.1/music/stayalive.mp3" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/MUYIio/CDN@2.0.1/music/stayalive.mp3</a></p>
</blockquote>
<p><strong>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</strong></p>
<p>// 加载任何Github发布、提交或分支</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></p>
</blockquote>
<p>// 加载 jQuery v3.2.1</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></p>
</blockquote>
<p>// 使用版本范围而不是特定版本</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a><br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></p>
</blockquote>
<p>// 完全省略该版本以获取最新版本</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a></p>
</blockquote>
<p>// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></p>
</blockquote>
<p>// 在末尾添加 / 以获取资源目录列表</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></p>
</blockquote>
<p>具体可以参考官方文档说明：</p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/8.png" alt></p>
<p>把博客中的文件替换成链接就行了</p>
<p><strong>示例：</strong></p>
<p><img src="!%5B%5D(https://cdn.jsdelivr.net/gh/MUYIio/ImageHosting/img/9.png" alt></p>
<p>参考：<a href="https://blog.csdn.net/qq_36759224/article/details/86936453?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160785072016780288298586%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160785072016780288298586&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-86936453.first_rank_v2_pc_rank_v29&utm_term=%E4%BD%BF%E7%94%A8jsdeliver%E5%BC%80%E5%90%AFcdn&spm=1018.2118.3001.4449" target="_blank" rel="noopener">免费CDN：jsDelivr+Github 使用方法</a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/ge-ren-bo-ke-wang-zhan-bei-e-yi-ddos-gong-ji-zen-me-ban.html">个人博客、网站被恶意DDOS攻击怎么办</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-05T15:53:34.000Z" itemprop="datePublished">
    2020-07-05
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/随笔/">随笔</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/DDOS/">DDOS</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>起因</strong>：几天前我的博客遭受DDOS攻击，攻击次数高达85万次，腾讯云COS加CDN欠费400，作为一个小白碰到有点不知所措，所以记录一下我处理的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DDOS/00.png" alt></p>
<p>首先，我的网站Page在Github和TencentYun，同时托管在服务器上，之前觉得腾讯云COS够快就没使用GitHub免费图床（付钱还有风险）。</p>
<h3 id="拒绝服务攻击（DDoS）"><a href="#拒绝服务攻击（DDoS）" class="headerlink" title="拒绝服务攻击（DDoS）"></a>拒绝服务攻击（DDoS）</h3><p>DDoS(Distributed Denial of Service),即分布式拒绝服务攻击,是目前最为强大、最难以防御的攻击方式之一。要理解DDos,得先从DoS说起。</p>
<p>最基本的DoS攻击就是利用合理的客户端请求来占用过多的服务器资源,从而使合法用户无法得到服务器的响应。DDoS攻击手段是在传统的DoS攻击基础之上产生的一类攻击方式,传统的DoS攻击一般是采用一对一方式的,当攻击目标CPU速度、内存或者网络带宽等等各项性能指标不高的情况下,它的效果是明显的,但随着计算机与网络技术的发展,计算机的处理能力显著增加,内存不断增大,同时也出现了千兆级别的网络,这使得DoS攻击逐渐失去效果。这时候分布式拒绝服务攻击手段(DDoS)便应运而生了。你理解了DoS攻击以后, DDoS的原理就非常简单了,它指的是攻击者借助公共网络,将数量庞大的计算机设备联合起来作为 攻击平台,对一个或多个目标发动攻击,从而达到瘫痪目标主机的目的。通常,在攻击开始前,攻击者会提前控制大量的用户计算机,称之为“肉鸡”,并通过指令使大量的肉鸡在同一时刻对某个主机进行访问,从而达到瘫痪目标主机的目的。</p>
<p>DDoS的攻击有很多种类型,如依赖蛮力的ICMP Flood、UDP Flood等等,随着硬件性能的 提升,需要的机器规模越来越大,组织大规模的攻击越来越困难,现在已经不常见,还有就是依赖协议特征以及具体的软件漏洞进行的攻击,如Slowloris攻击,Hash碰撞攻击等等,这类攻击主要利用协议以及软件漏洞发起攻击,需要在特定环境下才会出现,更多的攻击者采用的是前面两种的混合方式,即利用了协议、系统的缺陷,又具备了海量的流量, 如SYN Flood、DNS Query Flood等等。</p>
<h3 id="这里再说一下另外一种CC攻击"><a href="#这里再说一下另外一种CC攻击" class="headerlink" title="这里再说一下另外一种CC攻击"></a>这里再说一下另外一种CC攻击</h3><p>CC(Challenge Collapsar)攻击属于DDos的一种,是基于应用层HTTP协议 发起的DDos攻击,也被称为HTTP Flood。</p>
<p>CC攻击的原理是这样的,攻击者通过控制的大量“肉鸡”或者利用从互联网上搜寻的大量匿名的HTTP代理,模拟正常用户给网站发起请求直到该网站拒绝服务为止。大部分网站会通过CDN以及分布式缓存来加快服务端响应,提升网站的吞吐量,而这些精心构造的HTTP请求往往有意避开这些缓存,需要进行多次DB查询操作或者是一次请求返回大量的数据,加速系统 资源消耗,从而拖垮后端的业务处理系统,甚至连相关存储以及日志收集系统也无法幸免。</p>
<h2 id="1】"><a href="#1】" class="headerlink" title="1】-"></a>1】-</h2><p>当我知道已经是第二天早上，收到腾讯云的通知，欠费400。让我一个学生措不及防，打开电脑看到COS请求85.8万次，我猜测应该是被攻击了，第一时间找了腾讯云投诉，经过腾讯云技术人员追查是DDOS攻击，查到的IP是美国的</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DDOS/01.png" alt></p>
<h2 id="2】"><a href="#2】" class="headerlink" title="2】-"></a>2】-</h2><p>网上查找解决办法：</p>
<p>1.找12315投诉，但是现在已经不受理这类纠纷。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DDOS/02.png" alt></p>
<p>2.找网警举报，可能是金额太低，我提交之后一直没有回复。</p>
<p>3.最后只能找客服了，几天的交流才给我补款。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DDOS/04.png" alt></p>
<p>腾讯云坚持不承担损失，只知道让我去找网警去找解决办法，我倒是不明白到底谁是用户了。口口声声说是我没有设置好安全防护，腾讯云作为产品的提供方，并没有将产品Bug完善，那么谁应该承担？</p>
<p><strong>腾讯云客服以我没有设置防盗链为由，并不承担损失。总的来说，不管设置阈值预警还是防盗链，都不能完全阻止网站被盗刷，那么我设置也就没有多大意义。次数少的攻击可以阻挡，但是上万的攻击就没用了，因为就算网站返回404页面也会产生流量，攻击次数多产生的流量就多了。</strong></p>
<p>##3】-</p>
<p>最后给我补款：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.3/Images/posts/DDOS/05.png" alt></p>
<p>不管是阿里云还是其他平台CDN盗刷，都是可以退款，前提是不是自己蓄意而为。</p>
<p><strong>总结：</strong>吃一堑长一智，建议做好网站的安全防护不给坏人可乘之机！</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-xue-xi-bi-ji-zheng-li-di-san-zhang-han-shu.html">C++学习笔记整理-函数</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-05-08T11:54:09.000Z" itemprop="datePublished">
    2020-05-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C/">C++</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p><strong>前面几章大体上和C差不多，就从函数开始吧。</strong></p>
<h2 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h2><h2 id="1-函数的定义与使用"><a href="#1-函数的定义与使用" class="headerlink" title="1 .函数的定义与使用"></a>1 .函数的定义与使用</h2><h3 id="函数定义的语法形式："><a href="#函数定义的语法形式：" class="headerlink" title="函数定义的语法形式："></a>函数定义的语法形式：</h3><pre class="line-numbers language-c++"><code class="language-c++">类型标识符  函数名（形式参数表）
{  
   语句序列
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>若无返回值，类型标识符写void </li>
<li>形式参数表：是被初始化的内部变量，寿命和可见性仅限于函数内部 </li>
</ul>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p><strong>调用前先声明函数：</strong></p>
<ul>
<li>若函数定义在调用点之前，则无需另外声明； </li>
<li>若函数定义在调用点之后，则需要在调用函数前按如下形式声明函数原型： </li>
</ul>
<p>类型标识符 被调用函数名（含类型说明的形参表）;</p>
<p><strong>调用形式：</strong> </p>
<p>函数名（实参列表）</p>
<ul>
<li>嵌套调用：     在一个函数的函数体中，可以调用另一函数，称为嵌套调用。 </li>
<li>递归调用：     函数直接或间接调用自身。 </li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//1.编写一个求x的n次方的函数

#include <iostream>
using namespace std;

//计算x的n次方
double power(double x,int n)
{
    double val=1.0;
    while(n--)
        val*=x;
    return val;
}

int main()
{
    cout << "5 to the power 2 is :"<< power(5, 2) << endl;
    return 0;
}




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//2.数制转换
//输入一个8位二进制数，将其转换为十进制数输出。
//例如：11012=1(23)+1(22)+0(21)+1(20)=1310 
//所以，如果输入1101，则应输出13

#include <iostream>
using namespace std;

double power (double x,int n); //计算x的n次方

int main()
{
    int  value=0;
    cout <<"Enter an 8 bit binary number ";
    for (int i=7;i>=0;i--) 
    {
      char ch;
      cin>>ch;
      if (ch =='1')
            value+=static_cast<int>(power(2, i));
    }
    cout<<"Decimal value is "<<value<<endl;
    return 0;
}

double power(double x,int n)
{
    double val=1.0;
    while(n--) 
      val*=x;
    return val;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">
/*3.编写程序求π的值
π=16arctan(1/5)-4arctan(1/239)
其中arctan用如下形式的级数计算：
arctanx=x-x^3/3+x^/5-x^7/7+...
直到级数某项绝对值不大于10-15为止；π和x均为double型。*/

#include <iostream>
using namespace std;

double arctan(double x)
{
    double sqr = x * x;
    double e = x;
    double r = 0;
    int i = 1;
    while (e / i > 1e-15) {
        double f = e / i;
        r = (i % 4 == 1) ? r + f : r - f;
        e = e * sqr;
        i += 2;
    }
    return r;
}

int main() 
{
    double a = 16.0 * arctan(1 / 5.0); 
    double b = 4.0 * arctan(1 / 239.0); 
    /* 注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0 */

    cout << "PI = " << a - b << endl;
    return 0;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*4.寻找并输出11~999之间的数m，它满足m、m2和m3均为回文数。
回文：各位数字左右对称的整数。
例如：11满足上述条件 
112=121，113=1331。
分析：
10取余的方法，从最低位开始，依次取出该数的各位数字。按反序重新构成新的数，比较与原数是否相等，若相等，则原数为回文。*/

#include <iostream>
using namespace std;
//判断n是否为回文数
bool symm(unsigned n)
{
  unsigned i = n;
    unsigned m = 0;
    while (i > 0) {
      m = m*10+i%10;
      i/=10;
  }
  return m==n;
}

int main()
{
    for(unsigned m = 11; m < 1000; m++)
      if (symm(m) && symm(m * m) &&
          symm(m * m * m)) {
        cout << "m = " << m;
        cout << "  m * m = " << m * m;
        cout << "  m * m * m = "
             << m * m * m << endl;
      }
    return 0;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>/<em>5.计算如下公式，并输出结果：</em><br>$$<br>k =  \begin{cases}     \sqrt{sin^2r+sin^2s} &amp; \text{}\  当r^2\leqslant s^2\     \frac{1}{2}sin(rs) &amp; \text{}\ 当r^2&gt; s^2&amp;  \end{cases}<br>$$<br>其中r、s的值由键盘输入</p>
<p>sin x的近似值按如下公式计算，计算精度为10-10：</p>
<p>$$ sinx=\frac{x}{1!}+\frac{x^3}{3!}+\frac{x^5}{5!}+\frac{x^7}{7!}+…=\displaystyle \sum_{n=1}^∞(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!} $$</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <cmath>  /*对C++标准库中数学函数的说明*/
using namespace std;

const double TINY_VALUE = 1e-10;

double tsin(double x) 
{
    double g = 0;
    double t = x;
    int n = 1;
    do {
        g += t;
        n++;
        t = -t * x * x / (2 * n - 1) / (2 * n - 2);
    } while (fabs(t) >= TINY_VALUE); 
    return g;
} 

int main() 
{
    double k, r, s;
    cout << "r = ";
    cin >> r;
    cout << "s = ";
    cin >> s;
    if (r * r <= s * s)
      k=sqrt(tsin(r)*tsin(r)+tsin(s)*tsin(s));
    else
      k = tsin(r * s) / 2;
    cout << k << endl;
    return 0;
}



//运行结果：
r=5
s=8
1.37781
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*6.投骰子的随机游戏

每个骰子有六面，点数分别为1、2、3、4、5、6。游戏者在程序开始时输入一个无符号整数，作为产生随机数的种子。
每轮投两次骰子，第一轮如果和数为7或11则为胜，游戏结束；和数为2、3或12则为负，游戏结束；和数为其它值则将此值作为自己的点数，继续第二轮、第三轮...直到某轮的和数等于点数则取胜，若在此前出现和数为7则为负。
由rolldice函数负责模拟投骰子、计算和数并输出和数。

rand
函数原型：int rand(void);
所需头文件：<cstdlib>
功能和返回值：求出并返回一个伪随机数

srand
函数原型：void srand(unsigned int seed);
参数：seed产生随机数的种子。
所需头文件：<cstdlib>
功能：为使rand()产生一序列伪随机整数而设置起始点。使用1作为seed参数，可以重新初化rand()。*/

#include <iostream>
#include <cstdlib>
using namespace std;

//投骰子、计算和数、输出和数
int rollDice() {
    int die1 = 1 + rand() % 6;
    int die2 = 1 + rand() % 6;
    int sum = die1 + die2;
    cout << "player rolled " << die1 << " + " << die2 << " = " << sum << endl;
    return sum;
}

enum GameStatus { WIN, LOSE, PLAYING };

int main() {
    int sum, myPoint;
    GameStatus status;

    unsigned seed; 
    cout<<"Please enter an unsigned integer: ";
    cin >> seed;//输入随机数种子
    srand(seed);//将种子传递给rand()

    sum = rollDice(); //第一轮投骰子、计算和数

switch (sum) {
    case 7:   //如果和数为7或11则为胜,状态为WIN
    case 11:
      status = WIN;
      break;
    case 2:   //和数为2、3或12则为负,状态为LOSE
    case 3: 
    case 12:
      status = LOSE;
      break;
    default: /*其它情况,游戏尚无结果,状态为
            PLAYING,记下点数,为下一轮做准备 */
      status = PLAYING;
      myPoint = sum;
      cout << "point is " << myPoint << endl;
      break;
    }

while (status == PLAYING) { //只要状态仍为PLAYING,就继续进 行下一轮
      sum = rollDice();
      if (sum == myPoint)    //某轮的和数等于点数则取胜
        status = WIN;
      else if (sum == 7)    //出现和数为7则为负
        status = LOSE;
    }

    //当状态不为PLAYING时上面的循环结束,以下程序段输出游戏结果
    if (status == WIN)
      cout << "player wins" << endl;
    else
      cout << "player loses" << endl;

    return 0;
}
//运行结果：
Please enter an unsigned integer:23
player rolled 6 + 3 = 9
point is 9
player rolled 5 + 4 = 9
player wins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>嵌套调用</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">//1.输入两个整数，求平方和

#include <iostream>
using namespace std;

int fun2(int m) 
{
    return m * m;
}

int fun1(int x,int y) 
{
    return fun2(x) + fun2(y);
}

int main() 
{
    int a, b;
    cout<<"Please enter two integers (a and b): ";
    cin >> a >> b;
    cout << "The sum of square of a and  b: " << fun1(a, b) << endl;
    return 0;
}


//运行结果：
Please enter two integers(a and b): 3 4
The sum of square of a and b: 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>递归调用</strong></p>
<p>//1.求n!<br>$$<br>n!=  \begin{cases}     1 &amp; \text{}\ (n=0)  \     n(n-1)! &amp; \text{}\ (n&gt; 0)  \ \end{cases}<br>$$</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
using namespace std;

unsigned fac(int n)
{
    unsigned f;
    if (n == 0)
      f = 1;
  else
      f = fac(n - 1) * n;
  return f;
}

int main() 
{
    unsigned n;
    cout << "Enter a positive integer:";
    cin >> n;
    unsigned y = fac(n);
    cout << n << "! = " << y << endl;
    return 0;
}

//运行结果：
Enter a positive integer:8
8! = 40320
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*2.用递归法计算从n个人中选择k个人组成一个委员会的不同组合数。

分析：
   由n个人里选k个人的组合数 = 由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数
当n = k或k = 0时，组合数为1*/

#include <iostream>
using namespace std;

int comm(int n, int k) {
    if (k > n)
      return 0;
    else if (n == k || k == 0)
      return 1;
    else
      return comm(n - 1, k) + comm(n - 1, k - 1);
}

int main() {
    int n, k;
    cout << "Please enter two integers n and k: ";
    cin >> n >> k;
    cout << "C(n, k) = " << comm(n, k) << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3.汉诺塔问题</strong></p>
<p>有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%871.png" alt="img"></p>
<p>分析：</p>
<ul>
<li><strong>将n 个盘子从A针移到C针可以分解为下面三个步骤：</strong></li>
<li>①将A 上n-1个盘子移到 B针上（借助C针）;</li>
<li>②把A针上剩下的一个盘子移到C针上;</li>
<li>③将n-1个盘子从B针移到C针上（借助A针）; </li>
<li><strong>事实上，上面三个步骤包含两种操作：</strong> </li>
<li>①将多个盘子从一个针移到另一个针上，这是一个递归的过程。 hanoi函数实现。</li>
<li>②将1个盘子从一个针上移到另一针上。 用move函数实现</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//3.汉诺塔问题

#include <iostream>
using namespace std;

//把src针的最上面一个盘子移动到dest针上
void move(char src, char dest) { 
    cout << src << " --> " << dest << endl;
}

//把n个盘子从src针移动到dest针，以medium针作为中介
void hanoi(int n, char src, char medium, char dest) {
    if (n == 1)
      move(src, dest);
    else {
      hanoi(n - 1, src, dest, medium);
      move(src, dest);
      hanoi(n - 1, medium, src, dest);
    }
}

int main() {
    int m;
    cout << "Enter the number of diskes: ";
    cin >> m;
    cout << "the steps to moving " << m << " diskes:" << endl;
    hanoi(m,'A','B','C');
    return 0;
}

//运行结果：
Enter the number of diskes:3
the steps to moving 3 diskes:
A --> C
A --> B
C --> B
A --> C
B --> A
B --> C
A --> C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><ul>
<li>在函数被调用时才分配形参的存储单元。 </li>
<li>实参可以是常量、变量或表达式。 </li>
<li>实参类型必须与形参相符。 </li>
<li>值传递是传递参数值，即单向传递。 </li>
<li>引用传递可以实现双向传递 </li>
<li>常引用作参数可以保障实参数据的安全 </li>
</ul>
<p><strong>引用传递</strong></p>
<p>引用(&amp;)是标识符的别名,例如:</p>
<pre class="line-numbers language-c++"><code class="language-c++">int i,j;
int &ri=i;//建立一个int型的引用ri,并将其初始化为变量i的一个别名
j=10;
ri=j;//相当于 i = j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。 一旦一个引用被初始化后，就不能改为指向其它对象。 引用可以作为形参:</p>
<pre class="line-numbers language-c++"><code class="language-c++">void swap(int &a, int &b) {...}
//1.输入两个整数交换后输出

#include<iostream>
using namespace std;
void swap(int& a, int& b) {
    int t = a;
    a = b;
    b = t;
}
int main() {
    int x = 5, y = 10;
    cout << "x = " << x << "  y = " << y << endl;
    swap(x, y);
    cout << "x = " << x << "  y = " << y << endl;
    return 0;
}

//运行结果:
x = 5   y = 10
x = 10  y = 5
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//2.值传递与引用传递的比较

#include <iostream>
#include <iomanip>
using namespace std;
void fiddle(int in1, int &in2) 
{
    in1 = in1 + 100;
    in2 = in2 + 100;
    cout<<"The values are ";
    cout << setw(5) << in1;
    cout << setw(5) << in2 << endl;
}

int main() { 
  int v1=7,v2=12;
  cout << "The values are ";
  cout << setw(5) << v1;
  cout << setw(5) << v2 << endl;
  fiddle(v1, v2);
  cout << "The values are ";
  cout << setw(5) << v1;
  cout << setw(5) << v2 << endl;
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2.内联函数"></a>2.内联函数</h2><ul>
<li>声明时使用关键字 inline。 </li>
<li>编译时在调用处用函数体进行替换,节省了参数传递、控制转移等开销。 </li>
<li>内联函数体内不能有循环语句和switch语句。 </li>
<li>内联函数的声明必须出现在内联函数第一次被调用之前。 </li>
<li>对内联函数不能进行异常接口声明。 </li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//example:

#include <iostream>
using namespace std;

const double PI = 3.14159265358979;
inline double calArea(double radius) {
    return PI * radius * radius;
}

int main() {
    double r = 3.0;
    double area = calArea(r);
    cout << area << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-带默认参数值的函数"><a href="#3-带默认参数值的函数" class="headerlink" title="3.带默认参数值的函数"></a>3.带默认参数值的函数</h2><p>函数在声明时可以预先给出默认的形参值，调用时如给出实参，则采用实参值，否则采用预先给出的默认参数值。</p>
<p>例如：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x = 5,int y = 6) {
    return x + y;
}
int main() {
    add(10,20);//10+20
    add(10);  //10+6
    add();  //5+6
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>默认参数值的说明次序</strong></p>
<p>有默认参数的形参必须在形参列表的最后，也就是说默认参数值的右面不能有无默认值的参数。因为调用时实参与形参的结合是从左向右的顺序。</p>
<p>例：</p>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x, int y = 5, int z = 6);//正确
int add(int x = 1, int y = 5, int z);//错误
int add(int x = 1, int y, int z = 6);//错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>默认参数值与函数的调用位置</strong></p>
<p>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值必须在函数原型声明中给出；而如果只有函数的定义，或函数定义在前，则默认参数值需在函数定义中给出。 例：</p>
<pre><code>int add(int x = 5,int y = 6);        int add(int x = 5,int y = 6) {
//原型声明在前                         //只有定义，没有原型声明
int main() {                         return  x + y;
  add();                             }
}                                    int main() {
int add(int x,int y) {               add();
//此处不能再指定默认值                   }
  return x + y;
}
</code></pre><h2 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4.函数重载"></a>4.函数重载</h2><p>C++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。</p>
<p>例：</p>
<pre class="line-numbers language-c++"><code class="language-c++">//形参类型不同
int add(int x, int y);
float add(float x, float y);

//形参个数不同
int add(int x, int y);
int add(int x, int y, int z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">/*1.计算长方体的体积

子函数getVolume是计算体积的函数，有三个形参：length（长）、width（宽）、height（高），其中width和height带有默认值。
主函数中以不同形式调用getVolume函数，分析程序的运行结果。*/

#include <iostream>
#include <iomanip>
using namespace std;

int getVolume(int length, int width = 2, int height = 3);

int main() {
    const int X = 10, Y = 12, Z = 15;
    cout << "Some box data is " ;
    cout << getVolume(X, Y, Z) << endl;
    cout << "Some box data is " ;
    cout << getVolume(X, Y) << endl;
    cout << "Some box data is " ;
    cout << getVolume(X) << endl;
    return 0;
}

int getVolume(int length, int width/* = 2 */, int height/* = 3 */) {
    cout << setw(5) << length << setw(5) << width << setw(5) << height << '\t';
    return length * width * height;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>重载函数的形参必须不同:个数不同或类型不同。 </li>
<li>编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。 </li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x,int y);                     int add(int x,int y);
int add(int a,int b);                     void add(int x,int y);
//编译器不以形参名来区分                        //编译器不以返回值来区分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好：</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int add(int x, int y)               float add(float x,float y)
{  return x + y;  }                 {  return x - y;  }
//编写两个名为sumOfSquare的重载函数，分别求两整数的平方和及两实数的平方和。



#include <iostream>
using namespace std;

int sumOfSquare(int a, int b) {
    return a * a + b * b;
}
double sumOfSquare(double a, double b) {
    return a * a + b * b;
}
int main() {
    int m, n;
    cout << "Enter two integer: ";
    cin >> m >> n;
    cout << "Their sum of square: " << sumOfSquare(m, n) << endl;

    double x, y;
    cout << "Enter two real number: ";
    cin >> x >> y;
    cout << "Their sum of square: " << sumOfSquare(x, y) << endl;

    return 0;
}


//运行结果：
Enter two integer: 3 5
Their sum of square: 34
Enter two real number: 2.3 5.8
Their sum of square: 38.93<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="5-使用C-系统函数"><a href="#5-使用C-系统函数" class="headerlink" title="5.使用C++系统函数"></a>5.使用C++系统函数</h2><p>C++的系统库中提供了几百个函数可供程序员使用。 例如：求平方根函数（sprt）、求绝对值函数（abs）等。</p>
<p>使用系统函数时要包含相应的头文件。 例如：cmath 或 math.h</p>
<pre class="line-numbers language-c++"><code class="language-c++">/*1.从键盘输入一个角度值，求出该角度的正弦值、余弦值和正切值。

分析：
系统函数中提供了求正弦值、余弦值和正切值的函数：sin()、cos()、tan()，函数的说明在头文件cmath中。*/


#include <iostream>
#include <cmath>
using namespace std;

const double PI = 3.14159265358979;

int main() {
    double angle;
    cout << "Please enter an angle: ";
    cin >> angle;   //输入角度值

    double radian = angle * PI / 180;   //转化为弧度值
    cout << "sin(" << angle << ") = " << sin(radian) <<endl;
    cout << "cos(" << angle << ") = " << cos(radian) <<endl;
    cout << "tan(" << angle << ") = " << tan(radian) <<endl;
    return 0;
}

//运行结果：
30
sin(30)=0.5
cos(30)=0.866025
tan(30)=0.57735<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/c-xue-xi-bi-ji-zheng-li-di-si-zhang-lei-yu-dui-xiang.html">C++学习笔记整理-类与对象</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-04-26T10:53:44.000Z" itemprop="datePublished">
    2020-04-26
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/学习笔记/">学习笔记</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/C/">C++</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h1 id="第四章-类和对象"><a href="#第四章-类和对象" class="headerlink" title="第四章 类和对象"></a>第四章 类和对象</h1><h2 id="1-面向对象程序设计的基本特点"><a href="#1-面向对象程序设计的基本特点" class="headerlink" title="1.面向对象程序设计的基本特点"></a>1.面向对象程序设计的基本特点</h2><h3 id="①抽象"><a href="#①抽象" class="headerlink" title="①抽象"></a>①抽象</h3><p><strong>抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。</strong></p>
<ul>
<li><p>先注意问题的本质及描述，其次是实现过程或细节。</p>
</li>
<li><p>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</p>
</li>
<li><p>代码抽象：描述某类对象的共有的行为特征或具有的功能。</p>
</li>
<li><p>抽象的实现：通过类的声明。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//数据抽象：
int hour,int minute,int second
//代码抽象：
setTime(),showTime()

class  Clock {
  public: 
   void setTime(int newH, int newM, int newS);   void showTime();
  private: 
   int hour, minute, second;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②封装"><a href="#②封装" class="headerlink" title="②封装"></a>②封装</h3><p><strong>将抽象出的数据成员、代码成员相结合，将它们视为一个整体。</strong></p>
<ul>
<li><p>目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</p>
</li>
<li><p>实现封装：类声明中的{}</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//实例：

class  Clock {
  public://公有的访问权限
      void setTime(int newH, int newM, int newS);//外部接口
      void showTime();//外部接口
  private: //私有的访问权限
      int hour, minute, second;
};//边界
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="③继承"><a href="#③继承" class="headerlink" title="③继承"></a>③继承</h3><p><strong>是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。</strong></p>
<ul>
<li>实现：声明派生类</li>
</ul>
<h3 id="④多态"><a href="#④多态" class="headerlink" title="④多态"></a>④多态</h3><p><strong>多态：同一名称，不同的功能实现方式。</strong></p>
<ul>
<li><p>目的：达到行为标识统一，减少程序中标识符的个数。</p>
</li>
<li><p>实现：重载函数和虚函数</p>
</li>
</ul>
<hr>
<h2 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2.类和对象"></a>2.类和对象</h2><h3 id="①类和对象"><a href="#①类和对象" class="headerlink" title="①类和对象"></a>①类和对象</h3><p><strong>类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。</strong></p>
<ul>
<li><p>利用类可以实现数据的封装、隐藏、继承与派生。</p>
</li>
<li><p>利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。</p>
</li>
<li><p>定义一个新的class也就定义了一个新的类型</p>
</li>
</ul>
<h3 id="②类的定义"><a href="#②类的定义" class="headerlink" title="②类的定义"></a>②类的定义</h3><p>类是一种用户自定义类型，声明形式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class 类名称
{
   public:
             公有成员（外部接口）
   private:
             私有成员
   protected:
             保护型成员
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</strong></p>
</li>
<li><p><strong>在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。</strong><br><strong>如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。</strong></p>
</li>
<li><p><strong>protected保护型成员与private类似，其差别表现在继承与派生时对派生类的影响不同</strong></p>
</li>
</ul>
<hr>
<h3 id="③对象"><a href="#③对象" class="headerlink" title="③对象"></a>③对象</h3><p><strong>类的对象是该类的某一特定实体，即类类型的变量。</strong><br>声明形式：</p>
<pre class="line-numbers language-c++c"><code class="language-c++c">类名  对象名；
例：Clock  myClock;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>类中成员互访：直接使用成员名</p>
</li>
<li><p>类外访问：使用“对象名.成员名”方式访问 public 属性的成员</p>
</li>
</ul>
<h3 id="④类的成员函数"><a href="#④类的成员函数" class="headerlink" title="④类的成员函数"></a>④类的成员函数</h3><ul>
<li><p>在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。</p>
</li>
<li><p>允许声明重载函数和带默认形参值的函数</p>
</li>
</ul>
<h3 id="⑤内联成员函数"><a href="#⑤内联成员函数" class="headerlink" title="⑤内联成员函数"></a>⑤内联成员函数</h3><ul>
<li><p><strong>为了提高运行时的效率，对于较简单的函数可以声明为内联形式。</strong></p>
</li>
<li><p>内联函数体中不要有复杂结构（如循环语句和switch语句）。</p>
</li>
</ul>
<p>  在类中声明内联成员函数的方式：</p>
<ul>
<li>将函数体放在类的声明中。</li>
<li>使用inline关键字。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//example.1类的实现
#include<iostream>
using namespace std;
class Clock{
public:        
    void setTime(int newH = 0, int newM = 0, int newS = 0);
    void showTime();
private:    
    int hour, minute, second;
};
int main()
{
    Clock myClock;
    myClock.setTime(8, 30, 30);
    myClock.showTime();
    return 0;
}

void Clock::setTime(int newH, int newM,int newS)
{
   hour=newH;
   minute=newM;
   second=newS;
}
void Clock::showTime() 
{
   cout << hour << ":" << minute << ":" << second;
}


//运行结果：
8:30:30
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//Point类的完整程序

class Point {   //Point 类的定义
public:
    Point(int xx=0, int yy=0) { x = xx; y = yy; }    //构造函数，内联
    Point(const Point& p); //复制构造函数
    void setX(int xx) {x=xx;}
    void setY(int yy) {y=yy;}
    int getX() const { return x; } //常函数（第5章）
    int getY() const { return y; } //常函数（第5章）
private:
    int x, y; //私有数据
};
//成员函数的实现
Point::Point (const Point& p) {
  x = p.x;
  y = p.y;
  cout << "Calling the copy constructor " << endl;
}

//形参为Point类对象的函数
void fun1(Point p) {
    cout << p.getX() << endl;
}
//返回值为Point类对象的函数
Point fun2() {
    Point a(1, 2);
    return a;
}

//主程序
int main() {
    Point a(4, 5);    //第一个对象A
    Point b = a;    //情况一，用A初始化B。第一次调用复制构造函数
    cout << b.getX() << endl;
    fun1(b);    //情况二，对象B作为fun1的实参。第二次调用复制构造函数
    b = fun2();    //情况三，函数的返回值是类对象，函数返回时调用复制构造函数
    cout << b.getX() << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-构造函数和析构函数"><a href="#3-构造函数和析构函数" class="headerlink" title="3.构造函数和析构函数"></a>3.构造函数和析构函数</h2><h3 id="①构造函数"><a href="#①构造函数" class="headerlink" title="①构造函数"></a>①构造函数</h3><ul>
<li><p>类中的特殊函数</p>
</li>
<li><p>用于描述初始化算法</p>
</li>
<li><p>构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。</p>
</li>
<li><p>在对象创建时被自动调用</p>
</li>
<li><p>如果程序中未声明，则系统自动产生出一个默认的构造函数，其参数列表为空</p>
</li>
<li><p>构造函数可以是内联函数、重载函数、带默认参数值的函数</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//构造函数举例
class Clock {
public:
    Clock(int newH,int newM,int newS);//构造函数
    void setTime(int newH, int newM, int newS);
    void showTime();
private:
    int hour, minute, second;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//构造函数的实现：
Clock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) {
    }
建立对象时构造函数的作用：
int main() {
  Clock c(0,0,0); //此处将自动调用构造函数
  c.showTime();
    return 0;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②复制构造函数"><a href="#②复制构造函数" class="headerlink" title="②复制构造函数"></a>②复制构造函数</h3><p><strong>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">class 类名 {
public :
    类名（形参）；//构造函数
    类名（const  类名 &对象名）；//复制构造函数
           ...
}；
类名::类（ const  类名 &对象名）//复制构造函数的实现
{    函数体    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>复制构造函数被调用的三种情况</strong></p>
<ul>
<li><p>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</p>
</li>
<li><p>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</p>
</li>
<li><p>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。</p>
</li>
</ul>
<p><strong>有时不应该进行复制和赋值</strong></p>
<ul>
<li>例如，房屋中介系统有一个类描述待售房屋</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">class HomeForSale{…}
//通常没有完全一样的房屋，因此不应有复制构造<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//解决方法一：将不应该有的默认函数定义为私有

class HomeForSale{
public:
    …
private:
    …
    HomeForSale(const HomeForSale&);
    HomeForSale& operator=(const HomeForSale&)

//解决方法二：定义一个Uncopyable类作为基类

class Uncopyable{
protected:
    Uncopyable(){}
    ~ Uncopyable(){}
private:
     Uncopyable(const Uncopyable&);
     Uncopyable operator=(const Uncopyable&);
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="③默认构造函数"><a href="#③默认构造函数" class="headerlink" title="③默认构造函数"></a>③默认构造函数</h3><p><strong>调用时可以不需要参数的构造函数都是默认构造函数。</strong></p>
<ul>
<li><p>当不定义构造函数时，编译器自动产生默认构造函数</p>
</li>
<li><p>在类中可以自定义无参数的构造函数，也是默认构造函数</p>
</li>
<li><p>全部参数都有默认形参值的构造函数也是默认构造函数</p>
</li>
</ul>
<p><strong>下面两个都是默认构造函数，如果在类中同时出现，将产生编译错误：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">Clock();
Clock(int newH=0,int newM=0,int newS=0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//example.1
class Clock {
public:
    Clock(int newH,int newM,int newS);//构造函数
    Clock();//默认构造函数
    void setTime(int newH, int newM, int newS);
    void showTime();
private:
    int hour, minute, second;
};
//构造函数的实现：
Clock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) { }
//默认构造函数的实现：
Clock::Clock(): hour(0), minute(0), second(0) { }

//建立对象时构造函数的作用：
int main() {
  Clock c(8,10,0); //调用有参构造函数
  Clock c2();//调用无参构造函数
  c.showTime();
  c2.showTime();
    return 0;
}

void Clock::setTime(int newH, int newM,int newS)
{
   hour = newH;
   minute = newM;
   second = newS;
}
void Clock::showTime() 
{
   cout << hour << ":" << minute << ":" << second;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>有时不应该有默认的构造函数</strong></p>
<ul>
<li><p>有些类，不应该有默认初始化。<br>例如，没有姓名的学生对象是没有意义的<br>解决：<br>至少定义一个有参数的构造函数<br>不定义默认构造函数</p>
</li>
<li><p>需要深层复制时，默认的复制构造会引起错误。<br>解决：<br>自定义实现深层复制的复制构造函数</p>
</li>
</ul>
<h3 id="④隐含的复制构造函数"><a href="#④隐含的复制构造函数" class="headerlink" title="④隐含的复制构造函数"></a>④隐含的复制构造函数</h3><p>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。</p>
<p>这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</p>
<h3 id="⑤函数参数尽量传递常引用而不是值"><a href="#⑤函数参数尽量传递常引用而不是值" class="headerlink" title="⑤函数参数尽量传递常引用而不是值"></a>⑤函数参数尽量传递常引用而不是值</h3><ul>
<li>传递对象值会引起复制构造和析构，增加时间空间开销。</li>
<li>传常引用可避免这一问题。以引用做参数时，尽量使用常引用。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//例如：
void fun1(const Point &p) {
    cout << p.getX() << endl;
   p.setX(1); //语法错误：p是常引用而setX不是常函数
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基本类型、STL的迭代器和函数对象传值较好。</p>
<h3 id="⑥返回值优化"><a href="#⑥返回值优化" class="headerlink" title="⑥返回值优化"></a>⑥返回值优化</h3><ul>
<li><p>当函数返回一个对象时，会构造临时对象用以返回，这会增加开销。</p>
</li>
<li><p>用返回引用或者指针替代不是好办法。返回指向局部对象的指针或者引用，会引发错误。返回指向动态内存的指针或引用容易忘记动态空间释放，引起内存泄露。</p>
</li>
<li><p>解决显式构造临时对象返回。此举表面上还是构造了一个临时对象，但是编译器通常都会进行优化，使之不产生临时对象。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//例如：
Point fun2() {
    return Point(1, 2);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="⑦析构函数"><a href="#⑦析构函数" class="headerlink" title="⑦析构函数"></a>⑦析构函数</h3><ul>
<li><p>完成对象被删除前的一些清理工作。</p>
</li>
<li><p>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。</p>
</li>
<li><p>如果程序中未声明析构函数，编译器将自动产生一个隐含的析构函数。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//构造函数和析构函数举例

#include <iostream>
using namespace std;
class Point {     
public:
  Point(int xx,int yy);
  ~Point();
  //...其他函数原型
private:
  int x, y;
};

Point::Point(int xx,int yy) {
  x = xx;
  y = yy;
}
Point::~Point() {
}
//...其他函数的实现略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="3-类的组合"><a href="#3-类的组合" class="headerlink" title="3.类的组合"></a>3.类的组合</h2><h3 id="①组合"><a href="#①组合" class="headerlink" title="①组合"></a>①组合</h3><ul>
<li><p>类中的成员数据是另一个类的对象。</p>
</li>
<li><p>可以在已有抽象的基础上实现更复杂的抽象。</p>
</li>
</ul>
<p><strong>类组合的构造函数设计</strong></p>
<ul>
<li>原则：不仅要负责对本类中的基本类型成员数据赋初值，也要对对象成员初始化。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//声明形式：
类名::类名(对象成员所需的形参，本类成员形参)
       :对象1(参数)，对象2(参数)，......
{  
//函数体其他语句
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>构造组合类对象时的初始化次序</strong></p>
<ul>
<li><p>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。</p>
</li>
<li><p>成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。</p>
</li>
<li><p>初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化</p>
</li>
<li><p>处理完初始化列表之后，再执行构造函数的函数体</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//类的组合，线段（Line）类


#include <iostream>
#include <cmath>
using namespace std;
class Point {    //Point类定义
public:
    Point(int xx = 0, int yy = 0) {
        x = xx;
        y = yy;
    }
    Point(Point &p);
    int getX() { return x; }
    int getY() { return y; }
private:
    int x, y;
};
Point::Point(Point &p) {    //复制构造函数的实现
    x = p.x;
    y = p.y;
    cout << "Calling the copy constructor of Point" << endl;
}

public:    //外部接口
    Line(Point xp1, Point xp2);
    Line(Line &l);
    double getLen() { return len; }
private:    //私有数据成员
    Point p1, p2;    //Point类的对象p1,p2
    double len;
};
//组合类的构造函数
Line::Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) {
    cout << "Calling constructor of Line" << endl;
    double x = static_cast<double>(p1.getX() - p2.getX());
    double y = static_cast<double>(p1.getY() - p2.getY());
    len = sqrt(x * x + y * y);
}
Line::Line (Line &l): p1(l.p1), p2(l.p2) {//组合类的复制构造函数
    cout << "Calling the copy constructor of Line" << endl;
    len = l.len;
}

//主函数
int main() {
    Point myp1(1, 1), myp2(4, 5);    //建立Point类的对象
    Line line(myp1, myp2);    //建立Line类的对象
    Line line2(line);    //利用复制构造函数建立一个新对象
    cout << "The length of the line is: ";
    cout << line.getLen() << endl;
    cout << "The length of the line2 is: ";
    cout << line2.getLen() << endl;
    return 0;
}


//运行结果如下：
Calling the copy constructor of Point
Calling the copy constructor of Point
Calling the copy constructor of Point
Calling the copy constructor of Point
Calling constructor of Line
Calling the copy constructor of Point
Calling the copy constructor of Point
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>前向引用声明</strong></p>
<ul>
<li><p>类应该先声明，后使用</p>
</li>
<li><p>如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。</p>
</li>
<li><p>前向引用声明只为程序引入一个标识符，但具体声明在其他地方。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">//example

class B;  //前向引用声明
class A {
public:
  void f(B b);
};
class B {
public:
  void g(A a);
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>前向引用声明注意事项</strong></p>
<p>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Fred; //前向引用声明
class Barney {
   Fred x; //错误：类Fred的声明尚不完善
};
class Fred {
   Barney y;
};

//更正
class Fred;    //前向引用声明
class Barney {
public:
  ……
  void method() {
    x.yabbaDabbaDo();    //错误：Fred类的对象在定义之前被使用
  }
 private:
  Fred &x;//正确，经过前向引用声明，可以声明Fred类的对象引用
};

class Fred {
public:
  void yabbaDabbaDo();
private:
  Barney &y;
}; 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>前向引用声明注意事项</strong></p>
<ul>
<li>应该记住：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</li>
</ul>
<hr>
<h2 id="4-UML图形标识"><a href="#4-UML图形标识" class="headerlink" title="4.UML图形标识"></a>4.UML图形标识</h2><h3 id="①UML简介"><a href="#①UML简介" class="headerlink" title="①UML简介"></a>①UML简介</h3><p><strong>UML（Unified Modeling Language）语言是一种可视化的的面向对象建模语言。</strong></p>
<p><strong>UML有三个基本的部分</strong></p>
<ul>
<li><p>事物（Things）UML中重要的组成部分，在模型中属于最静态的部分，代表概念上的或物理上的元素</p>
</li>
<li><p>关系（Relationships）关系把事物紧密联系在一起</p>
</li>
<li><p>图（Diagrams）图是很多有相互相关的事物的组</p>
</li>
</ul>
<h3 id="②UML类图"><a href="#②UML类图" class="headerlink" title="②UML类图"></a>②UML类图</h3><p><strong>举例：Clock类的完整表示:</strong></p>
<table>
<thead>
<tr>
<th>Clock</th>
</tr>
</thead>
<tbody><tr>
<td>- hour:  int</td>
</tr>
<tr>
<td>- minute:  int</td>
</tr>
<tr>
<td>- second:  int</td>
</tr>
<tr>
<td>+ showTime(): void</td>
</tr>
<tr>
<td>+ setTime(newH:int=0,newM:int=0,newS:int=0)</td>
</tr>
</tbody></table>
<p><strong>Clock类的简洁表示</strong></p>
<table>
<thead>
<tr>
<th>Clock</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<h3 id="③对象图"><a href="#③对象图" class="headerlink" title="③对象图"></a>③对象图</h3><table>
<thead>
<tr>
<th align="center">myClock:Clock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">- hour: int</td>
</tr>
<tr>
<td align="center">- minute: int</td>
</tr>
<tr>
<td align="center">- second: int</td>
</tr>
</tbody></table>
<h3 id="④几种关系的图形标识"><a href="#④几种关系的图形标识" class="headerlink" title="④几种关系的图形标识"></a>④几种关系的图形标识</h3><p><strong>依赖关系</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%875.png" alt></p>
<p>图中的“类A”是源，“类B”是目标，表示“类A”使用了“类B”，或称“类A”依赖“类B”</p>
<p><strong>作用关系—关联</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%874.png" alt></p>
<p>图中的“重数A”决定了类B的每个对象与类A的多少个对象发生作用，同样“重数B”决定了类A的每个对象与类B的多少个对象发生作用。</p>
<p><strong>包含关系—聚集和组合</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%876.png" alt></p>
<p>聚集表示类之间的关系是整体与部分的关系，“包含”、“组成”、“分为……部分”等都是聚集关系。共享聚集：部分可以参加多个整体；组成聚集：整体拥有各个部分，整体与部分共存，如果整体不存在了，那么部分也就不存在了。</p>
<p><strong><em>采用UML方法来描述例4-4中Line类和Point类的关系</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%878.png" alt></p>
<p><strong>继承关系—泛化</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%877.png" alt></p>
<p><strong><em>带有注释的Line类和Point类关系的描述</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%873.png" alt></p>
<p><strong>注释</strong></p>
<p>在UML图形上，注释表示为带有褶角的矩形，然后用虚线连接到UML的其他元素上，它是一种用于在图中附加文字注释的机制。</p>
<h2 id="5-结构体和联合体"><a href="#5-结构体和联合体" class="headerlink" title="5.结构体和联合体"></a>5.结构体和联合体</h2><h3 id="①结构体"><a href="#①结构体" class="headerlink" title="①结构体"></a>①结构体</h3><p><strong>结构体是一种特殊形态的类</strong></p>
<ul>
<li><p>与类的唯一区别：类的缺省访问权限是private，结构体的缺省访问权限是public</p>
</li>
<li><p>结构体存在的主要原因：与C语言保持兼容</p>
</li>
</ul>
<p><strong>什么时候用结构体而不用类</strong></p>
<ul>
<li><p>定义主要用来保存数据、而没有什么操作的类型</p>
</li>
<li><p>人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便</p>
</li>
</ul>
<p><strong>结构体的定义和初始化</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">//结构体定义
struct 结构体名称 {
     公有成员
protected:
    保护型成员
private:
     私有成员
};


//一些结构体变量的初始化可以用以下形式
类型名 变量名 = { 成员数据1初值, 成员数据2初值, …… };
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//1.用结构体表示学生的基本信息

#include <iostream>
#include <iomanip>
#include <string>
using namespace std;

struct Student {    //学生信息结构体
    int num;        //学号
    string name;    //姓名，字符串对象，将在第6章详细介绍
    char sex;        //性别
    int age;        //年龄
};

int main() {
    Student stu = { 97001, "Lin Lin", 'F', 19 };
    cout << "Num:  " << stu.num << endl;
    cout << "Name: " << stu.name << endl;
    cout << "Sex:  " << stu.sex << endl;
    cout << "Age:  " << stu.age << endl;
    return 0;
}

//运行结果：
Num:  97001
Name: Lin Lin
Sex:  F
Age:  19
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="②联合体"><a href="#②联合体" class="headerlink" title="②联合体"></a>②联合体</h3><pre class="line-numbers language-c++"><code class="language-c++">//声明形式
union 联合体名称 {
    公有成员
protected:
    保护型成员
private:
    私有成员
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>特点：</strong></p>
<ul>
<li><p>成员共用相同的内存单元</p>
</li>
<li><p>任何两个成员不会同时有效</p>
</li>
</ul>
<p><strong>联合体的内存分配</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">union Mark {    //表示成绩的联合体
    char grade;    //等级制的成绩
    bool pass;    //只记是否通过课程的成绩
    int percent;    //百分制的成绩
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.5/Images/posts/C%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%872.png" alt></p>
<p><strong>无名联合</strong></p>
<p>无名联合没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问。</p>
<pre class="line-numbers language-c++"><code class="language-c++">例：
union {
  int i;
  float f;
}
//在程序中可以这样使用：
i = 10;
f = 2.2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">//example.使用联合体保存成绩信息，并且输出。

#include <string>
#include <iostream>
using namespace std;
class ExamInfo {
private:
    string name;    //课程名称
    enum { GRADE, PASS, PERCENTAGE } mode;//采用何种计分方式
    union {
        char grade;    //等级制的成绩
        bool pass;    //只记是否通过课程的成绩
        int percent;    //百分制的成绩
    };

public:
    //三种构造函数，分别用等级、是否通过和百分初始化
    ExamInfo(string name, char grade)
        : name(name), mode(GRADE), grade(grade) { }
    ExamInfo(string name, bool pass)
        : name(name), mode(PASS), pass(pass) { }
    ExamInfo(string name, int percent)
        : name(name), mode(PERCENTAGE), percent(percent) { }
    void show();
}

void ExamInfo::show() {
    cout << name << ": ";
    switch (mode) {
      case GRADE: cout << grade;  break;
      case PASS: cout << (pass ? "PASS" : "FAIL"); break;
      case PERCENTAGE: cout << percent; break;
    }
    cout << endl;
}

int main() {
    ExamInfo course1("English", 'B');
    ExamInfo course2("Calculus", true);
    ExamInfo course3("C++ Programming", 85);
    course1.show();
    course2.show();
    course3.show();
    return 0;
}

//运行结果：
English: B
Calculus: PASS
C++ Programming: 85<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>

      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">« prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">next »</a>
    </nav>
  </section>


            <footer>
    <div>© 2023 - Tyzhao </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>