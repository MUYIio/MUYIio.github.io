{"title":"高级数据结构-AC自动机总结","date":"2022-02-01T14:23:13.000Z","toc":true,"summary":null,"source":"_posts/高级数据结构-AC自动机总结.md","raw":"---\ntitle: 高级数据结构-AC自动机总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-02-01 22:23:13\npassword:\nsummary:\ntags:\n- AC自动机\ncategories:\n- 数据结构\nkeywords:\ndescription:\n---\n\n***例题来自于[ACWing](https://www.acwing.com/)网站***\n\n# 一、关于AC自动机\n\nAC自动机=KMP查找算法+Tire字典树 --->可优化为Trie图\n\n## KMP查找算法：\n\n### 思路：\n\n\n\n\n\n### 例题：\n\n给定一个模式串 SS，以及一个模板串 PP，所有字符串中只包含大小写英文字母以及阿拉伯数字。\n\n模板串 PP 在模式串 SS 中多次作为子串出现。\n\n求出模板串 PP 在模式串 SS 中所有出现的位置的起始下标。\n\n#### 输入格式\n\n第一行输入整数 NN，表示字符串 PP 的长度。\n\n第二行输入字符串 PP。\n\n第三行输入整数 MM，表示字符串 SS 的长度。\n\n第四行输入字符串 SS。\n\n#### 输出格式\n\n共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。\n\n#### 数据范围\n\n1≤N≤1051≤N≤105\n1≤M≤1061≤M≤106\n\n#### 输入样例：\n\n```\n3\naba\n5\nababa\n```\n\n#### 输出样例：\n\n```\n0 2\n```\n\n代码实现：\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100010, M = 1000010;\n\nint n, m;\nint ne[N]; //next数组\nchar s[M], p[N];\n\nint main()\n{\n    cin >> n >> p + 1 >> m >> s + 1; // 字符串从1开始\n    \n    // 求next数组\n    for (int i = 2, j = 0; i <= n; i ++ ) \n    {\n        while (j && p[i] != p[j + 1]) j = ne[j]; // 后退到next[j]\n        if (p[i] == p[j + 1]) j ++ ;\n        ne[i] = j; // 记录过程\n    }\n    \n    // 匹配字符串\n    for (int i = 1, j = 0; i <= m; i ++ )\n    {\n        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，退一步到next[j]\n        if (s[i] == p[j + 1]) j ++ ;\n        if (j == n) // 匹配成功\n        {\n            printf(\"%d \", i - n); // 输出结果\n            j = ne[j]; // 匹配成功的逻辑，后退一步\n        }\n    }\n    \n    return 0;\n}\n   \n```\n\n### 模板：\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; // N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; // next[]数组，避免和头文件next冲突\nchar s[N], p[M];  // s为模式串,p为匹配串\n\nint main()\n{\n    cin >> n >> s+1 >> m >> p+1;  // 下标从1开始\n\n    // 求next[]数组\n    for(int i = 2, j = 0; i <= m; i++)\n    {\n        while(j && p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    }\n    // 匹配操作\n    for(int i = 1, j = 0; i <= n; i++)\n    {\n        while(j && s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  // 满足匹配条件，打印开头下标, 从0开始\n        {\n\n            printf(\"%d \", i - m); // (若从1开始，加1)\n            j = ne[j];            // 再次继续匹配\n        }\n    }\n\n    return 0;\n}\n\n```\n\n\n\n## Tire字典树：\n\n思路：\n\n\n\n### 例题：\n\n维护一个字符串集合，支持两种操作：\n\n1. `I x` 向集合中插入一个字符串 xx；\n2. `Q x` 询问一个字符串在集合中出现了多少次。\n\n共有 NN 个操作，输入的字符串总长度不超过 105105，字符串仅包含小写英文字母。\n\n#### 输入格式\n\n第一行包含整数 NN，表示操作数。\n\n接下来 NN 行，每行包含一个操作指令，指令为 `I x` 或 `Q x` 中的一种。\n\n#### 输出格式\n\n对于每个询问指令 `Q x`，都要输出一个整数作为结果，表示 xx 在集合中出现的次数。\n\n每个结果占一行。\n\n#### 数据范围\n\n1≤N≤2∗1041≤N≤2∗104\n\n#### 输入样例：\n\n```\n5\nI abc\nQ abc\nQ ab\nI ab\nQ ab\n```\n\n#### 输出样例：\n\n```\n1\n0\n1\n```\n\n# 二、AC自动机实现\n\n一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，找出有多少个单词在文章里出现过。\n\n### 思路：\n\n\n\n\n\n### 例题：\n\n给定 nn 个长度不超过 5050 的由小写英文字母组成的单词，以及一篇长为 mm 的文章。\n\n请问，其中有多少个单词在文章中出现了。\n\n**注意：每个单词不论在文章中出现多少次，仅累计 11 次。**\n\n#### 输入格式\n\n第一行包含整数 TT，表示共有 TT 组测试数据。\n\n对于每组数据，第一行一个整数 nn，接下去 nn 行表示 nn 个单词，最后一行输入一个字符串，表示文章。\n\n#### 输出格式\n\n对于每组数据，输出一个占一行的整数，表示有多少个单词在文章中出现。\n\n#### 数据范围\n\n1≤n≤1041≤n≤104,\n1≤m≤1061≤m≤106\n\n#### 输入样例：\n\n```\n1\n5\nshe\nhe\nsay\nshr\nher\nyasherhs\n```\n\n#### 输出样例：\n\n```\n3\n```\n\n\n\n**代码实现：**\n\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N = 10010, S = 55, M = 1000010;\nint trie[N * S][26], cnt[N * S], idx;  //cnt[i]表示以i + 'a'为结尾的个数   idx为当前树节点的指针\nchar str[M]; //以\"/0\"为结尾，所以不用每次都更新\nint que[N * S], fail[N * S]; //que[]表示队列  ， fail[]为失配指针(下标表示树节点的指针)  \nint n;\n\n\nvoid insert(){\n    int p = 0;\n    for(int i = 0;str[i];++i){\n        int u = str[i] - 'a';\n        if(!trie[p][u]) trie[p][u] = ++idx;\n        p = trie[p][u];\n    }\n    cnt[p]++;\n}\n\nvoid build(){  //构造fail数组，bfs\n    int hh = 0,tt = -1;  //队头和队尾指针\n    //根节点是第0层\n    for(int i = 0;i < 26;++i){  //第一层的元素全部入队\n        if(trie[0][i]) que[++tt] = trie[0][i];\n    }\n    while(hh <= tt){\n        int ans = que[hh++];\n        //枚举当前队头的26个分支\n        for(int i = 0;i < 26;++i){\n            if(trie[ans][i]){  //如果存在我们就让它的fail指针指向他父亲节点 a 的 fail 指针指向的那个节点（根）的具有相同字母的子节点\n                fail[trie[ans][i]] = trie[fail[ans]][i];\n                que[++tt] = trie[ans][i];  //当前节点入队\n            }else{  //就算不存在，不跳，他的值等于父节点的fail只想的具有相同字母的子节点\n                trie[ans][i] = trie[fail[ans]][i]; \n            }\n        }\n    }\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n\n        memset(cnt,0,sizeof cnt);\n        memset(trie,0,sizeof trie);\n        memset(fail,0,sizeof fail);\n        idx = 0;\n      cin >> n;\n      for(int i = 0;i < n;++i){\n          scanf(\"%s\",str);\n          insert();\n      }\n\n      build();\n      scanf(\"%s\",str);\n\n      int res = 0;  \n      //j记录当前树节点的指针，初始是根节点 \n      for(int i = 0,j = 0;str[i];++i){  //枚举总串str的每一个字母\n          int u = str[i] - 'a';\n          j = trie[j][u];  //跳到下一个树节点\n          int p = j; //每次从当前树节点开始\n\n          //fail[p]所指向的树节点如果有结尾标记可以直接算上，因为当前模式串后缀和fail指针指向的模式串部分前缀相同，所以是包含在里面的\n          while(p){  //假如模式串\"she\"可以匹配上，那么匹配到\"e\"的时候，用fail指针跳到模式串\"he\"的\"e\"，那么也一定能够匹配\"he\"\n             res += cnt[p];\n             cnt[p] = 0;  //去除标记\n             p = fail[p];\n          }\n      }\n      cout << res << endl;\n    }\n    return 0;\n}\n```\n\n","slug":"高级数据结构-AC自动机总结","published":true,"updated":"2022-04-01T14:59:48.398Z","_id":"clq6dy4au003tikw09ffhenpd","comments":true,"layout":"post","photos":[],"link":"","html":"<p><strong><em>例题来自于<a href=\"https://www.acwing.com/\" target=\"_blank\" rel=\"noopener\">ACWing</a>网站</em></strong></p>\n<h1 id=\"一、关于AC自动机\"><a href=\"#一、关于AC自动机\" class=\"headerlink\" title=\"一、关于AC自动机\"></a>一、关于AC自动机</h1><p>AC自动机=KMP查找算法+Tire字典树 —&gt;可优化为Trie图</p>\n<h2 id=\"KMP查找算法：\"><a href=\"#KMP查找算法：\" class=\"headerlink\" title=\"KMP查找算法：\"></a>KMP查找算法：</h2><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><h3 id=\"例题：\"><a href=\"#例题：\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>给定一个模式串 SS，以及一个模板串 PP，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>\n<p>模板串 PP 在模式串 SS 中多次作为子串出现。</p>\n<p>求出模板串 PP 在模式串 SS 中所有出现的位置的起始下标。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行输入整数 NN，表示字符串 PP 的长度。</p>\n<p>第二行输入字符串 PP。</p>\n<p>第三行输入整数 MM，表示字符串 SS 的长度。</p>\n<p>第四行输入字符串 SS。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>1≤N≤1051≤N≤105<br>1≤M≤1061≤M≤106</p>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\naba\n5\nababa</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0 2</code></pre><p>代码实现：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <iostream>\n\nusing namespace std;\n\nconst int N = 100010, M = 1000010;\n\nint n, m;\nint ne[N]; //next数组\nchar s[M], p[N];\n\nint main()\n{\n    cin >> n >> p + 1 >> m >> s + 1; // 字符串从1开始\n\n    // 求next数组\n    for (int i = 2, j = 0; i <= n; i ++ ) \n    {\n        while (j && p[i] != p[j + 1]) j = ne[j]; // 后退到next[j]\n        if (p[i] == p[j + 1]) j ++ ;\n        ne[i] = j; // 记录过程\n    }\n\n    // 匹配字符串\n    for (int i = 1, j = 0; i <= m; i ++ )\n    {\n        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，退一步到next[j]\n        if (s[i] == p[j + 1]) j ++ ;\n        if (j == n) // 匹配成功\n        {\n            printf(\"%d \", i - n); // 输出结果\n            j = ne[j]; // 匹配成功的逻辑，后退一步\n        }\n    }\n\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"模板：\"><a href=\"#模板：\" class=\"headerlink\" title=\"模板：\"></a>模板：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <iostream>\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; // N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; // next[]数组，避免和头文件next冲突\nchar s[N], p[M];  // s为模式串,p为匹配串\n\nint main()\n{\n    cin >> n >> s+1 >> m >> p+1;  // 下标从1开始\n\n    // 求next[]数组\n    for(int i = 2, j = 0; i <= m; i++)\n    {\n        while(j && p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    }\n    // 匹配操作\n    for(int i = 1, j = 0; i <= n; i++)\n    {\n        while(j && s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  // 满足匹配条件，打印开头下标, 从0开始\n        {\n\n            printf(\"%d \", i - m); // (若从1开始，加1)\n            j = ne[j];            // 再次继续匹配\n        }\n    }\n\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"Tire字典树：\"><a href=\"#Tire字典树：\" class=\"headerlink\" title=\"Tire字典树：\"></a>Tire字典树：</h2><p>思路：</p>\n<h3 id=\"例题：-1\"><a href=\"#例题：-1\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>维护一个字符串集合，支持两种操作：</p>\n<ol>\n<li><code>I x</code> 向集合中插入一个字符串 xx；</li>\n<li><code>Q x</code> 询问一个字符串在集合中出现了多少次。</li>\n</ol>\n<p>共有 NN 个操作，输入的字符串总长度不超过 105105，字符串仅包含小写英文字母。</p>\n<h4 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含整数 NN，表示操作数。</p>\n<p>接下来 NN 行，每行包含一个操作指令，指令为 <code>I x</code> 或 <code>Q x</code> 中的一种。</p>\n<h4 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>对于每个询问指令 <code>Q x</code>，都要输出一个整数作为结果，表示 xx 在集合中出现的次数。</p>\n<p>每个结果占一行。</p>\n<h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>1≤N≤2∗1041≤N≤2∗104</p>\n<h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>5\nI abc\nQ abc\nQ ab\nI ab\nQ ab</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n0\n1</code></pre><h1 id=\"二、AC自动机实现\"><a href=\"#二、AC自动机实现\" class=\"headerlink\" title=\"二、AC自动机实现\"></a>二、AC自动机实现</h1><p>一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，找出有多少个单词在文章里出现过。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><h3 id=\"例题：-2\"><a href=\"#例题：-2\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>给定 nn 个长度不超过 5050 的由小写英文字母组成的单词，以及一篇长为 mm 的文章。</p>\n<p>请问，其中有多少个单词在文章中出现了。</p>\n<p><strong>注意：每个单词不论在文章中出现多少次，仅累计 11 次。</strong></p>\n<h4 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含整数 TT，表示共有 TT 组测试数据。</p>\n<p>对于每组数据，第一行一个整数 nn，接下去 nn 行表示 nn 个单词，最后一行输入一个字符串，表示文章。</p>\n<h4 id=\"输出格式-2\"><a href=\"#输出格式-2\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>对于每组数据，输出一个占一行的整数，表示有多少个单词在文章中出现。</p>\n<h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>1≤n≤1041≤n≤104,<br>1≤m≤1061≤m≤106</p>\n<h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>1\n5\nshe\nhe\nsay\nshr\nher\nyasherhs</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>3</code></pre><p><strong>代码实现：</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N = 10010, S = 55, M = 1000010;\nint trie[N * S][26], cnt[N * S], idx;  //cnt[i]表示以i + 'a'为结尾的个数   idx为当前树节点的指针\nchar str[M]; //以\"/0\"为结尾，所以不用每次都更新\nint que[N * S], fail[N * S]; //que[]表示队列  ， fail[]为失配指针(下标表示树节点的指针)  \nint n;\n\n\nvoid insert(){\n    int p = 0;\n    for(int i = 0;str[i];++i){\n        int u = str[i] - 'a';\n        if(!trie[p][u]) trie[p][u] = ++idx;\n        p = trie[p][u];\n    }\n    cnt[p]++;\n}\n\nvoid build(){  //构造fail数组，bfs\n    int hh = 0,tt = -1;  //队头和队尾指针\n    //根节点是第0层\n    for(int i = 0;i < 26;++i){  //第一层的元素全部入队\n        if(trie[0][i]) que[++tt] = trie[0][i];\n    }\n    while(hh <= tt){\n        int ans = que[hh++];\n        //枚举当前队头的26个分支\n        for(int i = 0;i < 26;++i){\n            if(trie[ans][i]){  //如果存在我们就让它的fail指针指向他父亲节点 a 的 fail 指针指向的那个节点（根）的具有相同字母的子节点\n                fail[trie[ans][i]] = trie[fail[ans]][i];\n                que[++tt] = trie[ans][i];  //当前节点入队\n            }else{  //就算不存在，不跳，他的值等于父节点的fail只想的具有相同字母的子节点\n                trie[ans][i] = trie[fail[ans]][i]; \n            }\n        }\n    }\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n\n        memset(cnt,0,sizeof cnt);\n        memset(trie,0,sizeof trie);\n        memset(fail,0,sizeof fail);\n        idx = 0;\n      cin >> n;\n      for(int i = 0;i < n;++i){\n          scanf(\"%s\",str);\n          insert();\n      }\n\n      build();\n      scanf(\"%s\",str);\n\n      int res = 0;  \n      //j记录当前树节点的指针，初始是根节点 \n      for(int i = 0,j = 0;str[i];++i){  //枚举总串str的每一个字母\n          int u = str[i] - 'a';\n          j = trie[j][u];  //跳到下一个树节点\n          int p = j; //每次从当前树节点开始\n\n          //fail[p]所指向的树节点如果有结尾标记可以直接算上，因为当前模式串后缀和fail指针指向的模式串部分前缀相同，所以是包含在里面的\n          while(p){  //假如模式串\"she\"可以匹配上，那么匹配到\"e\"的时候，用fail指针跳到模式串\"he\"的\"e\"，那么也一定能够匹配\"he\"\n             res += cnt[p];\n             cnt[p] = 0;  //去除标记\n             p = fail[p];\n          }\n      }\n      cout << res << endl;\n    }\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","excerpt":"","more":"<p><strong><em>例题来自于<a href=\"https://www.acwing.com/\" target=\"_blank\" rel=\"noopener\">ACWing</a>网站</em></strong></p>\n<h1 id=\"一、关于AC自动机\"><a href=\"#一、关于AC自动机\" class=\"headerlink\" title=\"一、关于AC自动机\"></a>一、关于AC自动机</h1><p>AC自动机=KMP查找算法+Tire字典树 —&gt;可优化为Trie图</p>\n<h2 id=\"KMP查找算法：\"><a href=\"#KMP查找算法：\" class=\"headerlink\" title=\"KMP查找算法：\"></a>KMP查找算法：</h2><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><h3 id=\"例题：\"><a href=\"#例题：\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>给定一个模式串 SS，以及一个模板串 PP，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>\n<p>模板串 PP 在模式串 SS 中多次作为子串出现。</p>\n<p>求出模板串 PP 在模式串 SS 中所有出现的位置的起始下标。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行输入整数 NN，表示字符串 PP 的长度。</p>\n<p>第二行输入字符串 PP。</p>\n<p>第三行输入整数 MM，表示字符串 SS 的长度。</p>\n<p>第四行输入字符串 SS。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>1≤N≤1051≤N≤105<br>1≤M≤1061≤M≤106</p>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\naba\n5\nababa</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0 2</code></pre><p>代码实现：</p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 100010, M = 1000010;\n\nint n, m;\nint ne[N]; //next数组\nchar s[M], p[N];\n\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; // 字符串从1开始\n\n    // 求next数组\n    for (int i = 2, j = 0; i &lt;= n; i ++ ) \n    {\n        while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; // 后退到next[j]\n        if (p[i] == p[j + 1]) j ++ ;\n        ne[i] = j; // 记录过程\n    }\n\n    // 匹配字符串\n    for (int i = 1, j = 0; i &lt;= m; i ++ )\n    {\n        while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，退一步到next[j]\n        if (s[i] == p[j + 1]) j ++ ;\n        if (j == n) // 匹配成功\n        {\n            printf(&quot;%d &quot;, i - n); // 输出结果\n            j = ne[j]; // 匹配成功的逻辑，后退一步\n        }\n    }\n\n    return 0;\n}\n</code></pre>\n<h3 id=\"模板：\"><a href=\"#模板：\" class=\"headerlink\" title=\"模板：\"></a>模板：</h3><pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; // N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; // next[]数组，避免和头文件next冲突\nchar s[N], p[M];  // s为模式串,p为匹配串\n\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; s+1 &gt;&gt; m &gt;&gt; p+1;  // 下标从1开始\n\n    // 求next[]数组\n    for(int i = 2, j = 0; i &lt;= m; i++)\n    {\n        while(j &amp;&amp; p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    }\n    // 匹配操作\n    for(int i = 1, j = 0; i &lt;= n; i++)\n    {\n        while(j &amp;&amp; s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  // 满足匹配条件，打印开头下标, 从0开始\n        {\n\n            printf(&quot;%d &quot;, i - m); // (若从1开始，加1)\n            j = ne[j];            // 再次继续匹配\n        }\n    }\n\n    return 0;\n}\n</code></pre>\n<h2 id=\"Tire字典树：\"><a href=\"#Tire字典树：\" class=\"headerlink\" title=\"Tire字典树：\"></a>Tire字典树：</h2><p>思路：</p>\n<h3 id=\"例题：-1\"><a href=\"#例题：-1\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>维护一个字符串集合，支持两种操作：</p>\n<ol>\n<li><code>I x</code> 向集合中插入一个字符串 xx；</li>\n<li><code>Q x</code> 询问一个字符串在集合中出现了多少次。</li>\n</ol>\n<p>共有 NN 个操作，输入的字符串总长度不超过 105105，字符串仅包含小写英文字母。</p>\n<h4 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含整数 NN，表示操作数。</p>\n<p>接下来 NN 行，每行包含一个操作指令，指令为 <code>I x</code> 或 <code>Q x</code> 中的一种。</p>\n<h4 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>对于每个询问指令 <code>Q x</code>，都要输出一个整数作为结果，表示 xx 在集合中出现的次数。</p>\n<p>每个结果占一行。</p>\n<h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>1≤N≤2∗1041≤N≤2∗104</p>\n<h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>5\nI abc\nQ abc\nQ ab\nI ab\nQ ab</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n0\n1</code></pre><h1 id=\"二、AC自动机实现\"><a href=\"#二、AC自动机实现\" class=\"headerlink\" title=\"二、AC自动机实现\"></a>二、AC自动机实现</h1><p>一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，找出有多少个单词在文章里出现过。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><h3 id=\"例题：-2\"><a href=\"#例题：-2\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>给定 nn 个长度不超过 5050 的由小写英文字母组成的单词，以及一篇长为 mm 的文章。</p>\n<p>请问，其中有多少个单词在文章中出现了。</p>\n<p><strong>注意：每个单词不论在文章中出现多少次，仅累计 11 次。</strong></p>\n<h4 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行包含整数 TT，表示共有 TT 组测试数据。</p>\n<p>对于每组数据，第一行一个整数 nn，接下去 nn 行表示 nn 个单词，最后一行输入一个字符串，表示文章。</p>\n<h4 id=\"输出格式-2\"><a href=\"#输出格式-2\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>对于每组数据，输出一个占一行的整数，表示有多少个单词在文章中出现。</p>\n<h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>1≤n≤1041≤n≤104,<br>1≤m≤1061≤m≤106</p>\n<h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>1\n5\nshe\nhe\nsay\nshr\nher\nyasherhs</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>3</code></pre><p><strong>代码实现：</strong></p>\n<pre><code class=\"c++\">#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 10010, S = 55, M = 1000010;\nint trie[N * S][26], cnt[N * S], idx;  //cnt[i]表示以i + &#39;a&#39;为结尾的个数   idx为当前树节点的指针\nchar str[M]; //以&quot;/0&quot;为结尾，所以不用每次都更新\nint que[N * S], fail[N * S]; //que[]表示队列  ， fail[]为失配指针(下标表示树节点的指针)  \nint n;\n\n\nvoid insert(){\n    int p = 0;\n    for(int i = 0;str[i];++i){\n        int u = str[i] - &#39;a&#39;;\n        if(!trie[p][u]) trie[p][u] = ++idx;\n        p = trie[p][u];\n    }\n    cnt[p]++;\n}\n\nvoid build(){  //构造fail数组，bfs\n    int hh = 0,tt = -1;  //队头和队尾指针\n    //根节点是第0层\n    for(int i = 0;i &lt; 26;++i){  //第一层的元素全部入队\n        if(trie[0][i]) que[++tt] = trie[0][i];\n    }\n    while(hh &lt;= tt){\n        int ans = que[hh++];\n        //枚举当前队头的26个分支\n        for(int i = 0;i &lt; 26;++i){\n            if(trie[ans][i]){  //如果存在我们就让它的fail指针指向他父亲节点 a 的 fail 指针指向的那个节点（根）的具有相同字母的子节点\n                fail[trie[ans][i]] = trie[fail[ans]][i];\n                que[++tt] = trie[ans][i];  //当前节点入队\n            }else{  //就算不存在，不跳，他的值等于父节点的fail只想的具有相同字母的子节点\n                trie[ans][i] = trie[fail[ans]][i]; \n            }\n        }\n    }\n}\n\nint main(){\n    int t;\n    cin &gt;&gt; t;\n    while(t--){\n\n        memset(cnt,0,sizeof cnt);\n        memset(trie,0,sizeof trie);\n        memset(fail,0,sizeof fail);\n        idx = 0;\n      cin &gt;&gt; n;\n      for(int i = 0;i &lt; n;++i){\n          scanf(&quot;%s&quot;,str);\n          insert();\n      }\n\n      build();\n      scanf(&quot;%s&quot;,str);\n\n      int res = 0;  \n      //j记录当前树节点的指针，初始是根节点 \n      for(int i = 0,j = 0;str[i];++i){  //枚举总串str的每一个字母\n          int u = str[i] - &#39;a&#39;;\n          j = trie[j][u];  //跳到下一个树节点\n          int p = j; //每次从当前树节点开始\n\n          //fail[p]所指向的树节点如果有结尾标记可以直接算上，因为当前模式串后缀和fail指针指向的模式串部分前缀相同，所以是包含在里面的\n          while(p){  //假如模式串&quot;she&quot;可以匹配上，那么匹配到&quot;e&quot;的时候，用fail指针跳到模式串&quot;he&quot;的&quot;e&quot;，那么也一定能够匹配&quot;he&quot;\n             res += cnt[p];\n             cnt[p] = 0;  //去除标记\n             p = fail[p];\n          }\n      }\n      cout &lt;&lt; res &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre>\n","path":"gao-ji-shu-ju-jie-gou-ac-zi-dong-ji-zong-jie.html","permalink":"https://www.yshawlon.cn/gao-ji-shu-ju-jie-gou-ac-zi-dong-ji-zong-jie.html","tags":[{"name":"AC自动机","_id":"clq6dy4bk0063ikw0ykf98mhu","slug":"AC自动机","path":"tags/AC自动机/","permalink":"https://www.yshawlon.cn/tags/AC自动机/","length":1}],"categories":[{"name":"数据结构","_id":"clq6dy4b6004sikw0nv2p9fos","slug":"数据结构","path":"categories/数据结构/","permalink":"https://www.yshawlon.cn/categories/数据结构/","length":1}],"prev":{"title":"操作系统实现第一篇","date":"2022-03-20T10:58:07.000Z","summary":null,"slug":"操作系统实现第一篇","published":true,"updated":"2023-04-07T09:41:43.492Z","_id":"clq6dy4am003dikw096xw6huv","layout":"post","photos":[],"link":"","excerpt":"","path":"cao-zuo-xi-tong-shi-xian-di-yi-pian.html","permalink":"https://www.yshawlon.cn/cao-zuo-xi-tong-shi-xian-di-yi-pian.html","__post":true},"next":{"title":"十大经典排序算法(附动画及代码)","date":"2021-12-14T02:44:44.000Z","summary":"关于各种排序算法的笔记总结，含代码展示和动画演示！","slug":"qSort","published":true,"updated":"2022-06-06T14:37:33.122Z","_id":"clq6dy49w001zikw0ccfcywxz","layout":"post","photos":[],"link":"","excerpt":"","path":"qsort.html","permalink":"https://www.yshawlon.cn/qsort.html","__post":true},"__post":true}